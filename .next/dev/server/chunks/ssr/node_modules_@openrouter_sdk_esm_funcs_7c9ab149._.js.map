{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/analyticsGetUserActivity.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeFormQuery } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Get user activity grouped by endpoint\n *\n * @remarks\n * Returns user activity data grouped by endpoint for the last 30 (completed) UTC days\n */\nexport function analyticsGetUserActivity(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => operations.GetUserActivityRequest$outboundSchema.optional().parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = null;\n    const path = pathToFunc(\"/activity\")();\n    const query = encodeFormQuery({\n        \"date\": payload?.date,\n    });\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"getUserActivity\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        query: query,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"400\", \"401\", \"403\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.GetUserActivityResponse$inboundSchema), M.jsonErr(400, errors.BadRequestResponseError$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(403, errors.ForbiddenResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=analyticsGetUserActivity.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;AAOO,SAAS,yBAAyB,MAAM,EAAE,OAAO,EAAE,OAAO;IAC7D,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ,SAAS;AAC/C;AACA,eAAe,IAAI,MAAM,EAAE,OAAO,EAAE,OAAO;IACvC,MAAM,SAAS,IAAA,yKAAS,EAAC,SAAS,CAAC,QAAU,8NAAgD,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ;IACvH,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;YAAU;SAAE;IAC1C;IACA,MAAM,UAAU,OAAO,KAAK;IAC5B,MAAM,OAAO;IACb,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,QAAQ,IAAA,iLAAe,EAAC;QAC1B,QAAQ,SAAS;IACrB;IACA,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,OAAO;QACP,MAAM;QACN,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;YAAO;YAAO;SAAM;QACtD,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,8NAAgD,GAAG,wKAAS,CAAC,KAAK,kOAA4C,GAAG,wKAAS,CAAC,KAAK,sOAA8C,GAAG,wKAAS,CAAC,KAAK,gOAA2C,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IACta,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,oDAAoD","ignoreList":[0]}},
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/apiKeysCreate.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeJSON } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Create a new API key\n */\nexport function apiKeysCreate(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => operations.CreateKeysRequest$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = encodeJSON(\"body\", payload, { explode: true });\n    const path = pathToFunc(\"/keys\")();\n    const headers = new Headers(compactMap({\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"createKeys\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"POST\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"400\", \"401\", \"429\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(201, operations.CreateKeysResponse$inboundSchema), M.jsonErr(400, errors.BadRequestResponseError$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(429, errors.TooManyRequestsResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=apiKeysCreate.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;AAIO,SAAS,cAAc,MAAM,EAAE,OAAO,EAAE,OAAO;IAClD,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ,SAAS;AAC/C;AACA,eAAe,IAAI,MAAM,EAAE,OAAO,EAAE,OAAO;IACvC,MAAM,SAAS,IAAA,yKAAS,EAAC,SAAS,CAAC,QAAU,oNAA2C,CAAC,KAAK,CAAC,QAAQ;IACvG,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;YAAU;SAAE;IAC1C;IACA,MAAM,UAAU,OAAO,KAAK;IAC5B,MAAM,OAAO,IAAA,4KAAU,EAAC,QAAQ,SAAS;QAAE,SAAS;IAAK;IACzD,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,gBAAgB;QAChB,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,MAAM;QACN,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;YAAO;YAAO;SAAM;QACtD,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,oNAA2C,GAAG,wKAAS,CAAC,KAAK,kOAA4C,GAAG,wKAAS,CAAC,KAAK,sOAA8C,GAAG,wKAAS,CAAC,KAAK,4OAAiD,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IACva,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,yCAAyC","ignoreList":[0]}},
    {"offset": {"line": 297, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/apiKeysDelete.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeSimple } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Delete an API key\n */\nexport function apiKeysDelete(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => operations.DeleteKeysRequest$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = null;\n    const pathParams = {\n        hash: encodeSimple(\"hash\", payload.hash, {\n            explode: false,\n            charEncoding: \"percent\",\n        }),\n    };\n    const path = pathToFunc(\"/keys/{hash}\")(pathParams);\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"deleteKeys\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"DELETE\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"401\", \"404\", \"429\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.DeleteKeysResponse$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(404, errors.NotFoundResponseError$inboundSchema), M.jsonErr(429, errors.TooManyRequestsResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=apiKeysDelete.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 446, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/apiKeysGet.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeSimple } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Get a single API key\n */\nexport function apiKeysGet(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => operations.GetKeyRequest$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = null;\n    const pathParams = {\n        hash: encodeSimple(\"hash\", payload.hash, {\n            explode: false,\n            charEncoding: \"percent\",\n        }),\n    };\n    const path = pathToFunc(\"/keys/{hash}\")(pathParams);\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"getKey\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"401\", \"404\", \"429\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.GetKeyResponse$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(404, errors.NotFoundResponseError$inboundSchema), M.jsonErr(429, errors.TooManyRequestsResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=apiKeysGet.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;AAIO,SAAS,WAAW,MAAM,EAAE,OAAO,EAAE,OAAO;IAC/C,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ,SAAS;AAC/C;AACA,eAAe,IAAI,MAAM,EAAE,OAAO,EAAE,OAAO;IACvC,MAAM,SAAS,IAAA,yKAAS,EAAC,SAAS,CAAC,QAAU,4MAAuC,CAAC,KAAK,CAAC,QAAQ;IACnG,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;YAAU;SAAE;IAC1C;IACA,MAAM,UAAU,OAAO,KAAK;IAC5B,MAAM,OAAO;IACb,MAAM,aAAa;QACf,MAAM,IAAA,8KAAY,EAAC,QAAQ,QAAQ,IAAI,EAAE;YACrC,SAAS;YACT,cAAc;QAClB;IACJ;IACA,MAAM,OAAO,IAAA,sKAAU,EAAC,gBAAgB;IACxC,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,MAAM;QACN,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;YAAO;YAAO;SAAM;QACtD,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,4MAAuC,GAAG,wKAAS,CAAC,KAAK,sOAA8C,GAAG,wKAAS,CAAC,KAAK,8NAA0C,GAAG,wKAAS,CAAC,KAAK,4OAAiD,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IACja,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 595, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/apiKeysGetCurrentKeyMetadata.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Get current API key\n *\n * @remarks\n * Get information on the API key associated with the current authentication session\n */\nexport function apiKeysGetCurrentKeyMetadata(client, options) {\n    return new APIPromise($do(client, options));\n}\nasync function $do(client, options) {\n    const path = pathToFunc(\"/key\")();\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"getCurrentKey\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"401\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.GetCurrentKeyResponse$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=apiKeysGetCurrentKeyMetadata.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;AAOO,SAAS,6BAA6B,MAAM,EAAE,OAAO;IACxD,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ;AACtC;AACA,eAAe,IAAI,MAAM,EAAE,OAAO;IAC9B,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;SAAM;QACxC,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,0NAA8C,GAAG,wKAAS,CAAC,KAAK,sOAA8C,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IACzS,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,wDAAwD","ignoreList":[0]}},
    {"offset": {"line": 718, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/apiKeysList.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeFormQuery } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * List API keys\n */\nexport function apiKeysList(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => operations.ListRequest$outboundSchema.optional().parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = null;\n    const path = pathToFunc(\"/keys\")();\n    const query = encodeFormQuery({\n        \"include_disabled\": payload?.include_disabled,\n        \"offset\": payload?.offset,\n    });\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"list\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        query: query,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"401\", \"429\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.ListResponse$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(429, errors.TooManyRequestsResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=apiKeysList.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;;;;AAIO,SAAS,YAAY,MAAM,EAAE,OAAO,EAAE,OAAO;IAChD,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ,SAAS;AAC/C;AACA,eAAe,IAAI,MAAM,EAAE,OAAO,EAAE,OAAO;IACvC,MAAM,SAAS,IAAA,yKAAS,EAAC,SAAS,CAAC,QAAU,wMAAqC,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ;IAC5G,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;YAAU;SAAE;IAC1C;IACA,MAAM,UAAU,OAAO,KAAK;IAC5B,MAAM,OAAO;IACb,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,QAAQ,IAAA,iLAAe,EAAC;QAC1B,oBAAoB,SAAS;QAC7B,UAAU,SAAS;IACvB;IACA,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,OAAO;QACP,MAAM;QACN,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;QAC/C,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,wMAAqC,GAAG,wKAAS,CAAC,KAAK,sOAA8C,GAAG,wKAAS,CAAC,KAAK,4OAAiD,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IACnW,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 864, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/apiKeysUpdate.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeJSON, encodeSimple } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Update an API key\n */\nexport function apiKeysUpdate(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => operations.UpdateKeysRequest$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = encodeJSON(\"body\", payload.RequestBody, { explode: true });\n    const pathParams = {\n        hash: encodeSimple(\"hash\", payload.hash, {\n            explode: false,\n            charEncoding: \"percent\",\n        }),\n    };\n    const path = pathToFunc(\"/keys/{hash}\")(pathParams);\n    const headers = new Headers(compactMap({\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"updateKeys\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"PATCH\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"400\", \"401\", \"404\", \"429\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.UpdateKeysResponse$inboundSchema), M.jsonErr(400, errors.BadRequestResponseError$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(404, errors.NotFoundResponseError$inboundSchema), M.jsonErr(429, errors.TooManyRequestsResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=apiKeysUpdate.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1018, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/betaResponsesSend.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeJSON } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as models from \"../models/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\nexport function betaResponsesSend(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => models.OpenResponsesRequest$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = encodeJSON(\"body\", payload, { explode: true });\n    const path = pathToFunc(\"/responses\")();\n    const headers = new Headers(compactMap({\n        \"Content-Type\": \"application/json\",\n        Accept: request?.stream ? \"text/event-stream\" : \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"createResponses\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"POST\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\n            \"400\",\n            \"401\",\n            \"402\",\n            \"404\",\n            \"408\",\n            \"413\",\n            \"422\",\n            \"429\",\n            \"4XX\",\n            \"500\",\n            \"502\",\n            \"503\",\n            \"524\",\n            \"529\",\n            \"5XX\",\n        ],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.CreateResponsesResponse$inboundSchema), M.sse(200, operations.CreateResponsesResponse$inboundSchema), M.jsonErr(400, errors.BadRequestResponseError$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(402, errors.PaymentRequiredResponseError$inboundSchema), M.jsonErr(404, errors.NotFoundResponseError$inboundSchema), M.jsonErr(408, errors.RequestTimeoutResponseError$inboundSchema), M.jsonErr(413, errors.PayloadTooLargeResponseError$inboundSchema), M.jsonErr(422, errors.UnprocessableEntityResponseError$inboundSchema), M.jsonErr(429, errors.TooManyRequestsResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.jsonErr(502, errors.BadGatewayResponseError$inboundSchema), M.jsonErr(503, errors.ServiceUnavailableResponseError$inboundSchema), M.jsonErr(524, errors.EdgeNetworkTimeoutResponseError$inboundSchema), M.jsonErr(529, errors.ProviderOverloadedResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=betaResponsesSend.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1184, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/chatSend.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeJSON } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as models from \"../models/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\nexport function chatSend(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => models.ChatGenerationParams$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = encodeJSON(\"body\", payload, { explode: true });\n    const path = pathToFunc(\"/chat/completions\")();\n    const headers = new Headers(compactMap({\n        \"Content-Type\": \"application/json\",\n        Accept: request?.stream ? \"text/event-stream\" : \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"sendChatCompletionRequest\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"POST\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"400\", \"401\", \"429\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.SendChatCompletionRequestResponse$inboundSchema), M.sse(200, operations.SendChatCompletionRequestResponse$inboundSchema), M.jsonErr([400, 401, 429], errors.ChatError$inboundSchema), M.jsonErr(500, errors.ChatError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=chatSend.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AACO,SAAS,SAAS,MAAM,EAAE,OAAO,EAAE,OAAO;IAC7C,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ,SAAS;AAC/C;AACA,eAAe,IAAI,MAAM,EAAE,OAAO,EAAE,OAAO;IACvC,MAAM,SAAS,IAAA,yKAAS,EAAC,SAAS,CAAC,QAAU,mNAA0C,CAAC,KAAK,CAAC,QAAQ;IACtG,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;YAAU;SAAE;IAC1C;IACA,MAAM,UAAU,OAAO,KAAK;IAC5B,MAAM,OAAO,IAAA,4KAAU,EAAC,QAAQ,SAAS;QAAE,SAAS;IAAK;IACzD,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,gBAAgB;QAChB,QAAQ,SAAS,SAAS,sBAAsB;IACpD;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,MAAM;QACN,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;YAAO;YAAO;SAAM;QACtD,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,kPAA0D,GAAG,oKAAK,CAAC,KAAK,kPAA0D,GAAG,wKAAS,CAAC;QAAC;QAAK;QAAK;KAAI,EAAE,sMAA8B,GAAG,wKAAS,CAAC,KAAK,sMAA8B,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IACvW,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,oCAAoC","ignoreList":[0]}},
    {"offset": {"line": 1333, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/completionsGenerate.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeJSON } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as models from \"../models/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Create a completion\n *\n * @remarks\n * Creates a completion for the provided prompt and parameters. Supports both streaming and non-streaming modes.\n */\nexport function completionsGenerate(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => models.CompletionCreateParams$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = encodeJSON(\"body\", payload, { explode: true });\n    const path = pathToFunc(\"/completions\")();\n    const headers = new Headers(compactMap({\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"createCompletions\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"POST\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"400\", \"401\", \"429\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, models.CompletionResponse$inboundSchema), M.jsonErr([400, 401, 429], errors.ChatError$inboundSchema), M.jsonErr(500, errors.ChatError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=completionsGenerate.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;AAOO,SAAS,oBAAoB,MAAM,EAAE,OAAO,EAAE,OAAO;IACxD,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ,SAAS;AAC/C;AACA,eAAe,IAAI,MAAM,EAAE,OAAO,EAAE,OAAO;IACvC,MAAM,SAAS,IAAA,yKAAS,EAAC,SAAS,CAAC,QAAU,uNAA4C,CAAC,KAAK,CAAC,QAAQ;IACxG,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;YAAU;SAAE;IAC1C;IACA,MAAM,UAAU,OAAO,KAAK;IAC5B,MAAM,OAAO,IAAA,4KAAU,EAAC,QAAQ,SAAS;QAAE,SAAS;IAAK;IACzD,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,gBAAgB;QAChB,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,MAAM;QACN,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;YAAO;YAAO;SAAM;QACtD,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,8MAAuC,GAAG,wKAAS,CAAC;QAAC;QAAK;QAAK;KAAI,EAAE,sMAA8B,GAAG,wKAAS,CAAC,KAAK,sMAA8B,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IAC5Q,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 1481, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/creditsCreateCoinbaseCharge.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeJSON } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { resolveSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as models from \"../models/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Create a Coinbase charge for crypto payment\n *\n * @remarks\n * Create a Coinbase charge for crypto payment\n */\nexport function creditsCreateCoinbaseCharge(client, security, request, options) {\n    return new APIPromise($do(client, security, request, options));\n}\nasync function $do(client, security, request, options) {\n    const parsed = safeParse(request, (value) => models.CreateChargeRequest$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = encodeJSON(\"body\", payload, { explode: true });\n    const path = pathToFunc(\"/credits/coinbase\")();\n    const headers = new Headers(compactMap({\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n    }));\n    const requestSecurity = resolveSecurity([\n        {\n            fieldName: \"Authorization\",\n            type: \"http:bearer\",\n            value: security?.bearer,\n        },\n    ]);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"createCoinbaseCharge\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: security,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"POST\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"400\", \"401\", \"429\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.CreateCoinbaseChargeResponse$inboundSchema), M.jsonErr(400, errors.BadRequestResponseError$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(429, errors.TooManyRequestsResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=creditsCreateCoinbaseCharge.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;AAOO,SAAS,4BAA4B,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO;IAC1E,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ,UAAU,SAAS;AACzD;AACA,eAAe,IAAI,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO;IACjD,MAAM,SAAS,IAAA,yKAAS,EAAC,SAAS,CAAC,QAAU,iNAAyC,CAAC,KAAK,CAAC,QAAQ;IACrG,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;YAAU;SAAE;IAC1C;IACA,MAAM,UAAU,OAAO,KAAK;IAC5B,MAAM,OAAO,IAAA,4KAAU,EAAC,QAAQ,SAAS;QAAE,SAAS;IAAK;IACzD,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,gBAAgB;QAChB,QAAQ;IACZ;IACA,MAAM,kBAAkB,IAAA,gLAAe,EAAC;QACpC;YACI,WAAW;YACX,MAAM;YACN,OAAO,UAAU;QACrB;KACH;IACD,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB;QAChB,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,MAAM;QACN,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;YAAO;YAAO;SAAM;QACtD,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,wOAAqD,GAAG,wKAAS,CAAC,KAAK,kOAA4C,GAAG,wKAAS,CAAC,KAAK,sOAA8C,GAAG,wKAAS,CAAC,KAAK,4OAAiD,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IACjb,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,uDAAuD","ignoreList":[0]}},
    {"offset": {"line": 1631, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/creditsGetCredits.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Get remaining credits\n *\n * @remarks\n * Get total credits purchased and used for the authenticated user\n */\nexport function creditsGetCredits(client, options) {\n    return new APIPromise($do(client, options));\n}\nasync function $do(client, options) {\n    const path = pathToFunc(\"/credits\")();\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"getCredits\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"401\", \"403\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.GetCreditsResponse$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(403, errors.ForbiddenResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=creditsGetCredits.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;;AAOO,SAAS,kBAAkB,MAAM,EAAE,OAAO;IAC7C,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ;AACtC;AACA,eAAe,IAAI,MAAM,EAAE,OAAO;IAC9B,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;QAC/C,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,oNAA2C,GAAG,wKAAS,CAAC,KAAK,sOAA8C,GAAG,wKAAS,CAAC,KAAK,gOAA2C,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IACnW,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,6CAA6C","ignoreList":[0]}},
    {"offset": {"line": 1756, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/embeddingsGenerate.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeJSON } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Submit an embedding request\n *\n * @remarks\n * Submits an embedding request to the embeddings router\n */\nexport function embeddingsGenerate(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => operations.CreateEmbeddingsRequest$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = encodeJSON(\"body\", payload, { explode: true });\n    const path = pathToFunc(\"/embeddings\")();\n    const headers = new Headers(compactMap({\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json;q=1, text/event-stream;q=0\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"createEmbeddings\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"POST\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\n            \"400\",\n            \"401\",\n            \"402\",\n            \"404\",\n            \"429\",\n            \"4XX\",\n            \"500\",\n            \"502\",\n            \"503\",\n            \"524\",\n            \"529\",\n            \"5XX\",\n        ],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.CreateEmbeddingsResponse$inboundSchema), M.text(200, operations.CreateEmbeddingsResponse$inboundSchema, {\n        ctype: \"text/event-stream\",\n    }), M.jsonErr(400, errors.BadRequestResponseError$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(402, errors.PaymentRequiredResponseError$inboundSchema), M.jsonErr(404, errors.NotFoundResponseError$inboundSchema), M.jsonErr(429, errors.TooManyRequestsResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.jsonErr(502, errors.BadGatewayResponseError$inboundSchema), M.jsonErr(503, errors.ServiceUnavailableResponseError$inboundSchema), M.jsonErr(524, errors.EdgeNetworkTimeoutResponseError$inboundSchema), M.jsonErr(529, errors.ProviderOverloadedResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=embeddingsGenerate.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1916, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/embeddingsListModels.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as models from \"../models/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * List all embeddings models\n *\n * @remarks\n * Returns a list of all available embeddings models and their properties\n */\nexport function embeddingsListModels(client, options) {\n    return new APIPromise($do(client, options));\n}\nasync function $do(client, options) {\n    const path = pathToFunc(\"/embeddings/models\")();\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"listEmbeddingsModels\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"400\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, models.ModelsListResponse$inboundSchema), M.jsonErr(400, errors.BadRequestResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=embeddingsListModels.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;AAOO,SAAS,qBAAqB,MAAM,EAAE,OAAO;IAChD,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ;AACtC;AACA,eAAe,IAAI,MAAM,EAAE,OAAO;IAC9B,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;SAAM;QACxC,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,8MAAuC,GAAG,wKAAS,CAAC,KAAK,kOAA4C,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IAChS,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 2039, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/endpointsList.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeSimple } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * List all endpoints for a model\n */\nexport function endpointsList(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => operations.ListEndpointsRequest$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = null;\n    const pathParams = {\n        author: encodeSimple(\"author\", payload.author, {\n            explode: false,\n            charEncoding: \"percent\",\n        }),\n        slug: encodeSimple(\"slug\", payload.slug, {\n            explode: false,\n            charEncoding: \"percent\",\n        }),\n    };\n    const path = pathToFunc(\"/models/{author}/{slug}/endpoints\")(pathParams);\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"listEndpoints\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"404\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.ListEndpointsResponse$inboundSchema), M.jsonErr(404, errors.NotFoundResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=endpointsList.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2188, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/endpointsListZdrEndpoints.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Preview the impact of ZDR on the available endpoints\n */\nexport function endpointsListZdrEndpoints(client, options) {\n    return new APIPromise($do(client, options));\n}\nasync function $do(client, options) {\n    const path = pathToFunc(\"/endpoints/zdr\")();\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"listEndpointsZdr\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.ListEndpointsZdrResponse$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=endpointsListZdrEndpoints.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAIO,SAAS,0BAA0B,MAAM,EAAE,OAAO;IACrD,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ;AACtC;AACA,eAAe,IAAI,MAAM,EAAE,OAAO;IAC9B,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;SAAM;QACjC,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,gOAAiD,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IAC5O,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 2309, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/generationsGetGeneration.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeFormQuery } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Get request & usage metadata for a generation\n */\nexport function generationsGetGeneration(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => operations.GetGenerationRequest$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = null;\n    const path = pathToFunc(\"/generation\")();\n    const query = encodeFormQuery({\n        \"id\": payload.id,\n    });\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"getGeneration\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        query: query,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\n            \"401\",\n            \"402\",\n            \"404\",\n            \"429\",\n            \"4XX\",\n            \"500\",\n            \"502\",\n            \"524\",\n            \"529\",\n            \"5XX\",\n        ],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.GetGenerationResponse$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(402, errors.PaymentRequiredResponseError$inboundSchema), M.jsonErr(404, errors.NotFoundResponseError$inboundSchema), M.jsonErr(429, errors.TooManyRequestsResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.jsonErr(502, errors.BadGatewayResponseError$inboundSchema), M.jsonErr(524, errors.EdgeNetworkTimeoutResponseError$inboundSchema), M.jsonErr(529, errors.ProviderOverloadedResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=generationsGetGeneration.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2464, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/modelsCount.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as models from \"../models/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Get total count of available models\n */\nexport function modelsCount(client, options) {\n    return new APIPromise($do(client, options));\n}\nasync function $do(client, options) {\n    const path = pathToFunc(\"/models/count\")();\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"listModelsCount\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, models.ModelsCountResponse$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=modelsCount.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAIO,SAAS,YAAY,MAAM,EAAE,OAAO;IACvC,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ;AACtC;AACA,eAAe,IAAI,MAAM,EAAE,OAAO;IAC9B,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;SAAM;QACjC,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,gNAAwC,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IACnO,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 2585, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/modelsList.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeFormQuery } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as models from \"../models/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * List all models and their properties\n */\nexport function modelsList(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => operations.GetModelsRequest$outboundSchema.optional().parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = null;\n    const path = pathToFunc(\"/models\")();\n    const query = encodeFormQuery({\n        \"category\": payload?.category,\n        \"supported_parameters\": payload?.supported_parameters,\n    });\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"getModels\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        query: query,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"400\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, models.ModelsListResponse$inboundSchema), M.jsonErr(400, errors.BadRequestResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=modelsList.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;AAIO,SAAS,WAAW,MAAM,EAAE,OAAO,EAAE,OAAO;IAC/C,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ,SAAS;AAC/C;AACA,eAAe,IAAI,MAAM,EAAE,OAAO,EAAE,OAAO;IACvC,MAAM,SAAS,IAAA,yKAAS,EAAC,SAAS,CAAC,QAAU,kNAA0C,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ;IACjH,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;YAAU;SAAE;IAC1C;IACA,MAAM,UAAU,OAAO,KAAK;IAC5B,MAAM,OAAO;IACb,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,QAAQ,IAAA,iLAAe,EAAC;QAC1B,YAAY,SAAS;QACrB,wBAAwB,SAAS;IACrC;IACA,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,OAAO;QACP,MAAM;QACN,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;SAAM;QACxC,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,8MAAuC,GAAG,wKAAS,CAAC,KAAK,kOAA4C,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IAChS,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 2731, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/modelsListForUser.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { resolveSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as models from \"../models/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * List models filtered by user provider preferences\n */\nexport function modelsListForUser(client, security, options) {\n    return new APIPromise($do(client, security, options));\n}\nasync function $do(client, security, options) {\n    const path = pathToFunc(\"/models/user\")();\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const requestSecurity = resolveSecurity([\n        {\n            fieldName: \"Authorization\",\n            type: \"http:bearer\",\n            value: security?.bearer,\n        },\n    ]);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"listModelsUser\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: security,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"401\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, models.ModelsListResponse$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=modelsListForUser.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;AAIO,SAAS,kBAAkB,MAAM,EAAE,QAAQ,EAAE,OAAO;IACvD,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ,UAAU;AAChD;AACA,eAAe,IAAI,MAAM,EAAE,QAAQ,EAAE,OAAO;IACxC,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,QAAQ;IACZ;IACA,MAAM,kBAAkB,IAAA,gLAAe,EAAC;QACpC;YACI,WAAW;YACX,MAAM;YACN,OAAO,UAAU;QACrB;KACH;IACD,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB;QAChB,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;SAAM;QACxC,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,8MAAuC,GAAG,wKAAS,CAAC,KAAK,sOAA8C,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IAClS,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,6CAA6C","ignoreList":[0]}},
    {"offset": {"line": 2856, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/oAuthCreateAuthCode.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeJSON } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Create authorization code\n *\n * @remarks\n * Create an authorization code for the PKCE flow to generate a user-controlled API key\n */\nexport function oAuthCreateAuthCode(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => operations.CreateAuthKeysCodeRequest$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = encodeJSON(\"body\", payload, { explode: true });\n    const path = pathToFunc(\"/auth/keys/code\")();\n    const headers = new Headers(compactMap({\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"createAuthKeysCode\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"POST\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"400\", \"401\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.CreateAuthKeysCodeResponse$inboundSchema), M.jsonErr(400, errors.BadRequestResponseError$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=oAuthCreateAuthCode.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;;;;AAOO,SAAS,oBAAoB,MAAM,EAAE,OAAO,EAAE,OAAO;IACxD,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ,SAAS;AAC/C;AACA,eAAe,IAAI,MAAM,EAAE,OAAO,EAAE,OAAO;IACvC,MAAM,SAAS,IAAA,yKAAS,EAAC,SAAS,CAAC,QAAU,oOAAmD,CAAC,KAAK,CAAC,QAAQ;IAC/G,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;YAAU;SAAE;IAC1C;IACA,MAAM,UAAU,OAAO,KAAK;IAC5B,MAAM,OAAO,IAAA,4KAAU,EAAC,QAAQ,SAAS;QAAE,SAAS;IAAK;IACzD,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,gBAAgB;QAChB,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,MAAM;QACN,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;QAC/C,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,oOAAmD,GAAG,wKAAS,CAAC,KAAK,kOAA4C,GAAG,wKAAS,CAAC,KAAK,sOAA8C,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IAC5W,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 3000, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/oAuthExchangeAuthCodeForAPIKey.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeJSON } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Exchange authorization code for API key\n *\n * @remarks\n * Exchange an authorization code from the PKCE flow for a user-controlled API key\n */\nexport function oAuthExchangeAuthCodeForAPIKey(client, request, options) {\n    return new APIPromise($do(client, request, options));\n}\nasync function $do(client, request, options) {\n    const parsed = safeParse(request, (value) => operations.ExchangeAuthCodeForAPIKeyRequest$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = encodeJSON(\"body\", payload, { explode: true });\n    const path = pathToFunc(\"/auth/keys\")();\n    const headers = new Headers(compactMap({\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"exchangeAuthCodeForAPIKey\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"POST\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"400\", \"403\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.ExchangeAuthCodeForAPIKeyResponse$inboundSchema), M.jsonErr(400, errors.BadRequestResponseError$inboundSchema), M.jsonErr(403, errors.ForbiddenResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=oAuthExchangeAuthCodeForAPIKey.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;;;;AAOO,SAAS,+BAA+B,MAAM,EAAE,OAAO,EAAE,OAAO;IACnE,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ,SAAS;AAC/C;AACA,eAAe,IAAI,MAAM,EAAE,OAAO,EAAE,OAAO;IACvC,MAAM,SAAS,IAAA,yKAAS,EAAC,SAAS,CAAC,QAAU,kPAA0D,CAAC,KAAK,CAAC,QAAQ;IACtH,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;YAAU;SAAE;IAC1C;IACA,MAAM,UAAU,OAAO,KAAK;IAC5B,MAAM,OAAO,IAAA,4KAAU,EAAC,QAAQ,SAAS;QAAE,SAAS;IAAK;IACzD,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,gBAAgB;QAChB,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,MAAM;QACN,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;QAC/C,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,kPAA0D,GAAG,wKAAS,CAAC,KAAK,kOAA4C,GAAG,wKAAS,CAAC,KAAK,gOAA2C,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IAChX,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,0DAA0D","ignoreList":[0]}},
    {"offset": {"line": 3144, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/oAuthCreateAuthorizationUrl.js"],"sourcesContent":["import z from \"zod/v3\";\nimport { serverURLFromOptions } from \"../lib/config.js\";\nconst CreateAuthorizationUrlBaseSchema = z.object({\n    callbackUrl: z.union([z.string().url(), z.instanceof(URL)]),\n    limit: z.number().optional(),\n});\nconst CreateAuthorizationurlParamsSchema = z.union([\n    CreateAuthorizationUrlBaseSchema.extend({\n        codeChallengeMethod: z.enum([\"S256\", \"plain\"]),\n        codeChallenge: z.string(),\n    }),\n    CreateAuthorizationUrlBaseSchema,\n]);\n/**\n * Generate a OAuth2 authorization URL\n *\n * @remarks\n * Generates a URL to redirect users to for authorizing your application. The\n * URL includes the provided callback URL and, if applicable, the code\n * challenge parameters for PKCE.\n *\n * @see {@link https://openrouter.ai/docs/use-cases/oauth-pkce}\n */\nexport function oAuthCreateAuthorizationUrl(client, params) {\n    const parsedParams = CreateAuthorizationurlParamsSchema.safeParse(params);\n    if (!parsedParams.success)\n        return { ok: false, error: parsedParams.error };\n    const baseURL = serverURLFromOptions(client._options);\n    if (!baseURL) {\n        return { ok: false, error: new Error(\"No server URL configured\") };\n    }\n    // Clone the URL to avoid mutating the original\n    const authURL = new URL(\"/auth\", baseURL);\n    authURL.searchParams.set(\"callback_url\", parsedParams.data.callbackUrl.toString());\n    if (\"codeChallengeMethod\" in parsedParams.data) {\n        authURL.searchParams.set(\"code_challenge\", parsedParams.data.codeChallenge);\n        authURL.searchParams.set(\"code_challenge_method\", parsedParams.data.codeChallengeMethod);\n    }\n    if (parsedParams.data.limit !== undefined) {\n        authURL.searchParams.set(\"limit\", parsedParams.data.limit.toString());\n    }\n    return { ok: true, value: authURL.toString() };\n}\n//# sourceMappingURL=oAuthCreateAuthorizationUrl.js.map"],"names":[],"mappings":";;;;AAAA;AACA;;;AACA,MAAM,mCAAmC,6JAAC,CAAC,MAAM,CAAC;IAC9C,aAAa,6JAAC,CAAC,KAAK,CAAC;QAAC,6JAAC,CAAC,MAAM,GAAG,GAAG;QAAI,6JAAC,CAAC,UAAU,CAAC;KAAK;IAC1D,OAAO,6JAAC,CAAC,MAAM,GAAG,QAAQ;AAC9B;AACA,MAAM,qCAAqC,6JAAC,CAAC,KAAK,CAAC;IAC/C,iCAAiC,MAAM,CAAC;QACpC,qBAAqB,6JAAC,CAAC,IAAI,CAAC;YAAC;YAAQ;SAAQ;QAC7C,eAAe,6JAAC,CAAC,MAAM;IAC3B;IACA;CACH;AAWM,SAAS,4BAA4B,MAAM,EAAE,MAAM;IACtD,MAAM,eAAe,mCAAmC,SAAS,CAAC;IAClE,IAAI,CAAC,aAAa,OAAO,EACrB,OAAO;QAAE,IAAI;QAAO,OAAO,aAAa,KAAK;IAAC;IAClD,MAAM,UAAU,IAAA,mLAAoB,EAAC,OAAO,QAAQ;IACpD,IAAI,CAAC,SAAS;QACV,OAAO;YAAE,IAAI;YAAO,OAAO,IAAI,MAAM;QAA4B;IACrE;IACA,+CAA+C;IAC/C,MAAM,UAAU,IAAI,IAAI,SAAS;IACjC,QAAQ,YAAY,CAAC,GAAG,CAAC,gBAAgB,aAAa,IAAI,CAAC,WAAW,CAAC,QAAQ;IAC/E,IAAI,yBAAyB,aAAa,IAAI,EAAE;QAC5C,QAAQ,YAAY,CAAC,GAAG,CAAC,kBAAkB,aAAa,IAAI,CAAC,aAAa;QAC1E,QAAQ,YAAY,CAAC,GAAG,CAAC,yBAAyB,aAAa,IAAI,CAAC,mBAAmB;IAC3F;IACA,IAAI,aAAa,IAAI,CAAC,KAAK,KAAK,WAAW;QACvC,QAAQ,YAAY,CAAC,GAAG,CAAC,SAAS,aAAa,IAAI,CAAC,KAAK,CAAC,QAAQ;IACtE;IACA,OAAO;QAAE,IAAI;QAAM,OAAO,QAAQ,QAAQ;IAAG;AACjD,EACA,uDAAuD","ignoreList":[0]}},
    {"offset": {"line": 3201, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/oAuthCreateSHA256CodeChallenge.js"],"sourcesContent":["import z from \"zod/v3\";\nconst CreateSHA256CodeChallengeRequestSchema = z.object({\n    /**\n     * If not provided, a random code verifier will be generated.\n     * If provided, must be 43-128 characters and contain only unreserved\n     * characters [A-Za-z0-9-._~] per RFC 7636.\n     */\n    codeVerifier: z\n        .string()\n        .min(43, \"Code verifier must be at least 43 characters\")\n        .max(128, \"Code verifier must be at most 128 characters\")\n        .regex(/^[A-Za-z0-9\\-._~]+$/, \"Code verifier must only contain unreserved characters: [A-Za-z0-9-._~]\")\n        .optional(),\n});\n/**\n * Convert a Uint8Array to base64url encoding (RFC 4648)\n */\nfunction arrayBufferToBase64Url(buffer) {\n    let binary = \"\";\n    for (let i = 0; i < buffer.length; i++) {\n        binary += String.fromCharCode(buffer[i]);\n    }\n    return btoa(binary)\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\")\n        .replace(/=+$/, \"\");\n}\n/**\n * Generate a cryptographically random code verifier per RFC 7636\n */\nfunction generateCodeVerifier() {\n    // RFC 7636 recommends 32 octets of random data, base64url encoded = 43 chars\n    const randomBytes = crypto.getRandomValues(new Uint8Array(32));\n    return arrayBufferToBase64Url(randomBytes);\n}\n/**\n * Generate a SHA-256 code challenge for PKCE\n *\n * @remarks\n * Generates a SHA-256 code challenge and corresponding code verifier for use\n * in the PKCE extension to OAuth2. If no code verifier is provided, a random\n * one will be generated according to RFC 7636 (32 random bytes, base64url\n * encoded). If a code verifier is provided, it must be 43-128 characters and\n * contain only unreserved characters [A-Za-z0-9-._~].\n *\n * @see {@link https://openrouter.ai/docs/use-cases/oauth-pkce}\n * @see {@link https://datatracker.ietf.org/doc/html/rfc7636}\n */\nexport async function oAuthCreateSHA256CodeChallenge(params = {}) {\n    const parsedParams = CreateSHA256CodeChallengeRequestSchema.safeParse(params);\n    if (!parsedParams.success)\n        return { ok: false, error: parsedParams.error };\n    const { codeVerifier = generateCodeVerifier() } = parsedParams.data;\n    // Generate SHA-256 hash\n    const encoder = new TextEncoder();\n    const data = encoder.encode(codeVerifier);\n    const hash = await crypto.subtle.digest(\"SHA-256\", data);\n    // Convert hash to base64url\n    const hashArray = new Uint8Array(hash);\n    const codeChallenge = arrayBufferToBase64Url(hashArray);\n    return {\n        ok: true,\n        value: {\n            codeChallenge,\n            codeVerifier,\n        },\n    };\n}\n//# sourceMappingURL=oAuthCreateSHA256CodeChallenge.js.map"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,yCAAyC,6JAAC,CAAC,MAAM,CAAC;IACpD;;;;KAIC,GACD,cAAc,6JAAC,CACV,MAAM,GACN,GAAG,CAAC,IAAI,gDACR,GAAG,CAAC,KAAK,gDACT,KAAK,CAAC,uBAAuB,0EAC7B,QAAQ;AACjB;AACA;;CAEC,GACD,SAAS,uBAAuB,MAAM;IAClC,IAAI,SAAS;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAK;QACpC,UAAU,OAAO,YAAY,CAAC,MAAM,CAAC,EAAE;IAC3C;IACA,OAAO,KAAK,QACP,OAAO,CAAC,OAAO,KACf,OAAO,CAAC,OAAO,KACf,OAAO,CAAC,OAAO;AACxB;AACA;;CAEC,GACD,SAAS;IACL,6EAA6E;IAC7E,MAAM,cAAc,OAAO,eAAe,CAAC,IAAI,WAAW;IAC1D,OAAO,uBAAuB;AAClC;AAcO,eAAe,+BAA+B,SAAS,CAAC,CAAC;IAC5D,MAAM,eAAe,uCAAuC,SAAS,CAAC;IACtE,IAAI,CAAC,aAAa,OAAO,EACrB,OAAO;QAAE,IAAI;QAAO,OAAO,aAAa,KAAK;IAAC;IAClD,MAAM,EAAE,eAAe,sBAAsB,EAAE,GAAG,aAAa,IAAI;IACnE,wBAAwB;IACxB,MAAM,UAAU,IAAI;IACpB,MAAM,OAAO,QAAQ,MAAM,CAAC;IAC5B,MAAM,OAAO,MAAM,OAAO,MAAM,CAAC,MAAM,CAAC,WAAW;IACnD,4BAA4B;IAC5B,MAAM,YAAY,IAAI,WAAW;IACjC,MAAM,gBAAgB,uBAAuB;IAC7C,OAAO;QACH,IAAI;QACJ,OAAO;YACH;YACA;QACJ;IACJ;AACJ,EACA,0DAA0D","ignoreList":[0]}},
    {"offset": {"line": 3256, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/parametersGetParameters.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport { encodeFormQuery, encodeSimple } from \"../lib/encodings.js\";\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { safeParse } from \"../lib/schemas.js\";\nimport { resolveSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * Get a model's supported parameters and data about which are most popular\n */\nexport function parametersGetParameters(client, security, request, options) {\n    return new APIPromise($do(client, security, request, options));\n}\nasync function $do(client, security, request, options) {\n    const parsed = safeParse(request, (value) => operations.GetParametersRequest$outboundSchema.parse(value), \"Input validation failed\");\n    if (!parsed.ok) {\n        return [parsed, { status: \"invalid\" }];\n    }\n    const payload = parsed.value;\n    const body = null;\n    const pathParams = {\n        author: encodeSimple(\"author\", payload.author, {\n            explode: false,\n            charEncoding: \"percent\",\n        }),\n        slug: encodeSimple(\"slug\", payload.slug, {\n            explode: false,\n            charEncoding: \"percent\",\n        }),\n    };\n    const path = pathToFunc(\"/parameters/{author}/{slug}\")(pathParams);\n    const query = encodeFormQuery({\n        \"provider\": payload.provider,\n    });\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const requestSecurity = resolveSecurity([\n        {\n            fieldName: \"Authorization\",\n            type: \"http:bearer\",\n            value: security?.bearer,\n        },\n    ]);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"getParameters\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: security,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        query: query,\n        body: body,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"401\", \"404\", \"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.GetParametersResponse$inboundSchema), M.jsonErr(401, errors.UnauthorizedResponseError$inboundSchema), M.jsonErr(404, errors.NotFoundResponseError$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=parametersGetParameters.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3413, "column": 0}, "map": {"version":3,"sources":["file:///D:/Nxtjs/rag-chatbot/node_modules/%40openrouter/sdk/esm/funcs/providersList.js"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nimport * as M from \"../lib/matchers.js\";\nimport { compactMap } from \"../lib/primitives.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport * as operations from \"../models/operations/index.js\";\nimport { APIPromise } from \"../types/async.js\";\n/**\n * List all providers\n */\nexport function providersList(client, options) {\n    return new APIPromise($do(client, options));\n}\nasync function $do(client, options) {\n    const path = pathToFunc(\"/providers\")();\n    const headers = new Headers(compactMap({\n        Accept: \"application/json\",\n    }));\n    const secConfig = await extractSecurity(client._options.apiKey);\n    const securityInput = secConfig == null ? {} : { apiKey: secConfig };\n    const requestSecurity = resolveGlobalSecurity(securityInput);\n    const context = {\n        options: client._options,\n        baseURL: options?.serverURL ?? client._baseURL ?? \"\",\n        operationID: \"listProviders\",\n        oAuth2Scopes: null,\n        resolvedSecurity: requestSecurity,\n        securitySource: client._options.apiKey,\n        retryConfig: options?.retries\n            || client._options.retryConfig\n            || { strategy: \"none\" },\n        retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n    };\n    const requestRes = client._createRequest(context, {\n        security: requestSecurity,\n        method: \"GET\",\n        baseURL: options?.serverURL,\n        path: path,\n        headers: headers,\n        userAgent: client._options.userAgent,\n        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,\n    }, options);\n    if (!requestRes.ok) {\n        return [requestRes, { status: \"invalid\" }];\n    }\n    const req = requestRes.value;\n    const doResult = await client._do(req, {\n        context,\n        errorCodes: [\"4XX\", \"500\", \"5XX\"],\n        retryConfig: context.retryConfig,\n        retryCodes: context.retryCodes,\n    });\n    if (!doResult.ok) {\n        return [doResult, { status: \"request-error\", request: req }];\n    }\n    const response = doResult.value;\n    const responseFields = {\n        HttpMeta: { Response: response, Request: req },\n    };\n    const [result] = await M.match(M.json(200, operations.ListProvidersResponse$inboundSchema), M.jsonErr(500, errors.InternalServerResponseError$inboundSchema), M.fail(\"4XX\"), M.fail(\"5XX\"))(response, req, { extraFields: responseFields });\n    if (!result.ok) {\n        return [result, { status: \"complete\", request: req, response }];\n    }\n    return [result, { status: \"complete\", request: req, response }];\n}\n//# sourceMappingURL=providersList.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAIO,SAAS,cAAc,MAAM,EAAE,OAAO;IACzC,OAAO,IAAI,0KAAU,CAAC,IAAI,QAAQ;AACtC;AACA,eAAe,IAAI,MAAM,EAAE,OAAO;IAC9B,MAAM,OAAO,IAAA,sKAAU,EAAC;IACxB,MAAM,UAAU,IAAI,QAAQ,IAAA,6KAAU,EAAC;QACnC,QAAQ;IACZ;IACA,MAAM,YAAY,MAAM,IAAA,gLAAe,EAAC,OAAO,QAAQ,CAAC,MAAM;IAC9D,MAAM,gBAAgB,aAAa,OAAO,CAAC,IAAI;QAAE,QAAQ;IAAU;IACnE,MAAM,kBAAkB,IAAA,sLAAqB,EAAC;IAC9C,MAAM,UAAU;QACZ,SAAS,OAAO,QAAQ;QACxB,SAAS,SAAS,aAAa,OAAO,QAAQ,IAAI;QAClD,aAAa;QACb,cAAc;QACd,kBAAkB;QAClB,gBAAgB,OAAO,QAAQ,CAAC,MAAM;QACtC,aAAa,SAAS,WACf,OAAO,QAAQ,CAAC,WAAW,IAC3B;YAAE,UAAU;QAAO;QAC1B,YAAY,SAAS,cAAc;YAAC;YAAO;YAAO;YAAO;YAAO;SAAM;IAC1E;IACA,MAAM,aAAa,OAAO,cAAc,CAAC,SAAS;QAC9C,UAAU;QACV,QAAQ;QACR,SAAS,SAAS;QAClB,MAAM;QACN,SAAS;QACT,WAAW,OAAO,QAAQ,CAAC,SAAS;QACpC,WAAW,SAAS,aAAa,OAAO,QAAQ,CAAC,SAAS,IAAI,CAAC;IACnE,GAAG;IACH,IAAI,CAAC,WAAW,EAAE,EAAE;QAChB,OAAO;YAAC;YAAY;gBAAE,QAAQ;YAAU;SAAE;IAC9C;IACA,MAAM,MAAM,WAAW,KAAK;IAC5B,MAAM,WAAW,MAAM,OAAO,GAAG,CAAC,KAAK;QACnC;QACA,YAAY;YAAC;YAAO;YAAO;SAAM;QACjC,aAAa,QAAQ,WAAW;QAChC,YAAY,QAAQ,UAAU;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,OAAO;YAAC;YAAU;gBAAE,QAAQ;gBAAiB,SAAS;YAAI;SAAE;IAChE;IACA,MAAM,WAAW,SAAS,KAAK;IAC/B,MAAM,iBAAiB;QACnB,UAAU;YAAE,UAAU;YAAU,SAAS;QAAI;IACjD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,sKAAO,CAAC,qKAAM,CAAC,KAAK,0NAA8C,GAAG,wKAAS,CAAC,KAAK,0OAAgD,GAAG,qKAAM,CAAC,QAAQ,qKAAM,CAAC,QAAQ,UAAU,KAAK;QAAE,aAAa;IAAe;IACzO,IAAI,CAAC,OAAO,EAAE,EAAE;QACZ,OAAO;YAAC;YAAQ;gBAAE,QAAQ;gBAAY,SAAS;gBAAK;YAAS;SAAE;IACnE;IACA,OAAO;QAAC;QAAQ;YAAE,QAAQ;YAAY,SAAS;YAAK;QAAS;KAAE;AACnE,EACA,yCAAyC","ignoreList":[0]}}]
}