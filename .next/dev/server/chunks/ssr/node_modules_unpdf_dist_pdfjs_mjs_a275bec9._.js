module.exports = [
"[project]/node_modules/unpdf/dist/pdfjs.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbortException",
    ()=>AbortException,
    "AnnotationEditorLayer",
    ()=>AnnotationEditorLayer,
    "AnnotationEditorParamsType",
    ()=>Xl,
    "AnnotationEditorType",
    ()=>Hl,
    "AnnotationEditorUIManager",
    ()=>AnnotationEditorUIManager,
    "AnnotationLayer",
    ()=>AnnotationLayer,
    "AnnotationMode",
    ()=>jl,
    "AnnotationType",
    ()=>Zl,
    "CSSConstants",
    ()=>CSSConstants,
    "ColorPicker",
    ()=>ColorPicker,
    "DOMSVGFactory",
    ()=>DOMSVGFactory,
    "DrawLayer",
    ()=>DrawLayer,
    "FeatureTest",
    ()=>util_FeatureTest,
    "GlobalWorkerOptions",
    ()=>GlobalWorkerOptions,
    "ImageKind",
    ()=>Jl,
    "InvalidPDFException",
    ()=>InvalidPDFException,
    "MathClamp",
    ()=>MathClamp,
    "OPS",
    ()=>sc,
    "OutputScale",
    ()=>OutputScale,
    "PDFDataRangeTransport",
    ()=>PDFDataRangeTransport,
    "PDFDateString",
    ()=>PDFDateString,
    "PDFWorker",
    ()=>PDFWorker,
    "PasswordResponses",
    ()=>hc,
    "PermissionFlag",
    ()=>ql,
    "PixelsPerInch",
    ()=>PixelsPerInch,
    "RenderingCancelledException",
    ()=>RenderingCancelledException,
    "ResponseException",
    ()=>ResponseException,
    "SignatureExtractor",
    ()=>SignatureExtractor,
    "SupportedImageMimeTypes",
    ()=>yc,
    "TextLayer",
    ()=>TextLayer,
    "TouchManager",
    ()=>TouchManager,
    "Util",
    ()=>Util,
    "VerbosityLevel",
    ()=>ac,
    "XfaLayer",
    ()=>XfaLayer,
    "applyOpacity",
    ()=>applyOpacity,
    "build",
    ()=>hh,
    "createValidAbsoluteUrl",
    ()=>createValidAbsoluteUrl,
    "fetchData",
    ()=>fetchData,
    "findContrastColor",
    ()=>findContrastColor,
    "getDocument",
    ()=>getDocument,
    "getFilenameFromUrl",
    ()=>getFilenameFromUrl,
    "getPdfFilenameFromUrl",
    ()=>getPdfFilenameFromUrl,
    "getRGB",
    ()=>getRGB,
    "getUuid",
    ()=>getUuid,
    "getXfaPageViewport",
    ()=>getXfaPageViewport,
    "isDataScheme",
    ()=>isDataScheme,
    "isPdfFile",
    ()=>isPdfFile,
    "isValidExplicitDest",
    ()=>Cc,
    "noContextMenu",
    ()=>noContextMenu,
    "normalizeUnicode",
    ()=>normalizeUnicode,
    "renderRichText",
    ()=>renderRichText,
    "setLayerDimensions",
    ()=>setLayerDimensions,
    "shadow",
    ()=>shadow,
    "stopEvent",
    ()=>stopEvent,
    "updateUrlHash",
    ()=>updateUrlHash,
    "version",
    ()=>lh
]);
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/unpdf/dist/pdfjs.mjs")}`;
    }
};
void 0 === globalThis.DOMMatrix && (globalThis.DOMMatrix = class {
}), void 0 === globalThis.FinalizationRegistry && (globalThis.FinalizationRegistry = class {
    register() {}
    unregister() {}
}), globalThis.navigator ??= {}, globalThis.navigator.platform ??= "", globalThis.navigator.userAgent ??= "", void 0 === Promise.withResolvers && (Promise.withResolvers = function() {
    let e1, t;
    return {
        promise: new Promise((i, n)=>{
            e1 = i, t = n;
        }),
        resolve: e1,
        reject: t
    };
});
const e1 = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type), t = [
    .001,
    0,
    0,
    .001,
    0,
    0
], i = 1.35, n = .35, a = .25925925925925924, s = 1, r = 2, o = 4, l = 8, c = 16, h = 64, d = 128, u = 256, g = "pdfjs_internal_editor_", f = 3, p = 9, m = 13, b = 15, y = 101, w = {
    PRINT: 4,
    MODIFY_CONTENTS: 8,
    COPY: 16,
    MODIFY_ANNOTATIONS: 32,
    FILL_INTERACTIVE_FORMS: 256,
    COPY_FOR_ACCESSIBILITY: 512,
    ASSEMBLE: 1024,
    PRINT_HIGH_QUALITY: 2048
}, x = 0, S = 4, v = 1, C = 2, k = 3, T = {
    TEXT: 1,
    LINK: 2,
    FREETEXT: 3,
    LINE: 4,
    SQUARE: 5,
    CIRCLE: 6,
    POLYGON: 7,
    POLYLINE: 8,
    HIGHLIGHT: 9,
    UNDERLINE: 10,
    SQUIGGLY: 11,
    STRIKEOUT: 12,
    STAMP: 13,
    CARET: 14,
    INK: 15,
    POPUP: 16,
    FILEATTACHMENT: 17,
    SOUND: 18,
    MOVIE: 19,
    WIDGET: 20,
    SCREEN: 21,
    PRINTERMARK: 22,
    TRAPNET: 23,
    WATERMARK: 24,
    THREED: 25,
    REDACT: 26
}, F = "Group", E = "R", M = 1, D = 2, O = 4, _ = 16, R = 32, N = 128, L = 512, U = 1, j = 2, $ = 4096, H = 8192, X = 32768, q = 65536, z = 131072, W = 1048576, G = 2097152, V = 8388608, K = 16777216, Y = 1, J = 2, Z = 3, Q = 4, ee = 5, te = {
    E: "Mouse Enter",
    X: "Mouse Exit",
    D: "Mouse Down",
    U: "Mouse Up",
    Fo: "Focus",
    Bl: "Blur",
    PO: "PageOpen",
    PC: "PageClose",
    PV: "PageVisible",
    PI: "PageInvisible",
    K: "Keystroke",
    F: "Format",
    V: "Validate",
    C: "Calculate"
}, ie = {
    WC: "WillClose",
    WS: "WillSave",
    DS: "DidSave",
    WP: "WillPrint",
    DP: "DidPrint"
}, ne = {
    O: "PageOpen",
    C: "PageClose"
}, ae = 1, se = 5, re = 1, oe = 2, le = 3, ce = 4, he = 5, de = 6, ue = 7, ge = 8, fe = 9, pe = 10, me = 11, be = 12, ye = 13, we = 14, Ae = 15, xe = 16, Se = 17, ve = 18, Ce = 19, ke = 20, Te = 21, Fe = 22, Ie = 23, Ee = 24, Me = 25, De = 26, Oe = 27, _e = 28, Pe = 29, Re = 30, Be = 31, Ne = 32, Le = 33, Ue = 34, je = 35, $e = 36, He = 37, Xe = 38, qe = 39, ze = 40, We = 41, Ge = 42, Ve = 43, Ke = 44, Ye = 45, Je = 46, Ze = 47, Qe = 48, et = 49, tt = 50, it = 51, nt = 52, at = 53, st = 54, rt = 55, ot = 56, lt = 57, ct = 58, ht = 59, dt = 60, ut = 61, gt = 62, ft = 63, pt = 64, mt = 65, bt = 66, yt = 67, wt = 68, At = 69, xt = 70, St = 71, vt = 72, Ct = 73, kt = 74, Tt = 75, Ft = 76, It = 77, Et = 80, Mt = 81, Dt = 83, Ot = 84, _t = 85, Pt = 86, Rt = 87, Bt = 88, Nt = 89, Lt = 90, Ut = 91, jt = 92, $t = 93, Ht = 94, Xt = 0, qt = 1, zt = 2, Wt = 3, Gt = 1, Vt = 2;
let Kt = ae;
function info$1(e1) {
    Kt >= se && console.info(`Info: ${e1}`);
}
function warn$1(e1) {
    Kt >= ae && console.warn(`Warning: ${e1}`);
}
function unreachable$1(e1) {
    throw new Error(e1);
}
function assert$1(e1, t) {
    e1 || unreachable$1(t);
}
function createValidAbsoluteUrl$1(e1, t = null, i = null) {
    if (!e1) return null;
    if (i && "string" == typeof e1) {
        if (i.addDefaultProtocol && e1.startsWith("www.")) {
            const t = e1.match(/\./g);
            t?.length >= 2 && (e1 = `http://${e1}`);
        }
        if (i.tryConvertEncoding) try {
            e1 = stringToUTF8String$1(e1);
        } catch  {}
    }
    const n = t ? URL.parse(e1, t) : URL.parse(e1);
    return function(e1) {
        switch(e1?.protocol){
            case "http:":
            case "https:":
            case "ftp:":
            case "mailto:":
            case "tel:":
                return !0;
            default:
                return !1;
        }
    }(n) ? n : null;
}
function shadow$1(e1, t, i, n = !1) {
    return Object.defineProperty(e1, t, {
        value: i,
        enumerable: !n,
        configurable: !0,
        writable: !1
    }), i;
}
const Yt = function() {
    function BaseException(e1, t) {
        this.message = e1, this.name = t;
    }
    return BaseException.prototype = new Error, BaseException.constructor = BaseException, BaseException;
}();
let Jt = class extends Yt {
    constructor(e1, t){
        super(e1, "PasswordException"), this.code = t;
    }
}, Zt = class extends Yt {
    constructor(e1, t){
        super(e1, "UnknownErrorException"), this.details = t;
    }
}, Qt = class extends Yt {
    constructor(e1){
        super(e1, "InvalidPDFException");
    }
}, ei = class extends Yt {
    constructor(e1, t, i){
        super(e1, "ResponseException"), this.status = t, this.missing = i;
    }
}, ti = class extends Yt {
    constructor(e1){
        super(e1, "FormatError");
    }
}, ii = class extends Yt {
    constructor(e1){
        super(e1, "AbortException");
    }
};
function bytesToString$1(e1) {
    "object" == typeof e1 && void 0 !== e1?.length || unreachable$1("Invalid argument for bytesToString");
    const t = e1.length, i = 8192;
    if (t < i) return String.fromCharCode.apply(null, e1);
    const n = [];
    for(let a = 0; a < t; a += i){
        const s = Math.min(a + i, t), r = e1.subarray(a, s);
        n.push(String.fromCharCode.apply(null, r));
    }
    return n.join("");
}
function stringToBytes$1(e1) {
    "string" != typeof e1 && unreachable$1("Invalid argument for stringToBytes");
    const t = e1.length, i = new Uint8Array(t);
    for(let n = 0; n < t; ++n)i[n] = 255 & e1.charCodeAt(n);
    return i;
}
function string32$1(e1) {
    return String.fromCharCode(e1 >> 24 & 255, e1 >> 16 & 255, e1 >> 8 & 255, 255 & e1);
}
function objectSize(e1) {
    return Object.keys(e1).length;
}
class FeatureTest {
    static get isLittleEndian() {
        return shadow$1(this, "isLittleEndian", function() {
            const e1 = new Uint8Array(4);
            return e1[0] = 1, 1 === new Uint32Array(e1.buffer, 0, 1)[0];
        }());
    }
    static get isEvalSupported() {
        return shadow$1(this, "isEvalSupported", function() {
            try {
                return new Function(""), !0;
            } catch  {
                return !1;
            }
        }());
    }
    static get isOffscreenCanvasSupported() {
        return shadow$1(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
    }
    static get isImageDecoderSupported() {
        return shadow$1(this, "isImageDecoderSupported", "undefined" != typeof ImageDecoder);
    }
    static get platform() {
        const { platform: e1, userAgent: t } = navigator;
        return shadow$1(this, "platform", {
            isAndroid: t.includes("Android"),
            isLinux: e1.includes("Linux"),
            isMac: e1.includes("Mac"),
            isWindows: e1.includes("Win"),
            isFirefox: t.includes("Firefox")
        });
    }
    static get isCSSRoundSupported() {
        return shadow$1(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
    }
}
const ni = Array.from(Array(256).keys(), (e1)=>e1.toString(16).padStart(2, "0"));
let ai = class {
    static makeHexColor(e1, t, i) {
        return `#${ni[e1]}${ni[t]}${ni[i]}`;
    }
    static domMatrixToTransform(e1) {
        return [
            e1.a,
            e1.b,
            e1.c,
            e1.d,
            e1.e,
            e1.f
        ];
    }
    static scaleMinMax(e1, t) {
        let i;
        e1[0] ? (e1[0] < 0 && (i = t[0], t[0] = t[2], t[2] = i), t[0] *= e1[0], t[2] *= e1[0], e1[3] < 0 && (i = t[1], t[1] = t[3], t[3] = i), t[1] *= e1[3], t[3] *= e1[3]) : (i = t[0], t[0] = t[1], t[1] = i, i = t[2], t[2] = t[3], t[3] = i, e1[1] < 0 && (i = t[1], t[1] = t[3], t[3] = i), t[1] *= e1[1], t[3] *= e1[1], e1[2] < 0 && (i = t[0], t[0] = t[2], t[2] = i), t[0] *= e1[2], t[2] *= e1[2]), t[0] += e1[4], t[1] += e1[5], t[2] += e1[4], t[3] += e1[5];
    }
    static transform(e1, t) {
        return [
            e1[0] * t[0] + e1[2] * t[1],
            e1[1] * t[0] + e1[3] * t[1],
            e1[0] * t[2] + e1[2] * t[3],
            e1[1] * t[2] + e1[3] * t[3],
            e1[0] * t[4] + e1[2] * t[5] + e1[4],
            e1[1] * t[4] + e1[3] * t[5] + e1[5]
        ];
    }
    static multiplyByDOMMatrix(e1, t) {
        return [
            e1[0] * t.a + e1[2] * t.b,
            e1[1] * t.a + e1[3] * t.b,
            e1[0] * t.c + e1[2] * t.d,
            e1[1] * t.c + e1[3] * t.d,
            e1[0] * t.e + e1[2] * t.f + e1[4],
            e1[1] * t.e + e1[3] * t.f + e1[5]
        ];
    }
    static applyTransform(e1, t, i = 0) {
        const n = e1[i], a = e1[i + 1];
        e1[i] = n * t[0] + a * t[2] + t[4], e1[i + 1] = n * t[1] + a * t[3] + t[5];
    }
    static applyTransformToBezier(e1, t, i = 0) {
        const n = t[0], a = t[1], s = t[2], r = t[3], o = t[4], l = t[5];
        for(let t = 0; t < 6; t += 2){
            const c = e1[i + t], h = e1[i + t + 1];
            e1[i + t] = c * n + h * s + o, e1[i + t + 1] = c * a + h * r + l;
        }
    }
    static applyInverseTransform(e1, t) {
        const i = e1[0], n = e1[1], a = t[0] * t[3] - t[1] * t[2];
        e1[0] = (i * t[3] - n * t[2] + t[2] * t[5] - t[4] * t[3]) / a, e1[1] = (-i * t[1] + n * t[0] + t[4] * t[1] - t[5] * t[0]) / a;
    }
    static axialAlignedBoundingBox(e1, t, i) {
        const n = t[0], a = t[1], s = t[2], r = t[3], o = t[4], l = t[5], c = e1[0], h = e1[1], d = e1[2], u = e1[3];
        let g = n * c + o, f = g, p = n * d + o, m = p, b = r * h + l, y = b, w = r * u + l, x = w;
        if (0 !== a || 0 !== s) {
            const e1 = a * c, t = a * d, i = s * h, n = s * u;
            g += i, m += i, p += n, f += n, b += e1, x += e1, w += t, y += t;
        }
        i[0] = Math.min(i[0], g, p, f, m), i[1] = Math.min(i[1], b, w, y, x), i[2] = Math.max(i[2], g, p, f, m), i[3] = Math.max(i[3], b, w, y, x);
    }
    static inverseTransform(e1) {
        const t = e1[0] * e1[3] - e1[1] * e1[2];
        return [
            e1[3] / t,
            -e1[1] / t,
            -e1[2] / t,
            e1[0] / t,
            (e1[2] * e1[5] - e1[4] * e1[3]) / t,
            (e1[4] * e1[1] - e1[5] * e1[0]) / t
        ];
    }
    static singularValueDecompose2dScale(e1, t) {
        const i = e1[0], n = e1[1], a = e1[2], s = e1[3], r = i ** 2 + n ** 2, o = i * a + n * s, l = a ** 2 + s ** 2, c = (r + l) / 2, h = Math.sqrt(c ** 2 - (r * l - o ** 2));
        t[0] = Math.sqrt(c + h || 1), t[1] = Math.sqrt(c - h || 1);
    }
    static normalizeRect(e1) {
        const t = e1.slice(0);
        return e1[0] > e1[2] && (t[0] = e1[2], t[2] = e1[0]), e1[1] > e1[3] && (t[1] = e1[3], t[3] = e1[1]), t;
    }
    static intersect(e1, t) {
        const i = Math.max(Math.min(e1[0], e1[2]), Math.min(t[0], t[2])), n = Math.min(Math.max(e1[0], e1[2]), Math.max(t[0], t[2]));
        if (i > n) return null;
        const a = Math.max(Math.min(e1[1], e1[3]), Math.min(t[1], t[3])), s = Math.min(Math.max(e1[1], e1[3]), Math.max(t[1], t[3]));
        return a > s ? null : [
            i,
            a,
            n,
            s
        ];
    }
    static pointBoundingBox(e1, t, i) {
        i[0] = Math.min(i[0], e1), i[1] = Math.min(i[1], t), i[2] = Math.max(i[2], e1), i[3] = Math.max(i[3], t);
    }
    static rectBoundingBox(e1, t, i, n, a) {
        a[0] = Math.min(a[0], e1, i), a[1] = Math.min(a[1], t, n), a[2] = Math.max(a[2], e1, i), a[3] = Math.max(a[3], t, n);
    }
    static #e(e1, t, i, n, a, s, r, o, l, c) {
        if (l <= 0 || l >= 1) return;
        const h = 1 - l, d = l * l, u = d * l, g = h * (h * (h * e1 + 3 * l * t) + 3 * d * i) + u * n, f = h * (h * (h * a + 3 * l * s) + 3 * d * r) + u * o;
        c[0] = Math.min(c[0], g), c[1] = Math.min(c[1], f), c[2] = Math.max(c[2], g), c[3] = Math.max(c[3], f);
    }
    static #t(e1, t, i, n, a, s, r, o, l, c, h, d) {
        if (Math.abs(l) < 1e-12) return void (Math.abs(c) >= 1e-12 && this.#e(e1, t, i, n, a, s, r, o, -h / c, d));
        const u = c ** 2 - 4 * h * l;
        if (u < 0) return;
        const g = Math.sqrt(u), f = 2 * l;
        this.#e(e1, t, i, n, a, s, r, o, (-c + g) / f, d), this.#e(e1, t, i, n, a, s, r, o, (-c - g) / f, d);
    }
    static bezierBoundingBox(e1, t, i, n, a, s, r, o, l) {
        l[0] = Math.min(l[0], e1, r), l[1] = Math.min(l[1], t, o), l[2] = Math.max(l[2], e1, r), l[3] = Math.max(l[3], t, o), this.#t(e1, i, a, r, t, n, s, o, 3 * (3 * (i - a) - e1 + r), 6 * (e1 - 2 * i + a), 3 * (i - e1), l), this.#t(e1, i, a, r, t, n, s, o, 3 * (3 * (n - s) - t + o), 6 * (t - 2 * n + s), 3 * (n - t), l);
    }
};
const si = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    728,
    711,
    710,
    729,
    733,
    731,
    730,
    732,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8226,
    8224,
    8225,
    8230,
    8212,
    8211,
    402,
    8260,
    8249,
    8250,
    8722,
    8240,
    8222,
    8220,
    8221,
    8216,
    8217,
    8218,
    8482,
    64257,
    64258,
    321,
    338,
    352,
    376,
    381,
    305,
    322,
    339,
    353,
    382,
    0,
    8364
];
function stringToPDFString(e1, t = !1) {
    if (e1[0] >= "Ã¯") {
        let i;
        if ("Ã¾" === e1[0] && "Ã¿" === e1[1] ? (i = "utf-16be", e1.length % 2 == 1 && (e1 = e1.slice(0, -1))) : "Ã¿" === e1[0] && "Ã¾" === e1[1] ? (i = "utf-16le", e1.length % 2 == 1 && (e1 = e1.slice(0, -1))) : "Ã¯" === e1[0] && "Â»" === e1[1] && "Â¿" === e1[2] && (i = "utf-8"), i) try {
            const n = new TextDecoder(i, {
                fatal: !0
            }), a = stringToBytes$1(e1), s = n.decode(a);
            return t || !s.includes("") ? s : s.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "");
        } catch (e1) {
            warn$1(`stringToPDFString: "${e1}".`);
        }
    }
    const i = [];
    for(let n = 0, a = e1.length; n < a; n++){
        const s = e1.charCodeAt(n);
        if (!t && 27 === s) {
            for(; ++n < a && 27 !== e1.charCodeAt(n););
            continue;
        }
        const r = si[s];
        i.push(r ? String.fromCharCode(r) : e1.charAt(n));
    }
    return i.join("");
}
function stringToUTF8String$1(e1) {
    return decodeURIComponent(escape(e1));
}
function utf8StringToString(e1) {
    return unescape(encodeURIComponent(e1));
}
function isArrayEqual(e1, t) {
    if (e1.length !== t.length) return !1;
    for(let i = 0, n = e1.length; i < n; i++)if (e1[i] !== t[i]) return !1;
    return !0;
}
function getModificationDate(e1 = new Date) {
    e1 instanceof Date || (e1 = new Date(e1));
    return [
        e1.getUTCFullYear().toString(),
        (e1.getUTCMonth() + 1).toString().padStart(2, "0"),
        e1.getUTCDate().toString().padStart(2, "0"),
        e1.getUTCHours().toString().padStart(2, "0"),
        e1.getUTCMinutes().toString().padStart(2, "0"),
        e1.getUTCSeconds().toString().padStart(2, "0")
    ].join("");
}
let ri = null, oi = null;
function MathClamp$1(e1, t, i) {
    return Math.min(Math.max(e1, t), i);
}
function toHexUtil(e1) {
    return Uint8Array.prototype.toHex ? e1.toHex() : Array.from(e1, (e1)=>ni[e1]).join("");
}
"function" != typeof Promise.try && (Promise.try = function(e1, ...t) {
    return new Promise((i)=>{
        i(e1(...t));
    });
}), "function" != typeof Math.sumPrecise && (Math.sumPrecise = function(e1) {
    return e1.reduce((e1, t)=>e1 + t, 0);
});
const li = Symbol("CIRCULAR_REF"), ci = Symbol("EOF");
let hi = Object.create(null), di = Object.create(null), ui = Object.create(null);
class Name {
    constructor(e1){
        this.name = e1;
    }
    static get(e1) {
        return di[e1] ||= new Name(e1);
    }
}
class Cmd {
    constructor(e1){
        this.cmd = e1;
    }
    static get(e1) {
        return hi[e1] ||= new Cmd(e1);
    }
}
const nonSerializable = function() {
    return nonSerializable;
};
class Dict {
    constructor(e1 = null){
        this._map = new Map, this.xref = e1, this.objId = null, this.suppressEncryption = !1, this.__nonSerializable__ = nonSerializable;
    }
    assignXref(e1) {
        this.xref = e1;
    }
    get size() {
        return this._map.size;
    }
    get(e1, t, i) {
        let n = this._map.get(e1);
        return void 0 === n && void 0 !== t && (n = this._map.get(t), void 0 === n && void 0 !== i && (n = this._map.get(i))), n instanceof Ref && this.xref ? this.xref.fetch(n, this.suppressEncryption) : n;
    }
    async getAsync(e1, t, i) {
        let n = this._map.get(e1);
        return void 0 === n && void 0 !== t && (n = this._map.get(t), void 0 === n && void 0 !== i && (n = this._map.get(i))), n instanceof Ref && this.xref ? this.xref.fetchAsync(n, this.suppressEncryption) : n;
    }
    getArray(e1, t, i) {
        let n = this._map.get(e1);
        if (void 0 === n && void 0 !== t && (n = this._map.get(t), void 0 === n && void 0 !== i && (n = this._map.get(i))), n instanceof Ref && this.xref && (n = this.xref.fetch(n, this.suppressEncryption)), Array.isArray(n)) {
            n = n.slice();
            for(let e1 = 0, t = n.length; e1 < t; e1++)n[e1] instanceof Ref && this.xref && (n[e1] = this.xref.fetch(n[e1], this.suppressEncryption));
        }
        return n;
    }
    getRaw(e1) {
        return this._map.get(e1);
    }
    getKeys() {
        return [
            ...this._map.keys()
        ];
    }
    getRawValues() {
        return [
            ...this._map.values()
        ];
    }
    set(e1, t) {
        this._map.set(e1, t);
    }
    setIfNotExists(e1, t) {
        this.has(e1) || this.set(e1, t);
    }
    setIfNumber(e1, t) {
        "number" == typeof t && this.set(e1, t);
    }
    setIfArray(e1, t) {
        (Array.isArray(t) || ArrayBuffer.isView(t)) && this.set(e1, t);
    }
    setIfDefined(e1, t) {
        null != t && this.set(e1, t);
    }
    setIfName(e1, t) {
        "string" == typeof t ? this.set(e1, Name.get(t)) : t instanceof Name && this.set(e1, t);
    }
    has(e1) {
        return this._map.has(e1);
    }
    *[Symbol.iterator]() {
        for (const [e1, t] of this._map)yield [
            e1,
            t instanceof Ref && this.xref ? this.xref.fetch(t, this.suppressEncryption) : t
        ];
    }
    static get empty() {
        const e1 = new Dict(null);
        return e1.set = (e1, t)=>{
            unreachable$1("Should not call `set` on the empty dictionary.");
        }, shadow$1(this, "empty", e1);
    }
    static merge({ xref: e1, dictArray: t, mergeSubDicts: i = !1 }) {
        const n = new Dict(e1), a = new Map;
        for (const e1 of t)if (e1 instanceof Dict) for (const [t, n] of e1._map){
            let e1 = a.get(t);
            if (void 0 === e1) e1 = [], a.set(t, e1);
            else if (!(i && n instanceof Dict)) continue;
            e1.push(n);
        }
        for (const [t, i] of a){
            if (1 === i.length || !(i[0] instanceof Dict)) {
                n._map.set(t, i[0]);
                continue;
            }
            const a = new Dict(e1);
            for (const e1 of i)for (const [t, i] of e1._map)a._map.has(t) || a._map.set(t, i);
            a.size > 0 && n._map.set(t, a);
        }
        return a.clear(), n.size > 0 ? n : Dict.empty;
    }
    clone() {
        const e1 = new Dict(this.xref);
        for (const t of this.getKeys())e1.set(t, this.getRaw(t));
        return e1;
    }
    delete(e1) {
        this._map.delete(e1);
    }
}
class Ref {
    constructor(e1, t){
        this.num = e1, this.gen = t;
    }
    toString() {
        return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;
    }
    static fromString(e1) {
        const t = ui[e1];
        if (t) return t;
        const i = /^(\d+)R(\d*)$/.exec(e1);
        return i && "0" !== i[1] ? ui[e1] = new Ref(parseInt(i[1]), i[2] ? parseInt(i[2]) : 0) : null;
    }
    static get(e1, t) {
        const i = 0 === t ? `${e1}R` : `${e1}R${t}`;
        return ui[i] ||= new Ref(e1, t);
    }
}
class RefSet {
    constructor(e1 = null){
        this._set = new Set(e1?._set);
    }
    has(e1) {
        return this._set.has(e1.toString());
    }
    put(e1) {
        this._set.add(e1.toString());
    }
    remove(e1) {
        this._set.delete(e1.toString());
    }
    [Symbol.iterator]() {
        return this._set.values();
    }
    clear() {
        this._set.clear();
    }
}
class RefSetCache {
    constructor(){
        this._map = new Map;
    }
    get size() {
        return this._map.size;
    }
    get(e1) {
        return this._map.get(e1.toString());
    }
    has(e1) {
        return this._map.has(e1.toString());
    }
    put(e1, t) {
        this._map.set(e1.toString(), t);
    }
    putAlias(e1, t) {
        this._map.set(e1.toString(), this.get(t));
    }
    [Symbol.iterator]() {
        return this._map.values();
    }
    clear() {
        this._map.clear();
    }
    *values() {
        yield* this._map.values();
    }
    *items() {
        for (const [e1, t] of this._map)yield [
            Ref.fromString(e1),
            t
        ];
    }
}
function isName(e1, t) {
    return e1 instanceof Name && (void 0 === t || e1.name === t);
}
function isCmd(e1, t) {
    return e1 instanceof Cmd && (void 0 === t || e1.cmd === t);
}
function isDict(e1, t) {
    return e1 instanceof Dict && (void 0 === t || isName(e1.get("Type"), t));
}
function isRefsEqual(e1, t) {
    return e1.num === t.num && e1.gen === t.gen;
}
class BaseStream {
    get length() {
        unreachable$1("Abstract getter `length` accessed");
    }
    get isEmpty() {
        unreachable$1("Abstract getter `isEmpty` accessed");
    }
    get isDataLoaded() {
        return shadow$1(this, "isDataLoaded", !0);
    }
    getByte() {
        unreachable$1("Abstract method `getByte` called");
    }
    getBytes(e1) {
        unreachable$1("Abstract method `getBytes` called");
    }
    async getImageData(e1, t) {
        return this.getBytes(e1, t);
    }
    async asyncGetBytes() {
        unreachable$1("Abstract method `asyncGetBytes` called");
    }
    get isAsync() {
        return !1;
    }
    get isAsyncDecoder() {
        return !1;
    }
    get canAsyncDecodeImageFromBuffer() {
        return !1;
    }
    async getTransferableImage() {
        return null;
    }
    peekByte() {
        const e1 = this.getByte();
        return -1 !== e1 && this.pos--, e1;
    }
    peekBytes(e1) {
        const t = this.getBytes(e1);
        return this.pos -= t.length, t;
    }
    getUint16() {
        const e1 = this.getByte(), t = this.getByte();
        return -1 === e1 || -1 === t ? -1 : (e1 << 8) + t;
    }
    getInt32() {
        return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
    }
    getByteRange(e1, t) {
        unreachable$1("Abstract method `getByteRange` called");
    }
    getString(e1) {
        return bytesToString$1(this.getBytes(e1));
    }
    skip(e1) {
        this.pos += e1 || 1;
    }
    reset() {
        unreachable$1("Abstract method `reset` called");
    }
    moveStart() {
        unreachable$1("Abstract method `moveStart` called");
    }
    makeSubStream(e1, t, i = null) {
        unreachable$1("Abstract method `makeSubStream` called");
    }
    getBaseStreams() {
        return null;
    }
}
const gi = /^[1-9]\.\d$/, fi = 2 ** 31 - 1, pi = [
    1,
    0,
    0,
    1,
    0,
    0
], mi = [
    "ColorSpace",
    "ExtGState",
    "Font",
    "Pattern",
    "Properties",
    "Shading",
    "XObject"
], bi = [
    "ExtGState",
    "Font",
    "Properties",
    "XObject"
];
function getLookupTableFactory(e1) {
    let t;
    return function() {
        return e1 && (t = Object.create(null), e1(t), e1 = null), t;
    };
}
class MissingDataException extends Yt {
    constructor(e1, t){
        super(`Missing data [${e1}, ${t})`, "MissingDataException"), this.begin = e1, this.end = t;
    }
}
class ParserEOFException extends Yt {
    constructor(e1){
        super(e1, "ParserEOFException");
    }
}
class XRefEntryException extends Yt {
    constructor(e1){
        super(e1, "XRefEntryException");
    }
}
class XRefParseException extends Yt {
    constructor(e1){
        super(e1, "XRefParseException");
    }
}
function arrayBuffersToBytes(e1) {
    const t = e1.length;
    if (0 === t) return new Uint8Array(0);
    if (1 === t) return new Uint8Array(e1[0]);
    let i = 0;
    for(let n = 0; n < t; n++)i += e1[n].byteLength;
    const n = new Uint8Array(i);
    let a = 0;
    for(let i = 0; i < t; i++){
        const t = new Uint8Array(e1[i]);
        n.set(t, a), a += t.byteLength;
    }
    return n;
}
async function fetchBinaryData(e1) {
    const t = await fetch(e1);
    if (!t.ok) throw new Error(`Failed to fetch file "${e1}" with "${t.statusText}".`);
    return new Uint8Array(await t.arrayBuffer());
}
function getInheritableProperty({ dict: e1, key: t, getArray: i = !1, stopWhenFound: n = !0 }) {
    let a;
    const s = new RefSet;
    for(; e1 instanceof Dict && (!e1.objId || !s.has(e1.objId));){
        e1.objId && s.put(e1.objId);
        const r = i ? e1.getArray(t) : e1.get(t);
        if (void 0 !== r) {
            if (n) return r;
            (a ||= []).push(r);
        }
        e1 = e1.get("Parent");
    }
    return a;
}
const yi = [
    "",
    "C",
    "CC",
    "CCC",
    "CD",
    "D",
    "DC",
    "DCC",
    "DCCC",
    "CM",
    "",
    "X",
    "XX",
    "XXX",
    "XL",
    "L",
    "LX",
    "LXX",
    "LXXX",
    "XC",
    "",
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX"
];
function toRomanNumerals(e1, t = !1) {
    assert$1(Number.isInteger(e1) && e1 > 0, "The number should be a positive integer.");
    const i = "M".repeat(e1 / 1e3 | 0) + yi[e1 % 1e3 / 100 | 0] + yi[10 + (e1 % 100 / 10 | 0)] + yi[20 + e1 % 10];
    return t ? i.toLowerCase() : i;
}
function log2(e1) {
    return e1 > 0 ? Math.ceil(Math.log2(e1)) : 0;
}
function readInt8(e1, t) {
    return e1[t] << 24 >> 24;
}
function readInt16(e1, t) {
    return (e1[t] << 24 | e1[t + 1] << 16) >> 16;
}
function readUint16(e1, t) {
    return e1[t] << 8 | e1[t + 1];
}
function readUint32(e1, t) {
    return (e1[t] << 24 | e1[t + 1] << 16 | e1[t + 2] << 8 | e1[t + 3]) >>> 0;
}
function isWhiteSpace(e1) {
    return 32 === e1 || 9 === e1 || 13 === e1 || 10 === e1;
}
function isNumberArray(e1, t) {
    return Array.isArray(e1) ? (null === t || e1.length === t) && e1.every((e1)=>"number" == typeof e1) : ArrayBuffer.isView(e1) && !(e1 instanceof BigInt64Array || e1 instanceof BigUint64Array) && (null === t || e1.length === t);
}
function lookupMatrix(e1, t) {
    return isNumberArray(e1, 6) ? e1 : t;
}
function lookupRect(e1, t) {
    return isNumberArray(e1, 4) ? e1 : t;
}
function lookupNormalRect(e1, t) {
    return isNumberArray(e1, 4) ? ai.normalizeRect(e1) : t;
}
function parseXFAPath(e1) {
    const t = /(.+)\[(\d+)\]$/;
    return e1.split(".").map((e1)=>{
        const i = e1.match(t);
        return i ? {
            name: i[1],
            pos: parseInt(i[2], 10)
        } : {
            name: e1,
            pos: 0
        };
    });
}
function escapePDFName(e1) {
    const t = [];
    let i = 0;
    for(let n = 0, a = e1.length; n < a; n++){
        const a = e1.charCodeAt(n);
        (a < 33 || a > 126 || 35 === a || 40 === a || 41 === a || 60 === a || 62 === a || 91 === a || 93 === a || 123 === a || 125 === a || 47 === a || 37 === a) && (i < n && t.push(e1.substring(i, n)), t.push(`#${a.toString(16)}`), i = n + 1);
    }
    return 0 === t.length ? e1 : (i < e1.length && t.push(e1.substring(i, e1.length)), t.join(""));
}
function escapeString(e1) {
    return e1.replaceAll(/([()\\\n\r])/g, (e1)=>"\n" === e1 ? "\\n" : "\r" === e1 ? "\\r" : `\\${e1}`);
}
function _collectJS(e1, t, i, n) {
    if (!e1) return;
    let a = null;
    if (e1 instanceof Ref) {
        if (n.has(e1)) return;
        a = e1, n.put(a), e1 = t.fetch(e1);
    }
    if (Array.isArray(e1)) for (const a of e1)_collectJS(a, t, i, n);
    else if (e1 instanceof Dict) {
        if (isName(e1.get("S"), "JavaScript")) {
            const t = e1.get("JS");
            let n;
            t instanceof BaseStream ? n = t.getString() : "string" == typeof t && (n = t), n &&= stringToPDFString(n, !0).replaceAll("\0", ""), n && i.push(n.trim());
        }
        _collectJS(e1.getRaw("Next"), t, i, n);
    }
    a && n.remove(a);
}
function collectActions(e1, t, i) {
    const n = Object.create(null), a = getInheritableProperty({
        dict: t,
        key: "AA",
        stopWhenFound: !1
    });
    if (a) for(let t = a.length - 1; t >= 0; t--){
        const s = a[t];
        if (s instanceof Dict) for (const t of s.getKeys()){
            const a = i[t];
            if (!a) continue;
            const r = [];
            _collectJS(s.getRaw(t), e1, r, new RefSet), r.length > 0 && (n[a] = r);
        }
    }
    if (t.has("A")) {
        const i = [];
        _collectJS(t.get("A"), e1, i, new RefSet), i.length > 0 && (n.Action = i);
    }
    return objectSize(n) > 0 ? n : null;
}
const wi = {
    60: "&lt;",
    62: "&gt;",
    38: "&amp;",
    34: "&quot;",
    39: "&apos;"
};
function* codePointIter(e1) {
    for(let t = 0, i = e1.length; t < i; t++){
        const i = e1.codePointAt(t);
        i > 55295 && (i < 57344 || i > 65533) && t++, yield i;
    }
}
function encodeToXmlString(e1) {
    const t = [];
    let i = 0;
    for(let n = 0, a = e1.length; n < a; n++){
        const a = e1.codePointAt(n);
        if (32 <= a && a <= 126) {
            const s = wi[a];
            s && (i < n && t.push(e1.substring(i, n)), t.push(s), i = n + 1);
        } else i < n && t.push(e1.substring(i, n)), t.push(`&#x${a.toString(16).toUpperCase()};`), a > 55295 && (a < 57344 || a > 65533) && n++, i = n + 1;
    }
    return 0 === t.length ? e1 : (i < e1.length && t.push(e1.substring(i, e1.length)), t.join(""));
}
function validateFontName(e1, t = !1) {
    const i = /^("|').*("|')$/.exec(e1);
    if (i && i[1] === i[2]) {
        if (new RegExp(`[^\\\\]${i[1]}`).test(e1.slice(1, -1))) return t && warn$1(`FontFamily contains unescaped ${i[1]}: ${e1}.`), !1;
    } else for (const i of e1.split(/[ \t]+/))if (/^(\d|(-(\d|-)))/.test(i) || !/^[\w-\\]+$/.test(i)) return t && warn$1(`FontFamily contains invalid <custom-ident>: ${e1}.`), !1;
    return !0;
}
function validateCSSFont(e1) {
    const t = new Set([
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900",
        "1000",
        "normal",
        "bold",
        "bolder",
        "lighter"
    ]), { fontFamily: i, fontWeight: n, italicAngle: a } = e1;
    if (!validateFontName(i, !0)) return !1;
    const s = n ? n.toString() : "";
    e1.fontWeight = t.has(s) ? s : "400";
    const r = parseFloat(a);
    return e1.italicAngle = isNaN(r) || r < -90 || r > 90 ? "14" : a.toString(), !0;
}
function recoverJsURL(e1) {
    const t = new RegExp("^\\s*(" + [
        "app.launchURL",
        "window.open",
        "xfa.host.gotoURL"
    ].join("|").replaceAll(".", "\\.") + ")\\((?:'|\")([^'\"]*)(?:'|\")(?:,\\s*(\\w+)\\)|\\))", "i").exec(e1);
    return t?.[2] ? {
        url: t[2],
        newWindow: "app.launchURL" === t[1] && "true" === t[3]
    } : null;
}
function numberToString(e1) {
    if (Number.isInteger(e1)) return e1.toString();
    const t = Math.round(100 * e1);
    return t % 100 == 0 ? (t / 100).toString() : t % 10 == 0 ? e1.toFixed(1) : e1.toFixed(2);
}
function getNewAnnotationsMap(e1) {
    if (!e1) return null;
    const t = new Map;
    for (const [i, n] of e1){
        if (!i.startsWith(g)) continue;
        let e1 = t.get(n.pageIndex);
        e1 || (e1 = [], t.set(n.pageIndex, e1)), e1.push(n);
    }
    return t.size > 0 ? t : null;
}
function stringToAsciiOrUTF16BE(e1) {
    return null == e1 || function(e1) {
        if ("string" != typeof e1) return !1;
        return !e1 || /^[\x00-\x7F]*$/.test(e1);
    }(e1) ? e1 : stringToUTF16String(e1, !0);
}
function stringToUTF16HexString(e1) {
    const t = [];
    for(let i = 0, n = e1.length; i < n; i++){
        const n = e1.charCodeAt(i);
        t.push(ni[n >> 8 & 255], ni[255 & n]);
    }
    return t.join("");
}
function stringToUTF16String(e1, t = !1) {
    const i = [];
    t && i.push("Ã¾Ã¿");
    for(let t = 0, n = e1.length; t < n; t++){
        const n = e1.charCodeAt(t);
        i.push(String.fromCharCode(n >> 8 & 255), String.fromCharCode(255 & n));
    }
    return i.join("");
}
function getRotationMatrix(e1, t, i) {
    switch(e1){
        case 90:
            return [
                0,
                1,
                -1,
                0,
                t,
                0
            ];
        case 180:
            return [
                -1,
                0,
                0,
                -1,
                t,
                i
            ];
        case 270:
            return [
                0,
                -1,
                1,
                0,
                0,
                i
            ];
        default:
            throw new Error("Invalid rotation");
    }
}
function getSizeInBytes(e1) {
    return Math.ceil(Math.ceil(Math.log2(1 + e1)) / 8);
}
class QCMS {
    static #i = null;
    static _memory = null;
    static _mustAddAlpha = !1;
    static _destBuffer = null;
    static _destOffset = 0;
    static _destLength = 0;
    static _cssColor = "";
    static _makeHexColor = null;
    static get _memoryArray() {
        const e1 = this.#i;
        return e1?.byteLength ? e1 : this.#i = new Uint8Array(this._memory.buffer);
    }
}
let Ai;
const xi = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8", {
    ignoreBOM: !0,
    fatal: !0
}) : {
    decode: ()=>{
        throw Error("TextDecoder not available");
    }
};
"undefined" != typeof TextDecoder && xi.decode();
let Si = null;
function getUint8ArrayMemory0() {
    return null !== Si && 0 !== Si.byteLength || (Si = new Uint8Array(Ai.memory.buffer)), Si;
}
let vi = 0;
function passArray8ToWasm0(e1, t) {
    const i = t(1 * e1.length, 1) >>> 0;
    return getUint8ArrayMemory0().set(e1, i / 1), vi = e1.length, i;
}
const Ci = Object.freeze({
    RGB8: 0,
    0: "RGB8",
    RGBA8: 1,
    1: "RGBA8",
    BGRA8: 2,
    2: "BGRA8",
    Gray8: 3,
    3: "Gray8",
    GrayA8: 4,
    4: "GrayA8",
    CMYK: 5,
    5: "CMYK"
}), ki = Object.freeze({
    Perceptual: 0,
    0: "Perceptual",
    RelativeColorimetric: 1,
    1: "RelativeColorimetric",
    Saturation: 2,
    2: "Saturation",
    AbsoluteColorimetric: 3,
    3: "AbsoluteColorimetric"
});
function __wbg_get_imports() {
    const e1 = {
        wbg: {}
    };
    return e1.wbg.__wbg_copyresult_b08ee7d273f295dd = function(e1, t) {
        !function(e1, t) {
            const { _mustAddAlpha: i, _destBuffer: n, _destOffset: a, _destLength: s, _memoryArray: r } = QCMS;
            if (t !== s) if (i) for(let i = e1, s = e1 + t, o = a; i < s; i += 3, o += 4)n[o] = r[i], n[o + 1] = r[i + 1], n[o + 2] = r[i + 2], n[o + 3] = 255;
            else for(let i = e1, s = e1 + t, o = a; i < s; i += 3, o += 4)n[o] = r[i], n[o + 1] = r[i + 1], n[o + 2] = r[i + 2];
            else n.set(r.subarray(e1, e1 + t), a);
        }(e1 >>> 0, t >>> 0);
    }, e1.wbg.__wbg_copyrgb_d60ce17bb05d9b67 = function(e1) {
        !function(e1) {
            const { _destBuffer: t, _destOffset: i, _memoryArray: n } = QCMS;
            t[i] = n[e1], t[i + 1] = n[e1 + 1], t[i + 2] = n[e1 + 2];
        }(e1 >>> 0);
    }, e1.wbg.__wbg_makecssRGB_893bf0cd9fdb302d = function(e1) {
        !function(e1) {
            const { _memoryArray: t } = QCMS;
            QCMS._cssColor = QCMS._makeHexColor(t[e1], t[e1 + 1], t[e1 + 2]);
        }(e1 >>> 0);
    }, e1.wbg.__wbindgen_init_externref_table = function() {
        const e1 = Ai.__wbindgen_export_0, t = e1.grow(4);
        e1.set(0, void 0), e1.set(t + 0, void 0), e1.set(t + 1, null), e1.set(t + 2, !0), e1.set(t + 3, !1);
    }, e1.wbg.__wbindgen_throw = function(e1, t) {
        throw new Error((i = e1, n = t, i >>>= 0, xi.decode(getUint8ArrayMemory0().subarray(i, i + n))));
        var i, n;
    }, e1;
}
function initSync(e1) {
    if (void 0 !== Ai) return Ai;
    void 0 !== e1 && (Object.getPrototypeOf(e1) === Object.prototype ? { module: e1 } = e1 : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
    const t = __wbg_get_imports();
    e1 instanceof WebAssembly.Module || (e1 = new WebAssembly.Module(e1));
    return function(e1) {
        return Ai = e1.exports, Si = null, Ai.__wbindgen_start(), Ai;
    }(new WebAssembly.Instance(e1, t));
}
class ColorSpace {
    static #n = new Uint8ClampedArray(3);
    constructor(e1, t){
        this.name = e1, this.numComps = t;
    }
    getRgb(e1, t, i = new Uint8ClampedArray(3)) {
        return this.getRgbItem(e1, t, i, 0), i;
    }
    getRgbHex(e1, t) {
        const i = this.getRgb(e1, t, ColorSpace.#n);
        return ai.makeHexColor(i[0], i[1], i[2]);
    }
    getRgbItem(e1, t, i, n) {
        unreachable$1("Should not call ColorSpace.getRgbItem");
    }
    getRgbBuffer(e1, t, i, n, a, s, r) {
        unreachable$1("Should not call ColorSpace.getRgbBuffer");
    }
    getOutputLength(e1, t) {
        unreachable$1("Should not call ColorSpace.getOutputLength");
    }
    isPassthrough(e1) {
        return !1;
    }
    isDefaultDecode(e1, t) {
        return ColorSpace.isDefaultDecode(e1, this.numComps);
    }
    fillRgb(e1, t, i, n, a, s, r, o, l) {
        const c = t * i;
        let h = null;
        const d = 1 << r, u = i !== a || t !== n;
        if (this.isPassthrough(r)) h = o;
        else if (1 === this.numComps && c > d && "DeviceGray" !== this.name && "DeviceRGB" !== this.name) {
            const t = r <= 8 ? new Uint8Array(d) : new Uint16Array(d);
            for(let e1 = 0; e1 < d; e1++)t[e1] = e1;
            const i = new Uint8ClampedArray(3 * d);
            if (this.getRgbBuffer(t, 0, d, i, 0, r, 0), u) {
                h = new Uint8Array(3 * c);
                let e1 = 0;
                for(let t = 0; t < c; ++t){
                    const n = 3 * o[t];
                    h[e1++] = i[n], h[e1++] = i[n + 1], h[e1++] = i[n + 2];
                }
            } else {
                let t = 0;
                for(let n = 0; n < c; ++n){
                    const a = 3 * o[n];
                    e1[t++] = i[a], e1[t++] = i[a + 1], e1[t++] = i[a + 2], t += l;
                }
            }
        } else u ? (h = new Uint8ClampedArray(3 * c), this.getRgbBuffer(o, 0, c, h, 0, r, 0)) : this.getRgbBuffer(o, 0, n * s, e1, 0, r, l);
        if (h) if (u) !function(e1, t, i, n, a, s, r) {
            r = 1 !== r ? 0 : r;
            const o = i / a, l = n / s;
            let c, h = 0;
            const d = new Uint16Array(a), u = 3 * i;
            for(let e1 = 0; e1 < a; e1++)d[e1] = 3 * Math.floor(e1 * o);
            for(let i = 0; i < s; i++){
                const n = Math.floor(i * l) * u;
                for(let i = 0; i < a; i++)c = n + d[i], t[h++] = e1[c++], t[h++] = e1[c++], t[h++] = e1[c++], h += r;
            }
        }(h, e1, t, i, n, a, l);
        else {
            let t = 0, i = 0;
            for(let a = 0, r = n * s; a < r; a++)e1[t++] = h[i++], e1[t++] = h[i++], e1[t++] = h[i++], t += l;
        }
    }
    get usesZeroToOneRange() {
        return shadow$1(this, "usesZeroToOneRange", !0);
    }
    static isDefaultDecode(e1, t) {
        if (!Array.isArray(e1)) return !0;
        if (2 * t !== e1.length) return warn$1("The decode map is not the correct length"), !0;
        for(let t = 0, i = e1.length; t < i; t += 2)if (0 !== e1[t] || 1 !== e1[t + 1]) return !1;
        return !0;
    }
}
class AlternateCS extends ColorSpace {
    constructor(e1, t, i){
        super("Alternate", e1), this.base = t, this.tintFn = i, this.tmpBuf = new Float32Array(t.numComps);
    }
    getRgbItem(e1, t, i, n) {
        const a = this.tmpBuf;
        this.tintFn(e1, t, a, 0), this.base.getRgbItem(a, 0, i, n);
    }
    getRgbBuffer(e1, t, i, n, a, s, r) {
        const o = this.tintFn, l = this.base, c = 1 / ((1 << s) - 1), h = l.numComps, d = l.usesZeroToOneRange, u = (l.isPassthrough(8) || !d) && 0 === r;
        let g = u ? a : 0;
        const f = u ? n : new Uint8ClampedArray(h * i), p = this.numComps, m = new Float32Array(p), b = new Float32Array(h);
        let y, w;
        for(y = 0; y < i; y++){
            for(w = 0; w < p; w++)m[w] = e1[t++] * c;
            if (o(m, 0, b, 0), d) for(w = 0; w < h; w++)f[g++] = 255 * b[w];
            else l.getRgbItem(b, 0, f, g), g += h;
        }
        u || l.getRgbBuffer(f, 0, i, n, a, 8, r);
    }
    getOutputLength(e1, t) {
        return this.base.getOutputLength(e1 * this.base.numComps / this.numComps, t);
    }
}
class PatternCS extends ColorSpace {
    constructor(e1){
        super("Pattern", null), this.base = e1;
    }
    isDefaultDecode(e1, t) {
        unreachable$1("Should not call PatternCS.isDefaultDecode");
    }
}
class IndexedCS extends ColorSpace {
    constructor(e1, t, i){
        super("Indexed", 1), this.base = e1, this.highVal = t;
        const n = e1.numComps * (t + 1);
        if (this.lookup = new Uint8Array(n), i instanceof BaseStream) {
            const e1 = i.getBytes(n);
            this.lookup.set(e1);
        } else {
            if ("string" != typeof i) throw new ti(`IndexedCS - unrecognized lookup table: ${i}`);
            for(let e1 = 0; e1 < n; ++e1)this.lookup[e1] = 255 & i.charCodeAt(e1);
        }
    }
    getRgbItem(e1, t, i, n) {
        const { base: a, highVal: s, lookup: r } = this, o = MathClamp$1(Math.round(e1[t]), 0, s) * a.numComps;
        a.getRgbBuffer(r, o, 1, i, n, 8, 0);
    }
    getRgbBuffer(e1, t, i, n, a, s, r) {
        const { base: o, highVal: l, lookup: c } = this, { numComps: h } = o, d = o.getOutputLength(h, r);
        for(let s = 0; s < i; ++s){
            const i = MathClamp$1(Math.round(e1[t++]), 0, l) * h;
            o.getRgbBuffer(c, i, 1, n, a, 8, r), a += d;
        }
    }
    getOutputLength(e1, t) {
        return this.base.getOutputLength(e1 * this.base.numComps, t);
    }
    isDefaultDecode(e1, t) {
        return !Array.isArray(e1) || (2 !== e1.length ? (warn$1("Decode map length is not correct"), !0) : !Number.isInteger(t) || t < 1 ? (warn$1("Bits per component is not correct"), !0) : 0 === e1[0] && e1[1] === (1 << t) - 1);
    }
}
class DeviceGrayCS extends ColorSpace {
    constructor(){
        super("DeviceGray", 1);
    }
    getRgbItem(e1, t, i, n) {
        const a = 255 * e1[t];
        i[n] = i[n + 1] = i[n + 2] = a;
    }
    getRgbBuffer(e1, t, i, n, a, s, r) {
        const o = 255 / ((1 << s) - 1);
        let l = t, c = a;
        for(let t = 0; t < i; ++t){
            const t = o * e1[l++];
            n[c++] = t, n[c++] = t, n[c++] = t, c += r;
        }
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t);
    }
}
class DeviceRgbCS extends ColorSpace {
    constructor(){
        super("DeviceRGB", 3);
    }
    getRgbItem(e1, t, i, n) {
        i[n] = 255 * e1[t], i[n + 1] = 255 * e1[t + 1], i[n + 2] = 255 * e1[t + 2];
    }
    getRgbBuffer(e1, t, i, n, a, s, r) {
        if (8 === s && 0 === r) return void n.set(e1.subarray(t, t + 3 * i), a);
        const o = 255 / ((1 << s) - 1);
        let l = t, c = a;
        for(let t = 0; t < i; ++t)n[c++] = o * e1[l++], n[c++] = o * e1[l++], n[c++] = o * e1[l++], c += r;
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t) / 3 | 0;
    }
    isPassthrough(e1) {
        return 8 === e1;
    }
}
class DeviceRgbaCS extends ColorSpace {
    constructor(){
        super("DeviceRGBA", 4);
    }
    getOutputLength(e1, t) {
        return 4 * e1;
    }
    isPassthrough(e1) {
        return 8 === e1;
    }
    fillRgb(e1, t, i, n, a, s, r, o, l) {
        i !== a || t !== n ? function(e1, t, i, n, a, s, r) {
            const o = i / a, l = n / s;
            let c = 0;
            const h = new Uint16Array(a);
            if (1 === r) {
                for(let e1 = 0; e1 < a; e1++)h[e1] = Math.floor(e1 * o);
                const n = new Uint32Array(e1.buffer), r = new Uint32Array(t.buffer), d = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
                for(let e1 = 0; e1 < s; e1++){
                    const t = n.subarray(Math.floor(e1 * l) * i);
                    for(let e1 = 0; e1 < a; e1++)r[c++] |= t[h[e1]] & d;
                }
            } else {
                const n = 4, r = i * n;
                for(let e1 = 0; e1 < a; e1++)h[e1] = Math.floor(e1 * o) * n;
                for(let i = 0; i < s; i++){
                    const n = e1.subarray(Math.floor(i * l) * r);
                    for(let e1 = 0; e1 < a; e1++){
                        const i = h[e1];
                        t[c++] = n[i], t[c++] = n[i + 1], t[c++] = n[i + 2];
                    }
                }
            }
        }(o, e1, t, i, n, a, l) : function(e1, t, i) {
            if (1 === i) {
                const i = new Uint32Array(e1.buffer), n = new Uint32Array(t.buffer), a = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
                for(let e1 = 0, t = i.length; e1 < t; e1++)n[e1] |= i[e1] & a;
            } else {
                let i = 0;
                for(let n = 0, a = e1.length; n < a; n += 4)t[i++] = e1[n], t[i++] = e1[n + 1], t[i++] = e1[n + 2];
            }
        }(o, e1, l);
    }
}
class DeviceCmykCS extends ColorSpace {
    constructor(){
        super("DeviceCMYK", 4);
    }
    #a(e1, t, i, n, a) {
        const s = e1[t] * i, r = e1[t + 1] * i, o = e1[t + 2] * i, l = e1[t + 3] * i;
        n[a] = 255 + s * (-4.387332384609988 * s + 54.48615194189176 * r + 18.82290502165302 * o + 212.25662451639585 * l - 285.2331026137004) + r * (1.7149763477362134 * r - 5.6096736904047315 * o + -17.873870861415444 * l - 5.497006427196366) + o * (-2.5217340131683033 * o - 21.248923337353073 * l + 17.5119270841813) + l * (-21.86122147463605 * l - 189.48180835922747), n[a + 1] = 255 + s * (8.841041422036149 * s + 60.118027045597366 * r + 6.871425592049007 * o + 31.159100130055922 * l - 79.2970844816548) + r * (-15.310361306967817 * r + 17.575251261109482 * o + 131.35250912493976 * l - 190.9453302588951) + o * (4.444339102852739 * o + 9.8632861493405 * l - 24.86741582555878) + l * (-20.737325471181034 * l - 187.80453709719578), n[a + 2] = 255 + s * (.8842522430003296 * s + 8.078677503112928 * r + 30.89978309703729 * o - .23883238689178934 * l - 14.183576799673286) + r * (10.49593273432072 * r + 63.02378494754052 * o + 50.606957656360734 * l - 112.23884253719248) + o * (.03296041114873217 * o + 115.60384449646641 * l - 193.58209356861505) + l * (-22.33816807309886 * l - 180.12613974708367);
    }
    getRgbItem(e1, t, i, n) {
        this.#a(e1, t, 1, i, n);
    }
    getRgbBuffer(e1, t, i, n, a, s, r) {
        const o = 1 / ((1 << s) - 1);
        for(let s = 0; s < i; s++)this.#a(e1, t, o, n, a), t += 4, a += 3 + r;
    }
    getOutputLength(e1, t) {
        return e1 / 4 * (3 + t) | 0;
    }
}
class CalGrayCS extends ColorSpace {
    constructor(e1, t, i){
        if (super("CalGray", 1), !e1) throw new ti("WhitePoint missing - required for color space CalGray");
        if ([this.XW, this.YW, this.ZW] = e1, [this.XB, this.YB, this.ZB] = t || [
            0,
            0,
            0
        ], this.G = i || 1, this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new ti(`Invalid WhitePoint components for ${this.name}, no fallback available`);
        (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (info$1(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), 0 === this.XB && 0 === this.YB && 0 === this.ZB || warn$1(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && (info$1(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
    }
    #a(e1, t, i, n, a) {
        const s = (e1[t] * a) ** this.G, r = this.YW * s, o = Math.max(295.8 * r ** .3333333333333333 - 40.8, 0);
        i[n] = o, i[n + 1] = o, i[n + 2] = o;
    }
    getRgbItem(e1, t, i, n) {
        this.#a(e1, t, i, n, 1);
    }
    getRgbBuffer(e1, t, i, n, a, s, r) {
        const o = 1 / ((1 << s) - 1);
        for(let s = 0; s < i; ++s)this.#a(e1, t, n, a, o), t += 1, a += 3 + r;
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t);
    }
}
class CalRGBCS extends ColorSpace {
    static #s = new Float32Array([
        .8951,
        .2664,
        -.1614,
        -.7502,
        1.7135,
        .0367,
        .0389,
        -.0685,
        1.0296
    ]);
    static #r = new Float32Array([
        .9869929,
        -.1470543,
        .1599627,
        .4323053,
        .5183603,
        .0492912,
        -.0085287,
        .0400428,
        .9684867
    ]);
    static #o = new Float32Array([
        3.2404542,
        -1.5371385,
        -.4985314,
        -.969266,
        1.8760108,
        .041556,
        .0556434,
        -.2040259,
        1.0572252
    ]);
    static #l = new Float32Array([
        1,
        1,
        1
    ]);
    static #c = new Float32Array(3);
    static #h = new Float32Array(3);
    static #d = new Float32Array(3);
    static #u = (24 / 116) ** 3 / 8;
    constructor(e1, t, i, n){
        if (super("CalRGB", 3), !e1) throw new ti("WhitePoint missing - required for color space CalRGB");
        const [a, s, r] = this.whitePoint = e1, [o, l, c] = this.blackPoint = t || new Float32Array(3);
        if ([this.GR, this.GG, this.GB] = i || new Float32Array([
            1,
            1,
            1
        ]), [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = n || new Float32Array([
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]), a < 0 || r < 0 || 1 !== s) throw new ti(`Invalid WhitePoint components for ${this.name}, no fallback available`);
        (o < 0 || l < 0 || c < 0) && (info$1(`Invalid BlackPoint for ${this.name} [${o}, ${l}, ${c}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && (info$1(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
    }
    #g(e1, t, i) {
        i[0] = e1[0] * t[0] + e1[1] * t[1] + e1[2] * t[2], i[1] = e1[3] * t[0] + e1[4] * t[1] + e1[5] * t[2], i[2] = e1[6] * t[0] + e1[7] * t[1] + e1[8] * t[2];
    }
    #f(e1, t, i) {
        i[0] = 1 * t[0] / e1[0], i[1] = 1 * t[1] / e1[1], i[2] = 1 * t[2] / e1[2];
    }
    #p(e1, t, i) {
        i[0] = .95047 * t[0] / e1[0], i[1] = 1 * t[1] / e1[1], i[2] = 1.08883 * t[2] / e1[2];
    }
    #m(e1) {
        return e1 <= .0031308 ? MathClamp$1(12.92 * e1, 0, 1) : e1 >= .99554525 ? 1 : MathClamp$1(1.055 * e1 ** (1 / 2.4) - .055, 0, 1);
    }
    #b(e1) {
        return e1 < 0 ? -this.#b(-e1) : e1 > 8 ? ((e1 + 16) / 116) ** 3 : e1 * CalRGBCS.#u;
    }
    #y(e1, t, i) {
        if (0 === e1[0] && 0 === e1[1] && 0 === e1[2]) return i[0] = t[0], i[1] = t[1], void (i[2] = t[2]);
        const n = this.#b(0), a = (1 - n) / (1 - this.#b(e1[0])), s = 1 - a, r = (1 - n) / (1 - this.#b(e1[1])), o = 1 - r, l = (1 - n) / (1 - this.#b(e1[2])), c = 1 - l;
        i[0] = t[0] * a + s, i[1] = t[1] * r + o, i[2] = t[2] * l + c;
    }
    #w(e1, t, i) {
        if (1 === e1[0] && 1 === e1[2]) return i[0] = t[0], i[1] = t[1], void (i[2] = t[2]);
        const n = i;
        this.#g(CalRGBCS.#s, t, n);
        const a = CalRGBCS.#c;
        this.#f(e1, n, a), this.#g(CalRGBCS.#r, a, i);
    }
    #A(e1, t, i) {
        const n = i;
        this.#g(CalRGBCS.#s, t, n);
        const a = CalRGBCS.#c;
        this.#p(e1, n, a), this.#g(CalRGBCS.#r, a, i);
    }
    #a(e1, t, i, n, a) {
        const s = MathClamp$1(e1[t] * a, 0, 1), r = MathClamp$1(e1[t + 1] * a, 0, 1), o = MathClamp$1(e1[t + 2] * a, 0, 1), l = 1 === s ? 1 : s ** this.GR, c = 1 === r ? 1 : r ** this.GG, h = 1 === o ? 1 : o ** this.GB, d = this.MXA * l + this.MXB * c + this.MXC * h, u = this.MYA * l + this.MYB * c + this.MYC * h, g = this.MZA * l + this.MZB * c + this.MZC * h, f = CalRGBCS.#h;
        f[0] = d, f[1] = u, f[2] = g;
        const p = CalRGBCS.#d;
        this.#w(this.whitePoint, f, p);
        const m = CalRGBCS.#h;
        this.#y(this.blackPoint, p, m);
        const b = CalRGBCS.#d;
        this.#A(CalRGBCS.#l, m, b);
        const y = CalRGBCS.#h;
        this.#g(CalRGBCS.#o, b, y), i[n] = 255 * this.#m(y[0]), i[n + 1] = 255 * this.#m(y[1]), i[n + 2] = 255 * this.#m(y[2]);
    }
    getRgbItem(e1, t, i, n) {
        this.#a(e1, t, i, n, 1);
    }
    getRgbBuffer(e1, t, i, n, a, s, r) {
        const o = 1 / ((1 << s) - 1);
        for(let s = 0; s < i; ++s)this.#a(e1, t, n, a, o), t += 3, a += 3 + r;
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t) / 3 | 0;
    }
}
class LabCS extends ColorSpace {
    constructor(e1, t, i){
        if (super("Lab", 3), !e1) throw new ti("WhitePoint missing - required for color space Lab");
        if ([this.XW, this.YW, this.ZW] = e1, [this.amin, this.amax, this.bmin, this.bmax] = i || [
            -100,
            100,
            -100,
            100
        ], [this.XB, this.YB, this.ZB] = t || [
            0,
            0,
            0
        ], this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new ti("Invalid WhitePoint components, no fallback available");
        (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (info$1("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && (info$1("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
    }
    #x(e1) {
        return e1 >= 6 / 29 ? e1 ** 3 : 108 / 841 * (e1 - 4 / 29);
    }
    #S(e1, t, i, n) {
        return i + e1 * (n - i) / t;
    }
    #a(e1, t, i, n, a) {
        let s = e1[t], r = e1[t + 1], o = e1[t + 2];
        !1 !== i && (s = this.#S(s, i, 0, 100), r = this.#S(r, i, this.amin, this.amax), o = this.#S(o, i, this.bmin, this.bmax)), r > this.amax ? r = this.amax : r < this.amin && (r = this.amin), o > this.bmax ? o = this.bmax : o < this.bmin && (o = this.bmin);
        const l = (s + 16) / 116, c = l + r / 500, h = l - o / 200, d = this.XW * this.#x(c), u = this.YW * this.#x(l), g = this.ZW * this.#x(h);
        let f, p, m;
        this.ZW < 1 ? (f = 3.1339 * d + -1.617 * u + -.4906 * g, p = -.9785 * d + 1.916 * u + .0333 * g, m = .072 * d + -.229 * u + 1.4057 * g) : (f = 3.2406 * d + -1.5372 * u + -.4986 * g, p = -.9689 * d + 1.8758 * u + .0415 * g, m = .0557 * d + -.204 * u + 1.057 * g), n[a] = 255 * Math.sqrt(f), n[a + 1] = 255 * Math.sqrt(p), n[a + 2] = 255 * Math.sqrt(m);
    }
    getRgbItem(e1, t, i, n) {
        this.#a(e1, t, !1, i, n);
    }
    getRgbBuffer(e1, t, i, n, a, s, r) {
        const o = (1 << s) - 1;
        for(let s = 0; s < i; s++)this.#a(e1, t, o, n, a), t += 3, a += 3 + r;
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t) / 3 | 0;
    }
    isDefaultDecode(e1, t) {
        return !0;
    }
    get usesZeroToOneRange() {
        return shadow$1(this, "usesZeroToOneRange", !1);
    }
}
function fetchSync(e1) {
    const t = new XMLHttpRequest;
    return t.open("GET", e1, !1), t.responseType = "arraybuffer", t.send(null), t.response;
}
class IccColorSpace extends ColorSpace {
    #v;
    #C;
    static #k = !0;
    static #T = null;
    static #F = null;
    constructor(e1, t, i){
        if (!IccColorSpace.isUsable) throw new Error("No ICC color space support");
        let n;
        switch(super(t, i), i){
            case 1:
                n = Ci.Gray8, this.#C = (e1, t, i)=>(function(e1, t, i) {
                        Ai.qcms_convert_one(e1, t, i);
                    })(this.#v, 255 * e1[t], i);
                break;
            case 3:
                n = Ci.RGB8, this.#C = (e1, t, i)=>(function(e1, t, i, n, a) {
                        Ai.qcms_convert_three(e1, t, i, n, a);
                    })(this.#v, 255 * e1[t], 255 * e1[t + 1], 255 * e1[t + 2], i);
                break;
            case 4:
                n = Ci.CMYK, this.#C = (e1, t, i)=>(function(e1, t, i, n, a, s) {
                        Ai.qcms_convert_four(e1, t, i, n, a, s);
                    })(this.#v, 255 * e1[t], 255 * e1[t + 1], 255 * e1[t + 2], 255 * e1[t + 3], i);
                break;
            default:
                throw new Error(`Unsupported number of components: ${i}`);
        }
        if (this.#v = function(e1, t, i) {
            const n = passArray8ToWasm0(e1, Ai.__wbindgen_malloc), a = vi;
            return Ai.qcms_transformer_from_memory(n, a, t, i) >>> 0;
        }(e1, n, ki.Perceptual), !this.#v) throw new Error("Failed to create ICC color space");
        IccColorSpace.#F ||= new FinalizationRegistry((e1)=>{
            !function(e1) {
                Ai.qcms_drop_transformer(e1);
            }(e1);
        }), IccColorSpace.#F.register(this, this.#v);
    }
    getRgbHex(e1, t) {
        return this.#C(e1, t, !0), QCMS._cssColor;
    }
    getRgbItem(e1, t, i, n) {
        QCMS._destBuffer = i, QCMS._destOffset = n, QCMS._destLength = 3, this.#C(e1, t, !1), QCMS._destBuffer = null;
    }
    getRgbBuffer(e1, t, i, n, a, s, r) {
        if (e1 = e1.subarray(t, t + i * this.numComps), 8 !== s) {
            const t = 255 / ((1 << s) - 1);
            for(let i = 0, n = e1.length; i < n; i++)e1[i] *= t;
        }
        QCMS._mustAddAlpha = r && n.buffer === e1.buffer, QCMS._destBuffer = n, QCMS._destOffset = a, QCMS._destLength = i * (3 + r), function(e1, t) {
            const i = passArray8ToWasm0(t, Ai.__wbindgen_malloc), n = vi;
            Ai.qcms_convert_array(e1, i, n);
        }(this.#v, e1), QCMS._mustAddAlpha = !1, QCMS._destBuffer = null;
    }
    getOutputLength(e1, t) {
        return e1 / this.numComps * (3 + t) | 0;
    }
    static setOptions({ useWasm: e1, useWorkerFetch: t, wasmUrl: i }) {
        t ? (this.#k = e1, this.#T = i) : this.#k = !1;
    }
    static get isUsable() {
        let e1 = !1;
        if (this.#k) if (this.#T) try {
            this._module = initSync({
                module: fetchSync(`${this.#T}qcms_bg.wasm`)
            }), e1 = !!this._module, QCMS._memory = this._module.memory, QCMS._makeHexColor = ai.makeHexColor;
        } catch (e1) {
            warn$1(`ICCBased color space: "${e1}".`);
        }
        else warn$1("No ICC color space support due to missing `wasmUrl` API option");
        return shadow$1(this, "isUsable", e1);
    }
}
class CmykICCBasedCS extends IccColorSpace {
    static #I;
    constructor(){
        super(new Uint8Array(fetchSync(`${CmykICCBasedCS.#I}CGATS001Compat-v2-micro.icc`)), "DeviceCMYK", 4);
    }
    static setOptions({ iccUrl: e1 }) {
        this.#I = e1;
    }
    static get isUsable() {
        let e1 = !1;
        return IccColorSpace.isUsable && (this.#I ? e1 = !0 : warn$1("No CMYK ICC profile support due to missing `iccUrl` API option")), shadow$1(this, "isUsable", e1);
    }
}
class Stream extends BaseStream {
    constructor(e1, t, i, n){
        super(), this.bytes = e1 instanceof Uint8Array ? e1 : new Uint8Array(e1), this.start = t || 0, this.pos = this.start, this.end = t + i || this.bytes.length, this.dict = n;
    }
    get length() {
        return this.end - this.start;
    }
    get isEmpty() {
        return 0 === this.length;
    }
    getByte() {
        return this.pos >= this.end ? -1 : this.bytes[this.pos++];
    }
    getBytes(e1) {
        const t = this.bytes, i = this.pos, n = this.end;
        if (!e1) return t.subarray(i, n);
        let a = i + e1;
        return a > n && (a = n), this.pos = a, t.subarray(i, a);
    }
    getByteRange(e1, t) {
        return e1 < 0 && (e1 = 0), t > this.end && (t = this.end), this.bytes.subarray(e1, t);
    }
    reset() {
        this.pos = this.start;
    }
    moveStart() {
        this.start = this.pos;
    }
    makeSubStream(e1, t, i = null) {
        return new Stream(this.bytes.buffer, e1, t, i);
    }
}
class StringStream extends Stream {
    constructor(e1){
        super(stringToBytes$1(e1));
    }
}
class NullStream extends Stream {
    constructor(){
        super(new Uint8Array(0));
    }
}
class ChunkedStream extends Stream {
    constructor(e1, t, i){
        super(new Uint8Array(e1), 0, e1, null), this.chunkSize = t, this._loadedChunks = new Set, this.numChunks = Math.ceil(e1 / t), this.manager = i, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
    }
    getMissingChunks() {
        const e1 = [];
        for(let t = 0, i = this.numChunks; t < i; ++t)this._loadedChunks.has(t) || e1.push(t);
        return e1;
    }
    get numChunksLoaded() {
        return this._loadedChunks.size;
    }
    get isDataLoaded() {
        return this.numChunksLoaded === this.numChunks;
    }
    onReceiveData(e1, t) {
        const i = this.chunkSize;
        if (e1 % i !== 0) throw new Error(`Bad begin offset: ${e1}`);
        const n = e1 + t.byteLength;
        if (n % i !== 0 && n !== this.bytes.length) throw new Error(`Bad end offset: ${n}`);
        this.bytes.set(new Uint8Array(t), e1);
        const a = Math.floor(e1 / i), s = Math.floor((n - 1) / i) + 1;
        for(let e1 = a; e1 < s; ++e1)this._loadedChunks.add(e1);
    }
    onReceiveProgressiveData(e1) {
        let t = this.progressiveDataLength;
        const i = Math.floor(t / this.chunkSize);
        this.bytes.set(new Uint8Array(e1), t), t += e1.byteLength, this.progressiveDataLength = t;
        const n = t >= this.end ? this.numChunks : Math.floor(t / this.chunkSize);
        for(let e1 = i; e1 < n; ++e1)this._loadedChunks.add(e1);
    }
    ensureByte(e1) {
        if (e1 < this.progressiveDataLength) return;
        const t = Math.floor(e1 / this.chunkSize);
        if (!(t > this.numChunks) && t !== this.lastSuccessfulEnsureByteChunk) {
            if (!this._loadedChunks.has(t)) throw new MissingDataException(e1, e1 + 1);
            this.lastSuccessfulEnsureByteChunk = t;
        }
    }
    ensureRange(e1, t) {
        if (e1 >= t) return;
        if (t <= this.progressiveDataLength) return;
        const i = Math.floor(e1 / this.chunkSize);
        if (i > this.numChunks) return;
        const n = Math.min(Math.floor((t - 1) / this.chunkSize) + 1, this.numChunks);
        for(let a = i; a < n; ++a)if (!this._loadedChunks.has(a)) throw new MissingDataException(e1, t);
    }
    nextEmptyChunk(e1) {
        const t = this.numChunks;
        for(let i = 0; i < t; ++i){
            const n = (e1 + i) % t;
            if (!this._loadedChunks.has(n)) return n;
        }
        return null;
    }
    hasChunk(e1) {
        return this._loadedChunks.has(e1);
    }
    getByte() {
        const e1 = this.pos;
        return e1 >= this.end ? -1 : (e1 >= this.progressiveDataLength && this.ensureByte(e1), this.bytes[this.pos++]);
    }
    getBytes(e1) {
        const t = this.bytes, i = this.pos, n = this.end;
        if (!e1) return n > this.progressiveDataLength && this.ensureRange(i, n), t.subarray(i, n);
        let a = i + e1;
        return a > n && (a = n), a > this.progressiveDataLength && this.ensureRange(i, a), this.pos = a, t.subarray(i, a);
    }
    getByteRange(e1, t) {
        return e1 < 0 && (e1 = 0), t > this.end && (t = this.end), t > this.progressiveDataLength && this.ensureRange(e1, t), this.bytes.subarray(e1, t);
    }
    makeSubStream(e1, t, i = null) {
        function ChunkedStreamSubstream() {}
        t ? e1 + t > this.progressiveDataLength && this.ensureRange(e1, e1 + t) : e1 >= this.progressiveDataLength && this.ensureByte(e1), ChunkedStreamSubstream.prototype = Object.create(this), ChunkedStreamSubstream.prototype.getMissingChunks = function() {
            const e1 = this.chunkSize, t = Math.floor(this.start / e1), i = Math.floor((this.end - 1) / e1) + 1, n = [];
            for(let e1 = t; e1 < i; ++e1)this._loadedChunks.has(e1) || n.push(e1);
            return n;
        }, Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", {
            get () {
                return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;
            },
            configurable: !0
        });
        const n = new ChunkedStreamSubstream;
        return n.pos = n.start = e1, n.end = e1 + t || this.end, n.dict = i, n;
    }
    getBaseStreams() {
        return [
            this
        ];
    }
}
class ChunkedStreamManager {
    constructor(e1, t){
        this.length = t.length, this.chunkSize = t.rangeChunkSize, this.stream = new ChunkedStream(this.length, this.chunkSize, this), this.pdfNetworkStream = e1, this.disableAutoFetch = t.disableAutoFetch, this.msgHandler = t.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = new Map, this._requestsByChunk = new Map, this._promisesByRequest = new Map, this.progressiveDataLength = 0, this.aborted = !1, this._loadedStreamCapability = Promise.withResolvers();
    }
    sendRequest(e1, t) {
        const i = this.pdfNetworkStream.getRangeReader(e1, t);
        i.isStreamingSupported || (i.onProgress = this.onProgress.bind(this));
        let n = [], a = 0;
        return new Promise((e1, t)=>{
            const readChunk = ({ value: s, done: r })=>{
                try {
                    if (r) {
                        const t = arrayBuffersToBytes(n);
                        return n = null, void e1(t);
                    }
                    a += s.byteLength, i.isStreamingSupported && this.onProgress({
                        loaded: a
                    }), n.push(s), i.read().then(readChunk, t);
                } catch (e1) {
                    t(e1);
                }
            };
            i.read().then(readChunk, t);
        }).then((t)=>{
            this.aborted || this.onReceiveData({
                chunk: t,
                begin: e1
            });
        });
    }
    requestAllChunks(e1 = !1) {
        if (!e1) {
            const e1 = this.stream.getMissingChunks();
            this._requestChunks(e1);
        }
        return this._loadedStreamCapability.promise;
    }
    _requestChunks(e1) {
        const t = this.currRequestId++, i = new Set;
        this._chunksNeededByRequest.set(t, i);
        for (const t of e1)this.stream.hasChunk(t) || i.add(t);
        if (0 === i.size) return Promise.resolve();
        const n = Promise.withResolvers();
        this._promisesByRequest.set(t, n);
        const a = [];
        for (const e1 of i){
            let i = this._requestsByChunk.get(e1);
            i || (i = [], this._requestsByChunk.set(e1, i), a.push(e1)), i.push(t);
        }
        if (a.length > 0) {
            const e1 = this.groupChunks(a);
            for (const t of e1){
                const e1 = t.beginChunk * this.chunkSize, i = Math.min(t.endChunk * this.chunkSize, this.length);
                this.sendRequest(e1, i).catch(n.reject);
            }
        }
        return n.promise.catch((e1)=>{
            if (!this.aborted) throw e1;
        });
    }
    getStream() {
        return this.stream;
    }
    requestRange(e1, t) {
        t = Math.min(t, this.length);
        const i = this.getBeginChunk(e1), n = this.getEndChunk(t), a = [];
        for(let e1 = i; e1 < n; ++e1)a.push(e1);
        return this._requestChunks(a);
    }
    requestRanges(e1 = []) {
        const t = [];
        for (const i of e1){
            const e1 = this.getBeginChunk(i.begin), n = this.getEndChunk(i.end);
            for(let i = e1; i < n; ++i)t.includes(i) || t.push(i);
        }
        return t.sort((e1, t)=>e1 - t), this._requestChunks(t);
    }
    groupChunks(e1) {
        const t = [];
        let i = -1, n = -1;
        for(let a = 0, s = e1.length; a < s; ++a){
            const s = e1[a];
            i < 0 && (i = s), n >= 0 && n + 1 !== s && (t.push({
                beginChunk: i,
                endChunk: n + 1
            }), i = s), a + 1 === e1.length && t.push({
                beginChunk: i,
                endChunk: s + 1
            }), n = s;
        }
        return t;
    }
    onProgress(e1) {
        this.msgHandler.send("DocProgress", {
            loaded: this.stream.numChunksLoaded * this.chunkSize + e1.loaded,
            total: this.length
        });
    }
    onReceiveData(e1) {
        const t = e1.chunk, i = void 0 === e1.begin, n = i ? this.progressiveDataLength : e1.begin, a = n + t.byteLength, s = Math.floor(n / this.chunkSize), r = a < this.length ? Math.floor(a / this.chunkSize) : Math.ceil(a / this.chunkSize);
        i ? (this.stream.onReceiveProgressiveData(t), this.progressiveDataLength = a) : this.stream.onReceiveData(n, t), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
        const o = [];
        for(let e1 = s; e1 < r; ++e1){
            const t = this._requestsByChunk.get(e1);
            if (t) {
                this._requestsByChunk.delete(e1);
                for (const i of t){
                    const t = this._chunksNeededByRequest.get(i);
                    t.has(e1) && t.delete(e1), t.size > 0 || o.push(i);
                }
            }
        }
        if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {
            let e1;
            if (1 === this.stream.numChunksLoaded) {
                const t = this.stream.numChunks - 1;
                this.stream.hasChunk(t) || (e1 = t);
            } else e1 = this.stream.nextEmptyChunk(r);
            Number.isInteger(e1) && this._requestChunks([
                e1
            ]);
        }
        for (const e1 of o){
            const t = this._promisesByRequest.get(e1);
            this._promisesByRequest.delete(e1), t.resolve();
        }
        this.msgHandler.send("DocProgress", {
            loaded: this.stream.numChunksLoaded * this.chunkSize,
            total: this.length
        });
    }
    onError(e1) {
        this._loadedStreamCapability.reject(e1);
    }
    getBeginChunk(e1) {
        return Math.floor(e1 / this.chunkSize);
    }
    getEndChunk(e1) {
        return Math.floor((e1 - 1) / this.chunkSize) + 1;
    }
    abort(e1) {
        this.aborted = !0, this.pdfNetworkStream?.cancelAllRequests(e1);
        for (const t of this._promisesByRequest.values())t.reject(e1);
    }
}
function convertToRGBA(e1) {
    switch(e1.kind){
        case v:
            return convertBlackAndWhiteToRGBA$1(e1);
        case C:
            return function({ src: e1, srcPos: t = 0, dest: i, destPos: n = 0, width: a, height: s }) {
                let r = 0;
                const o = a * s * 3, l = o >> 2, c = new Uint32Array(e1.buffer, t, l);
                if (FeatureTest.isLittleEndian) {
                    for(; r < l - 2; r += 3, n += 4){
                        const e1 = c[r], t = c[r + 1], a = c[r + 2];
                        i[n] = 4278190080 | e1, i[n + 1] = e1 >>> 24 | t << 8 | 4278190080, i[n + 2] = t >>> 16 | a << 16 | 4278190080, i[n + 3] = a >>> 8 | 4278190080;
                    }
                    for(let a = 4 * r, s = t + o; a < s; a += 3)i[n++] = e1[a] | e1[a + 1] << 8 | e1[a + 2] << 16 | 4278190080;
                } else {
                    for(; r < l - 2; r += 3, n += 4){
                        const e1 = c[r], t = c[r + 1], a = c[r + 2];
                        i[n] = 255 | e1, i[n + 1] = e1 << 24 | t >>> 8 | 255, i[n + 2] = t << 16 | a >>> 16 | 255, i[n + 3] = a << 8 | 255;
                    }
                    for(let a = 4 * r, s = t + o; a < s; a += 3)i[n++] = e1[a] << 24 | e1[a + 1] << 16 | e1[a + 2] << 8 | 255;
                }
                return {
                    srcPos: t + o,
                    destPos: n
                };
            }(e1);
    }
    return null;
}
function convertBlackAndWhiteToRGBA$1({ src: e1, srcPos: t = 0, dest: i, width: n, height: a, nonBlackColor: s = 4294967295, inverseDecode: r = !1 }) {
    const o = FeatureTest.isLittleEndian ? 4278190080 : 255, [l, c] = r ? [
        s,
        o
    ] : [
        o,
        s
    ], h = n >> 3, d = 7 & n, u = e1.length;
    i = new Uint32Array(i.buffer);
    let g = 0;
    for(let n = 0; n < a; n++){
        for(const n = t + h; t < n; t++){
            const n = t < u ? e1[t] : 255;
            i[g++] = 128 & n ? c : l, i[g++] = 64 & n ? c : l, i[g++] = 32 & n ? c : l, i[g++] = 16 & n ? c : l, i[g++] = 8 & n ? c : l, i[g++] = 4 & n ? c : l, i[g++] = 2 & n ? c : l, i[g++] = 1 & n ? c : l;
        }
        if (0 === d) continue;
        const n = t < u ? e1[t++] : 255;
        for(let e1 = 0; e1 < d; e1++)i[g++] = n & 1 << 7 - e1 ? c : l;
    }
    return {
        srcPos: t,
        destPos: g
    };
}
class ImageResizer {
    static #E = 2048;
    static #M = FeatureTest.isImageDecoderSupported;
    constructor(e1, t){
        this._imgData = e1, this._isMask = t;
    }
    static get canUseImageDecoder() {
        return shadow$1(this, "canUseImageDecoder", this.#M ? ImageDecoder.isTypeSupported("image/bmp") : Promise.resolve(!1));
    }
    static needsToBeResized(e1, t) {
        if (e1 <= this.#E && t <= this.#E) return !1;
        const { MAX_DIM: i } = this;
        if (e1 > i || t > i) return !0;
        const n = e1 * t;
        if (this._hasMaxArea) return n > this.MAX_AREA;
        if (n < this.#E ** 2) return !1;
        if (this._areGoodDims(e1, t)) return this.#E = Math.max(this.#E, Math.floor(Math.sqrt(e1 * t))), !1;
        this.#E = this._guessMax(this.#E, i, 128, 0);
        return n > (this.MAX_AREA = this.#E ** 2);
    }
    static getReducePowerForJPX(e1, t, i) {
        const n = e1 * t, a = 2 ** 30 / (4 * i);
        if (!this.needsToBeResized(e1, t)) return n > a ? Math.ceil(Math.log2(n / a)) : 0;
        const { MAX_DIM: s, MAX_AREA: r } = this, o = Math.max(e1 / s, t / s, Math.sqrt(n / Math.min(a, r)));
        return Math.ceil(Math.log2(o));
    }
    static get MAX_DIM() {
        return shadow$1(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
    }
    static get MAX_AREA() {
        return this._hasMaxArea = !0, shadow$1(this, "MAX_AREA", this._guessMax(this.#E, this.MAX_DIM, 128, 0) ** 2);
    }
    static set MAX_AREA(e1) {
        e1 >= 0 && (this._hasMaxArea = !0, shadow$1(this, "MAX_AREA", e1));
    }
    static setOptions({ canvasMaxAreaInBytes: e1 = -1, isImageDecoderSupported: t = !1 }) {
        this._hasMaxArea || (this.MAX_AREA = e1 >> 2), this.#M = t;
    }
    static _areGoodDims(e1, t) {
        try {
            const i = new OffscreenCanvas(e1, t), n = i.getContext("2d");
            n.fillRect(0, 0, 1, 1);
            const a = n.getImageData(0, 0, 1, 1).data[3];
            return i.width = i.height = 1, 0 !== a;
        } catch  {
            return !1;
        }
    }
    static _guessMax(e1, t, i, n) {
        for(; e1 + i + 1 < t;){
            const i = Math.floor((e1 + t) / 2), a = n || i;
            this._areGoodDims(i, a) ? e1 = i : t = i;
        }
        return e1;
    }
    static async createImage(e1, t = !1) {
        return new ImageResizer(e1, t)._createImage();
    }
    async _createImage() {
        const { _imgData: e1 } = this, { width: t, height: i } = e1;
        if (t * i * 4 > fi) {
            const e1 = this.#D();
            if (e1) return e1;
        }
        const n = this._encodeBMP();
        let a, s;
        await ImageResizer.canUseImageDecoder ? (a = new ImageDecoder({
            data: n,
            type: "image/bmp",
            preferAnimation: !1,
            transfer: [
                n.buffer
            ]
        }), s = a.decode().catch((e1)=>(warn$1(`BMP image decoding failed: ${e1}`), createImageBitmap(new Blob([
                this._encodeBMP().buffer
            ], {
                type: "image/bmp"
            })))).finally(()=>{
            a.close();
        })) : s = createImageBitmap(new Blob([
            n.buffer
        ], {
            type: "image/bmp"
        }));
        const { MAX_AREA: r, MAX_DIM: o } = ImageResizer, l = Math.max(t / o, i / o, Math.sqrt(t * i / r)), c = Math.max(l, 2), h = Math.round(10 * (l + 1.25)) / 10 / c, d = Math.floor(Math.log2(h)), u = new Array(d + 2).fill(2);
        u[0] = c, u.splice(-1, 1, h / (1 << d));
        let g = t, f = i;
        const p = await s;
        let m = p.image || p;
        for (const e1 of u){
            const t = g, i = f;
            g = Math.floor(g / e1) - 1, f = Math.floor(f / e1) - 1;
            const n = new OffscreenCanvas(g, f);
            n.getContext("2d").drawImage(m, 0, 0, t, i, 0, 0, g, f), m.close(), m = n.transferToImageBitmap();
        }
        return e1.data = null, e1.bitmap = m, e1.width = g, e1.height = f, e1;
    }
    #D() {
        const { _imgData: e1 } = this, { data: t, width: i, height: n, kind: a } = e1, s = i * n * 4, r = Math.ceil(Math.log2(s / fi)), o = i >> r, l = n >> r;
        let c, h = n;
        try {
            c = new Uint8Array(s);
        } catch  {
            let e1 = Math.floor(Math.log2(s + 1));
            for(;;)try {
                c = new Uint8Array(2 ** e1 - 1);
                break;
            } catch  {
                e1 -= 1;
            }
            h = Math.floor((2 ** e1 - 1) / (4 * i));
            const t = i * h * 4;
            t < c.length && (c = new Uint8Array(t));
        }
        const d = new Uint32Array(c.buffer), u = new Uint32Array(o * l);
        let g = 0, f = 0;
        const p = Math.ceil(n / h), m = n % h === 0 ? n : n % h;
        for(let e1 = 0; e1 < p; e1++){
            const n = e1 < p - 1 ? h : m;
            ({ srcPos: g } = convertToRGBA({
                kind: a,
                src: t,
                dest: d,
                width: i,
                height: n,
                inverseDecode: this._isMask,
                srcPos: g
            }));
            for(let e1 = 0, t = n >> r; e1 < t; e1++){
                const t = d.subarray((e1 << r) * i);
                for(let e1 = 0; e1 < o; e1++)u[f++] = t[e1 << r];
            }
        }
        if (ImageResizer.needsToBeResized(o, l)) return e1.data = u, e1.width = o, e1.height = l, e1.kind = k, null;
        const b = new OffscreenCanvas(o, l);
        return b.getContext("2d", {
            willReadFrequently: !0
        }).putImageData(new ImageData(new Uint8ClampedArray(u.buffer), o, l), 0, 0), e1.data = null, e1.bitmap = b.transferToImageBitmap(), e1.width = o, e1.height = l, e1;
    }
    _encodeBMP() {
        const { width: e1, height: t, kind: i } = this._imgData;
        let n, a = this._imgData.data, s = new Uint8Array(0), r = s, o = 0;
        switch(i){
            case v:
                {
                    n = 1, s = new Uint8Array(this._isMask ? [
                        255,
                        255,
                        255,
                        255,
                        0,
                        0,
                        0,
                        0
                    ] : [
                        0,
                        0,
                        0,
                        0,
                        255,
                        255,
                        255,
                        255
                    ]);
                    const i = e1 + 7 >> 3, r = i + 3 & -4;
                    if (i !== r) {
                        const e1 = new Uint8Array(r * t);
                        let n = 0;
                        for(let s = 0, o = t * i; s < o; s += i, n += r)e1.set(a.subarray(s, s + i), n);
                        a = e1;
                    }
                    break;
                }
            case C:
                if (n = 24, 3 & e1) {
                    const i = 3 * e1, n = i + 3 & -4, s = n - i, r = new Uint8Array(n * t);
                    let o = 0;
                    for(let e1 = 0, n = t * i; e1 < n; e1 += i){
                        const t = a.subarray(e1, e1 + i);
                        for(let e1 = 0; e1 < i; e1 += 3)r[o++] = t[e1 + 2], r[o++] = t[e1 + 1], r[o++] = t[e1];
                        o += s;
                    }
                    a = r;
                } else for(let e1 = 0, t = a.length; e1 < t; e1 += 3){
                    const t = a[e1];
                    a[e1] = a[e1 + 2], a[e1 + 2] = t;
                }
                break;
            case k:
                n = 32, o = 3, r = new Uint8Array(68);
                const i1 = new DataView(r.buffer);
                FeatureTest.isLittleEndian ? (i1.setUint32(0, 255, !0), i1.setUint32(4, 65280, !0), i1.setUint32(8, 16711680, !0), i1.setUint32(12, 4278190080, !0)) : (i1.setUint32(0, 4278190080, !0), i1.setUint32(4, 16711680, !0), i1.setUint32(8, 65280, !0), i1.setUint32(12, 255, !0));
                break;
            default:
                throw new Error("invalid format");
        }
        let l = 0;
        const c = 40 + r.length, h = 14 + c + s.length + a.length, d = new Uint8Array(h), u = new DataView(d.buffer);
        return u.setUint16(l, 19778, !0), l += 2, u.setUint32(l, h, !0), l += 4, u.setUint32(l, 0, !0), l += 4, u.setUint32(l, 14 + c + s.length, !0), l += 4, u.setUint32(l, c, !0), l += 4, u.setInt32(l, e1, !0), l += 4, u.setInt32(l, -t, !0), l += 4, u.setUint16(l, 1, !0), l += 2, u.setUint16(l, n, !0), l += 2, u.setUint32(l, o, !0), l += 4, u.setUint32(l, 0, !0), l += 4, u.setInt32(l, 0, !0), l += 4, u.setInt32(l, 0, !0), l += 4, u.setUint32(l, s.length / 4, !0), l += 4, u.setUint32(l, 0, !0), l += 4, d.set(r, l), l += r.length, d.set(s, l), l += s.length, d.set(a, l), d;
    }
}
const Ti = new Uint8Array(0);
class DecodeStream extends BaseStream {
    constructor(e1){
        if (super(), this._rawMinBufferLength = e1 || 0, this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = Ti, this.minBufferLength = 512, e1) for(; this.minBufferLength < e1;)this.minBufferLength *= 2;
    }
    get isEmpty() {
        for(; !this.eof && 0 === this.bufferLength;)this.readBlock();
        return 0 === this.bufferLength;
    }
    ensureBuffer(e1) {
        const t = this.buffer;
        if (e1 <= t.byteLength) return t;
        let i = this.minBufferLength;
        for(; i < e1;)i *= 2;
        const n = new Uint8Array(i);
        return n.set(t), this.buffer = n;
    }
    getByte() {
        const e1 = this.pos;
        for(; this.bufferLength <= e1;){
            if (this.eof) return -1;
            this.readBlock();
        }
        return this.buffer[this.pos++];
    }
    getBytes(e1, t = null) {
        const i = this.pos;
        let n;
        if (e1) {
            for(this.ensureBuffer(i + e1), n = i + e1; !this.eof && this.bufferLength < n;)this.readBlock(t);
            const a = this.bufferLength;
            n > a && (n = a);
        } else {
            for(; !this.eof;)this.readBlock(t);
            n = this.bufferLength;
        }
        return this.pos = n, this.buffer.subarray(i, n);
    }
    async getImageData(e1, t) {
        if (!this.canAsyncDecodeImageFromBuffer) return this.isAsyncDecoder ? this.decodeImage(null, t) : this.getBytes(e1, t);
        const i = await this.stream.asyncGetBytes();
        return this.decodeImage(i, t);
    }
    reset() {
        this.pos = 0;
    }
    makeSubStream(e1, t, i = null) {
        if (void 0 === t) for(; !this.eof;)this.readBlock();
        else {
            const i = e1 + t;
            for(; this.bufferLength <= i && !this.eof;)this.readBlock();
        }
        return new Stream(this.buffer, e1, t, i);
    }
    getBaseStreams() {
        return this.str ? this.str.getBaseStreams() : null;
    }
}
class StreamsSequenceStream extends DecodeStream {
    constructor(e1, t = null){
        e1 = e1.filter((e1)=>e1 instanceof BaseStream);
        let i = 0;
        for (const t of e1)i += t instanceof DecodeStream ? t._rawMinBufferLength : t.length;
        super(i), this.streams = e1, this._onError = t;
    }
    readBlock() {
        const e1 = this.streams;
        if (0 === e1.length) return void (this.eof = !0);
        const t = e1.shift();
        let i;
        try {
            i = t.getBytes();
        } catch (e1) {
            if (this._onError) return void this._onError(e1, t.dict?.objId);
            throw e1;
        }
        const n = this.bufferLength, a = n + i.length;
        this.ensureBuffer(a).set(i, n), this.bufferLength = a;
    }
    getBaseStreams() {
        const e1 = [];
        for (const t of this.streams){
            const i = t.getBaseStreams();
            i && e1.push(...i);
        }
        return e1.length > 0 ? e1 : null;
    }
}
class ColorSpaceUtils {
    static parse({ cs: e1, xref: t, resources: i = null, pdfFunctionFactory: n, globalColorSpaceCache: a, localColorSpaceCache: s, asyncIfNotCached: r = !1 }) {
        const o = {
            xref: t,
            resources: i,
            pdfFunctionFactory: n,
            globalColorSpaceCache: a,
            localColorSpaceCache: s
        };
        let l, c, h;
        if (e1 instanceof Ref) {
            c = e1;
            const i = a.getByRef(c) || s.getByRef(c);
            if (i) return i;
            e1 = t.fetch(e1);
        }
        if (e1 instanceof Name) {
            l = e1.name;
            const t = s.getByName(l);
            if (t) return t;
        }
        try {
            h = this.#O(e1, o);
        } catch (e1) {
            if (r && !(e1 instanceof MissingDataException)) return Promise.reject(e1);
            throw e1;
        }
        return (l || c) && (s.set(l, c, h), c && a.set(null, c, h)), r ? Promise.resolve(h) : h;
    }
    static #_(e1, t) {
        const { globalColorSpaceCache: i } = t;
        let n;
        if (e1 instanceof Ref) {
            n = e1;
            const t = i.getByRef(n);
            if (t) return t;
        }
        const a = this.#O(e1, t);
        return n && i.set(null, n, a), a;
    }
    static #O(e1, t) {
        const { xref: i, resources: n, pdfFunctionFactory: a, globalColorSpaceCache: s } = t;
        if ((e1 = i.fetchIfRef(e1)) instanceof Name) switch(e1.name){
            case "G":
            case "DeviceGray":
                return this.gray;
            case "RGB":
            case "DeviceRGB":
                return this.rgb;
            case "DeviceRGBA":
                return this.rgba;
            case "CMYK":
            case "DeviceCMYK":
                return this.cmyk;
            case "Pattern":
                return new PatternCS(null);
            default:
                if (n instanceof Dict) {
                    const i = n.get("ColorSpace");
                    if (i instanceof Dict) {
                        const n = i.get(e1.name);
                        if (n) {
                            if (n instanceof Name) return this.#O(n, t);
                            e1 = n;
                            break;
                        }
                    }
                }
                return warn$1(`Unrecognized ColorSpace: ${e1.name}`), this.gray;
        }
        if (Array.isArray(e1)) {
            const n = i.fetchIfRef(e1[0]).name;
            let r, o, l, c, h, d;
            switch(n){
                case "G":
                case "DeviceGray":
                    return this.gray;
                case "RGB":
                case "DeviceRGB":
                    return this.rgb;
                case "CMYK":
                case "DeviceCMYK":
                    return this.cmyk;
                case "CalGray":
                    return r = i.fetchIfRef(e1[1]), c = r.getArray("WhitePoint"), h = r.getArray("BlackPoint"), d = r.get("Gamma"), new CalGrayCS(c, h, d);
                case "CalRGB":
                    r = i.fetchIfRef(e1[1]), c = r.getArray("WhitePoint"), h = r.getArray("BlackPoint"), d = r.getArray("Gamma");
                    const u = r.getArray("Matrix");
                    return new CalRGBCS(c, h, d, u);
                case "ICCBased":
                    const g = e1[1] instanceof Ref;
                    if (g) {
                        const t = s.getByRef(e1[1]);
                        if (t) return t;
                    }
                    const f = i.fetchIfRef(e1[1]), p = f.dict;
                    if (o = p.get("N"), IccColorSpace.isUsable) try {
                        const t = new IccColorSpace(f.getBytes(), "ICCBased", o);
                        return g && s.set(null, e1[1], t), t;
                    } catch (t) {
                        if (t instanceof MissingDataException) throw t;
                        warn$1(`ICCBased color space (${e1[1]}): "${t}".`);
                    }
                    const m = p.getRaw("Alternate");
                    if (m) {
                        const e1 = this.#_(m, t);
                        if (e1.numComps === o) return e1;
                        warn$1("ICCBased color space: Ignoring incorrect /Alternate entry.");
                    }
                    if (1 === o) return this.gray;
                    if (3 === o) return this.rgb;
                    if (4 === o) return this.cmyk;
                    break;
                case "Pattern":
                    return l = e1[1] || null, l && (l = this.#_(l, t)), new PatternCS(l);
                case "I":
                case "Indexed":
                    l = this.#_(e1[1], t);
                    const b = MathClamp$1(i.fetchIfRef(e1[2]), 0, 255), y = i.fetchIfRef(e1[3]);
                    return new IndexedCS(l, b, y);
                case "Separation":
                case "DeviceN":
                    const w = i.fetchIfRef(e1[1]);
                    o = Array.isArray(w) ? w.length : 1, l = this.#_(e1[2], t);
                    const x = a.create(e1[3]);
                    return new AlternateCS(o, l, x);
                case "Lab":
                    r = i.fetchIfRef(e1[1]), c = r.getArray("WhitePoint"), h = r.getArray("BlackPoint");
                    const S = r.getArray("Range");
                    return new LabCS(c, h, S);
                default:
                    return warn$1(`Unimplemented ColorSpace object: ${n}`), this.gray;
            }
        }
        return warn$1(`Unrecognized ColorSpace object: ${e1}`), this.gray;
    }
    static get gray() {
        return shadow$1(this, "gray", new DeviceGrayCS);
    }
    static get rgb() {
        return shadow$1(this, "rgb", new DeviceRgbCS);
    }
    static get rgba() {
        return shadow$1(this, "rgba", new DeviceRgbaCS);
    }
    static get cmyk() {
        if (CmykICCBasedCS.isUsable) try {
            return shadow$1(this, "cmyk", new CmykICCBasedCS);
        } catch  {
            warn$1("CMYK fallback: DeviceCMYK");
        }
        return shadow$1(this, "cmyk", new DeviceCmykCS);
    }
}
class JpegError extends Yt {
    constructor(e1){
        super(e1, "JpegError");
    }
}
class DNLMarkerError extends Yt {
    constructor(e1, t){
        super(e1, "DNLMarkerError"), this.scanLines = t;
    }
}
class EOIMarkerError extends Yt {
    constructor(e1){
        super(e1, "EOIMarkerError");
    }
}
const Fi = new Uint8Array([
    0,
    1,
    8,
    16,
    9,
    2,
    3,
    10,
    17,
    24,
    32,
    25,
    18,
    11,
    4,
    5,
    12,
    19,
    26,
    33,
    40,
    48,
    41,
    34,
    27,
    20,
    13,
    6,
    7,
    14,
    21,
    28,
    35,
    42,
    49,
    56,
    57,
    50,
    43,
    36,
    29,
    22,
    15,
    23,
    30,
    37,
    44,
    51,
    58,
    59,
    52,
    45,
    38,
    31,
    39,
    46,
    53,
    60,
    61,
    54,
    47,
    55,
    62,
    63
]), Ii = 4017, Ei = 799, Mi = 3406, Di = 2276, Oi = 1567, _i = 3784, Pi = 5793, Ri = 2896;
function buildHuffmanTable(e1, t) {
    let i, n, a = 0, s = 16;
    for(; s > 0 && !e1[s - 1];)s--;
    const r = [
        {
            children: [],
            index: 0
        }
    ];
    let o, l = r[0];
    for(i = 0; i < s; i++){
        for(n = 0; n < e1[i]; n++){
            for(l = r.pop(), l.children[l.index] = t[a]; l.index > 0;)l = r.pop();
            for(l.index++, r.push(l); r.length <= i;)r.push(o = {
                children: [],
                index: 0
            }), l.children[l.index] = o.children, l = o;
            a++;
        }
        i + 1 < s && (r.push(o = {
            children: [],
            index: 0
        }), l.children[l.index] = o.children, l = o);
    }
    return r[0].children;
}
function getBlockBufferOffset(e1, t, i) {
    return 64 * ((e1.blocksPerLine + 1) * t + i);
}
function decodeScan(e1, t, i, n, a, s, r, o, l, c = !1) {
    const h = i.mcusPerLine, d = i.progressive, u = t;
    let g = 0, f = 0;
    function readBit() {
        if (f > 0) return f--, g >> f & 1;
        if (g = e1[t++], 255 === g) {
            const n = e1[t++];
            if (n) {
                if (220 === n && c) {
                    const n = readUint16(e1, t += 2);
                    if (t += 2, n > 0 && n !== i.scanLines) throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", n);
                } else if (217 === n) {
                    if (c) {
                        const e1 = y * (8 === i.precision ? 8 : 0);
                        if (e1 > 0 && Math.round(i.scanLines / e1) >= 5) throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", e1);
                    }
                    throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                }
                throw new JpegError(`unexpected marker ${(g << 8 | n).toString(16)}`);
            }
        }
        return f = 7, g >>> 7;
    }
    function decodeHuffman(e1) {
        let t = e1;
        for(;;){
            switch(t = t[readBit()], typeof t){
                case "number":
                    return t;
                case "object":
                    continue;
            }
            throw new JpegError("invalid huffman sequence");
        }
    }
    function receive(e1) {
        let t = 0;
        for(; e1 > 0;)t = t << 1 | readBit(), e1--;
        return t;
    }
    function receiveAndExtend(e1) {
        if (1 === e1) return 1 === readBit() ? 1 : -1;
        const t = receive(e1);
        return t >= 1 << e1 - 1 ? t : t + (-1 << e1) + 1;
    }
    let p = 0;
    let m, b = 0;
    let y = 0;
    function decodeMcu(e1, t, i, n, a) {
        const s = i % h;
        y = (i / h | 0) * e1.v + n;
        const r = s * e1.h + a;
        t(e1, getBlockBufferOffset(e1, y, r));
    }
    function decodeBlock(e1, t, i) {
        y = i / e1.blocksPerLine | 0;
        const n = i % e1.blocksPerLine;
        t(e1, getBlockBufferOffset(e1, y, n));
    }
    const w = n.length;
    let x, S, v, C, k, T;
    T = d ? 0 === s ? 0 === o ? function(e1, t) {
        const i = decodeHuffman(e1.huffmanTableDC), n = 0 === i ? 0 : receiveAndExtend(i) << l;
        e1.blockData[t] = e1.pred += n;
    } : function(e1, t) {
        e1.blockData[t] |= readBit() << l;
    } : 0 === o ? function(e1, t) {
        if (p > 0) return void p--;
        let i = s;
        const n = r;
        for(; i <= n;){
            const n = decodeHuffman(e1.huffmanTableAC), a = 15 & n, s = n >> 4;
            if (0 === a) {
                if (s < 15) {
                    p = receive(s) + (1 << s) - 1;
                    break;
                }
                i += 16;
                continue;
            }
            i += s;
            const r = Fi[i];
            e1.blockData[t + r] = receiveAndExtend(a) * (1 << l), i++;
        }
    } : function(e1, t) {
        let i = s;
        const n = r;
        let a, o, c = 0;
        for(; i <= n;){
            const n = t + Fi[i], s = e1.blockData[n] < 0 ? -1 : 1;
            switch(b){
                case 0:
                    if (o = decodeHuffman(e1.huffmanTableAC), a = 15 & o, c = o >> 4, 0 === a) c < 15 ? (p = receive(c) + (1 << c), b = 4) : (c = 16, b = 1);
                    else {
                        if (1 !== a) throw new JpegError("invalid ACn encoding");
                        m = receiveAndExtend(a), b = c ? 2 : 3;
                    }
                    continue;
                case 1:
                case 2:
                    e1.blockData[n] ? e1.blockData[n] += s * (readBit() << l) : (c--, 0 === c && (b = 2 === b ? 3 : 0));
                    break;
                case 3:
                    e1.blockData[n] ? e1.blockData[n] += s * (readBit() << l) : (e1.blockData[n] = m << l, b = 0);
                    break;
                case 4:
                    e1.blockData[n] && (e1.blockData[n] += s * (readBit() << l));
            }
            i++;
        }
        4 === b && (p--, 0 === p && (b = 0));
    } : function(e1, t) {
        const i = decodeHuffman(e1.huffmanTableDC), n = 0 === i ? 0 : receiveAndExtend(i);
        e1.blockData[t] = e1.pred += n;
        let a = 1;
        for(; a < 64;){
            const i = decodeHuffman(e1.huffmanTableAC), n = 15 & i, s = i >> 4;
            if (0 === n) {
                if (s < 15) break;
                a += 16;
                continue;
            }
            a += s;
            const r = Fi[a];
            e1.blockData[t + r] = receiveAndExtend(n), a++;
        }
    };
    let F, E = 0;
    const M = 1 === w ? n[0].blocksPerLine * n[0].blocksPerColumn : h * i.mcusPerColumn;
    let D, O;
    for(; E <= M;){
        const i = a ? Math.min(M - E, a) : M;
        if (i > 0) {
            for(S = 0; S < w; S++)n[S].pred = 0;
            if (p = 0, 1 === w) for(x = n[0], k = 0; k < i; k++)decodeBlock(x, T, E), E++;
            else for(k = 0; k < i; k++){
                for(S = 0; S < w; S++)for(x = n[S], D = x.h, O = x.v, v = 0; v < O; v++)for(C = 0; C < D; C++)decodeMcu(x, T, E, v, C);
                E++;
            }
        }
        if (f = 0, F = findNextFileMarker(e1, t), !F) break;
        if (F.invalid) {
            warn$1(`decodeScan - ${i > 0 ? "unexpected" : "excessive"} MCU data, current marker is: ${F.invalid}`), t = F.offset;
        }
        if (!(F.marker >= 65488 && F.marker <= 65495)) break;
        t += 2;
    }
    return t - u;
}
function quantizeAndInverse(e1, t, i) {
    const n = e1.quantizationTable, a = e1.blockData;
    let s, r, o, l, c, h, d, u, g, f, p, m, b, y, w, x, S;
    if (!n) throw new JpegError("missing required Quantization Table.");
    for(let e1 = 0; e1 < 64; e1 += 8)g = a[t + e1], f = a[t + e1 + 1], p = a[t + e1 + 2], m = a[t + e1 + 3], b = a[t + e1 + 4], y = a[t + e1 + 5], w = a[t + e1 + 6], x = a[t + e1 + 7], g *= n[e1], 0 !== (f | p | m | b | y | w | x) ? (f *= n[e1 + 1], p *= n[e1 + 2], m *= n[e1 + 3], b *= n[e1 + 4], y *= n[e1 + 5], w *= n[e1 + 6], x *= n[e1 + 7], s = Pi * g + 128 >> 8, r = Pi * b + 128 >> 8, o = p, l = w, c = Ri * (f - x) + 128 >> 8, u = Ri * (f + x) + 128 >> 8, h = m << 4, d = y << 4, s = s + r + 1 >> 1, r = s - r, S = o * _i + l * Oi + 128 >> 8, o = o * Oi - l * _i + 128 >> 8, l = S, c = c + d + 1 >> 1, d = c - d, u = u + h + 1 >> 1, h = u - h, s = s + l + 1 >> 1, l = s - l, r = r + o + 1 >> 1, o = r - o, S = c * Di + u * Mi + 2048 >> 12, c = c * Mi - u * Di + 2048 >> 12, u = S, S = h * Ei + d * Ii + 2048 >> 12, h = h * Ii - d * Ei + 2048 >> 12, d = S, i[e1] = s + u, i[e1 + 7] = s - u, i[e1 + 1] = r + d, i[e1 + 6] = r - d, i[e1 + 2] = o + h, i[e1 + 5] = o - h, i[e1 + 3] = l + c, i[e1 + 4] = l - c) : (S = Pi * g + 512 >> 10, i[e1] = S, i[e1 + 1] = S, i[e1 + 2] = S, i[e1 + 3] = S, i[e1 + 4] = S, i[e1 + 5] = S, i[e1 + 6] = S, i[e1 + 7] = S);
    for(let e1 = 0; e1 < 8; ++e1)g = i[e1], f = i[e1 + 8], p = i[e1 + 16], m = i[e1 + 24], b = i[e1 + 32], y = i[e1 + 40], w = i[e1 + 48], x = i[e1 + 56], 0 !== (f | p | m | b | y | w | x) ? (s = Pi * g + 2048 >> 12, r = Pi * b + 2048 >> 12, o = p, l = w, c = Ri * (f - x) + 2048 >> 12, u = Ri * (f + x) + 2048 >> 12, h = m, d = y, s = 4112 + (s + r + 1 >> 1), r = s - r, S = o * _i + l * Oi + 2048 >> 12, o = o * Oi - l * _i + 2048 >> 12, l = S, c = c + d + 1 >> 1, d = c - d, u = u + h + 1 >> 1, h = u - h, s = s + l + 1 >> 1, l = s - l, r = r + o + 1 >> 1, o = r - o, S = c * Di + u * Mi + 2048 >> 12, c = c * Mi - u * Di + 2048 >> 12, u = S, S = h * Ei + d * Ii + 2048 >> 12, h = h * Ii - d * Ei + 2048 >> 12, d = S, g = s + u, x = s - u, f = r + d, w = r - d, p = o + h, y = o - h, m = l + c, b = l - c, g < 16 ? g = 0 : g >= 4080 ? g = 255 : g >>= 4, f < 16 ? f = 0 : f >= 4080 ? f = 255 : f >>= 4, p < 16 ? p = 0 : p >= 4080 ? p = 255 : p >>= 4, m < 16 ? m = 0 : m >= 4080 ? m = 255 : m >>= 4, b < 16 ? b = 0 : b >= 4080 ? b = 255 : b >>= 4, y < 16 ? y = 0 : y >= 4080 ? y = 255 : y >>= 4, w < 16 ? w = 0 : w >= 4080 ? w = 255 : w >>= 4, x < 16 ? x = 0 : x >= 4080 ? x = 255 : x >>= 4, a[t + e1] = g, a[t + e1 + 8] = f, a[t + e1 + 16] = p, a[t + e1 + 24] = m, a[t + e1 + 32] = b, a[t + e1 + 40] = y, a[t + e1 + 48] = w, a[t + e1 + 56] = x) : (S = Pi * g + 8192 >> 14, S = S < -2040 ? 0 : S >= 2024 ? 255 : S + 2056 >> 4, a[t + e1] = S, a[t + e1 + 8] = S, a[t + e1 + 16] = S, a[t + e1 + 24] = S, a[t + e1 + 32] = S, a[t + e1 + 40] = S, a[t + e1 + 48] = S, a[t + e1 + 56] = S);
}
function buildComponentData(e1, t) {
    const i = t.blocksPerLine, n = t.blocksPerColumn, a = new Int16Array(64);
    for(let e1 = 0; e1 < n; e1++)for(let n = 0; n < i; n++){
        quantizeAndInverse(t, getBlockBufferOffset(t, e1, n), a);
    }
    return t.blockData;
}
function findNextFileMarker(e1, t, i = t) {
    const n = e1.length - 1;
    let a = i < t ? i : t;
    if (t >= n) return null;
    const s = readUint16(e1, t);
    if (s >= 65472 && s <= 65534) return {
        invalid: null,
        marker: s,
        offset: t
    };
    let r = readUint16(e1, a);
    for(; !(r >= 65472 && r <= 65534);){
        if (++a >= n) return null;
        r = readUint16(e1, a);
    }
    return {
        invalid: s.toString(16),
        marker: r,
        offset: a
    };
}
function prepareComponents(e1) {
    const t = Math.ceil(e1.samplesPerLine / 8 / e1.maxH), i = Math.ceil(e1.scanLines / 8 / e1.maxV);
    for (const n of e1.components){
        const a = Math.ceil(Math.ceil(e1.samplesPerLine / 8) * n.h / e1.maxH), s = Math.ceil(Math.ceil(e1.scanLines / 8) * n.v / e1.maxV), r = t * n.h, o = 64 * (i * n.v) * (r + 1);
        n.blockData = new Int16Array(o), n.blocksPerLine = a, n.blocksPerColumn = s;
    }
    e1.mcusPerLine = t, e1.mcusPerColumn = i;
}
function readDataBlock(e1, t) {
    const i = readUint16(e1, t);
    let n = (t += 2) + i - 2;
    const a = findNextFileMarker(e1, n, t);
    a?.invalid && (warn$1("readDataBlock - incorrect length, current marker is: " + a.invalid), n = a.offset);
    const s = e1.subarray(t, n);
    return {
        appData: s,
        oldOffset: t,
        newOffset: t + s.length
    };
}
function skipData(e1, t) {
    const i = readUint16(e1, t), n = (t += 2) + i - 2, a = findNextFileMarker(e1, n, t);
    return a?.invalid ? a.offset : n;
}
class JpegImage {
    constructor({ decodeTransform: e1 = null, colorTransform: t = -1 } = {}){
        this._decodeTransform = e1, this._colorTransform = t;
    }
    static canUseImageDecoder(e1, t = -1) {
        let i = null, n = 0, a = null, s = readUint16(e1, n);
        if (n += 2, 65496 !== s) throw new JpegError("SOI not found");
        s = readUint16(e1, n), n += 2;
        e1: for(; 65497 !== s;){
            switch(s){
                case 65505:
                    const { appData: t, oldOffset: r, newOffset: o } = readDataBlock(e1, n);
                    if (n = o, 69 === t[0] && 120 === t[1] && 105 === t[2] && 102 === t[3] && 0 === t[4] && 0 === t[5]) {
                        if (i) throw new JpegError("Duplicate EXIF-blocks found.");
                        i = {
                            exifStart: r + 6,
                            exifEnd: o
                        };
                    }
                    s = readUint16(e1, n), n += 2;
                    continue;
                case 65472:
                case 65473:
                case 65474:
                    a = e1[n + 7];
                    break e1;
                case 65535:
                    255 !== e1[n] && n--;
            }
            n = skipData(e1, n), s = readUint16(e1, n), n += 2;
        }
        return 4 === a || 3 === a && 0 === t ? null : i || {};
    }
    parse(e1, { dnlScanLines: t = null } = {}) {
        let i, n, a = 0, s = null, r = null, o = 0;
        const l = [], c = [], h = [];
        let d = readUint16(e1, a);
        if (a += 2, 65496 !== d) throw new JpegError("SOI not found");
        d = readUint16(e1, a), a += 2;
        e1: for(; 65497 !== d;){
            let u, g, f;
            switch(d){
                case 65504:
                case 65505:
                case 65506:
                case 65507:
                case 65508:
                case 65509:
                case 65510:
                case 65511:
                case 65512:
                case 65513:
                case 65514:
                case 65515:
                case 65516:
                case 65517:
                case 65518:
                case 65519:
                case 65534:
                    const { appData: p, newOffset: m } = readDataBlock(e1, a);
                    a = m, 65504 === d && 74 === p[0] && 70 === p[1] && 73 === p[2] && 70 === p[3] && 0 === p[4] && (s = {
                        version: {
                            major: p[5],
                            minor: p[6]
                        },
                        densityUnits: p[7],
                        xDensity: p[8] << 8 | p[9],
                        yDensity: p[10] << 8 | p[11],
                        thumbWidth: p[12],
                        thumbHeight: p[13],
                        thumbData: p.subarray(14, 14 + 3 * p[12] * p[13])
                    }), 65518 === d && 65 === p[0] && 100 === p[1] && 111 === p[2] && 98 === p[3] && 101 === p[4] && (r = {
                        version: p[5] << 8 | p[6],
                        flags0: p[7] << 8 | p[8],
                        flags1: p[9] << 8 | p[10],
                        transformCode: p[11]
                    });
                    break;
                case 65499:
                    const b = readUint16(e1, a);
                    a += 2;
                    const y = b + a - 2;
                    let w;
                    for(; a < y;){
                        const t = e1[a++], i = new Uint16Array(64);
                        if (t >> 4) {
                            if (t >> 4 != 1) throw new JpegError("DQT - invalid table spec");
                            for(g = 0; g < 64; g++)w = Fi[g], i[w] = readUint16(e1, a), a += 2;
                        } else for(g = 0; g < 64; g++)w = Fi[g], i[w] = e1[a++];
                        l[15 & t] = i;
                    }
                    break;
                case 65472:
                case 65473:
                case 65474:
                    if (i) throw new JpegError("Only single frame JPEGs supported");
                    a += 2, i = {}, i.extended = 65473 === d, i.progressive = 65474 === d, i.precision = e1[a++];
                    const x = readUint16(e1, a);
                    a += 2, i.scanLines = t || x, i.samplesPerLine = readUint16(e1, a), a += 2, i.components = [], i.componentIds = {};
                    const S = e1[a++];
                    let v = 0, C = 0;
                    for(u = 0; u < S; u++){
                        const t = e1[a], n = e1[a + 1] >> 4, s = 15 & e1[a + 1];
                        v < n && (v = n), C < s && (C = s);
                        const r = e1[a + 2];
                        f = i.components.push({
                            h: n,
                            v: s,
                            quantizationId: r,
                            quantizationTable: null
                        }), i.componentIds[t] = f - 1, a += 3;
                    }
                    i.maxH = v, i.maxV = C, prepareComponents(i);
                    break;
                case 65476:
                    const k = readUint16(e1, a);
                    for(a += 2, u = 2; u < k;){
                        const t = e1[a++], i = new Uint8Array(16);
                        let n = 0;
                        for(g = 0; g < 16; g++, a++)n += i[g] = e1[a];
                        const s = new Uint8Array(n);
                        for(g = 0; g < n; g++, a++)s[g] = e1[a];
                        u += 17 + n, (t >> 4 ? c : h)[15 & t] = buildHuffmanTable(i, s);
                    }
                    break;
                case 65501:
                    a += 2, n = readUint16(e1, a), a += 2;
                    break;
                case 65498:
                    const T = 1 === ++o && !t;
                    a += 2;
                    const F = e1[a++], E = [];
                    for(u = 0; u < F; u++){
                        const t = e1[a++], n = i.componentIds[t], s = i.components[n];
                        s.index = t;
                        const r = e1[a++];
                        s.huffmanTableDC = h[r >> 4], s.huffmanTableAC = c[15 & r], E.push(s);
                    }
                    const M = e1[a++], D = e1[a++], O = e1[a++];
                    try {
                        a += decodeScan(e1, a, i, E, n, M, D, O >> 4, 15 & O, T);
                    } catch (t) {
                        if (t instanceof DNLMarkerError) return warn$1(`${t.message} -- attempting to re-parse the JPEG image.`), this.parse(e1, {
                            dnlScanLines: t.scanLines
                        });
                        if (t instanceof EOIMarkerError) {
                            warn$1(`${t.message} -- ignoring the rest of the image data.`);
                            break e1;
                        }
                        throw t;
                    }
                    break;
                case 65500:
                    a += 4;
                    break;
                case 65535:
                    255 !== e1[a] && a--;
                    break;
                default:
                    const _ = findNextFileMarker(e1, a - 2, a - 3);
                    if (_?.invalid) {
                        warn$1("JpegImage.parse - unexpected data, current marker is: " + _.invalid), a = _.offset;
                        break;
                    }
                    if (!_ || a >= e1.length - 1) {
                        warn$1("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                        break e1;
                    }
                    throw new JpegError("JpegImage.parse - unknown marker: " + d.toString(16));
            }
            d = readUint16(e1, a), a += 2;
        }
        if (!i) throw new JpegError("JpegImage.parse - no frame data found.");
        this.width = i.samplesPerLine, this.height = i.scanLines, this.jfif = s, this.adobe = r, this.components = [];
        for (const e1 of i.components){
            const t = l[e1.quantizationId];
            t && (e1.quantizationTable = t), this.components.push({
                index: e1.index,
                output: buildComponentData(0, e1),
                scaleX: e1.h / i.maxH,
                scaleY: e1.v / i.maxV,
                blocksPerLine: e1.blocksPerLine,
                blocksPerColumn: e1.blocksPerColumn
            });
        }
        this.numComponents = this.components.length;
    }
    _getLinearizedBlockData(e1, t, i = !1) {
        const n = this.width / e1, a = this.height / t;
        let s, r, o, l, c, h, d, u, g, f, p, m = 0;
        const b = this.components.length, y = e1 * t * b, w = new Uint8ClampedArray(y), x = new Uint32Array(e1), S = 4294967288;
        let v;
        for(d = 0; d < b; d++){
            if (s = this.components[d], r = s.scaleX * n, o = s.scaleY * a, m = d, p = s.output, l = s.blocksPerLine + 1 << 3, r !== v) {
                for(c = 0; c < e1; c++)u = 0 | c * r, x[c] = (u & S) << 3 | 7 & u;
                v = r;
            }
            for(h = 0; h < t; h++)for(u = 0 | h * o, f = l * (u & S) | (7 & u) << 3, c = 0; c < e1; c++)w[m] = p[f + x[c]], m += b;
        }
        let C = this._decodeTransform;
        if (i || 4 !== b || C || (C = new Int32Array([
            -256,
            255,
            -256,
            255,
            -256,
            255,
            -256,
            255
        ])), C) for(d = 0; d < y;)for(u = 0, g = 0; u < b; u++, d++, g += 2)w[d] = (w[d] * C[g] >> 8) + C[g + 1];
        return w;
    }
    get _isColorConversionNeeded() {
        return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;
    }
    _convertYccToRgb(e1) {
        let t, i, n;
        for(let a = 0, s = e1.length; a < s; a += 3)t = e1[a], i = e1[a + 1], n = e1[a + 2], e1[a] = t - 179.456 + 1.402 * n, e1[a + 1] = t + 135.459 - .344 * i - .714 * n, e1[a + 2] = t - 226.816 + 1.772 * i;
        return e1;
    }
    _convertYccToRgba(e1, t) {
        for(let i = 0, n = 0, a = e1.length; i < a; i += 3, n += 4){
            const a = e1[i], s = e1[i + 1], r = e1[i + 2];
            t[n] = a - 179.456 + 1.402 * r, t[n + 1] = a + 135.459 - .344 * s - .714 * r, t[n + 2] = a - 226.816 + 1.772 * s, t[n + 3] = 255;
        }
        return t;
    }
    _convertYcckToRgb(e1) {
        return this._convertYcckToCmyk(e1), this._convertCmykToRgb(e1);
    }
    _convertYcckToRgba(e1) {
        return this._convertYcckToCmyk(e1), this._convertCmykToRgba(e1);
    }
    _convertYcckToCmyk(e1) {
        let t, i, n;
        for(let a = 0, s = e1.length; a < s; a += 4)t = e1[a], i = e1[a + 1], n = e1[a + 2], e1[a] = 434.456 - t - 1.402 * n, e1[a + 1] = 119.541 - t + .344 * i + .714 * n, e1[a + 2] = 481.816 - t - 1.772 * i;
        return e1;
    }
    _convertCmykToRgb(e1) {
        const t = e1.length / 4;
        return ColorSpaceUtils.cmyk.getRgbBuffer(e1, 0, t, e1, 0, 8, 0), e1.subarray(0, 3 * t);
    }
    _convertCmykToRgba(e1) {
        if (ColorSpaceUtils.cmyk.getRgbBuffer(e1, 0, e1.length / 4, e1, 0, 8, 1), ColorSpaceUtils.cmyk instanceof DeviceCmykCS) for(let t = 3, i = e1.length; t < i; t += 4)e1[t] = 255;
        return e1;
    }
    getData({ width: e1, height: t, forceRGBA: i = !1, forceRGB: n = !1, isSourcePDF: a = !1 }) {
        if (this.numComponents > 4) throw new JpegError("Unsupported color mode");
        const s = this._getLinearizedBlockData(e1, t, a);
        if (1 === this.numComponents && (i || n)) {
            const e1 = s.length * (i ? 4 : 3), t = new Uint8ClampedArray(e1);
            let n = 0;
            if (i) !function(e1, t) {
                if (FeatureTest.isLittleEndian) for(let i = 0, n = e1.length; i < n; i++)t[i] = 65793 * e1[i] | 4278190080;
                else for(let i = 0, n = e1.length; i < n; i++)t[i] = 16843008 * e1[i] | 255;
            }(s, new Uint32Array(t.buffer));
            else for (const e1 of s)t[n++] = e1, t[n++] = e1, t[n++] = e1;
            return t;
        }
        if (3 === this.numComponents && this._isColorConversionNeeded) {
            if (i) {
                const e1 = new Uint8ClampedArray(s.length / 3 * 4);
                return this._convertYccToRgba(s, e1);
            }
            return this._convertYccToRgb(s);
        }
        if (4 === this.numComponents) {
            if (this._isColorConversionNeeded) return i ? this._convertYcckToRgba(s) : n ? this._convertYcckToRgb(s) : this._convertYcckToCmyk(s);
            if (i) return this._convertCmykToRgba(s);
            if (n) return this._convertCmykToRgb(s);
        }
        return s;
    }
}
class JpegStream extends DecodeStream {
    static #M = FeatureTest.isImageDecoderSupported;
    constructor(e1, t, i){
        super(t), this.stream = e1, this.dict = e1.dict, this.maybeLength = t, this.params = i;
    }
    static get canUseImageDecoder() {
        return shadow$1(this, "canUseImageDecoder", this.#M ? ImageDecoder.isTypeSupported("image/jpeg") : Promise.resolve(!1));
    }
    static setOptions({ isImageDecoderSupported: e1 = !1 }) {
        this.#M = e1;
    }
    get bytes() {
        return shadow$1(this, "bytes", this.stream.getBytes(this.maybeLength));
    }
    ensureBuffer(e1) {}
    readBlock() {
        this.decodeImage();
    }
    get jpegOptions() {
        const e1 = {
            decodeTransform: void 0,
            colorTransform: void 0
        }, t = this.dict.getArray("D", "Decode");
        if ((this.forceRGBA || this.forceRGB) && Array.isArray(t)) {
            const i = this.dict.get("BPC", "BitsPerComponent") || 8, n = t.length, a = new Int32Array(n);
            let s = !1;
            const r = (1 << i) - 1;
            for(let e1 = 0; e1 < n; e1 += 2)a[e1] = 256 * (t[e1 + 1] - t[e1]) | 0, a[e1 + 1] = t[e1] * r | 0, 256 === a[e1] && 0 === a[e1 + 1] || (s = !0);
            s && (e1.decodeTransform = a);
        }
        if (this.params instanceof Dict) {
            const t = this.params.get("ColorTransform");
            Number.isInteger(t) && (e1.colorTransform = t);
        }
        return shadow$1(this, "jpegOptions", e1);
    }
    #P(e1) {
        for(let t = 0, i = e1.length - 1; t < i; t++)if (255 === e1[t] && 216 === e1[t + 1]) {
            t > 0 && (e1 = e1.subarray(t));
            break;
        }
        return e1;
    }
    decodeImage(e1) {
        if (this.eof) return this.buffer;
        e1 = this.#P(e1 || this.bytes);
        const t = new JpegImage(this.jpegOptions);
        t.parse(e1);
        const i = t.getData({
            width: this.drawWidth,
            height: this.drawHeight,
            forceRGBA: this.forceRGBA,
            forceRGB: this.forceRGB,
            isSourcePDF: !0
        });
        return this.buffer = i, this.bufferLength = i.length, this.eof = !0, this.buffer;
    }
    get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
    }
    async getTransferableImage() {
        if (!await JpegStream.canUseImageDecoder) return null;
        const e1 = this.jpegOptions;
        if (e1.decodeTransform) return null;
        let t;
        try {
            const i = this.canAsyncDecodeImageFromBuffer && await this.stream.asyncGetBytes() || this.bytes;
            if (!i) return null;
            let n = this.#P(i);
            const a = JpegImage.canUseImageDecoder(n, e1.colorTransform);
            return a ? (a.exifStart && (n = n.slice(), n.fill(0, a.exifStart, a.exifEnd)), t = new ImageDecoder({
                data: n,
                type: "image/jpeg",
                preferAnimation: !1
            }), (await t.decode()).image) : null;
        } catch (e1) {
            return warn$1(`getTransferableImage - failed: "${e1}".`), null;
        } finally{
            t?.close();
        }
    }
}
class JpxError extends Yt {
    constructor(e1){
        super(e1, "JpxError");
    }
}
class JpxImage {
    static #R = null;
    static #B = null;
    static #N = null;
    static #k = !0;
    static #L = !0;
    static #T = null;
    static setOptions({ handler: e1, useWasm: t, useWorkerFetch: i, wasmUrl: n }) {
        this.#k = t, this.#L = i, this.#T = n, i || (this.#B = e1);
    }
    static async #U(e1) {}
    static async #j(e1, t, i) {}
    static async decode(e1, { numComponents: t = 4, isIndexedColormap: i = !1, smaskInData: n = !1, reducePower: a = 0 } = {}) {
        const s = await this.#N;
        if (!s) throw new JpxError("OpenJPEG failed to initialize");
        let r;
        try {
            const o = e1.length;
            r = s._malloc(o), s.writeArrayToMemory(e1, r);
            if (s._jp2_decode(r, o, t > 0 ? t : 0, !!i, !!n, a)) {
                const { errorMessages: e1 } = s;
                if (e1) throw delete s.errorMessages, new JpxError(e1);
                throw new JpxError("Unknown error");
            }
            const { imageData: l } = s;
            return s.imageData = null, l;
        } finally{
            r && s._free(r);
        }
    }
    static cleanup() {
        this.#N = null;
    }
    static parseImageProperties(e1) {
        let t = e1.getByte();
        for(; t >= 0;){
            const i = t;
            t = e1.getByte();
            if (65361 === (i << 8 | t)) {
                e1.skip(4);
                const t = e1.getInt32() >>> 0, i = e1.getInt32() >>> 0, n = e1.getInt32() >>> 0, a = e1.getInt32() >>> 0;
                e1.skip(16);
                return {
                    width: t - n,
                    height: i - a,
                    bitsPerComponent: 8,
                    componentsCount: e1.getUint16()
                };
            }
        }
        throw new JpxError("No size marker found in JPX stream");
    }
}
function addState(e1, t, i, n, a) {
    let s = e1;
    for(let e1 = 0, i = t.length - 1; e1 < i; e1++){
        const i = t[e1];
        s = s[i] ||= [];
    }
    s[t.at(-1)] = {
        checkFn: i,
        iterateFn: n,
        processFn: a
    };
}
const Bi = [];
addState(Bi, [
    pe,
    be,
    Pt,
    me
], null, function(e1, t) {
    const i = e1.fnArray, n = (t - (e1.iCurr - 3)) % 4;
    switch(n){
        case 0:
            return i[t] === pe;
        case 1:
            return i[t] === be;
        case 2:
            return i[t] === Pt;
        case 3:
            return i[t] === me;
    }
    throw new Error(`iterateInlineImageGroup - invalid pos: ${n}`);
}, function(e1, t) {
    const i = e1.fnArray, n = e1.argsArray, a = e1.iCurr, s = a - 3, r = a - 2, o = a - 1, l = Math.min(Math.floor((t - s) / 4), 200);
    if (l < 10) return t - (t - s) % 4;
    let c = 0;
    const h = [];
    let d = 0, u = 1, g = 1;
    for(let e1 = 0; e1 < l; e1++){
        const t = n[r + (e1 << 2)], i = n[o + (e1 << 2)][0];
        u + i.width > 1e3 && (c = Math.max(c, u), g += d + 2, u = 0, d = 0), h.push({
            transform: t,
            x: u,
            y: g,
            w: i.width,
            h: i.height
        }), u += i.width + 2, d = Math.max(d, i.height);
    }
    const f = Math.max(c, u) + 1, p = g + d + 1, m = new Uint8Array(f * p * 4), b = f << 2;
    for(let e1 = 0; e1 < l; e1++){
        const t = n[o + (e1 << 2)][0].data, i = h[e1].w << 2;
        let a = 0, s = h[e1].x + h[e1].y * f << 2;
        m.set(t.subarray(0, i), s - b);
        for(let n = 0, r = h[e1].h; n < r; n++)m.set(t.subarray(a, a + i), s), a += i, s += b;
        for(m.set(t.subarray(a - i, a), s); s >= 0;)t[s - 4] = t[s], t[s - 3] = t[s + 1], t[s - 2] = t[s + 2], t[s - 1] = t[s + 3], t[s + i] = t[s + i - 4], t[s + i + 1] = t[s + i - 3], t[s + i + 2] = t[s + i - 2], t[s + i + 3] = t[s + i - 1], s -= b;
    }
    const y = {
        width: f,
        height: p
    };
    if (e1.isOffscreenCanvasSupported) {
        const e1 = new OffscreenCanvas(f, p);
        e1.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(m.buffer), f, p), 0, 0), y.bitmap = e1.transferToImageBitmap(), y.data = null;
    } else y.kind = k, y.data = m;
    return i.splice(s, 4 * l, Rt), n.splice(s, 4 * l, [
        y,
        h
    ]), s + 1;
}), addState(Bi, [
    pe,
    be,
    Dt,
    me
], null, function(e1, t) {
    const i = e1.fnArray, n = (t - (e1.iCurr - 3)) % 4;
    switch(n){
        case 0:
            return i[t] === pe;
        case 1:
            return i[t] === be;
        case 2:
            return i[t] === Dt;
        case 3:
            return i[t] === me;
    }
    throw new Error(`iterateImageMaskGroup - invalid pos: ${n}`);
}, function(e1, t) {
    const i = e1.fnArray, n = e1.argsArray, a = e1.iCurr, s = a - 3, r = a - 2, o = a - 1;
    let l = Math.floor((t - s) / 4);
    if (l < 10) return t - (t - s) % 4;
    let c, h, d = !1;
    const u = n[o][0], g = n[r][0], f = n[r][1], p = n[r][2], m = n[r][3];
    if (f === p) {
        d = !0, c = r + 4;
        let e1 = o + 4;
        for(let t = 1; t < l; t++, c += 4, e1 += 4)if (h = n[c], n[e1][0] !== u || h[0] !== g || h[1] !== f || h[2] !== p || h[3] !== m) {
            t < 10 ? d = !1 : l = t;
            break;
        }
    }
    if (d) {
        l = Math.min(l, 1e3);
        const e1 = new Float32Array(2 * l);
        c = r;
        for(let t = 0; t < l; t++, c += 4)h = n[c], e1[t << 1] = h[4], e1[1 + (t << 1)] = h[5];
        i.splice(s, 4 * l, Nt), n.splice(s, 4 * l, [
            u,
            g,
            f,
            p,
            m,
            e1
        ]);
    } else {
        l = Math.min(l, 100);
        const e1 = [];
        for(let t = 0; t < l; t++){
            h = n[r + (t << 2)];
            const i = n[o + (t << 2)][0];
            e1.push({
                data: i.data,
                width: i.width,
                height: i.height,
                interpolate: i.interpolate,
                count: i.count,
                transform: h
            });
        }
        i.splice(s, 4 * l, Ot), n.splice(s, 4 * l, [
            e1
        ]);
    }
    return s + 1;
}), addState(Bi, [
    pe,
    be,
    _t,
    me
], function(e1) {
    const t = e1.argsArray, i = e1.iCurr - 2;
    return 0 === t[i][1] && 0 === t[i][2];
}, function(e1, t) {
    const i = e1.fnArray, n = e1.argsArray, a = (t - (e1.iCurr - 3)) % 4;
    switch(a){
        case 0:
            return i[t] === pe;
        case 1:
            if (i[t] !== be) return !1;
            const a1 = e1.iCurr - 2, s = n[a1][0], r = n[a1][3];
            return n[t][0] === s && 0 === n[t][1] && 0 === n[t][2] && n[t][3] === r;
        case 2:
            if (i[t] !== _t) return !1;
            const o = n[e1.iCurr - 1][0];
            return n[t][0] === o;
        case 3:
            return i[t] === me;
    }
    throw new Error(`iterateImageGroup - invalid pos: ${a}`);
}, function(e1, t) {
    const i = e1.fnArray, n = e1.argsArray, a = e1.iCurr, s = a - 3, r = a - 2, o = n[a - 1][0], l = n[r][0], c = n[r][3], h = Math.min(Math.floor((t - s) / 4), 1e3);
    if (h < 3) return t - (t - s) % 4;
    const d = new Float32Array(2 * h);
    let u = r;
    for(let e1 = 0; e1 < h; e1++, u += 4){
        const t = n[u];
        d[e1 << 1] = t[4], d[1 + (e1 << 1)] = t[5];
    }
    const g = [
        o,
        l,
        c,
        d
    ];
    return i.splice(s, 4 * h, Bt), n.splice(s, 4 * h, g), s + 1;
}), addState(Bi, [
    Be,
    He,
    Ge,
    Ke,
    Ne
], null, function(e1, t) {
    const i = e1.fnArray, n = e1.argsArray, a = (t - (e1.iCurr - 4)) % 5;
    switch(a){
        case 0:
            return i[t] === Be;
        case 1:
            return i[t] === He;
        case 2:
            return i[t] === Ge;
        case 3:
            if (i[t] !== Ke) return !1;
            const a1 = e1.iCurr - 3, s = n[a1][0], r = n[a1][1];
            return n[t][0] === s && n[t][1] === r;
        case 4:
            return i[t] === Ne;
    }
    throw new Error(`iterateShowTextGroup - invalid pos: ${a}`);
}, function(e1, t) {
    const i = e1.fnArray, n = e1.argsArray, a = e1.iCurr, s = a - 4, r = a - 3, o = a - 2, l = a - 1, c = a, h = n[r][0], d = n[r][1];
    let u = Math.min(Math.floor((t - s) / 5), 1e3);
    if (u < 3) return t - (t - s) % 5;
    let g = s;
    s >= 4 && i[s - 4] === i[r] && i[s - 3] === i[o] && i[s - 2] === i[l] && i[s - 1] === i[c] && n[s - 4][0] === h && n[s - 4][1] === d && (u++, g -= 5);
    let f = g + 4;
    for(let e1 = 1; e1 < u; e1++)i.splice(f, 3), n.splice(f, 3), f += 2;
    return f + 1;
}), addState(Bi, [
    pe,
    be,
    Ut,
    me
], (e1)=>{
    const t = e1.argsArray, i = t[e1.iCurr - 1][0];
    if (i !== ke && i !== Te && i !== Ee && i !== Me && i !== De && i !== Oe) return !0;
    const n = t[e1.iCurr - 2];
    return 1 === n[0] && 0 === n[1] && 0 === n[2] && 1 === n[3];
}, ()=>!1, (e1, t)=>{
    const { fnArray: i, argsArray: n } = e1, a = e1.iCurr, s = a - 3, r = a - 2, o = n[a - 1], l = n[r], [, [c], h] = o;
    if (h) {
        ai.scaleMinMax(l, h);
        for(let e1 = 0, t = c.length; e1 < t;)switch(c[e1++]){
            case Xt:
            case qt:
                ai.applyTransform(c, l, e1), e1 += 2;
                break;
            case zt:
                ai.applyTransformToBezier(c, l, e1), e1 += 6;
        }
    }
    return i.splice(s, 4, Ut), n.splice(s, 4, o), s + 1;
});
class NullOptimizer {
    constructor(e1){
        this.queue = e1;
    }
    _optimize() {}
    push(e1, t) {
        this.queue.fnArray.push(e1), this.queue.argsArray.push(t), this._optimize();
    }
    flush() {}
    reset() {}
}
class QueueOptimizer extends NullOptimizer {
    constructor(e1){
        super(e1), this.state = null, this.context = {
            iCurr: 0,
            fnArray: e1.fnArray,
            argsArray: e1.argsArray,
            isOffscreenCanvasSupported: OperatorList.isOffscreenCanvasSupported
        }, this.match = null, this.lastProcessed = 0;
    }
    _optimize() {
        const e1 = this.queue.fnArray;
        let t = this.lastProcessed, i = e1.length, n = this.state, a = this.match;
        if (!n && !a && t + 1 === i && !Bi[e1[t]]) return void (this.lastProcessed = i);
        const s = this.context;
        for(; t < i;){
            if (a) {
                if ((0, a.iterateFn)(s, t)) {
                    t++;
                    continue;
                }
                if (t = (0, a.processFn)(s, t + 1), i = e1.length, a = null, n = null, t >= i) break;
            }
            n = (n || Bi)[e1[t]], n && !Array.isArray(n) ? (s.iCurr = t, t++, !n.checkFn || (0, n.checkFn)(s) ? (a = n, n = null) : n = null) : t++;
        }
        this.state = n, this.match = a, this.lastProcessed = t;
    }
    flush() {
        for(; this.match;){
            const e1 = this.queue.fnArray.length;
            this.lastProcessed = (0, this.match.processFn)(this.context, e1), this.match = null, this.state = null, this._optimize();
        }
    }
    reset() {
        this.state = null, this.match = null, this.lastProcessed = 0;
    }
}
class OperatorList {
    static CHUNK_SIZE = 1e3;
    static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;
    static isOffscreenCanvasSupported = !1;
    constructor(e1 = 0, t){
        this._streamSink = t, this.fnArray = [], this.argsArray = [], this.optimizer = !t || e1 & u ? new NullOptimizer(this) : new QueueOptimizer(this), this.dependencies = new Set, this._totalLength = 0, this.weight = 0, this._resolved = t ? null : Promise.resolve();
    }
    static setOptions({ isOffscreenCanvasSupported: e1 }) {
        this.isOffscreenCanvasSupported = e1;
    }
    get length() {
        return this.argsArray.length;
    }
    get ready() {
        return this._resolved || this._streamSink.ready;
    }
    get totalLength() {
        return this._totalLength + this.length;
    }
    addOp(e1, t) {
        this.optimizer.push(e1, t), this.weight++, this._streamSink && (this.weight >= OperatorList.CHUNK_SIZE || this.weight >= OperatorList.CHUNK_SIZE_ABOUT && (e1 === me || e1 === Ne)) && this.flush();
    }
    addImageOps(e1, t, i, n = !1) {
        n && (this.addOp(pe), this.addOp(fe, [
            [
                [
                    "SMask",
                    !1
                ]
            ]
        ])), void 0 !== i && this.addOp(xt, [
            "OC",
            i
        ]), this.addOp(e1, t), void 0 !== i && this.addOp(St, []), n && this.addOp(me);
    }
    addDependency(e1) {
        this.dependencies.has(e1) || (this.dependencies.add(e1), this.addOp(re, [
            e1
        ]));
    }
    addDependencies(e1) {
        for (const t of e1)this.addDependency(t);
    }
    addOpList(e1) {
        if (e1 instanceof OperatorList) {
            for (const t of e1.dependencies)this.dependencies.add(t);
            for(let t = 0, i = e1.length; t < i; t++)this.addOp(e1.fnArray[t], e1.argsArray[t]);
        } else warn$1('addOpList - ignoring invalid "opList" parameter.');
    }
    getIR() {
        return {
            fnArray: this.fnArray,
            argsArray: this.argsArray,
            length: this.length
        };
    }
    get _transfers() {
        const e1 = [], { fnArray: t, argsArray: i, length: n } = this;
        for(let a = 0; a < n; a++)switch(t[a]){
            case Pt:
            case Rt:
            case Dt:
                {
                    const { bitmap: t, data: n } = i[a][0];
                    (t || n?.buffer) && e1.push(t || n.buffer);
                    break;
                }
            case Ut:
                {
                    const [, [t], n] = i[a];
                    t && e1.push(t.buffer, n.buffer);
                    break;
                }
            case kt:
                const [t1, n] = i[a];
                t1 && e1.push(t1.buffer), n && e1.push(n.buffer);
                break;
            case Ge:
                e1.push(i[a][0].buffer);
        }
        return e1;
    }
    flush(e1 = !1, t = null) {
        this.optimizer.flush();
        const i = this.length;
        this._totalLength += i, this._streamSink.enqueue({
            fnArray: this.fnArray,
            argsArray: this.argsArray,
            lastChunk: e1,
            separateAnnots: t,
            length: i
        }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
    }
}
function hexToInt(e1, t) {
    let i = 0;
    for(let n = 0; n <= t; n++)i = i << 8 | e1[n];
    return i >>> 0;
}
function hexToStr(e1, t) {
    return 1 === t ? String.fromCharCode(e1[0], e1[1]) : 3 === t ? String.fromCharCode(e1[0], e1[1], e1[2], e1[3]) : String.fromCharCode(...e1.subarray(0, t + 1));
}
function addHex(e1, t, i) {
    let n = 0;
    for(let a = i; a >= 0; a--)n += e1[a] + t[a], e1[a] = 255 & n, n >>= 8;
}
function incHex(e1, t) {
    let i = 1;
    for(let n = t; n >= 0 && i > 0; n--)i += e1[n], e1[n] = 255 & i, i >>= 8;
}
const Ni = 16;
class BinaryCMapStream {
    constructor(e1){
        this.buffer = e1, this.pos = 0, this.end = e1.length, this.tmpBuf = new Uint8Array(19);
    }
    readByte() {
        return this.pos >= this.end ? -1 : this.buffer[this.pos++];
    }
    readNumber() {
        let e1, t = 0;
        do {
            const i = this.readByte();
            if (i < 0) throw new ti("unexpected EOF in bcmap");
            e1 = !(128 & i), t = t << 7 | 127 & i;
        }while (!e1)
        return t;
    }
    readSigned() {
        const e1 = this.readNumber();
        return 1 & e1 ? ~(e1 >>> 1) : e1 >>> 1;
    }
    readHex(e1, t) {
        e1.set(this.buffer.subarray(this.pos, this.pos + t + 1)), this.pos += t + 1;
    }
    readHexNumber(e1, t) {
        let i;
        const n = this.tmpBuf;
        let a = 0;
        do {
            const e1 = this.readByte();
            if (e1 < 0) throw new ti("unexpected EOF in bcmap");
            i = !(128 & e1), n[a++] = 127 & e1;
        }while (!i)
        let s = t, r = 0, o = 0;
        for(; s >= 0;){
            for(; o < 8 && n.length > 0;)r |= n[--a] << o, o += 7;
            e1[s] = 255 & r, s--, r >>= 8, o -= 8;
        }
    }
    readHexSigned(e1, t) {
        this.readHexNumber(e1, t);
        const i = 1 & e1[t] ? 255 : 0;
        let n = 0;
        for(let a = 0; a <= t; a++)n = (1 & n) << 8 | e1[a], e1[a] = n >> 1 ^ i;
    }
    readString() {
        const e1 = this.readNumber(), t = new Array(e1);
        for(let i = 0; i < e1; i++)t[i] = this.readNumber();
        return String.fromCharCode(...t);
    }
}
class BinaryCMapReader {
    async process(e1, t, i) {
        const n = new BinaryCMapStream(e1), a = n.readByte();
        t.vertical = !!(1 & a);
        let s = null;
        const r = new Uint8Array(Ni), o = new Uint8Array(Ni), l = new Uint8Array(Ni), c = new Uint8Array(Ni), h = new Uint8Array(Ni);
        let d, u;
        for(; (u = n.readByte()) >= 0;){
            const e1 = u >> 5;
            if (7 === e1) {
                switch(31 & u){
                    case 0:
                        n.readString();
                        break;
                    case 1:
                        s = n.readString();
                }
                continue;
            }
            const i = !!(16 & u), a = 15 & u;
            if (a + 1 > Ni) throw new Error("BinaryCMapReader.process: Invalid dataSize.");
            const g = 1, f = n.readNumber();
            switch(e1){
                case 0:
                    n.readHex(r, a), n.readHexNumber(o, a), addHex(o, r, a), t.addCodespaceRange(a + 1, hexToInt(r, a), hexToInt(o, a));
                    for(let e1 = 1; e1 < f; e1++)incHex(o, a), n.readHexNumber(r, a), addHex(r, o, a), n.readHexNumber(o, a), addHex(o, r, a), t.addCodespaceRange(a + 1, hexToInt(r, a), hexToInt(o, a));
                    break;
                case 1:
                    n.readHex(r, a), n.readHexNumber(o, a), addHex(o, r, a), n.readNumber();
                    for(let e1 = 1; e1 < f; e1++)incHex(o, a), n.readHexNumber(r, a), addHex(r, o, a), n.readHexNumber(o, a), addHex(o, r, a), n.readNumber();
                    break;
                case 2:
                    n.readHex(l, a), d = n.readNumber(), t.mapOne(hexToInt(l, a), d);
                    for(let e1 = 1; e1 < f; e1++)incHex(l, a), i || (n.readHexNumber(h, a), addHex(l, h, a)), d = n.readSigned() + (d + 1), t.mapOne(hexToInt(l, a), d);
                    break;
                case 3:
                    n.readHex(r, a), n.readHexNumber(o, a), addHex(o, r, a), d = n.readNumber(), t.mapCidRange(hexToInt(r, a), hexToInt(o, a), d);
                    for(let e1 = 1; e1 < f; e1++)incHex(o, a), i ? r.set(o) : (n.readHexNumber(r, a), addHex(r, o, a)), n.readHexNumber(o, a), addHex(o, r, a), d = n.readNumber(), t.mapCidRange(hexToInt(r, a), hexToInt(o, a), d);
                    break;
                case 4:
                    n.readHex(l, g), n.readHex(c, a), t.mapOne(hexToInt(l, g), hexToStr(c, a));
                    for(let e1 = 1; e1 < f; e1++)incHex(l, g), i || (n.readHexNumber(h, g), addHex(l, h, g)), incHex(c, a), n.readHexSigned(h, a), addHex(c, h, a), t.mapOne(hexToInt(l, g), hexToStr(c, a));
                    break;
                case 5:
                    n.readHex(r, g), n.readHexNumber(o, g), addHex(o, r, g), n.readHex(c, a), t.mapBfRange(hexToInt(r, g), hexToInt(o, g), hexToStr(c, a));
                    for(let e1 = 1; e1 < f; e1++)incHex(o, g), i ? r.set(o) : (n.readHexNumber(r, g), addHex(r, o, g)), n.readHexNumber(o, g), addHex(o, r, g), n.readHex(c, a), t.mapBfRange(hexToInt(r, g), hexToInt(o, g), hexToStr(c, a));
                    break;
                default:
                    throw new Error(`BinaryCMapReader.process - unknown type: ${e1}`);
            }
        }
        return s ? i(s) : t;
    }
}
class Ascii85Stream extends DecodeStream {
    constructor(e1, t){
        t && (t *= .8), super(t), this.str = e1, this.dict = e1.dict, this.input = new Uint8Array(5);
    }
    readBlock() {
        const e1 = this.str;
        let t = e1.getByte();
        for(; isWhiteSpace(t);)t = e1.getByte();
        if (-1 === t || 126 === t) return void (this.eof = !0);
        const i = this.bufferLength;
        let n, a;
        if (122 === t) {
            for(n = this.ensureBuffer(i + 4), a = 0; a < 4; ++a)n[i + a] = 0;
            this.bufferLength += 4;
        } else {
            const s = this.input;
            for(s[0] = t, a = 1; a < 5; ++a){
                for(t = e1.getByte(); isWhiteSpace(t);)t = e1.getByte();
                if (s[a] = t, -1 === t || 126 === t) break;
            }
            if (n = this.ensureBuffer(i + a - 1), this.bufferLength += a - 1, a < 5) {
                for(; a < 5; ++a)s[a] = 117;
                this.eof = !0;
            }
            let r = 0;
            for(a = 0; a < 5; ++a)r = 85 * r + (s[a] - 33);
            for(a = 3; a >= 0; --a)n[i + a] = 255 & r, r >>= 8;
        }
    }
}
class AsciiHexStream extends DecodeStream {
    constructor(e1, t){
        t && (t *= .5), super(t), this.str = e1, this.dict = e1.dict, this.firstDigit = -1;
    }
    readBlock() {
        const e1 = this.str.getBytes(8e3);
        if (!e1.length) return void (this.eof = !0);
        const t = e1.length + 1 >> 1, i = this.ensureBuffer(this.bufferLength + t);
        let n = this.bufferLength, a = this.firstDigit;
        for (const t of e1){
            let e1;
            if (t >= 48 && t <= 57) e1 = 15 & t;
            else {
                if (!(t >= 65 && t <= 70 || t >= 97 && t <= 102)) {
                    if (62 === t) {
                        this.eof = !0;
                        break;
                    }
                    continue;
                }
                e1 = 9 + (15 & t);
            }
            a < 0 ? a = e1 : (i[n++] = a << 4 | e1, a = -1);
        }
        a >= 0 && this.eof && (i[n++] = a << 4, a = -1), this.firstDigit = a, this.bufferLength = n;
    }
}
const ji = -1, $i = [
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        7,
        8
    ],
    [
        7,
        7
    ],
    [
        6,
        6
    ],
    [
        6,
        6
    ],
    [
        6,
        5
    ],
    [
        6,
        5
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ]
], Hi = [
    [
        -1,
        -1
    ],
    [
        12,
        -2
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        11,
        1792
    ],
    [
        11,
        1792
    ],
    [
        12,
        1984
    ],
    [
        12,
        2048
    ],
    [
        12,
        2112
    ],
    [
        12,
        2176
    ],
    [
        12,
        2240
    ],
    [
        12,
        2304
    ],
    [
        11,
        1856
    ],
    [
        11,
        1856
    ],
    [
        11,
        1920
    ],
    [
        11,
        1920
    ],
    [
        12,
        2368
    ],
    [
        12,
        2432
    ],
    [
        12,
        2496
    ],
    [
        12,
        2560
    ]
], Xi = [
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        8,
        29
    ],
    [
        8,
        29
    ],
    [
        8,
        30
    ],
    [
        8,
        30
    ],
    [
        8,
        45
    ],
    [
        8,
        45
    ],
    [
        8,
        46
    ],
    [
        8,
        46
    ],
    [
        7,
        22
    ],
    [
        7,
        22
    ],
    [
        7,
        22
    ],
    [
        7,
        22
    ],
    [
        7,
        23
    ],
    [
        7,
        23
    ],
    [
        7,
        23
    ],
    [
        7,
        23
    ],
    [
        8,
        47
    ],
    [
        8,
        47
    ],
    [
        8,
        48
    ],
    [
        8,
        48
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        7,
        20
    ],
    [
        7,
        20
    ],
    [
        7,
        20
    ],
    [
        7,
        20
    ],
    [
        8,
        33
    ],
    [
        8,
        33
    ],
    [
        8,
        34
    ],
    [
        8,
        34
    ],
    [
        8,
        35
    ],
    [
        8,
        35
    ],
    [
        8,
        36
    ],
    [
        8,
        36
    ],
    [
        8,
        37
    ],
    [
        8,
        37
    ],
    [
        8,
        38
    ],
    [
        8,
        38
    ],
    [
        7,
        19
    ],
    [
        7,
        19
    ],
    [
        7,
        19
    ],
    [
        7,
        19
    ],
    [
        8,
        31
    ],
    [
        8,
        31
    ],
    [
        8,
        32
    ],
    [
        8,
        32
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        8,
        53
    ],
    [
        8,
        53
    ],
    [
        8,
        54
    ],
    [
        8,
        54
    ],
    [
        7,
        26
    ],
    [
        7,
        26
    ],
    [
        7,
        26
    ],
    [
        7,
        26
    ],
    [
        8,
        39
    ],
    [
        8,
        39
    ],
    [
        8,
        40
    ],
    [
        8,
        40
    ],
    [
        8,
        41
    ],
    [
        8,
        41
    ],
    [
        8,
        42
    ],
    [
        8,
        42
    ],
    [
        8,
        43
    ],
    [
        8,
        43
    ],
    [
        8,
        44
    ],
    [
        8,
        44
    ],
    [
        7,
        21
    ],
    [
        7,
        21
    ],
    [
        7,
        21
    ],
    [
        7,
        21
    ],
    [
        7,
        28
    ],
    [
        7,
        28
    ],
    [
        7,
        28
    ],
    [
        7,
        28
    ],
    [
        8,
        61
    ],
    [
        8,
        61
    ],
    [
        8,
        62
    ],
    [
        8,
        62
    ],
    [
        8,
        63
    ],
    [
        8,
        63
    ],
    [
        8,
        0
    ],
    [
        8,
        0
    ],
    [
        8,
        320
    ],
    [
        8,
        320
    ],
    [
        8,
        384
    ],
    [
        8,
        384
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        7,
        27
    ],
    [
        7,
        27
    ],
    [
        7,
        27
    ],
    [
        7,
        27
    ],
    [
        8,
        59
    ],
    [
        8,
        59
    ],
    [
        8,
        60
    ],
    [
        8,
        60
    ],
    [
        9,
        1472
    ],
    [
        9,
        1536
    ],
    [
        9,
        1600
    ],
    [
        9,
        1728
    ],
    [
        7,
        18
    ],
    [
        7,
        18
    ],
    [
        7,
        18
    ],
    [
        7,
        18
    ],
    [
        7,
        24
    ],
    [
        7,
        24
    ],
    [
        7,
        24
    ],
    [
        7,
        24
    ],
    [
        8,
        49
    ],
    [
        8,
        49
    ],
    [
        8,
        50
    ],
    [
        8,
        50
    ],
    [
        8,
        51
    ],
    [
        8,
        51
    ],
    [
        8,
        52
    ],
    [
        8,
        52
    ],
    [
        7,
        25
    ],
    [
        7,
        25
    ],
    [
        7,
        25
    ],
    [
        7,
        25
    ],
    [
        8,
        55
    ],
    [
        8,
        55
    ],
    [
        8,
        56
    ],
    [
        8,
        56
    ],
    [
        8,
        57
    ],
    [
        8,
        57
    ],
    [
        8,
        58
    ],
    [
        8,
        58
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        8,
        448
    ],
    [
        8,
        448
    ],
    [
        8,
        512
    ],
    [
        8,
        512
    ],
    [
        9,
        704
    ],
    [
        9,
        768
    ],
    [
        8,
        640
    ],
    [
        8,
        640
    ],
    [
        8,
        576
    ],
    [
        8,
        576
    ],
    [
        9,
        832
    ],
    [
        9,
        896
    ],
    [
        9,
        960
    ],
    [
        9,
        1024
    ],
    [
        9,
        1088
    ],
    [
        9,
        1152
    ],
    [
        9,
        1216
    ],
    [
        9,
        1280
    ],
    [
        9,
        1344
    ],
    [
        9,
        1408
    ],
    [
        7,
        256
    ],
    [
        7,
        256
    ],
    [
        7,
        256
    ],
    [
        7,
        256
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ]
], qi = [
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        12,
        -2
    ],
    [
        12,
        -2
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        11,
        1792
    ],
    [
        11,
        1792
    ],
    [
        11,
        1792
    ],
    [
        11,
        1792
    ],
    [
        12,
        1984
    ],
    [
        12,
        1984
    ],
    [
        12,
        2048
    ],
    [
        12,
        2048
    ],
    [
        12,
        2112
    ],
    [
        12,
        2112
    ],
    [
        12,
        2176
    ],
    [
        12,
        2176
    ],
    [
        12,
        2240
    ],
    [
        12,
        2240
    ],
    [
        12,
        2304
    ],
    [
        12,
        2304
    ],
    [
        11,
        1856
    ],
    [
        11,
        1856
    ],
    [
        11,
        1856
    ],
    [
        11,
        1856
    ],
    [
        11,
        1920
    ],
    [
        11,
        1920
    ],
    [
        11,
        1920
    ],
    [
        11,
        1920
    ],
    [
        12,
        2368
    ],
    [
        12,
        2368
    ],
    [
        12,
        2432
    ],
    [
        12,
        2432
    ],
    [
        12,
        2496
    ],
    [
        12,
        2496
    ],
    [
        12,
        2560
    ],
    [
        12,
        2560
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        12,
        52
    ],
    [
        12,
        52
    ],
    [
        13,
        640
    ],
    [
        13,
        704
    ],
    [
        13,
        768
    ],
    [
        13,
        832
    ],
    [
        12,
        55
    ],
    [
        12,
        55
    ],
    [
        12,
        56
    ],
    [
        12,
        56
    ],
    [
        13,
        1280
    ],
    [
        13,
        1344
    ],
    [
        13,
        1408
    ],
    [
        13,
        1472
    ],
    [
        12,
        59
    ],
    [
        12,
        59
    ],
    [
        12,
        60
    ],
    [
        12,
        60
    ],
    [
        13,
        1536
    ],
    [
        13,
        1600
    ],
    [
        11,
        24
    ],
    [
        11,
        24
    ],
    [
        11,
        24
    ],
    [
        11,
        24
    ],
    [
        11,
        25
    ],
    [
        11,
        25
    ],
    [
        11,
        25
    ],
    [
        11,
        25
    ],
    [
        13,
        1664
    ],
    [
        13,
        1728
    ],
    [
        12,
        320
    ],
    [
        12,
        320
    ],
    [
        12,
        384
    ],
    [
        12,
        384
    ],
    [
        12,
        448
    ],
    [
        12,
        448
    ],
    [
        13,
        512
    ],
    [
        13,
        576
    ],
    [
        12,
        53
    ],
    [
        12,
        53
    ],
    [
        12,
        54
    ],
    [
        12,
        54
    ],
    [
        13,
        896
    ],
    [
        13,
        960
    ],
    [
        13,
        1024
    ],
    [
        13,
        1088
    ],
    [
        13,
        1152
    ],
    [
        13,
        1216
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ]
], zi = [
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        11,
        23
    ],
    [
        11,
        23
    ],
    [
        12,
        50
    ],
    [
        12,
        51
    ],
    [
        12,
        44
    ],
    [
        12,
        45
    ],
    [
        12,
        46
    ],
    [
        12,
        47
    ],
    [
        12,
        57
    ],
    [
        12,
        58
    ],
    [
        12,
        61
    ],
    [
        12,
        256
    ],
    [
        10,
        16
    ],
    [
        10,
        16
    ],
    [
        10,
        16
    ],
    [
        10,
        16
    ],
    [
        10,
        17
    ],
    [
        10,
        17
    ],
    [
        10,
        17
    ],
    [
        10,
        17
    ],
    [
        12,
        48
    ],
    [
        12,
        49
    ],
    [
        12,
        62
    ],
    [
        12,
        63
    ],
    [
        12,
        30
    ],
    [
        12,
        31
    ],
    [
        12,
        32
    ],
    [
        12,
        33
    ],
    [
        12,
        40
    ],
    [
        12,
        41
    ],
    [
        11,
        22
    ],
    [
        11,
        22
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        12,
        128
    ],
    [
        12,
        192
    ],
    [
        12,
        26
    ],
    [
        12,
        27
    ],
    [
        12,
        28
    ],
    [
        12,
        29
    ],
    [
        11,
        19
    ],
    [
        11,
        19
    ],
    [
        11,
        20
    ],
    [
        11,
        20
    ],
    [
        12,
        34
    ],
    [
        12,
        35
    ],
    [
        12,
        36
    ],
    [
        12,
        37
    ],
    [
        12,
        38
    ],
    [
        12,
        39
    ],
    [
        11,
        21
    ],
    [
        11,
        21
    ],
    [
        12,
        42
    ],
    [
        12,
        43
    ],
    [
        10,
        0
    ],
    [
        10,
        0
    ],
    [
        10,
        0
    ],
    [
        10,
        0
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ]
], Wi = [
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        6,
        9
    ],
    [
        6,
        8
    ],
    [
        5,
        7
    ],
    [
        5,
        7
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ]
];
class CCITTFaxDecoder {
    constructor(e1, t = {}){
        if ("function" != typeof e1?.next) throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
        let i;
        for(this.source = e1, this.eof = !1, this.encoding = t.K || 0, this.eoline = t.EndOfLine || !1, this.byteAlign = t.EncodedByteAlign || !1, this.columns = t.Columns || 1728, this.rows = t.Rows || 0, this.eoblock = t.EndOfBlock ?? !0, this.black = t.BlackIs1 || !1, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = !1; 0 === (i = this._lookBits(12));)this._eatBits(1);
        1 === i && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
    }
    readNextChar() {
        if (this.eof) return -1;
        const e1 = this.refLine, t = this.codingLine, i = this.columns;
        let n, a, s, r, o;
        if (0 === this.outputBits) {
            if (this.rowsDone && (this.eof = !0), this.eof) return -1;
            let s, o, l;
            if (this.err = !1, this.nextLine2D) {
                for(r = 0; t[r] < i; ++r)e1[r] = t[r];
                for(e1[r++] = i, e1[r] = i, t[0] = 0, this.codingPos = 0, n = 0, a = 0; t[this.codingPos] < i;)switch(s = this._getTwoDimCode(), s){
                    case 0:
                        this._addPixels(e1[n + 1], a), e1[n + 1] < i && (n += 2);
                        break;
                    case 1:
                        if (s = o = 0, a) {
                            do {
                                s += l = this._getBlackCode();
                            }while (l >= 64)
                            do {
                                o += l = this._getWhiteCode();
                            }while (l >= 64)
                        } else {
                            do {
                                s += l = this._getWhiteCode();
                            }while (l >= 64)
                            do {
                                o += l = this._getBlackCode();
                            }while (l >= 64)
                        }
                        for(this._addPixels(t[this.codingPos] + s, a), t[this.codingPos] < i && this._addPixels(t[this.codingPos] + o, 1 ^ a); e1[n] <= t[this.codingPos] && e1[n] < i;)n += 2;
                        break;
                    case 7:
                        if (this._addPixels(e1[n] + 3, a), a ^= 1, t[this.codingPos] < i) for(++n; e1[n] <= t[this.codingPos] && e1[n] < i;)n += 2;
                        break;
                    case 5:
                        if (this._addPixels(e1[n] + 2, a), a ^= 1, t[this.codingPos] < i) for(++n; e1[n] <= t[this.codingPos] && e1[n] < i;)n += 2;
                        break;
                    case 3:
                        if (this._addPixels(e1[n] + 1, a), a ^= 1, t[this.codingPos] < i) for(++n; e1[n] <= t[this.codingPos] && e1[n] < i;)n += 2;
                        break;
                    case 2:
                        if (this._addPixels(e1[n], a), a ^= 1, t[this.codingPos] < i) for(++n; e1[n] <= t[this.codingPos] && e1[n] < i;)n += 2;
                        break;
                    case 8:
                        if (this._addPixelsNeg(e1[n] - 3, a), a ^= 1, t[this.codingPos] < i) for(n > 0 ? --n : ++n; e1[n] <= t[this.codingPos] && e1[n] < i;)n += 2;
                        break;
                    case 6:
                        if (this._addPixelsNeg(e1[n] - 2, a), a ^= 1, t[this.codingPos] < i) for(n > 0 ? --n : ++n; e1[n] <= t[this.codingPos] && e1[n] < i;)n += 2;
                        break;
                    case 4:
                        if (this._addPixelsNeg(e1[n] - 1, a), a ^= 1, t[this.codingPos] < i) for(n > 0 ? --n : ++n; e1[n] <= t[this.codingPos] && e1[n] < i;)n += 2;
                        break;
                    case ji:
                        this._addPixels(i, 0), this.eof = !0;
                        break;
                    default:
                        info$1("bad 2d code"), this._addPixels(i, 0), this.err = !0;
                }
            } else for(t[0] = 0, this.codingPos = 0, a = 0; t[this.codingPos] < i;){
                if (s = 0, a) do {
                    s += l = this._getBlackCode();
                }while (l >= 64)
                else do {
                    s += l = this._getWhiteCode();
                }while (l >= 64)
                this._addPixels(t[this.codingPos] + s, a), a ^= 1;
            }
            let c = !1;
            if (this.byteAlign && (this.inputBits &= -8), this.eoblock || this.row !== this.rows - 1) {
                if (s = this._lookBits(12), this.eoline) for(; s !== ji && 1 !== s;)this._eatBits(1), s = this._lookBits(12);
                else for(; 0 === s;)this._eatBits(1), s = this._lookBits(12);
                1 === s ? (this._eatBits(12), c = !0) : s === ji && (this.eof = !0);
            } else this.rowsDone = !0;
            if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && c && this.byteAlign) {
                if (s = this._lookBits(12), 1 === s) {
                    if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0) for(r = 0; r < 4; ++r)s = this._lookBits(12), 1 !== s && info$1("bad rtc code: " + s), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
                    this.eof = !0;
                }
            } else if (this.err && this.eoline) {
                for(;;){
                    if (s = this._lookBits(13), s === ji) return this.eof = !0, -1;
                    if (s >> 1 == 1) break;
                    this._eatBits(1);
                }
                this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(1 & s));
            }
            this.outputBits = t[0] > 0 ? t[this.codingPos = 0] : t[this.codingPos = 1], this.row++;
        }
        if (this.outputBits >= 8) o = 1 & this.codingPos ? 0 : 255, this.outputBits -= 8, 0 === this.outputBits && t[this.codingPos] < i && (this.codingPos++, this.outputBits = t[this.codingPos] - t[this.codingPos - 1]);
        else {
            s = 8, o = 0;
            do {
                if ("number" != typeof this.outputBits) throw new ti('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
                this.outputBits > s ? (o <<= s, 1 & this.codingPos || (o |= 255 >> 8 - s), this.outputBits -= s, s = 0) : (o <<= this.outputBits, 1 & this.codingPos || (o |= 255 >> 8 - this.outputBits), s -= this.outputBits, this.outputBits = 0, t[this.codingPos] < i ? (this.codingPos++, this.outputBits = t[this.codingPos] - t[this.codingPos - 1]) : s > 0 && (o <<= s, s = 0));
            }while (s)
        }
        return this.black && (o ^= 255), o;
    }
    _addPixels(e1, t) {
        const i = this.codingLine;
        let n = this.codingPos;
        e1 > i[n] && (e1 > this.columns && (info$1("row is wrong length"), this.err = !0, e1 = this.columns), 1 & n ^ t && ++n, i[n] = e1), this.codingPos = n;
    }
    _addPixelsNeg(e1, t) {
        const i = this.codingLine;
        let n = this.codingPos;
        if (e1 > i[n]) e1 > this.columns && (info$1("row is wrong length"), this.err = !0, e1 = this.columns), 1 & n ^ t && ++n, i[n] = e1;
        else if (e1 < i[n]) {
            for(e1 < 0 && (info$1("invalid code"), this.err = !0, e1 = 0); n > 0 && e1 < i[n - 1];)--n;
            i[n] = e1;
        }
        this.codingPos = n;
    }
    _findTableCode(e1, t, i, n) {
        const a = n || 0;
        for(let n = e1; n <= t; ++n){
            let e1 = this._lookBits(n);
            if (e1 === ji) return [
                !0,
                1,
                !1
            ];
            if (n < t && (e1 <<= t - n), !a || e1 >= a) {
                const t = i[e1 - a];
                if (t[0] === n) return this._eatBits(n), [
                    !0,
                    t[1],
                    !0
                ];
            }
        }
        return [
            !1,
            0,
            !1
        ];
    }
    _getTwoDimCode() {
        let e1, t = 0;
        if (this.eoblock) {
            if (t = this._lookBits(7), e1 = $i[t], e1?.[0] > 0) return this._eatBits(e1[0]), e1[1];
        } else {
            const e1 = this._findTableCode(1, 7, $i);
            if (e1[0] && e1[2]) return e1[1];
        }
        return info$1("Bad two dim code"), ji;
    }
    _getWhiteCode() {
        let e1, t = 0;
        if (this.eoblock) {
            if (t = this._lookBits(12), t === ji) return 1;
            if (e1 = t >> 5 ? Xi[t >> 3] : Hi[t], e1[0] > 0) return this._eatBits(e1[0]), e1[1];
        } else {
            let e1 = this._findTableCode(1, 9, Xi);
            if (e1[0]) return e1[1];
            if (e1 = this._findTableCode(11, 12, Hi), e1[0]) return e1[1];
        }
        return info$1("bad white code"), this._eatBits(1), 1;
    }
    _getBlackCode() {
        let e1, t;
        if (this.eoblock) {
            if (e1 = this._lookBits(13), e1 === ji) return 1;
            if (t = e1 >> 7 ? !(e1 >> 9) && e1 >> 7 ? zi[(e1 >> 1) - 64] : Wi[e1 >> 7] : qi[e1], t[0] > 0) return this._eatBits(t[0]), t[1];
        } else {
            let e1 = this._findTableCode(2, 6, Wi);
            if (e1[0]) return e1[1];
            if (e1 = this._findTableCode(7, 12, zi, 64), e1[0]) return e1[1];
            if (e1 = this._findTableCode(10, 13, qi), e1[0]) return e1[1];
        }
        return info$1("bad black code"), this._eatBits(1), 1;
    }
    _lookBits(e1) {
        let t;
        for(; this.inputBits < e1;){
            if (-1 === (t = this.source.next())) return 0 === this.inputBits ? ji : this.inputBuf << e1 - this.inputBits & 65535 >> 16 - e1;
            this.inputBuf = this.inputBuf << 8 | t, this.inputBits += 8;
        }
        return this.inputBuf >> this.inputBits - e1 & 65535 >> 16 - e1;
    }
    _eatBits(e1) {
        (this.inputBits -= e1) < 0 && (this.inputBits = 0);
    }
}
class CCITTFaxStream extends DecodeStream {
    constructor(e1, t, i){
        super(t), this.str = e1, this.dict = e1.dict, i instanceof Dict || (i = Dict.empty);
        const n = {
            next: ()=>e1.getByte()
        };
        this.ccittFaxDecoder = new CCITTFaxDecoder(n, {
            K: i.get("K"),
            EndOfLine: i.get("EndOfLine"),
            EncodedByteAlign: i.get("EncodedByteAlign"),
            Columns: i.get("Columns"),
            Rows: i.get("Rows"),
            EndOfBlock: i.get("EndOfBlock"),
            BlackIs1: i.get("BlackIs1")
        });
    }
    readBlock() {
        for(; !this.eof;){
            const e1 = this.ccittFaxDecoder.readNextChar();
            if (-1 === e1) return void (this.eof = !0);
            this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = e1;
        }
    }
}
const Gi = new Int32Array([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]), Vi = new Int32Array([
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    65547,
    65549,
    65551,
    65553,
    131091,
    131095,
    131099,
    131103,
    196643,
    196651,
    196659,
    196667,
    262211,
    262227,
    262243,
    262259,
    327811,
    327843,
    327875,
    327907,
    258,
    258,
    258
]), Ki = new Int32Array([
    1,
    2,
    3,
    4,
    65541,
    65543,
    131081,
    131085,
    196625,
    196633,
    262177,
    262193,
    327745,
    327777,
    393345,
    393409,
    459009,
    459137,
    524801,
    525057,
    590849,
    591361,
    657409,
    658433,
    724993,
    727041,
    794625,
    798721,
    868353,
    876545
]), Yi = [
    new Int32Array([
        459008,
        524368,
        524304,
        524568,
        459024,
        524400,
        524336,
        590016,
        459016,
        524384,
        524320,
        589984,
        524288,
        524416,
        524352,
        590048,
        459012,
        524376,
        524312,
        589968,
        459028,
        524408,
        524344,
        590032,
        459020,
        524392,
        524328,
        59e4,
        524296,
        524424,
        524360,
        590064,
        459010,
        524372,
        524308,
        524572,
        459026,
        524404,
        524340,
        590024,
        459018,
        524388,
        524324,
        589992,
        524292,
        524420,
        524356,
        590056,
        459014,
        524380,
        524316,
        589976,
        459030,
        524412,
        524348,
        590040,
        459022,
        524396,
        524332,
        590008,
        524300,
        524428,
        524364,
        590072,
        459009,
        524370,
        524306,
        524570,
        459025,
        524402,
        524338,
        590020,
        459017,
        524386,
        524322,
        589988,
        524290,
        524418,
        524354,
        590052,
        459013,
        524378,
        524314,
        589972,
        459029,
        524410,
        524346,
        590036,
        459021,
        524394,
        524330,
        590004,
        524298,
        524426,
        524362,
        590068,
        459011,
        524374,
        524310,
        524574,
        459027,
        524406,
        524342,
        590028,
        459019,
        524390,
        524326,
        589996,
        524294,
        524422,
        524358,
        590060,
        459015,
        524382,
        524318,
        589980,
        459031,
        524414,
        524350,
        590044,
        459023,
        524398,
        524334,
        590012,
        524302,
        524430,
        524366,
        590076,
        459008,
        524369,
        524305,
        524569,
        459024,
        524401,
        524337,
        590018,
        459016,
        524385,
        524321,
        589986,
        524289,
        524417,
        524353,
        590050,
        459012,
        524377,
        524313,
        589970,
        459028,
        524409,
        524345,
        590034,
        459020,
        524393,
        524329,
        590002,
        524297,
        524425,
        524361,
        590066,
        459010,
        524373,
        524309,
        524573,
        459026,
        524405,
        524341,
        590026,
        459018,
        524389,
        524325,
        589994,
        524293,
        524421,
        524357,
        590058,
        459014,
        524381,
        524317,
        589978,
        459030,
        524413,
        524349,
        590042,
        459022,
        524397,
        524333,
        590010,
        524301,
        524429,
        524365,
        590074,
        459009,
        524371,
        524307,
        524571,
        459025,
        524403,
        524339,
        590022,
        459017,
        524387,
        524323,
        589990,
        524291,
        524419,
        524355,
        590054,
        459013,
        524379,
        524315,
        589974,
        459029,
        524411,
        524347,
        590038,
        459021,
        524395,
        524331,
        590006,
        524299,
        524427,
        524363,
        590070,
        459011,
        524375,
        524311,
        524575,
        459027,
        524407,
        524343,
        590030,
        459019,
        524391,
        524327,
        589998,
        524295,
        524423,
        524359,
        590062,
        459015,
        524383,
        524319,
        589982,
        459031,
        524415,
        524351,
        590046,
        459023,
        524399,
        524335,
        590014,
        524303,
        524431,
        524367,
        590078,
        459008,
        524368,
        524304,
        524568,
        459024,
        524400,
        524336,
        590017,
        459016,
        524384,
        524320,
        589985,
        524288,
        524416,
        524352,
        590049,
        459012,
        524376,
        524312,
        589969,
        459028,
        524408,
        524344,
        590033,
        459020,
        524392,
        524328,
        590001,
        524296,
        524424,
        524360,
        590065,
        459010,
        524372,
        524308,
        524572,
        459026,
        524404,
        524340,
        590025,
        459018,
        524388,
        524324,
        589993,
        524292,
        524420,
        524356,
        590057,
        459014,
        524380,
        524316,
        589977,
        459030,
        524412,
        524348,
        590041,
        459022,
        524396,
        524332,
        590009,
        524300,
        524428,
        524364,
        590073,
        459009,
        524370,
        524306,
        524570,
        459025,
        524402,
        524338,
        590021,
        459017,
        524386,
        524322,
        589989,
        524290,
        524418,
        524354,
        590053,
        459013,
        524378,
        524314,
        589973,
        459029,
        524410,
        524346,
        590037,
        459021,
        524394,
        524330,
        590005,
        524298,
        524426,
        524362,
        590069,
        459011,
        524374,
        524310,
        524574,
        459027,
        524406,
        524342,
        590029,
        459019,
        524390,
        524326,
        589997,
        524294,
        524422,
        524358,
        590061,
        459015,
        524382,
        524318,
        589981,
        459031,
        524414,
        524350,
        590045,
        459023,
        524398,
        524334,
        590013,
        524302,
        524430,
        524366,
        590077,
        459008,
        524369,
        524305,
        524569,
        459024,
        524401,
        524337,
        590019,
        459016,
        524385,
        524321,
        589987,
        524289,
        524417,
        524353,
        590051,
        459012,
        524377,
        524313,
        589971,
        459028,
        524409,
        524345,
        590035,
        459020,
        524393,
        524329,
        590003,
        524297,
        524425,
        524361,
        590067,
        459010,
        524373,
        524309,
        524573,
        459026,
        524405,
        524341,
        590027,
        459018,
        524389,
        524325,
        589995,
        524293,
        524421,
        524357,
        590059,
        459014,
        524381,
        524317,
        589979,
        459030,
        524413,
        524349,
        590043,
        459022,
        524397,
        524333,
        590011,
        524301,
        524429,
        524365,
        590075,
        459009,
        524371,
        524307,
        524571,
        459025,
        524403,
        524339,
        590023,
        459017,
        524387,
        524323,
        589991,
        524291,
        524419,
        524355,
        590055,
        459013,
        524379,
        524315,
        589975,
        459029,
        524411,
        524347,
        590039,
        459021,
        524395,
        524331,
        590007,
        524299,
        524427,
        524363,
        590071,
        459011,
        524375,
        524311,
        524575,
        459027,
        524407,
        524343,
        590031,
        459019,
        524391,
        524327,
        589999,
        524295,
        524423,
        524359,
        590063,
        459015,
        524383,
        524319,
        589983,
        459031,
        524415,
        524351,
        590047,
        459023,
        524399,
        524335,
        590015,
        524303,
        524431,
        524367,
        590079
    ]),
    9
], Ji = [
    new Int32Array([
        327680,
        327696,
        327688,
        327704,
        327684,
        327700,
        327692,
        327708,
        327682,
        327698,
        327690,
        327706,
        327686,
        327702,
        327694,
        0,
        327681,
        327697,
        327689,
        327705,
        327685,
        327701,
        327693,
        327709,
        327683,
        327699,
        327691,
        327707,
        327687,
        327703,
        327695,
        0
    ]),
    5
];
class FlateStream extends DecodeStream {
    constructor(e1, t){
        super(t), this.str = e1, this.dict = e1.dict;
        const i = e1.getByte(), n = e1.getByte();
        if (-1 === i || -1 === n) throw new ti(`Invalid header in flate stream: ${i}, ${n}`);
        if (8 != (15 & i)) throw new ti(`Unknown compression method in flate stream: ${i}, ${n}`);
        if (((i << 8) + n) % 31 != 0) throw new ti(`Bad FCHECK in flate stream: ${i}, ${n}`);
        if (32 & n) throw new ti(`FDICT bit set in flate stream: ${i}, ${n}`);
        this.codeSize = 0, this.codeBuf = 0;
    }
    async getImageData(e1, t) {
        const i = await this.asyncGetBytes();
        return i ? i.length <= e1 ? i : i.subarray(0, e1) : this.getBytes(e1);
    }
    async asyncGetBytes() {
        this.str.reset();
        const e1 = this.str.getBytes();
        try {
            const { readable: t, writable: i } = new DecompressionStream("deflate"), n = i.getWriter();
            await n.ready, n.write(e1).then(async ()=>{
                await n.ready, await n.close();
            }).catch(()=>{});
            const a = [];
            let s = 0;
            for await (const e1 of t)a.push(e1), s += e1.byteLength;
            const r = new Uint8Array(s);
            let o = 0;
            for (const e1 of a)r.set(e1, o), o += e1.byteLength;
            return r;
        } catch  {
            return this.str = new Stream(e1, 2, e1.length, this.str.dict), this.reset(), null;
        }
    }
    get isAsync() {
        return !0;
    }
    getBits(e1) {
        const t = this.str;
        let i, n = this.codeSize, a = this.codeBuf;
        for(; n < e1;){
            if (-1 === (i = t.getByte())) throw new ti("Bad encoding in flate stream");
            a |= i << n, n += 8;
        }
        return i = a & (1 << e1) - 1, this.codeBuf = a >> e1, this.codeSize = n -= e1, i;
    }
    getCode(e1) {
        const t = this.str, i = e1[0], n = e1[1];
        let a, s = this.codeSize, r = this.codeBuf;
        for(; s < n && -1 !== (a = t.getByte());)r |= a << s, s += 8;
        const o = i[r & (1 << n) - 1], l = o >> 16, c = 65535 & o;
        if (l < 1 || s < l) throw new ti("Bad encoding in flate stream");
        return this.codeBuf = r >> l, this.codeSize = s - l, c;
    }
    generateHuffmanTable(e1) {
        const t = e1.length;
        let i, n = 0;
        for(i = 0; i < t; ++i)e1[i] > n && (n = e1[i]);
        const a = 1 << n, s = new Int32Array(a);
        for(let r = 1, o = 0, l = 2; r <= n; ++r, o <<= 1, l <<= 1)for(let n = 0; n < t; ++n)if (e1[n] === r) {
            let e1 = 0, t = o;
            for(i = 0; i < r; ++i)e1 = e1 << 1 | 1 & t, t >>= 1;
            for(i = e1; i < a; i += l)s[i] = r << 16 | n;
            ++o;
        }
        return [
            s,
            n
        ];
    }
    #$(e1) {
        info$1(e1), this.eof = !0;
    }
    readBlock() {
        let e1, t, i;
        const n = this.str;
        try {
            t = this.getBits(3);
        } catch (e1) {
            return void this.#$(e1.message);
        }
        if (1 & t && (this.eof = !0), t >>= 1, 0 === t) {
            let t;
            if (-1 === (t = n.getByte())) return void this.#$("Bad block header in flate stream");
            let i = t;
            if (-1 === (t = n.getByte())) return void this.#$("Bad block header in flate stream");
            if (i |= t << 8, -1 === (t = n.getByte())) return void this.#$("Bad block header in flate stream");
            let a = t;
            if (-1 === (t = n.getByte())) return void this.#$("Bad block header in flate stream");
            if (a |= t << 8, a !== (65535 & ~i) && (0 !== i || 0 !== a)) throw new ti("Bad uncompressed block length in flate stream");
            this.codeBuf = 0, this.codeSize = 0;
            const s = this.bufferLength, r = s + i;
            if (e1 = this.ensureBuffer(r), this.bufferLength = r, 0 === i) -1 === n.peekByte() && (this.eof = !0);
            else {
                const t = n.getBytes(i);
                e1.set(t, s), t.length < i && (this.eof = !0);
            }
            return;
        }
        let a, s;
        if (1 === t) a = Yi, s = Ji;
        else {
            if (2 !== t) throw new ti("Unknown block type in flate stream");
            {
                const e1 = this.getBits(5) + 257, t = this.getBits(5) + 1, n = this.getBits(4) + 4, r = new Uint8Array(Gi.length);
                let o;
                for(o = 0; o < n; ++o)r[Gi[o]] = this.getBits(3);
                const l = this.generateHuffmanTable(r);
                i = 0, o = 0;
                const c = e1 + t, h = new Uint8Array(c);
                let d, u, g;
                for(; o < c;){
                    const e1 = this.getCode(l);
                    if (16 === e1) d = 2, u = 3, g = i;
                    else if (17 === e1) d = 3, u = 3, g = i = 0;
                    else {
                        if (18 !== e1) {
                            h[o++] = i = e1;
                            continue;
                        }
                        d = 7, u = 11, g = i = 0;
                    }
                    let t = this.getBits(d) + u;
                    for(; t-- > 0;)h[o++] = g;
                }
                a = this.generateHuffmanTable(h.subarray(0, e1)), s = this.generateHuffmanTable(h.subarray(e1, c));
            }
        }
        e1 = this.buffer;
        let r = e1 ? e1.length : 0, o = this.bufferLength;
        for(;;){
            let t = this.getCode(a);
            if (t < 256) {
                o + 1 >= r && (e1 = this.ensureBuffer(o + 1), r = e1.length), e1[o++] = t;
                continue;
            }
            if (256 === t) return void (this.bufferLength = o);
            t -= 257, t = Vi[t];
            let n = t >> 16;
            n > 0 && (n = this.getBits(n)), i = (65535 & t) + n, t = this.getCode(s), t = Ki[t], n = t >> 16, n > 0 && (n = this.getBits(n));
            const l = (65535 & t) + n;
            o + i >= r && (e1 = this.ensureBuffer(o + i), r = e1.length);
            for(let t = 0; t < i; ++t, ++o)e1[o] = e1[o - l];
        }
    }
}
const Zi = [
    {
        qe: 22017,
        nmps: 1,
        nlps: 1,
        switchFlag: 1
    },
    {
        qe: 13313,
        nmps: 2,
        nlps: 6,
        switchFlag: 0
    },
    {
        qe: 6145,
        nmps: 3,
        nlps: 9,
        switchFlag: 0
    },
    {
        qe: 2753,
        nmps: 4,
        nlps: 12,
        switchFlag: 0
    },
    {
        qe: 1313,
        nmps: 5,
        nlps: 29,
        switchFlag: 0
    },
    {
        qe: 545,
        nmps: 38,
        nlps: 33,
        switchFlag: 0
    },
    {
        qe: 22017,
        nmps: 7,
        nlps: 6,
        switchFlag: 1
    },
    {
        qe: 21505,
        nmps: 8,
        nlps: 14,
        switchFlag: 0
    },
    {
        qe: 18433,
        nmps: 9,
        nlps: 14,
        switchFlag: 0
    },
    {
        qe: 14337,
        nmps: 10,
        nlps: 14,
        switchFlag: 0
    },
    {
        qe: 12289,
        nmps: 11,
        nlps: 17,
        switchFlag: 0
    },
    {
        qe: 9217,
        nmps: 12,
        nlps: 18,
        switchFlag: 0
    },
    {
        qe: 7169,
        nmps: 13,
        nlps: 20,
        switchFlag: 0
    },
    {
        qe: 5633,
        nmps: 29,
        nlps: 21,
        switchFlag: 0
    },
    {
        qe: 22017,
        nmps: 15,
        nlps: 14,
        switchFlag: 1
    },
    {
        qe: 21505,
        nmps: 16,
        nlps: 14,
        switchFlag: 0
    },
    {
        qe: 20737,
        nmps: 17,
        nlps: 15,
        switchFlag: 0
    },
    {
        qe: 18433,
        nmps: 18,
        nlps: 16,
        switchFlag: 0
    },
    {
        qe: 14337,
        nmps: 19,
        nlps: 17,
        switchFlag: 0
    },
    {
        qe: 13313,
        nmps: 20,
        nlps: 18,
        switchFlag: 0
    },
    {
        qe: 12289,
        nmps: 21,
        nlps: 19,
        switchFlag: 0
    },
    {
        qe: 10241,
        nmps: 22,
        nlps: 19,
        switchFlag: 0
    },
    {
        qe: 9217,
        nmps: 23,
        nlps: 20,
        switchFlag: 0
    },
    {
        qe: 8705,
        nmps: 24,
        nlps: 21,
        switchFlag: 0
    },
    {
        qe: 7169,
        nmps: 25,
        nlps: 22,
        switchFlag: 0
    },
    {
        qe: 6145,
        nmps: 26,
        nlps: 23,
        switchFlag: 0
    },
    {
        qe: 5633,
        nmps: 27,
        nlps: 24,
        switchFlag: 0
    },
    {
        qe: 5121,
        nmps: 28,
        nlps: 25,
        switchFlag: 0
    },
    {
        qe: 4609,
        nmps: 29,
        nlps: 26,
        switchFlag: 0
    },
    {
        qe: 4353,
        nmps: 30,
        nlps: 27,
        switchFlag: 0
    },
    {
        qe: 2753,
        nmps: 31,
        nlps: 28,
        switchFlag: 0
    },
    {
        qe: 2497,
        nmps: 32,
        nlps: 29,
        switchFlag: 0
    },
    {
        qe: 2209,
        nmps: 33,
        nlps: 30,
        switchFlag: 0
    },
    {
        qe: 1313,
        nmps: 34,
        nlps: 31,
        switchFlag: 0
    },
    {
        qe: 1089,
        nmps: 35,
        nlps: 32,
        switchFlag: 0
    },
    {
        qe: 673,
        nmps: 36,
        nlps: 33,
        switchFlag: 0
    },
    {
        qe: 545,
        nmps: 37,
        nlps: 34,
        switchFlag: 0
    },
    {
        qe: 321,
        nmps: 38,
        nlps: 35,
        switchFlag: 0
    },
    {
        qe: 273,
        nmps: 39,
        nlps: 36,
        switchFlag: 0
    },
    {
        qe: 133,
        nmps: 40,
        nlps: 37,
        switchFlag: 0
    },
    {
        qe: 73,
        nmps: 41,
        nlps: 38,
        switchFlag: 0
    },
    {
        qe: 37,
        nmps: 42,
        nlps: 39,
        switchFlag: 0
    },
    {
        qe: 21,
        nmps: 43,
        nlps: 40,
        switchFlag: 0
    },
    {
        qe: 9,
        nmps: 44,
        nlps: 41,
        switchFlag: 0
    },
    {
        qe: 5,
        nmps: 45,
        nlps: 42,
        switchFlag: 0
    },
    {
        qe: 1,
        nmps: 45,
        nlps: 43,
        switchFlag: 0
    },
    {
        qe: 22017,
        nmps: 46,
        nlps: 46,
        switchFlag: 0
    }
];
class ArithmeticDecoder {
    constructor(e1, t, i){
        this.data = e1, this.bp = t, this.dataEnd = i, this.chigh = e1[t], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
    }
    byteIn() {
        const e1 = this.data;
        let t = this.bp;
        255 === e1[t] ? e1[t + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (t++, this.clow += e1[t] << 9, this.ct = 7, this.bp = t) : (t++, this.clow += t < this.dataEnd ? e1[t] << 8 : 65280, this.ct = 8, this.bp = t), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
    }
    readBit(e1, t) {
        let i = e1[t] >> 1, n = 1 & e1[t];
        const a = Zi[i], s = a.qe;
        let r, o = this.a - s;
        if (this.chigh < s) o < s ? (o = s, r = n, i = a.nmps) : (o = s, r = 1 ^ n, 1 === a.switchFlag && (n = r), i = a.nlps);
        else {
            if (this.chigh -= s, 32768 & o) return this.a = o, n;
            o < s ? (r = 1 ^ n, 1 === a.switchFlag && (n = r), i = a.nlps) : (r = n, i = a.nmps);
        }
        do {
            0 === this.ct && this.byteIn(), o <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
        }while (!(32768 & o))
        return this.a = o, e1[t] = i << 1 | n, r;
    }
}
class Jbig2Error extends Yt {
    constructor(e1){
        super(e1, "Jbig2Error");
    }
}
class ContextCache {
    getContexts(e1) {
        return e1 in this ? this[e1] : this[e1] = new Int8Array(65536);
    }
}
class DecodingContext {
    constructor(e1, t, i){
        this.data = e1, this.start = t, this.end = i;
    }
    get decoder() {
        return shadow$1(this, "decoder", new ArithmeticDecoder(this.data, this.start, this.end));
    }
    get contextCache() {
        return shadow$1(this, "contextCache", new ContextCache);
    }
}
function decodeInteger(e1, t, i) {
    const n = e1.getContexts(t);
    let a = 1;
    function readBits(e1) {
        let t = 0;
        for(let s = 0; s < e1; s++){
            const e1 = i.readBit(n, a);
            a = a < 256 ? a << 1 | e1 : 511 & (a << 1 | e1) | 256, t = t << 1 | e1;
        }
        return t >>> 0;
    }
    const s = readBits(1), r = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
    let o;
    return 0 === s ? o = r : r > 0 && (o = -r), o >= -2147483648 && o <= fi ? o : null;
}
function decodeIAID(e1, t, i) {
    const n = e1.getContexts("IAID");
    let a = 1;
    for(let e1 = 0; e1 < i; e1++){
        a = a << 1 | t.readBit(n, a);
    }
    return i < 31 ? a & (1 << i) - 1 : 2147483647 & a;
}
const Qi = [
    "SymbolDictionary",
    null,
    null,
    null,
    "IntermediateTextRegion",
    null,
    "ImmediateTextRegion",
    "ImmediateLosslessTextRegion",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "PatternDictionary",
    null,
    null,
    null,
    "IntermediateHalftoneRegion",
    null,
    "ImmediateHalftoneRegion",
    "ImmediateLosslessHalftoneRegion",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "IntermediateGenericRegion",
    null,
    "ImmediateGenericRegion",
    "ImmediateLosslessGenericRegion",
    "IntermediateGenericRefinementRegion",
    null,
    "ImmediateGenericRefinementRegion",
    "ImmediateLosslessGenericRefinementRegion",
    null,
    null,
    null,
    null,
    "PageInformation",
    "EndOfPage",
    "EndOfStripe",
    "EndOfFile",
    "Profiles",
    "Tables",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "Extension"
], en = [
    [
        {
            x: -1,
            y: -2
        },
        {
            x: 0,
            y: -2
        },
        {
            x: 1,
            y: -2
        },
        {
            x: -2,
            y: -1
        },
        {
            x: -1,
            y: -1
        },
        {
            x: 0,
            y: -1
        },
        {
            x: 1,
            y: -1
        },
        {
            x: 2,
            y: -1
        },
        {
            x: -4,
            y: 0
        },
        {
            x: -3,
            y: 0
        },
        {
            x: -2,
            y: 0
        },
        {
            x: -1,
            y: 0
        }
    ],
    [
        {
            x: -1,
            y: -2
        },
        {
            x: 0,
            y: -2
        },
        {
            x: 1,
            y: -2
        },
        {
            x: 2,
            y: -2
        },
        {
            x: -2,
            y: -1
        },
        {
            x: -1,
            y: -1
        },
        {
            x: 0,
            y: -1
        },
        {
            x: 1,
            y: -1
        },
        {
            x: 2,
            y: -1
        },
        {
            x: -3,
            y: 0
        },
        {
            x: -2,
            y: 0
        },
        {
            x: -1,
            y: 0
        }
    ],
    [
        {
            x: -1,
            y: -2
        },
        {
            x: 0,
            y: -2
        },
        {
            x: 1,
            y: -2
        },
        {
            x: -2,
            y: -1
        },
        {
            x: -1,
            y: -1
        },
        {
            x: 0,
            y: -1
        },
        {
            x: 1,
            y: -1
        },
        {
            x: -2,
            y: 0
        },
        {
            x: -1,
            y: 0
        }
    ],
    [
        {
            x: -3,
            y: -1
        },
        {
            x: -2,
            y: -1
        },
        {
            x: -1,
            y: -1
        },
        {
            x: 0,
            y: -1
        },
        {
            x: 1,
            y: -1
        },
        {
            x: -4,
            y: 0
        },
        {
            x: -3,
            y: 0
        },
        {
            x: -2,
            y: 0
        },
        {
            x: -1,
            y: 0
        }
    ]
], tn = [
    {
        coding: [
            {
                x: 0,
                y: -1
            },
            {
                x: 1,
                y: -1
            },
            {
                x: -1,
                y: 0
            }
        ],
        reference: [
            {
                x: 0,
                y: -1
            },
            {
                x: 1,
                y: -1
            },
            {
                x: -1,
                y: 0
            },
            {
                x: 0,
                y: 0
            },
            {
                x: 1,
                y: 0
            },
            {
                x: -1,
                y: 1
            },
            {
                x: 0,
                y: 1
            },
            {
                x: 1,
                y: 1
            }
        ]
    },
    {
        coding: [
            {
                x: -1,
                y: -1
            },
            {
                x: 0,
                y: -1
            },
            {
                x: 1,
                y: -1
            },
            {
                x: -1,
                y: 0
            }
        ],
        reference: [
            {
                x: 0,
                y: -1
            },
            {
                x: -1,
                y: 0
            },
            {
                x: 0,
                y: 0
            },
            {
                x: 1,
                y: 0
            },
            {
                x: 0,
                y: 1
            },
            {
                x: 1,
                y: 1
            }
        ]
    }
], nn = [
    39717,
    1941,
    229,
    405
];
function decodeBitmap(e1, t, i, n, a, s, r, o) {
    if (e1) {
        return decodeMMRBitmap(new Reader(o.data, o.start, o.end), t, i, !1);
    }
    if (0 === n && !a && 4 === r.length && 3 === r[0].x && -1 === r[0].y && -3 === r[1].x && -1 === r[1].y && 2 === r[2].x && -2 === r[2].y && -2 === r[3].x && -2 === r[3].y) return function(e1, t, i) {
        const n = i.decoder, a = i.contextCache.getContexts("GB"), s = [];
        let r, o, l, c, h, d, u;
        for(o = 0; o < t; o++)for(h = s[o] = new Uint8Array(e1), d = o < 1 ? h : s[o - 1], u = o < 2 ? h : s[o - 2], r = u[0] << 13 | u[1] << 12 | u[2] << 11 | d[0] << 7 | d[1] << 6 | d[2] << 5 | d[3] << 4, l = 0; l < e1; l++)h[l] = c = n.readBit(a, r), r = (31735 & r) << 1 | (l + 3 < e1 ? u[l + 3] << 11 : 0) | (l + 4 < e1 ? d[l + 4] << 4 : 0) | c;
        return s;
    }(t, i, o);
    const l = en[n].concat(r);
    l.sort((e1, t)=>e1.y - t.y || e1.x - t.x);
    const c = l.length, h = new Int8Array(c), d = new Int8Array(c), u = [];
    let g, f, p = 0, m = 0, b = 0, y = 0;
    for(f = 0; f < c; f++)h[f] = l[f].x, d[f] = l[f].y, m = Math.min(m, l[f].x), b = Math.max(b, l[f].x), y = Math.min(y, l[f].y), f < c - 1 && l[f].y === l[f + 1].y && l[f].x === l[f + 1].x - 1 ? p |= 1 << c - 1 - f : u.push(f);
    const w = u.length, x = new Int8Array(w), S = new Int8Array(w), v = new Uint16Array(w);
    for(g = 0; g < w; g++)f = u[g], x[g] = l[f].x, S[g] = l[f].y, v[g] = 1 << c - 1 - f;
    const C = -m, k = -y, T = t - b, F = nn[n];
    let E = new Uint8Array(t);
    const M = [], D = o.decoder, O = o.contextCache.getContexts("GB");
    let _, R, N, L, U, j = 0, $ = 0;
    for(let e1 = 0; e1 < i; e1++){
        if (a) {
            if (j ^= D.readBit(O, F), j) {
                M.push(E);
                continue;
            }
        }
        for(E = new Uint8Array(E), M.push(E), _ = 0; _ < t; _++){
            if (_ >= C && _ < T && e1 >= k) for($ = $ << 1 & p, f = 0; f < w; f++)R = e1 + S[f], N = _ + x[f], L = M[R][N], L && (L = v[f], $ |= L);
            else for($ = 0, U = c - 1, f = 0; f < c; f++, U--)N = _ + h[f], N >= 0 && N < t && (R = e1 + d[f], R >= 0 && (L = M[R][N], L && ($ |= L << U)));
            const i = D.readBit(O, $);
            E[_] = i;
        }
    }
    return M;
}
function decodeRefinement(e1, t, i, n, a, s, r, o, l) {
    let c = tn[i].coding;
    0 === i && (c = c.concat([
        o[0]
    ]));
    const h = c.length, d = new Int32Array(h), u = new Int32Array(h);
    let g;
    for(g = 0; g < h; g++)d[g] = c[g].x, u[g] = c[g].y;
    let f = tn[i].reference;
    0 === i && (f = f.concat([
        o[1]
    ]));
    const p = f.length, m = new Int32Array(p), b = new Int32Array(p);
    for(g = 0; g < p; g++)m[g] = f[g].x, b[g] = f[g].y;
    const y = n[0].length, w = n.length, x = [], S = l.decoder, v = l.contextCache.getContexts("GR");
    for(let i = 0; i < t; i++){
        const t = new Uint8Array(e1);
        x.push(t);
        for(let r = 0; r < e1; r++){
            let o, l, c = 0;
            for(g = 0; g < h; g++)o = i + u[g], l = r + d[g], o < 0 || l < 0 || l >= e1 ? c <<= 1 : c = c << 1 | x[o][l];
            for(g = 0; g < p; g++)o = i + b[g] - s, l = r + m[g] - a, o < 0 || o >= w || l < 0 || l >= y ? c <<= 1 : c = c << 1 | n[o][l];
            const f = S.readBit(v, c);
            t[r] = f;
        }
    }
    return x;
}
function decodeTextRegion(e1, t, i, n, a, s, r, o, l, c, h, d, u, g, f, p, m, b, y) {
    if (e1 && t) throw new Jbig2Error("refinement with Huffman is not supported");
    const w = [];
    let x, S;
    for(x = 0; x < n; x++)S = new Uint8Array(i), a && S.fill(a), w.push(S);
    const v = m.decoder, C = m.contextCache;
    let k = e1 ? -g.tableDeltaT.decode(y) : -decodeInteger(C, "IADT", v), T = 0;
    for(x = 0; x < s;){
        k += e1 ? g.tableDeltaT.decode(y) : decodeInteger(C, "IADT", v);
        T += e1 ? g.tableFirstS.decode(y) : decodeInteger(C, "IAFS", v);
        let n = T;
        for(;;){
            let a = 0;
            r > 1 && (a = e1 ? y.readBits(b) : decodeInteger(C, "IAIT", v));
            const s = r * k + a, T = e1 ? g.symbolIDTable.decode(y) : decodeIAID(C, v, l), F = t && (e1 ? y.readBit() : decodeInteger(C, "IARI", v));
            let E = o[T], M = E[0].length, D = E.length;
            if (F) {
                const e1 = decodeInteger(C, "IARDW", v), t = decodeInteger(C, "IARDH", v);
                M += e1, D += t, E = decodeRefinement(M, D, f, E, (e1 >> 1) + decodeInteger(C, "IARDX", v), (t >> 1) + decodeInteger(C, "IARDY", v), 0, p, m);
            }
            let O = 0;
            c ? 1 & d ? O = D - 1 : n += D - 1 : d > 1 ? n += M - 1 : O = M - 1;
            const _ = s - (1 & d ? 0 : D - 1), R = n - (2 & d ? M - 1 : 0);
            let N, L, U;
            if (c) for(N = 0; N < D; N++){
                if (S = w[R + N], !S) continue;
                U = E[N];
                const e1 = Math.min(i - _, M);
                switch(u){
                    case 0:
                        for(L = 0; L < e1; L++)S[_ + L] |= U[L];
                        break;
                    case 2:
                        for(L = 0; L < e1; L++)S[_ + L] ^= U[L];
                        break;
                    default:
                        throw new Jbig2Error(`operator ${u} is not supported`);
                }
            }
            else for(L = 0; L < D; L++)if (S = w[_ + L], S) switch(U = E[L], u){
                case 0:
                    for(N = 0; N < M; N++)S[R + N] |= U[N];
                    break;
                case 2:
                    for(N = 0; N < M; N++)S[R + N] ^= U[N];
                    break;
                default:
                    throw new Jbig2Error(`operator ${u} is not supported`);
            }
            x++;
            const j = e1 ? g.tableDeltaS.decode(y) : decodeInteger(C, "IADS", v);
            if (null === j) break;
            n += O + j + h;
        }
    }
    return w;
}
function readSegmentHeader(e1, t) {
    const i = {};
    i.number = readUint32(e1, t);
    const n = e1[t + 4], a = 63 & n;
    if (!Qi[a]) throw new Jbig2Error("invalid segment type: " + a);
    i.type = a, i.typeName = Qi[a], i.deferredNonRetain = !!(128 & n);
    const s = !!(64 & n), r = e1[t + 5];
    let o = r >> 5 & 7;
    const l = [
        31 & r
    ];
    let c = t + 6;
    if (7 === r) {
        o = 536870911 & readUint32(e1, c - 1), c += 3;
        let t = o + 7 >> 3;
        for(l[0] = e1[c++]; --t > 0;)l.push(e1[c++]);
    } else if (5 === r || 6 === r) throw new Jbig2Error("invalid referred-to flags");
    i.retainBits = l;
    let h = 4;
    i.number <= 256 ? h = 1 : i.number <= 65536 && (h = 2);
    const d = [];
    let u, g;
    for(u = 0; u < o; u++){
        let t;
        t = 1 === h ? e1[c] : 2 === h ? readUint16(e1, c) : readUint32(e1, c), d.push(t), c += h;
    }
    if (i.referredTo = d, s ? (i.pageAssociation = readUint32(e1, c), c += 4) : i.pageAssociation = e1[c++], i.length = readUint32(e1, c), c += 4, 4294967295 === i.length) {
        if (38 !== a) throw new Jbig2Error("invalid unknown segment length");
        {
            const t = readRegionSegmentInformation(e1, c), n = !!(1 & e1[c + an]), a = 6, s = new Uint8Array(a);
            for(n || (s[0] = 255, s[1] = 172), s[2] = t.height >>> 24 & 255, s[3] = t.height >> 16 & 255, s[4] = t.height >> 8 & 255, s[5] = 255 & t.height, u = c, g = e1.length; u < g; u++){
                let t = 0;
                for(; t < a && s[t] === e1[u + t];)t++;
                if (t === a) {
                    i.length = u + a;
                    break;
                }
            }
            if (4294967295 === i.length) throw new Jbig2Error("segment end was not found");
        }
    }
    return i.headerEnd = c, i;
}
function readSegments(e1, t, i, n) {
    const a = [];
    let s = i;
    for(; s < n;){
        const i = readSegmentHeader(t, s);
        s = i.headerEnd;
        const n = {
            header: i,
            data: t
        };
        if (e1.randomAccess || (n.start = s, s += i.length, n.end = s), a.push(n), 51 === i.type) break;
    }
    if (e1.randomAccess) for(let e1 = 0, t = a.length; e1 < t; e1++)a[e1].start = s, s += a[e1].header.length, a[e1].end = s;
    return a;
}
function readRegionSegmentInformation(e1, t) {
    return {
        width: readUint32(e1, t),
        height: readUint32(e1, t + 4),
        x: readUint32(e1, t + 8),
        y: readUint32(e1, t + 12),
        combinationOperator: 7 & e1[t + 16]
    };
}
const an = 17;
function processSegment(e1, t) {
    const i = e1.header, n = e1.data, a = e1.end;
    let s, r, o, l, c = e1.start;
    switch(i.type){
        case 0:
            const e2 = {}, t1 = readUint16(n, c);
            if (e2.huffman = !!(1 & t1), e2.refinement = !!(2 & t1), e2.huffmanDHSelector = t1 >> 2 & 3, e2.huffmanDWSelector = t1 >> 4 & 3, e2.bitmapSizeSelector = t1 >> 6 & 1, e2.aggregationInstancesSelector = t1 >> 7 & 1, e2.bitmapCodingContextUsed = !!(256 & t1), e2.bitmapCodingContextRetained = !!(512 & t1), e2.template = t1 >> 10 & 3, e2.refinementTemplate = t1 >> 12 & 1, c += 2, !e2.huffman) {
                for(l = 0 === e2.template ? 4 : 1, r = [], o = 0; o < l; o++)r.push({
                    x: readInt8(n, c),
                    y: readInt8(n, c + 1)
                }), c += 2;
                e2.at = r;
            }
            if (e2.refinement && !e2.refinementTemplate) {
                for(r = [], o = 0; o < 2; o++)r.push({
                    x: readInt8(n, c),
                    y: readInt8(n, c + 1)
                }), c += 2;
                e2.refinementAt = r;
            }
            e2.numberOfExportedSymbols = readUint32(n, c), c += 4, e2.numberOfNewSymbols = readUint32(n, c), c += 4, s = [
                e2,
                i.number,
                i.referredTo,
                n,
                c,
                a
            ];
            break;
        case 6:
        case 7:
            const h = {};
            h.info = readRegionSegmentInformation(n, c), c += an;
            const d = readUint16(n, c);
            if (c += 2, h.huffman = !!(1 & d), h.refinement = !!(2 & d), h.logStripSize = d >> 2 & 3, h.stripSize = 1 << h.logStripSize, h.referenceCorner = d >> 4 & 3, h.transposed = !!(64 & d), h.combinationOperator = d >> 7 & 3, h.defaultPixelValue = d >> 9 & 1, h.dsOffset = d << 17 >> 27, h.refinementTemplate = d >> 15 & 1, h.huffman) {
                const e1 = readUint16(n, c);
                c += 2, h.huffmanFS = 3 & e1, h.huffmanDS = e1 >> 2 & 3, h.huffmanDT = e1 >> 4 & 3, h.huffmanRefinementDW = e1 >> 6 & 3, h.huffmanRefinementDH = e1 >> 8 & 3, h.huffmanRefinementDX = e1 >> 10 & 3, h.huffmanRefinementDY = e1 >> 12 & 3, h.huffmanRefinementSizeSelector = !!(16384 & e1);
            }
            if (h.refinement && !h.refinementTemplate) {
                for(r = [], o = 0; o < 2; o++)r.push({
                    x: readInt8(n, c),
                    y: readInt8(n, c + 1)
                }), c += 2;
                h.refinementAt = r;
            }
            h.numberOfSymbolInstances = readUint32(n, c), c += 4, s = [
                h,
                i.referredTo,
                n,
                c,
                a
            ];
            break;
        case 16:
            const u = {}, g = n[c++];
            u.mmr = !!(1 & g), u.template = g >> 1 & 3, u.patternWidth = n[c++], u.patternHeight = n[c++], u.maxPatternIndex = readUint32(n, c), c += 4, s = [
                u,
                i.number,
                n,
                c,
                a
            ];
            break;
        case 22:
        case 23:
            const f = {};
            f.info = readRegionSegmentInformation(n, c), c += an;
            const p = n[c++];
            f.mmr = !!(1 & p), f.template = p >> 1 & 3, f.enableSkip = !!(8 & p), f.combinationOperator = p >> 4 & 7, f.defaultPixelValue = p >> 7 & 1, f.gridWidth = readUint32(n, c), c += 4, f.gridHeight = readUint32(n, c), c += 4, f.gridOffsetX = 4294967295 & readUint32(n, c), c += 4, f.gridOffsetY = 4294967295 & readUint32(n, c), c += 4, f.gridVectorX = readUint16(n, c), c += 2, f.gridVectorY = readUint16(n, c), c += 2, s = [
                f,
                i.referredTo,
                n,
                c,
                a
            ];
            break;
        case 38:
        case 39:
            const m = {};
            m.info = readRegionSegmentInformation(n, c), c += an;
            const b = n[c++];
            if (m.mmr = !!(1 & b), m.template = b >> 1 & 3, m.prediction = !!(8 & b), !m.mmr) {
                for(l = 0 === m.template ? 4 : 1, r = [], o = 0; o < l; o++)r.push({
                    x: readInt8(n, c),
                    y: readInt8(n, c + 1)
                }), c += 2;
                m.at = r;
            }
            s = [
                m,
                n,
                c,
                a
            ];
            break;
        case 48:
            const y = {
                width: readUint32(n, c),
                height: readUint32(n, c + 4),
                resolutionX: readUint32(n, c + 8),
                resolutionY: readUint32(n, c + 12)
            };
            4294967295 === y.height && delete y.height;
            const w = n[c + 16];
            readUint16(n, c + 17), y.lossless = !!(1 & w), y.refinement = !!(2 & w), y.defaultPixelValue = w >> 2 & 1, y.combinationOperator = w >> 3 & 3, y.requiresBuffer = !!(32 & w), y.combinationOperatorOverride = !!(64 & w), s = [
                y
            ];
            break;
        case 49:
        case 50:
        case 51:
        case 62:
            break;
        case 53:
            s = [
                i.number,
                n,
                c,
                a
            ];
            break;
        default:
            throw new Jbig2Error(`segment type ${i.typeName}(${i.type}) is not implemented`);
    }
    const h1 = "on" + i.typeName;
    h1 in t && t[h1].apply(t, s);
}
function processSegments(e1, t) {
    for(let i = 0, n = e1.length; i < n; i++)processSegment(e1[i], t);
}
class SimpleSegmentVisitor {
    onPageInformation(e1) {
        this.currentPageInfo = e1;
        const t = e1.width + 7 >> 3, i = new Uint8ClampedArray(t * e1.height);
        e1.defaultPixelValue && i.fill(255), this.buffer = i;
    }
    drawBitmap(e1, t) {
        const i = this.currentPageInfo, n = e1.width, a = e1.height, s = i.width + 7 >> 3, r = i.combinationOperatorOverride ? e1.combinationOperator : i.combinationOperator, o = this.buffer, l = 128 >> (7 & e1.x);
        let c, h, d, u, g = e1.y * s + (e1.x >> 3);
        switch(r){
            case 0:
                for(c = 0; c < a; c++){
                    for(d = l, u = g, h = 0; h < n; h++)t[c][h] && (o[u] |= d), d >>= 1, d || (d = 128, u++);
                    g += s;
                }
                break;
            case 2:
                for(c = 0; c < a; c++){
                    for(d = l, u = g, h = 0; h < n; h++)t[c][h] && (o[u] ^= d), d >>= 1, d || (d = 128, u++);
                    g += s;
                }
                break;
            default:
                throw new Jbig2Error(`operator ${r} is not supported`);
        }
    }
    onImmediateGenericRegion(e1, t, i, n) {
        const a = e1.info, s = new DecodingContext(t, i, n), r = decodeBitmap(e1.mmr, a.width, a.height, e1.template, e1.prediction, 0, e1.at, s);
        this.drawBitmap(a, r);
    }
    onImmediateLosslessGenericRegion() {
        this.onImmediateGenericRegion(...arguments);
    }
    onSymbolDictionary(e1, t, i, n, a, s) {
        let r, o;
        e1.huffman && (r = function(e1, t, i) {
            let n, a, s, r, o = 0;
            switch(e1.huffmanDHSelector){
                case 0:
                case 1:
                    n = getStandardTable(e1.huffmanDHSelector + 4);
                    break;
                case 3:
                    n = getCustomHuffmanTable(o, t, i), o++;
                    break;
                default:
                    throw new Jbig2Error("invalid Huffman DH selector");
            }
            switch(e1.huffmanDWSelector){
                case 0:
                case 1:
                    a = getStandardTable(e1.huffmanDWSelector + 2);
                    break;
                case 3:
                    a = getCustomHuffmanTable(o, t, i), o++;
                    break;
                default:
                    throw new Jbig2Error("invalid Huffman DW selector");
            }
            e1.bitmapSizeSelector ? (s = getCustomHuffmanTable(o, t, i), o++) : s = getStandardTable(1);
            r = e1.aggregationInstancesSelector ? getCustomHuffmanTable(o, t, i) : getStandardTable(1);
            return {
                tableDeltaHeight: n,
                tableDeltaWidth: a,
                tableBitmapSize: s,
                tableAggregateInstances: r
            };
        }(e1, i, this.customTables), o = new Reader(n, a, s));
        let l = this.symbols;
        l || (this.symbols = l = {});
        const c = [];
        for (const e1 of i){
            const t = l[e1];
            t && c.push(...t);
        }
        const h = new DecodingContext(n, a, s);
        l[t] = function(e1, t, i, n, a, s, r, o, l, c, h, d) {
            if (e1 && t) throw new Jbig2Error("symbol refinement with Huffman is not supported");
            const u = [];
            let g = 0, f = log2(i.length + n);
            const p = h.decoder, m = h.contextCache;
            let b, y;
            for(e1 && (b = getStandardTable(1), y = [], f = Math.max(f, 1)); u.length < n;){
                g += e1 ? s.tableDeltaHeight.decode(d) : decodeInteger(m, "IADH", p);
                let n = 0, a = 0;
                const b = e1 ? y.length : 0;
                for(;;){
                    const b = e1 ? s.tableDeltaWidth.decode(d) : decodeInteger(m, "IADW", p);
                    if (null === b) break;
                    let w;
                    if (n += b, a += n, t) {
                        const a = decodeInteger(m, "IAAI", p);
                        if (a > 1) w = decodeTextRegion(e1, t, n, g, 0, a, 1, i.concat(u), f, 0, 0, 1, 0, s, l, c, h, 0, d);
                        else {
                            const e1 = decodeIAID(m, p, f), t = decodeInteger(m, "IARDX", p), a = decodeInteger(m, "IARDY", p);
                            w = decodeRefinement(n, g, l, e1 < i.length ? i[e1] : u[e1 - i.length], t, a, 0, c, h);
                        }
                        u.push(w);
                    } else e1 ? y.push(n) : (w = decodeBitmap(!1, n, g, r, !1, 0, o, h), u.push(w));
                }
                if (e1 && !t) {
                    const e1 = s.tableBitmapSize.decode(d);
                    let t;
                    if (d.byteAlign(), 0 === e1) t = readUncompressedBitmap(d, a, g);
                    else {
                        const i = d.end, n = d.position + e1;
                        d.end = n, t = decodeMMRBitmap(d, a, g, !1), d.end = i, d.position = n;
                    }
                    const i = y.length;
                    if (b === i - 1) u.push(t);
                    else {
                        let e1, n, a, s, r, o = 0;
                        for(e1 = b; e1 < i; e1++){
                            for(s = y[e1], a = o + s, r = [], n = 0; n < g; n++)r.push(t[n].subarray(o, a));
                            u.push(r), o = a;
                        }
                    }
                }
            }
            const w = [], x = [];
            let S, v, C = !1;
            const k = i.length + n;
            for(; x.length < k;){
                let t = e1 ? b.decode(d) : decodeInteger(m, "IAEX", p);
                for(; t--;)x.push(C);
                C = !C;
            }
            for(S = 0, v = i.length; S < v; S++)x[S] && w.push(i[S]);
            for(let e1 = 0; e1 < n; S++, e1++)x[S] && w.push(u[e1]);
            return w;
        }(e1.huffman, e1.refinement, c, e1.numberOfNewSymbols, e1.numberOfExportedSymbols, r, e1.template, e1.at, e1.refinementTemplate, e1.refinementAt, h, o);
    }
    onImmediateTextRegion(e1, t, i, n, a) {
        const s = e1.info;
        let r, o;
        const l = this.symbols, c = [];
        for (const e1 of t){
            const t = l[e1];
            t && c.push(...t);
        }
        const h = log2(c.length);
        e1.huffman && (o = new Reader(i, n, a), r = function(e1, t, i, n, a) {
            const s = [];
            for(let e1 = 0; e1 <= 34; e1++){
                const t = a.readBits(4);
                s.push(new HuffmanLine([
                    e1,
                    t,
                    0,
                    0
                ]));
            }
            const r = new HuffmanTable(s, !1);
            s.length = 0;
            for(let e1 = 0; e1 < n;){
                const t = r.decode(a);
                if (t >= 32) {
                    let i, n, r;
                    switch(t){
                        case 32:
                            if (0 === e1) throw new Jbig2Error("no previous value in symbol ID table");
                            n = a.readBits(2) + 3, i = s[e1 - 1].prefixLength;
                            break;
                        case 33:
                            n = a.readBits(3) + 3, i = 0;
                            break;
                        case 34:
                            n = a.readBits(7) + 11, i = 0;
                            break;
                        default:
                            throw new Jbig2Error("invalid code length in symbol ID table");
                    }
                    for(r = 0; r < n; r++)s.push(new HuffmanLine([
                        e1,
                        i,
                        0,
                        0
                    ])), e1++;
                } else s.push(new HuffmanLine([
                    e1,
                    t,
                    0,
                    0
                ])), e1++;
            }
            a.byteAlign();
            const o = new HuffmanTable(s, !1);
            let l, c, h, d = 0;
            switch(e1.huffmanFS){
                case 0:
                case 1:
                    l = getStandardTable(e1.huffmanFS + 6);
                    break;
                case 3:
                    l = getCustomHuffmanTable(d, t, i), d++;
                    break;
                default:
                    throw new Jbig2Error("invalid Huffman FS selector");
            }
            switch(e1.huffmanDS){
                case 0:
                case 1:
                case 2:
                    c = getStandardTable(e1.huffmanDS + 8);
                    break;
                case 3:
                    c = getCustomHuffmanTable(d, t, i), d++;
                    break;
                default:
                    throw new Jbig2Error("invalid Huffman DS selector");
            }
            switch(e1.huffmanDT){
                case 0:
                case 1:
                case 2:
                    h = getStandardTable(e1.huffmanDT + 11);
                    break;
                case 3:
                    h = getCustomHuffmanTable(d, t, i), d++;
                    break;
                default:
                    throw new Jbig2Error("invalid Huffman DT selector");
            }
            if (e1.refinement) throw new Jbig2Error("refinement with Huffman is not supported");
            return {
                symbolIDTable: o,
                tableFirstS: l,
                tableDeltaS: c,
                tableDeltaT: h
            };
        }(e1, t, this.customTables, c.length, o));
        const d = new DecodingContext(i, n, a), u = decodeTextRegion(e1.huffman, e1.refinement, s.width, s.height, e1.defaultPixelValue, e1.numberOfSymbolInstances, e1.stripSize, c, h, e1.transposed, e1.dsOffset, e1.referenceCorner, e1.combinationOperator, r, e1.refinementTemplate, e1.refinementAt, d, e1.logStripSize, o);
        this.drawBitmap(s, u);
    }
    onImmediateLosslessTextRegion() {
        this.onImmediateTextRegion(...arguments);
    }
    onPatternDictionary(e1, t, i, n, a) {
        let s = this.patterns;
        s || (this.patterns = s = {});
        const r = new DecodingContext(i, n, a);
        s[t] = function(e1, t, i, n, a, s) {
            const r = [];
            e1 || (r.push({
                x: -t,
                y: 0
            }), 0 === a && r.push({
                x: -3,
                y: -1
            }, {
                x: 2,
                y: -2
            }, {
                x: -2,
                y: -2
            }));
            const o = decodeBitmap(e1, (n + 1) * t, i, a, !1, 0, r, s), l = [];
            for(let e1 = 0; e1 <= n; e1++){
                const n = [], a = t * e1, s = a + t;
                for(let e1 = 0; e1 < i; e1++)n.push(o[e1].subarray(a, s));
                l.push(n);
            }
            return l;
        }(e1.mmr, e1.patternWidth, e1.patternHeight, e1.maxPatternIndex, e1.template, r);
    }
    onImmediateHalftoneRegion(e1, t, i, n, a) {
        const s = this.patterns[t[0]], r = e1.info, o = new DecodingContext(i, n, a), l = function(e1, t, i, n, a, s, r, o, l, c, h, d, u, g, f) {
            if (r) throw new Jbig2Error("skip is not supported");
            if (0 !== o) throw new Jbig2Error(`operator "${o}" is not supported in halftone region`);
            const p = [];
            let m, b, y;
            for(m = 0; m < a; m++)y = new Uint8Array(n), s && y.fill(s), p.push(y);
            const w = t.length, x = t[0], S = x[0].length, v = x.length, C = log2(w), k = [];
            e1 || (k.push({
                x: i <= 1 ? 3 : 2,
                y: -1
            }), 0 === i && k.push({
                x: -3,
                y: -1
            }, {
                x: 2,
                y: -2
            }, {
                x: -2,
                y: -2
            }));
            const T = [];
            let F, E, M, D, O, _, R, N, L, U, j;
            for(e1 && (F = new Reader(f.data, f.start, f.end)), m = C - 1; m >= 0; m--)E = e1 ? decodeMMRBitmap(F, l, c, !0) : decodeBitmap(!1, l, c, i, !1, 0, k, f), T[m] = E;
            for(M = 0; M < c; M++)for(D = 0; D < l; D++){
                for(O = 0, _ = 0, b = C - 1; b >= 0; b--)O ^= T[b][M][D], _ |= O << b;
                if (R = t[_], N = h + M * g + D * u >> 8, L = d + M * u - D * g >> 8, N >= 0 && N + S <= n && L >= 0 && L + v <= a) for(m = 0; m < v; m++)for(j = p[L + m], U = R[m], b = 0; b < S; b++)j[N + b] |= U[b];
                else {
                    let e1, t;
                    for(m = 0; m < v; m++)if (t = L + m, !(t < 0 || t >= a)) for(j = p[t], U = R[m], b = 0; b < S; b++)e1 = N + b, e1 >= 0 && e1 < n && (j[e1] |= U[b]);
                }
            }
            return p;
        }(e1.mmr, s, e1.template, r.width, r.height, e1.defaultPixelValue, e1.enableSkip, e1.combinationOperator, e1.gridWidth, e1.gridHeight, e1.gridOffsetX, e1.gridOffsetY, e1.gridVectorX, e1.gridVectorY, o);
        this.drawBitmap(r, l);
    }
    onImmediateLosslessHalftoneRegion() {
        this.onImmediateHalftoneRegion(...arguments);
    }
    onTables(e1, t, i, n) {
        let a = this.customTables;
        a || (this.customTables = a = {}), a[e1] = function(e1, t, i) {
            const n = e1[t], a = 4294967295 & readUint32(e1, t + 1), s = 4294967295 & readUint32(e1, t + 5), r = new Reader(e1, t + 9, i), o = 1 + (n >> 1 & 7), l = 1 + (n >> 4 & 7), c = [];
            let h, d, u = a;
            do {
                h = r.readBits(o), d = r.readBits(l), c.push(new HuffmanLine([
                    u,
                    h,
                    d,
                    0
                ])), u += 1 << d;
            }while (u < s)
            h = r.readBits(o), c.push(new HuffmanLine([
                a - 1,
                h,
                32,
                0,
                "lower"
            ])), h = r.readBits(o), c.push(new HuffmanLine([
                s,
                h,
                32,
                0
            ])), 1 & n && (h = r.readBits(o), c.push(new HuffmanLine([
                h,
                0
            ])));
            return new HuffmanTable(c, !1);
        }(t, i, n);
    }
}
class HuffmanLine {
    constructor(e1){
        2 === e1.length ? (this.isOOB = !0, this.rangeLow = 0, this.prefixLength = e1[0], this.rangeLength = 0, this.prefixCode = e1[1], this.isLowerRange = !1) : (this.isOOB = !1, this.rangeLow = e1[0], this.prefixLength = e1[1], this.rangeLength = e1[2], this.prefixCode = e1[3], this.isLowerRange = "lower" === e1[4]);
    }
}
class HuffmanTreeNode {
    constructor(e1){
        this.children = [], e1 ? (this.isLeaf = !0, this.rangeLength = e1.rangeLength, this.rangeLow = e1.rangeLow, this.isLowerRange = e1.isLowerRange, this.isOOB = e1.isOOB) : this.isLeaf = !1;
    }
    buildTree(e1, t) {
        const i = e1.prefixCode >> t & 1;
        if (t <= 0) this.children[i] = new HuffmanTreeNode(e1);
        else {
            let n = this.children[i];
            n || (this.children[i] = n = new HuffmanTreeNode(null)), n.buildTree(e1, t - 1);
        }
    }
    decodeNode(e1) {
        if (this.isLeaf) {
            if (this.isOOB) return null;
            const t = e1.readBits(this.rangeLength);
            return this.rangeLow + (this.isLowerRange ? -t : t);
        }
        const t = this.children[e1.readBit()];
        if (!t) throw new Jbig2Error("invalid Huffman data");
        return t.decodeNode(e1);
    }
}
class HuffmanTable {
    constructor(e1, t){
        t || this.assignPrefixCodes(e1), this.rootNode = new HuffmanTreeNode(null);
        for(let t = 0, i = e1.length; t < i; t++){
            const i = e1[t];
            i.prefixLength > 0 && this.rootNode.buildTree(i, i.prefixLength - 1);
        }
    }
    decode(e1) {
        return this.rootNode.decodeNode(e1);
    }
    assignPrefixCodes(e1) {
        const t = e1.length;
        let i = 0;
        for(let n = 0; n < t; n++)i = Math.max(i, e1[n].prefixLength);
        const n = new Uint32Array(i + 1);
        for(let i = 0; i < t; i++)n[e1[i].prefixLength]++;
        let a, s, r, o = 1, l = 0;
        for(n[0] = 0; o <= i;){
            for(l = l + n[o - 1] << 1, a = l, s = 0; s < t;)r = e1[s], r.prefixLength === o && (r.prefixCode = a, a++), s++;
            o++;
        }
    }
}
const sn = {};
function getStandardTable(e1) {
    let t, i = sn[e1];
    if (i) return i;
    switch(e1){
        case 1:
            t = [
                [
                    0,
                    1,
                    4,
                    0
                ],
                [
                    16,
                    2,
                    8,
                    2
                ],
                [
                    272,
                    3,
                    16,
                    6
                ],
                [
                    65808,
                    3,
                    32,
                    7
                ]
            ];
            break;
        case 2:
            t = [
                [
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    0,
                    2
                ],
                [
                    2,
                    3,
                    0,
                    6
                ],
                [
                    3,
                    4,
                    3,
                    14
                ],
                [
                    11,
                    5,
                    6,
                    30
                ],
                [
                    75,
                    6,
                    32,
                    62
                ],
                [
                    6,
                    63
                ]
            ];
            break;
        case 3:
            t = [
                [
                    -256,
                    8,
                    8,
                    254
                ],
                [
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    0,
                    2
                ],
                [
                    2,
                    3,
                    0,
                    6
                ],
                [
                    3,
                    4,
                    3,
                    14
                ],
                [
                    11,
                    5,
                    6,
                    30
                ],
                [
                    -257,
                    8,
                    32,
                    255,
                    "lower"
                ],
                [
                    75,
                    7,
                    32,
                    126
                ],
                [
                    6,
                    62
                ]
            ];
            break;
        case 4:
            t = [
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    2,
                    0,
                    2
                ],
                [
                    3,
                    3,
                    0,
                    6
                ],
                [
                    4,
                    4,
                    3,
                    14
                ],
                [
                    12,
                    5,
                    6,
                    30
                ],
                [
                    76,
                    5,
                    32,
                    31
                ]
            ];
            break;
        case 5:
            t = [
                [
                    -255,
                    7,
                    8,
                    126
                ],
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    2,
                    0,
                    2
                ],
                [
                    3,
                    3,
                    0,
                    6
                ],
                [
                    4,
                    4,
                    3,
                    14
                ],
                [
                    12,
                    5,
                    6,
                    30
                ],
                [
                    -256,
                    7,
                    32,
                    127,
                    "lower"
                ],
                [
                    76,
                    6,
                    32,
                    62
                ]
            ];
            break;
        case 6:
            t = [
                [
                    -2048,
                    5,
                    10,
                    28
                ],
                [
                    -1024,
                    4,
                    9,
                    8
                ],
                [
                    -512,
                    4,
                    8,
                    9
                ],
                [
                    -256,
                    4,
                    7,
                    10
                ],
                [
                    -128,
                    5,
                    6,
                    29
                ],
                [
                    -64,
                    5,
                    5,
                    30
                ],
                [
                    -32,
                    4,
                    5,
                    11
                ],
                [
                    0,
                    2,
                    7,
                    0
                ],
                [
                    128,
                    3,
                    7,
                    2
                ],
                [
                    256,
                    3,
                    8,
                    3
                ],
                [
                    512,
                    4,
                    9,
                    12
                ],
                [
                    1024,
                    4,
                    10,
                    13
                ],
                [
                    -2049,
                    6,
                    32,
                    62,
                    "lower"
                ],
                [
                    2048,
                    6,
                    32,
                    63
                ]
            ];
            break;
        case 7:
            t = [
                [
                    -1024,
                    4,
                    9,
                    8
                ],
                [
                    -512,
                    3,
                    8,
                    0
                ],
                [
                    -256,
                    4,
                    7,
                    9
                ],
                [
                    -128,
                    5,
                    6,
                    26
                ],
                [
                    -64,
                    5,
                    5,
                    27
                ],
                [
                    -32,
                    4,
                    5,
                    10
                ],
                [
                    0,
                    4,
                    5,
                    11
                ],
                [
                    32,
                    5,
                    5,
                    28
                ],
                [
                    64,
                    5,
                    6,
                    29
                ],
                [
                    128,
                    4,
                    7,
                    12
                ],
                [
                    256,
                    3,
                    8,
                    1
                ],
                [
                    512,
                    3,
                    9,
                    2
                ],
                [
                    1024,
                    3,
                    10,
                    3
                ],
                [
                    -1025,
                    5,
                    32,
                    30,
                    "lower"
                ],
                [
                    2048,
                    5,
                    32,
                    31
                ]
            ];
            break;
        case 8:
            t = [
                [
                    -15,
                    8,
                    3,
                    252
                ],
                [
                    -7,
                    9,
                    1,
                    508
                ],
                [
                    -5,
                    8,
                    1,
                    253
                ],
                [
                    -3,
                    9,
                    0,
                    509
                ],
                [
                    -2,
                    7,
                    0,
                    124
                ],
                [
                    -1,
                    4,
                    0,
                    10
                ],
                [
                    0,
                    2,
                    1,
                    0
                ],
                [
                    2,
                    5,
                    0,
                    26
                ],
                [
                    3,
                    6,
                    0,
                    58
                ],
                [
                    4,
                    3,
                    4,
                    4
                ],
                [
                    20,
                    6,
                    1,
                    59
                ],
                [
                    22,
                    4,
                    4,
                    11
                ],
                [
                    38,
                    4,
                    5,
                    12
                ],
                [
                    70,
                    5,
                    6,
                    27
                ],
                [
                    134,
                    5,
                    7,
                    28
                ],
                [
                    262,
                    6,
                    7,
                    60
                ],
                [
                    390,
                    7,
                    8,
                    125
                ],
                [
                    646,
                    6,
                    10,
                    61
                ],
                [
                    -16,
                    9,
                    32,
                    510,
                    "lower"
                ],
                [
                    1670,
                    9,
                    32,
                    511
                ],
                [
                    2,
                    1
                ]
            ];
            break;
        case 9:
            t = [
                [
                    -31,
                    8,
                    4,
                    252
                ],
                [
                    -15,
                    9,
                    2,
                    508
                ],
                [
                    -11,
                    8,
                    2,
                    253
                ],
                [
                    -7,
                    9,
                    1,
                    509
                ],
                [
                    -5,
                    7,
                    1,
                    124
                ],
                [
                    -3,
                    4,
                    1,
                    10
                ],
                [
                    -1,
                    3,
                    1,
                    2
                ],
                [
                    1,
                    3,
                    1,
                    3
                ],
                [
                    3,
                    5,
                    1,
                    26
                ],
                [
                    5,
                    6,
                    1,
                    58
                ],
                [
                    7,
                    3,
                    5,
                    4
                ],
                [
                    39,
                    6,
                    2,
                    59
                ],
                [
                    43,
                    4,
                    5,
                    11
                ],
                [
                    75,
                    4,
                    6,
                    12
                ],
                [
                    139,
                    5,
                    7,
                    27
                ],
                [
                    267,
                    5,
                    8,
                    28
                ],
                [
                    523,
                    6,
                    8,
                    60
                ],
                [
                    779,
                    7,
                    9,
                    125
                ],
                [
                    1291,
                    6,
                    11,
                    61
                ],
                [
                    -32,
                    9,
                    32,
                    510,
                    "lower"
                ],
                [
                    3339,
                    9,
                    32,
                    511
                ],
                [
                    2,
                    0
                ]
            ];
            break;
        case 10:
            t = [
                [
                    -21,
                    7,
                    4,
                    122
                ],
                [
                    -5,
                    8,
                    0,
                    252
                ],
                [
                    -4,
                    7,
                    0,
                    123
                ],
                [
                    -3,
                    5,
                    0,
                    24
                ],
                [
                    -2,
                    2,
                    2,
                    0
                ],
                [
                    2,
                    5,
                    0,
                    25
                ],
                [
                    3,
                    6,
                    0,
                    54
                ],
                [
                    4,
                    7,
                    0,
                    124
                ],
                [
                    5,
                    8,
                    0,
                    253
                ],
                [
                    6,
                    2,
                    6,
                    1
                ],
                [
                    70,
                    5,
                    5,
                    26
                ],
                [
                    102,
                    6,
                    5,
                    55
                ],
                [
                    134,
                    6,
                    6,
                    56
                ],
                [
                    198,
                    6,
                    7,
                    57
                ],
                [
                    326,
                    6,
                    8,
                    58
                ],
                [
                    582,
                    6,
                    9,
                    59
                ],
                [
                    1094,
                    6,
                    10,
                    60
                ],
                [
                    2118,
                    7,
                    11,
                    125
                ],
                [
                    -22,
                    8,
                    32,
                    254,
                    "lower"
                ],
                [
                    4166,
                    8,
                    32,
                    255
                ],
                [
                    2,
                    2
                ]
            ];
            break;
        case 11:
            t = [
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    2,
                    1,
                    2
                ],
                [
                    4,
                    4,
                    0,
                    12
                ],
                [
                    5,
                    4,
                    1,
                    13
                ],
                [
                    7,
                    5,
                    1,
                    28
                ],
                [
                    9,
                    5,
                    2,
                    29
                ],
                [
                    13,
                    6,
                    2,
                    60
                ],
                [
                    17,
                    7,
                    2,
                    122
                ],
                [
                    21,
                    7,
                    3,
                    123
                ],
                [
                    29,
                    7,
                    4,
                    124
                ],
                [
                    45,
                    7,
                    5,
                    125
                ],
                [
                    77,
                    7,
                    6,
                    126
                ],
                [
                    141,
                    7,
                    32,
                    127
                ]
            ];
            break;
        case 12:
            t = [
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    2,
                    0,
                    2
                ],
                [
                    3,
                    3,
                    1,
                    6
                ],
                [
                    5,
                    5,
                    0,
                    28
                ],
                [
                    6,
                    5,
                    1,
                    29
                ],
                [
                    8,
                    6,
                    1,
                    60
                ],
                [
                    10,
                    7,
                    0,
                    122
                ],
                [
                    11,
                    7,
                    1,
                    123
                ],
                [
                    13,
                    7,
                    2,
                    124
                ],
                [
                    17,
                    7,
                    3,
                    125
                ],
                [
                    25,
                    7,
                    4,
                    126
                ],
                [
                    41,
                    8,
                    5,
                    254
                ],
                [
                    73,
                    8,
                    32,
                    255
                ]
            ];
            break;
        case 13:
            t = [
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    3,
                    0,
                    4
                ],
                [
                    3,
                    4,
                    0,
                    12
                ],
                [
                    4,
                    5,
                    0,
                    28
                ],
                [
                    5,
                    4,
                    1,
                    13
                ],
                [
                    7,
                    3,
                    3,
                    5
                ],
                [
                    15,
                    6,
                    1,
                    58
                ],
                [
                    17,
                    6,
                    2,
                    59
                ],
                [
                    21,
                    6,
                    3,
                    60
                ],
                [
                    29,
                    6,
                    4,
                    61
                ],
                [
                    45,
                    6,
                    5,
                    62
                ],
                [
                    77,
                    7,
                    6,
                    126
                ],
                [
                    141,
                    7,
                    32,
                    127
                ]
            ];
            break;
        case 14:
            t = [
                [
                    -2,
                    3,
                    0,
                    4
                ],
                [
                    -1,
                    3,
                    0,
                    5
                ],
                [
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    3,
                    0,
                    6
                ],
                [
                    2,
                    3,
                    0,
                    7
                ]
            ];
            break;
        case 15:
            t = [
                [
                    -24,
                    7,
                    4,
                    124
                ],
                [
                    -8,
                    6,
                    2,
                    60
                ],
                [
                    -4,
                    5,
                    1,
                    28
                ],
                [
                    -2,
                    4,
                    0,
                    12
                ],
                [
                    -1,
                    3,
                    0,
                    4
                ],
                [
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    3,
                    0,
                    5
                ],
                [
                    2,
                    4,
                    0,
                    13
                ],
                [
                    3,
                    5,
                    1,
                    29
                ],
                [
                    5,
                    6,
                    2,
                    61
                ],
                [
                    9,
                    7,
                    4,
                    125
                ],
                [
                    -25,
                    7,
                    32,
                    126,
                    "lower"
                ],
                [
                    25,
                    7,
                    32,
                    127
                ]
            ];
            break;
        default:
            throw new Jbig2Error(`standard table B.${e1} does not exist`);
    }
    for(let e1 = 0, i = t.length; e1 < i; e1++)t[e1] = new HuffmanLine(t[e1]);
    return i = new HuffmanTable(t, !0), sn[e1] = i, i;
}
class Reader {
    constructor(e1, t, i){
        this.data = e1, this.start = t, this.end = i, this.position = t, this.shift = -1, this.currentByte = 0;
    }
    readBit() {
        if (this.shift < 0) {
            if (this.position >= this.end) throw new Jbig2Error("end of data while reading bit");
            this.currentByte = this.data[this.position++], this.shift = 7;
        }
        const e1 = this.currentByte >> this.shift & 1;
        return this.shift--, e1;
    }
    readBits(e1) {
        let t, i = 0;
        for(t = e1 - 1; t >= 0; t--)i |= this.readBit() << t;
        return i;
    }
    byteAlign() {
        this.shift = -1;
    }
    next() {
        return this.position >= this.end ? -1 : this.data[this.position++];
    }
}
function getCustomHuffmanTable(e1, t, i) {
    let n = 0;
    for(let a = 0, s = t.length; a < s; a++){
        const s = i[t[a]];
        if (s) {
            if (e1 === n) return s;
            n++;
        }
    }
    throw new Jbig2Error("can't find custom Huffman table");
}
function readUncompressedBitmap(e1, t, i) {
    const n = [];
    for(let a = 0; a < i; a++){
        const i = new Uint8Array(t);
        n.push(i);
        for(let n = 0; n < t; n++)i[n] = e1.readBit();
        e1.byteAlign();
    }
    return n;
}
function decodeMMRBitmap(e1, t, i, n) {
    const a = new CCITTFaxDecoder(e1, {
        K: -1,
        Columns: t,
        Rows: i,
        BlackIs1: !0,
        EndOfBlock: n
    }), s = [];
    let r, o = !1;
    for(let e1 = 0; e1 < i; e1++){
        const e1 = new Uint8Array(t);
        s.push(e1);
        let i = -1;
        for(let n = 0; n < t; n++)i < 0 && (r = a.readNextChar(), -1 === r && (r = 0, o = !0), i = 7), e1[n] = r >> i & 1, i--;
    }
    if (n && !o) {
        const e1 = 5;
        for(let t = 0; t < e1 && -1 !== a.readNextChar(); t++);
    }
    return s;
}
class Jbig2Image {
    parseChunks(e1) {
        return function(e1) {
            const t = new SimpleSegmentVisitor;
            for(let i = 0, n = e1.length; i < n; i++){
                const n = e1[i];
                processSegments(readSegments({}, n.data, n.start, n.end), t);
            }
            return t.buffer;
        }(e1);
    }
    parse(e1) {
        throw new Error("Not implemented: Jbig2Image.parse");
    }
}
class Jbig2Stream extends DecodeStream {
    constructor(e1, t, i){
        super(t), this.stream = e1, this.dict = e1.dict, this.maybeLength = t, this.params = i;
    }
    get bytes() {
        return shadow$1(this, "bytes", this.stream.getBytes(this.maybeLength));
    }
    ensureBuffer(e1) {}
    readBlock() {
        this.decodeImage();
    }
    decodeImage(e1) {
        if (this.eof) return this.buffer;
        e1 ||= this.bytes;
        const t = new Jbig2Image, i = [];
        if (this.params instanceof Dict) {
            const e1 = this.params.get("JBIG2Globals");
            if (e1 instanceof BaseStream) {
                const t = e1.getBytes();
                i.push({
                    data: t,
                    start: 0,
                    end: t.length
                });
            }
        }
        i.push({
            data: e1,
            start: 0,
            end: e1.length
        });
        const n = t.parseChunks(i), a = n.length;
        for(let e1 = 0; e1 < a; e1++)n[e1] ^= 255;
        return this.buffer = n, this.bufferLength = a, this.eof = !0, this.buffer;
    }
    get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
    }
}
class JpxStream extends DecodeStream {
    constructor(e1, t, i){
        super(t), this.stream = e1, this.dict = e1.dict, this.maybeLength = t, this.params = i;
    }
    get bytes() {
        return shadow$1(this, "bytes", this.stream.getBytes(this.maybeLength));
    }
    ensureBuffer(e1) {}
    readBlock(e1) {
        unreachable$1("JpxStream.readBlock");
    }
    get isAsyncDecoder() {
        return !0;
    }
    async decodeImage(e1, t) {
        return this.eof || (e1 ||= this.bytes, this.buffer = await JpxImage.decode(e1, t), this.bufferLength = this.buffer.length, this.eof = !0), this.buffer;
    }
    get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
    }
}
class LZWStream extends DecodeStream {
    constructor(e1, t, i){
        super(t), this.str = e1, this.dict = e1.dict, this.cachedData = 0, this.bitsCached = 0;
        const n = 4096, a = {
            earlyChange: i,
            codeLength: 9,
            nextCode: 258,
            dictionaryValues: new Uint8Array(n),
            dictionaryLengths: new Uint16Array(n),
            dictionaryPrevCodes: new Uint16Array(n),
            currentSequence: new Uint8Array(n),
            currentSequenceLength: 0
        };
        for(let e1 = 0; e1 < 256; ++e1)a.dictionaryValues[e1] = e1, a.dictionaryLengths[e1] = 1;
        this.lzwState = a;
    }
    readBits(e1) {
        let t = this.bitsCached, i = this.cachedData;
        for(; t < e1;){
            const e1 = this.str.getByte();
            if (-1 === e1) return this.eof = !0, null;
            i = i << 8 | e1, t += 8;
        }
        return this.bitsCached = t -= e1, this.cachedData = i, this.lastCode = null, i >>> t & (1 << e1) - 1;
    }
    readBlock() {
        let e1, t, i, n = 1024;
        const a = this.lzwState;
        if (!a) return;
        const s = a.earlyChange;
        let r = a.nextCode;
        const o = a.dictionaryValues, l = a.dictionaryLengths, c = a.dictionaryPrevCodes;
        let h = a.codeLength, d = a.prevCode;
        const u = a.currentSequence;
        let g = a.currentSequenceLength, f = 0, p = this.bufferLength, m = this.ensureBuffer(this.bufferLength + n);
        for(e1 = 0; e1 < 512; e1++){
            const e1 = this.readBits(h), a = g > 0;
            if (e1 < 256) u[0] = e1, g = 1;
            else {
                if (!(e1 >= 258)) {
                    if (256 === e1) {
                        h = 9, r = 258, g = 0;
                        continue;
                    }
                    this.eof = !0, delete this.lzwState;
                    break;
                }
                if (e1 < r) for(g = l[e1], t = g - 1, i = e1; t >= 0; t--)u[t] = o[i], i = c[i];
                else u[g++] = u[0];
            }
            if (a && (c[r] = d, l[r] = l[d] + 1, o[r] = u[0], r++, h = r + s & r + s - 1 ? h : 0 | Math.min(Math.log(r + s) / .6931471805599453 + 1, 12)), d = e1, f += g, n < f) {
                do {
                    n += 512;
                }while (n < f)
                m = this.ensureBuffer(this.bufferLength + n);
            }
            for(t = 0; t < g; t++)m[p++] = u[t];
        }
        a.nextCode = r, a.codeLength = h, a.prevCode = d, a.currentSequenceLength = g, this.bufferLength = p;
    }
}
class PredictorStream extends DecodeStream {
    constructor(e1, t, i){
        if (super(t), !(i instanceof Dict)) return e1;
        const n = this.predictor = i.get("Predictor") || 1;
        if (n <= 1) return e1;
        if (2 !== n && (n < 10 || n > 15)) throw new ti(`Unsupported predictor: ${n}`);
        this.readBlock = 2 === n ? this.readBlockTiff : this.readBlockPng, this.str = e1, this.dict = e1.dict;
        const a = this.colors = i.get("Colors") || 1, s = this.bits = i.get("BPC", "BitsPerComponent") || 8, r = this.columns = i.get("Columns") || 1;
        return this.pixBytes = a * s + 7 >> 3, this.rowBytes = r * a * s + 7 >> 3, this;
    }
    readBlockTiff() {
        const e1 = this.rowBytes, t = this.bufferLength, i = this.ensureBuffer(t + e1), n = this.bits, a = this.colors, s = this.str.getBytes(e1);
        if (this.eof = !s.length, this.eof) return;
        let r, o = 0, l = 0, c = 0, h = 0, d = t;
        if (1 === n && 1 === a) for(r = 0; r < e1; ++r){
            let e1 = s[r] ^ o;
            e1 ^= e1 >> 1, e1 ^= e1 >> 2, e1 ^= e1 >> 4, o = (1 & e1) << 7, i[d++] = e1;
        }
        else if (8 === n) {
            for(r = 0; r < a; ++r)i[d++] = s[r];
            for(; r < e1; ++r)i[d] = i[d - a] + s[r], d++;
        } else if (16 === n) {
            const t = 2 * a;
            for(r = 0; r < t; ++r)i[d++] = s[r];
            for(; r < e1; r += 2){
                const e1 = ((255 & s[r]) << 8) + (255 & s[r + 1]) + ((255 & i[d - t]) << 8) + (255 & i[d - t + 1]);
                i[d++] = e1 >> 8 & 255, i[d++] = 255 & e1;
            }
        } else {
            const e1 = new Uint8Array(a + 1), d = (1 << n) - 1;
            let u = 0, g = t;
            const f = this.columns;
            for(r = 0; r < f; ++r)for(let t = 0; t < a; ++t)c < n && (o = o << 8 | 255 & s[u++], c += 8), e1[t] = e1[t] + (o >> c - n) & d, c -= n, l = l << n | e1[t], h += n, h >= 8 && (i[g++] = l >> h - 8 & 255, h -= 8);
            h > 0 && (i[g++] = (l << 8 - h) + (o & (1 << 8 - h) - 1));
        }
        this.bufferLength += e1;
    }
    readBlockPng() {
        const e1 = this.rowBytes, t = this.pixBytes, i = this.str.getByte(), n = this.str.getBytes(e1);
        if (this.eof = !n.length, this.eof) return;
        const a = this.bufferLength, s = this.ensureBuffer(a + e1);
        let r = s.subarray(a - e1, a);
        0 === r.length && (r = new Uint8Array(e1));
        let o, l, c, h = a;
        switch(i){
            case 0:
                for(o = 0; o < e1; ++o)s[h++] = n[o];
                break;
            case 1:
                for(o = 0; o < t; ++o)s[h++] = n[o];
                for(; o < e1; ++o)s[h] = s[h - t] + n[o] & 255, h++;
                break;
            case 2:
                for(o = 0; o < e1; ++o)s[h++] = r[o] + n[o] & 255;
                break;
            case 3:
                for(o = 0; o < t; ++o)s[h++] = (r[o] >> 1) + n[o];
                for(; o < e1; ++o)s[h] = (r[o] + s[h - t] >> 1) + n[o] & 255, h++;
                break;
            case 4:
                for(o = 0; o < t; ++o)l = r[o], c = n[o], s[h++] = l + c;
                for(; o < e1; ++o){
                    l = r[o];
                    const e1 = r[o - t], i = s[h - t], a = i + l - e1;
                    let d = a - i;
                    d < 0 && (d = -d);
                    let u = a - l;
                    u < 0 && (u = -u);
                    let g = a - e1;
                    g < 0 && (g = -g), c = n[o], s[h++] = d <= u && d <= g ? i + c : u <= g ? l + c : e1 + c;
                }
                break;
            default:
                throw new ti(`Unsupported predictor: ${i}`);
        }
        this.bufferLength += e1;
    }
}
class RunLengthStream extends DecodeStream {
    constructor(e1, t){
        super(t), this.str = e1, this.dict = e1.dict;
    }
    readBlock() {
        const e1 = this.str.getBytes(2);
        if (!e1 || e1.length < 2 || 128 === e1[0]) return void (this.eof = !0);
        let t, i = this.bufferLength, n = e1[0];
        if (n < 128) {
            if (t = this.ensureBuffer(i + n + 1), t[i++] = e1[1], n > 0) {
                const e1 = this.str.getBytes(n);
                t.set(e1, i), i += n;
            }
        } else n = 257 - n, t = this.ensureBuffer(i + n + 1), t.fill(e1[1], i, i + n), i += n;
        this.bufferLength = i;
    }
}
class Parser {
    constructor({ lexer: e1, xref: t, allowStreams: i = !1, recoveryMode: n = !1 }){
        this.lexer = e1, this.xref = t, this.allowStreams = i, this.recoveryMode = n, this.imageCache = Object.create(null), this._imageId = 0, this.refill();
    }
    refill() {
        this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
    }
    shift() {
        this.buf2 instanceof Cmd && "ID" === this.buf2.cmd ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
    }
    tryShift() {
        try {
            return this.shift(), !0;
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            return !1;
        }
    }
    getObj(e1 = null) {
        const t = this.buf1;
        if (this.shift(), t instanceof Cmd) switch(t.cmd){
            case "BI":
                return this.makeInlineImage(e1);
            case "[":
                const i = [];
                for(; !isCmd(this.buf1, "]") && this.buf1 !== ci;)i.push(this.getObj(e1));
                if (this.buf1 === ci) {
                    if (this.recoveryMode) return i;
                    throw new ParserEOFException("End of file inside array.");
                }
                return this.shift(), i;
            case "<<":
                const n = new Dict(this.xref);
                for(; !isCmd(this.buf1, ">>") && this.buf1 !== ci;){
                    if (!(this.buf1 instanceof Name)) {
                        info$1("Malformed dictionary: key must be a name object"), this.shift();
                        continue;
                    }
                    const t = this.buf1.name;
                    if (this.shift(), this.buf1 === ci) break;
                    n.set(t, this.getObj(e1));
                }
                if (this.buf1 === ci) {
                    if (this.recoveryMode) return n;
                    throw new ParserEOFException("End of file inside dictionary.");
                }
                return isCmd(this.buf2, "stream") ? this.allowStreams ? this.makeStream(n, e1) : n : (this.shift(), n);
            default:
                return t;
        }
        if (Number.isInteger(t)) {
            if (Number.isInteger(this.buf1) && isCmd(this.buf2, "R")) {
                const e1 = Ref.get(t, this.buf1);
                return this.shift(), this.shift(), e1;
            }
            return t;
        }
        return "string" == typeof t && e1 ? e1.decryptString(t) : t;
    }
    findDefaultInlineStreamEnd(e1) {
        const { knownCommands: t } = this.lexer, i = e1.pos;
        let n, a, s = 0;
        for(; -1 !== (n = e1.getByte());)if (0 === s) s = 69 === n ? 1 : 0;
        else if (1 === s) s = 73 === n ? 2 : 0;
        else if (32 === n || 10 === n || 13 === n) {
            a = e1.pos;
            const i = e1.peekBytes(15), r = i.length;
            if (0 === r) break;
            for(let e1 = 0; e1 < r; e1++)if (n = i[e1], (0 !== n || 0 === i[e1 + 1]) && 10 !== n && 13 !== n && (n < 32 || n > 127)) {
                s = 0;
                break;
            }
            if (2 !== s) continue;
            if (!t) {
                warn$1("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
                continue;
            }
            const o = new Lexer(new Stream(e1.peekBytes(75)), t);
            o._hexStringWarn = ()=>{};
            let l = 0;
            for(;;){
                const e1 = o.getObj();
                if (e1 === ci) {
                    s = 0;
                    break;
                }
                if (e1 instanceof Cmd) {
                    const i = t[e1.cmd];
                    if (!i) {
                        s = 0;
                        break;
                    }
                    if (i.variableArgs ? l <= i.numArgs : l === i.numArgs) break;
                    l = 0;
                    continue;
                }
                l++;
            }
            if (2 === s) break;
        } else s = 0;
        -1 === n && (warn$1("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), a && (warn$1('... trying to recover by using the last "EI" occurrence.'), e1.skip(-(e1.pos - a))));
        let r = 4;
        return e1.skip(-r), n = e1.peekByte(), e1.skip(r), isWhiteSpace(n) || r--, e1.pos - r - i;
    }
    findDCTDecodeInlineStreamEnd(e1) {
        const t = e1.pos;
        let i, n, a = !1;
        for(; -1 !== (i = e1.getByte());)if (255 === i) {
            switch(e1.getByte()){
                case 0:
                    break;
                case 255:
                    e1.skip(-1);
                    break;
                case 217:
                    a = !0;
                    break;
                case 192:
                case 193:
                case 194:
                case 195:
                case 197:
                case 198:
                case 199:
                case 201:
                case 202:
                case 203:
                case 205:
                case 206:
                case 207:
                case 196:
                case 204:
                case 218:
                case 219:
                case 220:
                case 221:
                case 222:
                case 223:
                case 224:
                case 225:
                case 226:
                case 227:
                case 228:
                case 229:
                case 230:
                case 231:
                case 232:
                case 233:
                case 234:
                case 235:
                case 236:
                case 237:
                case 238:
                case 239:
                case 254:
                    n = e1.getUint16(), n > 2 ? e1.skip(n - 2) : e1.skip(-2);
            }
            if (a) break;
        }
        const s = e1.pos - t;
        return -1 === i ? (warn$1("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), e1.skip(-s), this.findDefaultInlineStreamEnd(e1)) : (this.inlineStreamSkipEI(e1), s);
    }
    findASCII85DecodeInlineStreamEnd(e1) {
        const t = e1.pos;
        let i;
        for(; -1 !== (i = e1.getByte());)if (126 === i) {
            const t = e1.pos;
            for(i = e1.peekByte(); isWhiteSpace(i);)e1.skip(), i = e1.peekByte();
            if (62 === i) {
                e1.skip();
                break;
            }
            if (e1.pos > t) {
                const t = e1.peekBytes(2);
                if (69 === t[0] && 73 === t[1]) break;
            }
        }
        const n = e1.pos - t;
        return -1 === i ? (warn$1("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), e1.skip(-n), this.findDefaultInlineStreamEnd(e1)) : (this.inlineStreamSkipEI(e1), n);
    }
    findASCIIHexDecodeInlineStreamEnd(e1) {
        const t = e1.pos;
        let i;
        for(; -1 !== (i = e1.getByte()) && 62 !== i;);
        const n = e1.pos - t;
        return -1 === i ? (warn$1("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), e1.skip(-n), this.findDefaultInlineStreamEnd(e1)) : (this.inlineStreamSkipEI(e1), n);
    }
    inlineStreamSkipEI(e1) {
        let t, i = 0;
        for(; -1 !== (t = e1.getByte());)if (0 === i) i = 69 === t ? 1 : 0;
        else if (1 === i) i = 73 === t ? 2 : 0;
        else if (2 === i) break;
    }
    makeInlineImage(e1) {
        const t = this.lexer, i = t.stream, n = Object.create(null);
        let a;
        for(; !isCmd(this.buf1, "ID") && this.buf1 !== ci;){
            if (!(this.buf1 instanceof Name)) throw new ti("Dictionary key must be a name object");
            const t = this.buf1.name;
            if (this.shift(), this.buf1 === ci) break;
            n[t] = this.getObj(e1);
        }
        -1 !== t.beginInlineImagePos && (a = i.pos - t.beginInlineImagePos);
        const s = this.xref.fetchIfRef(n.F || n.Filter);
        let r;
        if (s instanceof Name) r = s.name;
        else if (Array.isArray(s)) {
            const e1 = this.xref.fetchIfRef(s[0]);
            e1 instanceof Name && (r = e1.name);
        }
        const o = i.pos;
        let l, c;
        switch(r){
            case "DCT":
            case "DCTDecode":
                l = this.findDCTDecodeInlineStreamEnd(i);
                break;
            case "A85":
            case "ASCII85Decode":
                l = this.findASCII85DecodeInlineStreamEnd(i);
                break;
            case "AHx":
            case "ASCIIHexDecode":
                l = this.findASCIIHexDecodeInlineStreamEnd(i);
                break;
            default:
                l = this.findDefaultInlineStreamEnd(i);
        }
        if (l < 1e3 && a > 0) {
            const e1 = i.pos;
            i.pos = t.beginInlineImagePos, c = function(e1) {
                const t = [], i = e1.length;
                let n = 0;
                for(; n < i - 1;)t.push(e1[n++] << 8 | e1[n++]);
                return n < i && t.push(e1[n]), i + "_" + String.fromCharCode.apply(null, t);
            }(i.getBytes(a + l)), i.pos = e1;
            const n = this.imageCache[c];
            if (void 0 !== n) return this.buf2 = Cmd.get("EI"), this.shift(), n.reset(), n;
        }
        const h = new Dict(this.xref);
        for(const e1 in n)h.set(e1, n[e1]);
        let d = i.makeSubStream(o, l, h);
        return e1 && (d = e1.createStream(d, l)), d = this.filter(d, h, l), d.dict = h, void 0 !== c && (d.cacheKey = "inline_img_" + ++this._imageId, this.imageCache[c] = d), this.buf2 = Cmd.get("EI"), this.shift(), d;
    }
    #H(e1) {
        const { stream: t } = this.lexer;
        t.pos = e1;
        const i = new Uint8Array([
            101,
            110,
            100
        ]), n = i.length, a = [
            new Uint8Array([
                115,
                116,
                114,
                101,
                97,
                109
            ]),
            new Uint8Array([
                115,
                116,
                101,
                97,
                109
            ]),
            new Uint8Array([
                115,
                116,
                114,
                101,
                97
            ])
        ], s = 9 - n;
        for(; t.pos < t.end;){
            const r = t.peekBytes(2048), o = r.length - 9;
            if (o <= 0) break;
            let l = 0;
            for(; l < o;){
                let o = 0;
                for(; o < n && r[l + o] === i[o];)o++;
                if (o >= n) {
                    let n = !1;
                    for (const e1 of a){
                        const t = e1.length;
                        let a = 0;
                        for(; a < t && r[l + o + a] === e1[a];)a++;
                        if (a >= s) {
                            n = !0;
                            break;
                        }
                        if (a >= t) {
                            isWhiteSpace(r[l + o + a]) && (info$1(`Found "${bytesToString$1([
                                ...i,
                                ...e1
                            ])}" when searching for endstream command.`), n = !0);
                            break;
                        }
                    }
                    if (n) return t.pos += l, t.pos - e1;
                }
                l++;
            }
            t.pos += o;
        }
        return -1;
    }
    makeStream(e1, t) {
        const i = this.lexer;
        let n = i.stream;
        i.skipToNextLine();
        const a = n.pos - 1;
        let s = e1.get("Length");
        if (Number.isInteger(s) || (info$1(`Bad length "${s && s.toString()}" in stream.`), s = 0), n.pos = a + s, i.nextChar(), this.tryShift() && isCmd(this.buf2, "endstream")) this.shift();
        else {
            if (s = this.#H(a), s < 0) throw new ti("Missing endstream command.");
            i.nextChar(), this.shift(), this.shift();
        }
        return this.shift(), n = n.makeSubStream(a, s, e1), t && (n = t.createStream(n, s)), n = this.filter(n, e1, s), n.dict = e1, n;
    }
    filter(e1, t, i) {
        let n = t.get("F", "Filter"), a = t.get("DP", "DecodeParms");
        if (n instanceof Name) return Array.isArray(a) && warn$1("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(e1, n.name, i, a);
        let s = i;
        if (Array.isArray(n)) {
            const t = n, i = a;
            for(let r = 0, o = t.length; r < o; ++r){
                if (n = this.xref.fetchIfRef(t[r]), !(n instanceof Name)) throw new ti(`Bad filter name "${n}"`);
                a = null, Array.isArray(i) && r in i && (a = this.xref.fetchIfRef(i[r])), e1 = this.makeFilter(e1, n.name, s, a), s = null;
            }
        }
        return e1;
    }
    makeFilter(e1, t, i, n) {
        if (0 === i) return warn$1(`Empty "${t}" stream.`), new NullStream;
        try {
            switch(t){
                case "Fl":
                case "FlateDecode":
                    return n ? new PredictorStream(new FlateStream(e1, i), i, n) : new FlateStream(e1, i);
                case "LZW":
                case "LZWDecode":
                    let t1 = 1;
                    return n ? (n.has("EarlyChange") && (t1 = n.get("EarlyChange")), new PredictorStream(new LZWStream(e1, i, t1), i, n)) : new LZWStream(e1, i, t1);
                case "DCT":
                case "DCTDecode":
                    return new JpegStream(e1, i, n);
                case "JPX":
                case "JPXDecode":
                    return new JpxStream(e1, i, n);
                case "A85":
                case "ASCII85Decode":
                    return new Ascii85Stream(e1, i);
                case "AHx":
                case "ASCIIHexDecode":
                    return new AsciiHexStream(e1, i);
                case "CCF":
                case "CCITTFaxDecode":
                    return new CCITTFaxStream(e1, i, n);
                case "RL":
                case "RunLengthDecode":
                    return new RunLengthStream(e1, i);
                case "JBIG2Decode":
                    return new Jbig2Stream(e1, i, n);
            }
            return warn$1(`Filter "${t}" is not supported.`), e1;
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            return warn$1(`Invalid stream: "${e1}"`), new NullStream;
        }
    }
}
const rn = [
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    2,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
function toHexDigit(e1) {
    return e1 >= 48 && e1 <= 57 ? 15 & e1 : e1 >= 65 && e1 <= 70 || e1 >= 97 && e1 <= 102 ? 9 + (15 & e1) : -1;
}
class Lexer {
    constructor(e1, t = null){
        this.stream = e1, this.nextChar(), this.strBuf = [], this.knownCommands = t, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
    }
    nextChar() {
        return this.currentChar = this.stream.getByte();
    }
    peekChar() {
        return this.stream.peekByte();
    }
    getNumber() {
        let e1 = this.currentChar, t = !1, i = 0, n = 1;
        if (45 === e1 ? (n = -1, e1 = this.nextChar(), 45 === e1 && (e1 = this.nextChar())) : 43 === e1 && (e1 = this.nextChar()), 10 === e1 || 13 === e1) do {
            e1 = this.nextChar();
        }while (10 === e1 || 13 === e1)
        if (46 === e1 && (i = 10, e1 = this.nextChar()), e1 < 48 || e1 > 57) {
            const t = `Invalid number: ${String.fromCharCode(e1)} (charCode ${e1})`;
            if (isWhiteSpace(e1) || 40 === e1 || 60 === e1 || -1 === e1) return info$1(`Lexer.getNumber - "${t}".`), 0;
            throw new ti(t);
        }
        let a = e1 - 48, s = 0, r = 1;
        for(; (e1 = this.nextChar()) >= 0;)if (e1 >= 48 && e1 <= 57) {
            const n = e1 - 48;
            t ? s = 10 * s + n : (0 !== i && (i *= 10), a = 10 * a + n);
        } else if (46 === e1) {
            if (0 !== i) break;
            i = 1;
        } else if (45 === e1) warn$1("Badly formatted number: minus sign in the middle");
        else {
            if (69 !== e1 && 101 !== e1) break;
            if (e1 = this.peekChar(), 43 === e1 || 45 === e1) r = 45 === e1 ? -1 : 1, this.nextChar();
            else if (e1 < 48 || e1 > 57) break;
            t = !0;
        }
        return 0 !== i && (a /= i), t && (a *= 10 ** (r * s)), n * a;
    }
    getString() {
        let e1 = 1, t = !1;
        const i = this.strBuf;
        i.length = 0;
        let n = this.nextChar();
        for(;;){
            let a = !1;
            switch(0 | n){
                case -1:
                    warn$1("Unterminated string"), t = !0;
                    break;
                case 40:
                    ++e1, i.push("(");
                    break;
                case 41:
                    0 === --e1 ? (this.nextChar(), t = !0) : i.push(")");
                    break;
                case 92:
                    switch(n = this.nextChar(), n){
                        case -1:
                            warn$1("Unterminated string"), t = !0;
                            break;
                        case 110:
                            i.push("\n");
                            break;
                        case 114:
                            i.push("\r");
                            break;
                        case 116:
                            i.push("\t");
                            break;
                        case 98:
                            i.push("\b");
                            break;
                        case 102:
                            i.push("\f");
                            break;
                        case 92:
                        case 40:
                        case 41:
                            i.push(String.fromCharCode(n));
                            break;
                        case 48:
                        case 49:
                        case 50:
                        case 51:
                        case 52:
                        case 53:
                        case 54:
                        case 55:
                            let e2 = 15 & n;
                            n = this.nextChar(), a = !0, n >= 48 && n <= 55 && (e2 = (e2 << 3) + (15 & n), n = this.nextChar(), n >= 48 && n <= 55 && (a = !1, e2 = (e2 << 3) + (15 & n))), i.push(String.fromCharCode(e2));
                            break;
                        case 13:
                            10 === this.peekChar() && this.nextChar();
                            break;
                        case 10:
                            break;
                        default:
                            i.push(String.fromCharCode(n));
                    }
                    break;
                default:
                    i.push(String.fromCharCode(n));
            }
            if (t) break;
            a || (n = this.nextChar());
        }
        return i.join("");
    }
    getName() {
        let e1, t;
        const i = this.strBuf;
        for(i.length = 0; (e1 = this.nextChar()) >= 0 && !rn[e1];)if (35 === e1) {
            if (e1 = this.nextChar(), rn[e1]) {
                warn$1("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), i.push("#");
                break;
            }
            const n = toHexDigit(e1);
            if (-1 !== n) {
                t = e1, e1 = this.nextChar();
                const a = toHexDigit(e1);
                if (-1 === a) {
                    if (warn$1(`Lexer_getName: Illegal digit (${String.fromCharCode(e1)}) in hexadecimal number.`), i.push("#", String.fromCharCode(t)), rn[e1]) break;
                    i.push(String.fromCharCode(e1));
                    continue;
                }
                i.push(String.fromCharCode(n << 4 | a));
            } else i.push("#", String.fromCharCode(e1));
        } else i.push(String.fromCharCode(e1));
        return i.length > 127 && warn$1(`Name token is longer than allowed by the spec: ${i.length}`), Name.get(i.join(""));
    }
    _hexStringWarn(e1) {
        5 !== this._hexStringNumWarn++ ? this._hexStringNumWarn > 5 || warn$1(`getHexString - ignoring invalid character: ${e1}`) : warn$1("getHexString - ignoring additional invalid characters.");
    }
    getHexString() {
        const e1 = this.strBuf;
        e1.length = 0;
        let t = this.currentChar, i = -1, n = -1;
        for(this._hexStringNumWarn = 0;;){
            if (t < 0) {
                warn$1("Unterminated hex string");
                break;
            }
            if (62 === t) {
                this.nextChar();
                break;
            }
            1 !== rn[t] ? (n = toHexDigit(t), -1 === n ? this._hexStringWarn(t) : -1 === i ? i = n : (e1.push(String.fromCharCode(i << 4 | n)), i = -1), t = this.nextChar()) : t = this.nextChar();
        }
        return -1 !== i && e1.push(String.fromCharCode(i << 4)), e1.join("");
    }
    getObj() {
        let e1 = !1, t = this.currentChar;
        for(;;){
            if (t < 0) return ci;
            if (e1) 10 !== t && 13 !== t || (e1 = !1);
            else if (37 === t) e1 = !0;
            else if (1 !== rn[t]) break;
            t = this.nextChar();
        }
        switch(0 | t){
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 43:
            case 45:
            case 46:
                return this.getNumber();
            case 40:
                return this.getString();
            case 47:
                return this.getName();
            case 91:
                return this.nextChar(), Cmd.get("[");
            case 93:
                return this.nextChar(), Cmd.get("]");
            case 60:
                return t = this.nextChar(), 60 === t ? (this.nextChar(), Cmd.get("<<")) : this.getHexString();
            case 62:
                return t = this.nextChar(), 62 === t ? (this.nextChar(), Cmd.get(">>")) : Cmd.get(">");
            case 123:
                return this.nextChar(), Cmd.get("{");
            case 125:
                return this.nextChar(), Cmd.get("}");
            case 41:
                throw this.nextChar(), new ti(`Illegal character: ${t}`);
        }
        let i = String.fromCharCode(t);
        if (t < 32 || t > 127) {
            const e1 = this.peekChar();
            if (e1 >= 32 && e1 <= 127) return this.nextChar(), Cmd.get(i);
        }
        const n = this.knownCommands;
        let a = void 0 !== n?.[i];
        for(; (t = this.nextChar()) >= 0 && !rn[t];){
            const e1 = i + String.fromCharCode(t);
            if (a && void 0 === n[e1]) break;
            if (128 === i.length) throw new ti(`Command token too long: ${i.length}`);
            i = e1, a = void 0 !== n?.[i];
        }
        return "true" === i || "false" !== i && ("null" === i ? null : ("BI" === i && (this.beginInlineImagePos = this.stream.pos), Cmd.get(i)));
    }
    skipToNextLine() {
        let e1 = this.currentChar;
        for(; e1 >= 0;){
            if (13 === e1) {
                e1 = this.nextChar(), 10 === e1 && this.nextChar();
                break;
            }
            if (10 === e1) {
                this.nextChar();
                break;
            }
            e1 = this.nextChar();
        }
    }
}
class Linearization {
    static create(e1) {
        function getInt(e1, t, i = !1) {
            const n = e1.get(t);
            if (Number.isInteger(n) && (i ? n >= 0 : n > 0)) return n;
            throw new Error(`The "${t}" parameter in the linearization dictionary is invalid.`);
        }
        const t = new Parser({
            lexer: new Lexer(e1),
            xref: null
        }), i = t.getObj(), n = t.getObj(), a = t.getObj(), s = t.getObj();
        let r, o;
        if (!(Number.isInteger(i) && Number.isInteger(n) && isCmd(a, "obj") && s instanceof Dict && "number" == typeof (r = s.get("Linearized")) && r > 0)) return null;
        if ((o = getInt(s, "L")) !== e1.length) throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
        return {
            length: o,
            hints: function(e1) {
                const t = e1.get("H");
                let i;
                if (Array.isArray(t) && (2 === (i = t.length) || 4 === i)) {
                    for(let e1 = 0; e1 < i; e1++){
                        const i = t[e1];
                        if (!(Number.isInteger(i) && i > 0)) throw new Error(`Hint (${e1}) in the linearization dictionary is invalid.`);
                    }
                    return t;
                }
                throw new Error("Hint array in the linearization dictionary is invalid.");
            }(s),
            objectNumberFirst: getInt(s, "O"),
            endFirst: getInt(s, "E"),
            numPages: getInt(s, "N"),
            mainXRefEntriesOffset: getInt(s, "T"),
            pageFirst: s.has("P") ? getInt(s, "P", !0) : 0
        };
    }
}
const on = [
    "Adobe-GB1-UCS2",
    "Adobe-CNS1-UCS2",
    "Adobe-Japan1-UCS2",
    "Adobe-Korea1-UCS2",
    "78-EUC-H",
    "78-EUC-V",
    "78-H",
    "78-RKSJ-H",
    "78-RKSJ-V",
    "78-V",
    "78ms-RKSJ-H",
    "78ms-RKSJ-V",
    "83pv-RKSJ-H",
    "90ms-RKSJ-H",
    "90ms-RKSJ-V",
    "90msp-RKSJ-H",
    "90msp-RKSJ-V",
    "90pv-RKSJ-H",
    "90pv-RKSJ-V",
    "Add-H",
    "Add-RKSJ-H",
    "Add-RKSJ-V",
    "Add-V",
    "Adobe-CNS1-0",
    "Adobe-CNS1-1",
    "Adobe-CNS1-2",
    "Adobe-CNS1-3",
    "Adobe-CNS1-4",
    "Adobe-CNS1-5",
    "Adobe-CNS1-6",
    "Adobe-GB1-0",
    "Adobe-GB1-1",
    "Adobe-GB1-2",
    "Adobe-GB1-3",
    "Adobe-GB1-4",
    "Adobe-GB1-5",
    "Adobe-Japan1-0",
    "Adobe-Japan1-1",
    "Adobe-Japan1-2",
    "Adobe-Japan1-3",
    "Adobe-Japan1-4",
    "Adobe-Japan1-5",
    "Adobe-Japan1-6",
    "Adobe-Korea1-0",
    "Adobe-Korea1-1",
    "Adobe-Korea1-2",
    "B5-H",
    "B5-V",
    "B5pc-H",
    "B5pc-V",
    "CNS-EUC-H",
    "CNS-EUC-V",
    "CNS1-H",
    "CNS1-V",
    "CNS2-H",
    "CNS2-V",
    "ETHK-B5-H",
    "ETHK-B5-V",
    "ETen-B5-H",
    "ETen-B5-V",
    "ETenms-B5-H",
    "ETenms-B5-V",
    "EUC-H",
    "EUC-V",
    "Ext-H",
    "Ext-RKSJ-H",
    "Ext-RKSJ-V",
    "Ext-V",
    "GB-EUC-H",
    "GB-EUC-V",
    "GB-H",
    "GB-V",
    "GBK-EUC-H",
    "GBK-EUC-V",
    "GBK2K-H",
    "GBK2K-V",
    "GBKp-EUC-H",
    "GBKp-EUC-V",
    "GBT-EUC-H",
    "GBT-EUC-V",
    "GBT-H",
    "GBT-V",
    "GBTpc-EUC-H",
    "GBTpc-EUC-V",
    "GBpc-EUC-H",
    "GBpc-EUC-V",
    "H",
    "HKdla-B5-H",
    "HKdla-B5-V",
    "HKdlb-B5-H",
    "HKdlb-B5-V",
    "HKgccs-B5-H",
    "HKgccs-B5-V",
    "HKm314-B5-H",
    "HKm314-B5-V",
    "HKm471-B5-H",
    "HKm471-B5-V",
    "HKscs-B5-H",
    "HKscs-B5-V",
    "Hankaku",
    "Hiragana",
    "KSC-EUC-H",
    "KSC-EUC-V",
    "KSC-H",
    "KSC-Johab-H",
    "KSC-Johab-V",
    "KSC-V",
    "KSCms-UHC-H",
    "KSCms-UHC-HW-H",
    "KSCms-UHC-HW-V",
    "KSCms-UHC-V",
    "KSCpc-EUC-H",
    "KSCpc-EUC-V",
    "Katakana",
    "NWP-H",
    "NWP-V",
    "RKSJ-H",
    "RKSJ-V",
    "Roman",
    "UniCNS-UCS2-H",
    "UniCNS-UCS2-V",
    "UniCNS-UTF16-H",
    "UniCNS-UTF16-V",
    "UniCNS-UTF32-H",
    "UniCNS-UTF32-V",
    "UniCNS-UTF8-H",
    "UniCNS-UTF8-V",
    "UniGB-UCS2-H",
    "UniGB-UCS2-V",
    "UniGB-UTF16-H",
    "UniGB-UTF16-V",
    "UniGB-UTF32-H",
    "UniGB-UTF32-V",
    "UniGB-UTF8-H",
    "UniGB-UTF8-V",
    "UniJIS-UCS2-H",
    "UniJIS-UCS2-HW-H",
    "UniJIS-UCS2-HW-V",
    "UniJIS-UCS2-V",
    "UniJIS-UTF16-H",
    "UniJIS-UTF16-V",
    "UniJIS-UTF32-H",
    "UniJIS-UTF32-V",
    "UniJIS-UTF8-H",
    "UniJIS-UTF8-V",
    "UniJIS2004-UTF16-H",
    "UniJIS2004-UTF16-V",
    "UniJIS2004-UTF32-H",
    "UniJIS2004-UTF32-V",
    "UniJIS2004-UTF8-H",
    "UniJIS2004-UTF8-V",
    "UniJISPro-UCS2-HW-V",
    "UniJISPro-UCS2-V",
    "UniJISPro-UTF8-V",
    "UniJISX0213-UTF32-H",
    "UniJISX0213-UTF32-V",
    "UniJISX02132004-UTF32-H",
    "UniJISX02132004-UTF32-V",
    "UniKS-UCS2-H",
    "UniKS-UCS2-V",
    "UniKS-UTF16-H",
    "UniKS-UTF16-V",
    "UniKS-UTF32-H",
    "UniKS-UTF32-V",
    "UniKS-UTF8-H",
    "UniKS-UTF8-V",
    "V",
    "WP-Symbol"
], ln = 2 ** 24 - 1;
class CMap {
    constructor(e1 = !1){
        this.codespaceRanges = [
            [],
            [],
            [],
            []
        ], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = !1, this.useCMap = null, this.builtInCMap = e1;
    }
    addCodespaceRange(e1, t, i) {
        this.codespaceRanges[e1 - 1].push(t, i), this.numCodespaceRanges++;
    }
    mapCidRange(e1, t, i) {
        if (t - e1 > ln) throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
        for(; e1 <= t;)this._map[e1++] = i++;
    }
    mapBfRange(e1, t, i) {
        if (t - e1 > ln) throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
        const n = i.length - 1;
        for(; e1 <= t;){
            this._map[e1++] = i;
            const t = i.charCodeAt(n) + 1;
            t > 255 ? i = i.substring(0, n - 1) + String.fromCharCode(i.charCodeAt(n - 1) + 1) + "\0" : i = i.substring(0, n) + String.fromCharCode(t);
        }
    }
    mapBfRangeToArray(e1, t, i) {
        if (t - e1 > ln) throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
        const n = i.length;
        let a = 0;
        for(; e1 <= t && a < n;)this._map[e1] = i[a++], ++e1;
    }
    mapOne(e1, t) {
        this._map[e1] = t;
    }
    lookup(e1) {
        return this._map[e1];
    }
    contains(e1) {
        return void 0 !== this._map[e1];
    }
    forEach(e1) {
        const t = this._map, i = t.length;
        if (i <= 65536) for(let n = 0; n < i; n++)void 0 !== t[n] && e1(n, t[n]);
        else for(const i in t)e1(i, t[i]);
    }
    charCodeOf(e1) {
        const t = this._map;
        if (t.length <= 65536) return t.indexOf(e1);
        for(const i in t)if (t[i] === e1) return 0 | i;
        return -1;
    }
    getMap() {
        return this._map;
    }
    readCharCode(e1, t, i) {
        let n = 0;
        const a = this.codespaceRanges;
        for(let s = 0, r = a.length; s < r; s++){
            n = (n << 8 | e1.charCodeAt(t + s)) >>> 0;
            const r = a[s];
            for(let e1 = 0, t = r.length; e1 < t;){
                const t = r[e1++], a = r[e1++];
                if (n >= t && n <= a) return i.charcode = n, void (i.length = s + 1);
            }
        }
        i.charcode = 0, i.length = 1;
    }
    getCharCodeLength(e1) {
        const t = this.codespaceRanges;
        for(let i = 0, n = t.length; i < n; i++){
            const n = t[i];
            for(let t = 0, a = n.length; t < a;){
                const a = n[t++], s = n[t++];
                if (e1 >= a && e1 <= s) return i + 1;
            }
        }
        return 1;
    }
    get length() {
        return this._map.length;
    }
    get isIdentityCMap() {
        if ("Identity-H" !== this.name && "Identity-V" !== this.name) return !1;
        if (65536 !== this._map.length) return !1;
        for(let e1 = 0; e1 < 65536; e1++)if (this._map[e1] !== e1) return !1;
        return !0;
    }
}
class IdentityCMap extends CMap {
    constructor(e1, t){
        super(), this.vertical = e1, this.addCodespaceRange(t, 0, 65535);
    }
    mapCidRange(e1, t, i) {
        unreachable$1("should not call mapCidRange");
    }
    mapBfRange(e1, t, i) {
        unreachable$1("should not call mapBfRange");
    }
    mapBfRangeToArray(e1, t, i) {
        unreachable$1("should not call mapBfRangeToArray");
    }
    mapOne(e1, t) {
        unreachable$1("should not call mapCidOne");
    }
    lookup(e1) {
        return Number.isInteger(e1) && e1 <= 65535 ? e1 : void 0;
    }
    contains(e1) {
        return Number.isInteger(e1) && e1 <= 65535;
    }
    forEach(e1) {
        for(let t = 0; t <= 65535; t++)e1(t, t);
    }
    charCodeOf(e1) {
        return Number.isInteger(e1) && e1 <= 65535 ? e1 : -1;
    }
    getMap() {
        const e1 = new Array(65536);
        for(let t = 0; t <= 65535; t++)e1[t] = t;
        return e1;
    }
    get length() {
        return 65536;
    }
    get isIdentityCMap() {
        unreachable$1("should not access .isIdentityCMap");
    }
}
function strToInt(e1) {
    let t = 0;
    for(let i = 0; i < e1.length; i++)t = t << 8 | e1.charCodeAt(i);
    return t >>> 0;
}
function expectString(e1) {
    if ("string" != typeof e1) throw new ti("Malformed CMap: expected string.");
}
function expectInt(e1) {
    if (!Number.isInteger(e1)) throw new ti("Malformed CMap: expected int.");
}
function parseBfChar(e1, t) {
    for(;;){
        let i = t.getObj();
        if (i === ci) break;
        if (isCmd(i, "endbfchar")) return;
        expectString(i);
        const n = strToInt(i);
        i = t.getObj(), expectString(i);
        const a = i;
        e1.mapOne(n, a);
    }
}
function parseBfRange(e1, t) {
    for(;;){
        let i = t.getObj();
        if (i === ci) break;
        if (isCmd(i, "endbfrange")) return;
        expectString(i);
        const n = strToInt(i);
        i = t.getObj(), expectString(i);
        const a = strToInt(i);
        if (i = t.getObj(), Number.isInteger(i) || "string" == typeof i) {
            const t = Number.isInteger(i) ? String.fromCharCode(i) : i;
            e1.mapBfRange(n, a, t);
        } else {
            if (!isCmd(i, "[")) break;
            {
                i = t.getObj();
                const s = [];
                for(; !isCmd(i, "]") && i !== ci;)s.push(i), i = t.getObj();
                e1.mapBfRangeToArray(n, a, s);
            }
        }
    }
    throw new ti("Invalid bf range.");
}
function parseCidChar(e1, t) {
    for(;;){
        let i = t.getObj();
        if (i === ci) break;
        if (isCmd(i, "endcidchar")) return;
        expectString(i);
        const n = strToInt(i);
        i = t.getObj(), expectInt(i);
        const a = i;
        e1.mapOne(n, a);
    }
}
function parseCidRange(e1, t) {
    for(;;){
        let i = t.getObj();
        if (i === ci) break;
        if (isCmd(i, "endcidrange")) return;
        expectString(i);
        const n = strToInt(i);
        i = t.getObj(), expectString(i);
        const a = strToInt(i);
        i = t.getObj(), expectInt(i);
        const s = i;
        e1.mapCidRange(n, a, s);
    }
}
function parseCodespaceRange(e1, t) {
    for(;;){
        let i = t.getObj();
        if (i === ci) break;
        if (isCmd(i, "endcodespacerange")) return;
        if ("string" != typeof i) break;
        const n = strToInt(i);
        if (i = t.getObj(), "string" != typeof i) break;
        const a = strToInt(i);
        e1.addCodespaceRange(i.length, n, a);
    }
    throw new ti("Invalid codespace range.");
}
function parseWMode(e1, t) {
    const i = t.getObj();
    Number.isInteger(i) && (e1.vertical = !!i);
}
function parseCMapName(e1, t) {
    const i = t.getObj();
    i instanceof Name && (e1.name = i.name);
}
async function parseCMap(e1, t, i, n) {
    let a, s;
    e1: for(;;)try {
        const i = t.getObj();
        if (i === ci) break;
        if (i instanceof Name) "WMode" === i.name ? parseWMode(e1, t) : "CMapName" === i.name && parseCMapName(e1, t), a = i;
        else if (i instanceof Cmd) switch(i.cmd){
            case "endcmap":
                break e1;
            case "usecmap":
                a instanceof Name && (s = a.name);
                break;
            case "begincodespacerange":
                parseCodespaceRange(e1, t);
                break;
            case "beginbfchar":
                parseBfChar(e1, t);
                break;
            case "begincidchar":
                parseCidChar(e1, t);
                break;
            case "beginbfrange":
                parseBfRange(e1, t);
                break;
            case "begincidrange":
                parseCidRange(e1, t);
        }
    } catch (e1) {
        if (e1 instanceof MissingDataException) throw e1;
        warn$1("Invalid cMap data: " + e1);
        continue;
    }
    return !n && s && (n = s), n ? extendCMap(e1, i, n) : e1;
}
async function extendCMap(e1, t, i) {
    if (e1.useCMap = await createBuiltInCMap(i, t), 0 === e1.numCodespaceRanges) {
        const t = e1.useCMap.codespaceRanges;
        for(let i = 0; i < t.length; i++)e1.codespaceRanges[i] = t[i].slice();
        e1.numCodespaceRanges = e1.useCMap.numCodespaceRanges;
    }
    return e1.useCMap.forEach(function(t, i) {
        e1.contains(t) || e1.mapOne(t, i);
    }), e1;
}
async function createBuiltInCMap(e1, t) {
    if ("Identity-H" === e1) return new IdentityCMap(!1, 2);
    if ("Identity-V" === e1) return new IdentityCMap(!0, 2);
    if (!on.includes(e1)) throw new Error("Unknown CMap name: " + e1);
    if (!t) throw new Error("Built-in CMap parameters are not provided.");
    const { cMapData: i, isCompressed: n } = await t(e1), a = new CMap(!0);
    if (n) return (new BinaryCMapReader).process(i, a, (e1)=>extendCMap(a, t, e1));
    const s = new Lexer(new Stream(i));
    return parseCMap(a, s, t, null);
}
class CMapFactory {
    static async create({ encoding: e1, fetchBuiltInCMap: t, useCMap: i }) {
        if (e1 instanceof Name) return createBuiltInCMap(e1.name, t);
        if (e1 instanceof BaseStream) {
            const n = await parseCMap(new CMap, new Lexer(e1), t, i);
            return n.isIdentityCMap ? createBuiltInCMap(n.name, t) : n;
        }
        throw new Error("Encoding required.");
    }
}
const cn = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "",
    "",
    "",
    "isuperior",
    "",
    "",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "",
    "",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "",
    "",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "",
    "Dotaccentsmall",
    "",
    "",
    "Macronsmall",
    "",
    "",
    "figuredash",
    "hypheninferior",
    "",
    "",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "",
    "",
    "",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "",
    "",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall"
], hn = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "centoldstyle",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "",
    "threequartersemdash",
    "",
    "questionsmall",
    "",
    "",
    "",
    "",
    "Ethsmall",
    "",
    "",
    "onequarter",
    "onehalf",
    "threequarters",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "",
    "",
    "",
    "",
    "",
    "",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "",
    "parenrightinferior",
    "Circumflexsmall",
    "hypheninferior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "",
    "",
    "asuperior",
    "centsuperior",
    "",
    "",
    "",
    "",
    "Aacutesmall",
    "Agravesmall",
    "Acircumflexsmall",
    "Adieresissmall",
    "Atildesmall",
    "Aringsmall",
    "Ccedillasmall",
    "Eacutesmall",
    "Egravesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Iacutesmall",
    "Igravesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ntildesmall",
    "Oacutesmall",
    "Ogravesmall",
    "Ocircumflexsmall",
    "Odieresissmall",
    "Otildesmall",
    "Uacutesmall",
    "Ugravesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "",
    "eightsuperior",
    "fourinferior",
    "threeinferior",
    "sixinferior",
    "eightinferior",
    "seveninferior",
    "Scaronsmall",
    "",
    "centinferior",
    "twoinferior",
    "",
    "Dieresissmall",
    "",
    "Caronsmall",
    "osuperior",
    "fiveinferior",
    "",
    "commainferior",
    "periodinferior",
    "Yacutesmall",
    "",
    "dollarinferior",
    "",
    "",
    "Thornsmall",
    "",
    "nineinferior",
    "zeroinferior",
    "Zcaronsmall",
    "AEsmall",
    "Oslashsmall",
    "questiondownsmall",
    "oneinferior",
    "Lslashsmall",
    "",
    "",
    "",
    "",
    "",
    "",
    "Cedillasmall",
    "",
    "",
    "",
    "",
    "",
    "OEsmall",
    "figuredash",
    "hyphensuperior",
    "",
    "",
    "",
    "",
    "exclamdownsmall",
    "",
    "Ydieresissmall",
    "",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "ninesuperior",
    "zerosuperior",
    "",
    "esuperior",
    "rsuperior",
    "tsuperior",
    "",
    "",
    "isuperior",
    "ssuperior",
    "dsuperior",
    "",
    "",
    "",
    "",
    "",
    "lsuperior",
    "Ogoneksmall",
    "Brevesmall",
    "Macronsmall",
    "bsuperior",
    "nsuperior",
    "msuperior",
    "commasuperior",
    "periodsuperior",
    "Dotaccentsmall",
    "Ringsmall",
    "",
    "",
    "",
    ""
], dn = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "",
    "Adieresis",
    "Aring",
    "Ccedilla",
    "Eacute",
    "Ntilde",
    "Odieresis",
    "Udieresis",
    "aacute",
    "agrave",
    "acircumflex",
    "adieresis",
    "atilde",
    "aring",
    "ccedilla",
    "eacute",
    "egrave",
    "ecircumflex",
    "edieresis",
    "iacute",
    "igrave",
    "icircumflex",
    "idieresis",
    "ntilde",
    "oacute",
    "ograve",
    "ocircumflex",
    "odieresis",
    "otilde",
    "uacute",
    "ugrave",
    "ucircumflex",
    "udieresis",
    "dagger",
    "degree",
    "cent",
    "sterling",
    "section",
    "bullet",
    "paragraph",
    "germandbls",
    "registered",
    "copyright",
    "trademark",
    "acute",
    "dieresis",
    "notequal",
    "AE",
    "Oslash",
    "infinity",
    "plusminus",
    "lessequal",
    "greaterequal",
    "yen",
    "mu",
    "partialdiff",
    "summation",
    "product",
    "pi",
    "integral",
    "ordfeminine",
    "ordmasculine",
    "Omega",
    "ae",
    "oslash",
    "questiondown",
    "exclamdown",
    "logicalnot",
    "radical",
    "florin",
    "approxequal",
    "Delta",
    "guillemotleft",
    "guillemotright",
    "ellipsis",
    "space",
    "Agrave",
    "Atilde",
    "Otilde",
    "OE",
    "oe",
    "endash",
    "emdash",
    "quotedblleft",
    "quotedblright",
    "quoteleft",
    "quoteright",
    "divide",
    "lozenge",
    "ydieresis",
    "Ydieresis",
    "fraction",
    "currency",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "daggerdbl",
    "periodcentered",
    "quotesinglbase",
    "quotedblbase",
    "perthousand",
    "Acircumflex",
    "Ecircumflex",
    "Aacute",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Oacute",
    "Ocircumflex",
    "apple",
    "Ograve",
    "Uacute",
    "Ucircumflex",
    "Ugrave",
    "dotlessi",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron"
], un = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "",
    "questiondown",
    "",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "",
    "ring",
    "cedilla",
    "",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "AE",
    "",
    "ordfeminine",
    "",
    "",
    "",
    "",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "",
    "",
    "",
    "",
    "",
    "ae",
    "",
    "",
    "",
    "dotlessi",
    "",
    "",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "",
    "",
    "",
    ""
], gn = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "bullet",
    "Euro",
    "bullet",
    "quotesinglbase",
    "florin",
    "quotedblbase",
    "ellipsis",
    "dagger",
    "daggerdbl",
    "circumflex",
    "perthousand",
    "Scaron",
    "guilsinglleft",
    "OE",
    "bullet",
    "Zcaron",
    "bullet",
    "bullet",
    "quoteleft",
    "quoteright",
    "quotedblleft",
    "quotedblright",
    "bullet",
    "endash",
    "emdash",
    "tilde",
    "trademark",
    "scaron",
    "guilsinglright",
    "oe",
    "bullet",
    "zcaron",
    "Ydieresis",
    "space",
    "exclamdown",
    "cent",
    "sterling",
    "currency",
    "yen",
    "brokenbar",
    "section",
    "dieresis",
    "copyright",
    "ordfeminine",
    "guillemotleft",
    "logicalnot",
    "hyphen",
    "registered",
    "macron",
    "degree",
    "plusminus",
    "twosuperior",
    "threesuperior",
    "acute",
    "mu",
    "paragraph",
    "periodcentered",
    "cedilla",
    "onesuperior",
    "ordmasculine",
    "guillemotright",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondown",
    "Agrave",
    "Aacute",
    "Acircumflex",
    "Atilde",
    "Adieresis",
    "Aring",
    "AE",
    "Ccedilla",
    "Egrave",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Igrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Eth",
    "Ntilde",
    "Ograve",
    "Oacute",
    "Ocircumflex",
    "Otilde",
    "Odieresis",
    "multiply",
    "Oslash",
    "Ugrave",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Yacute",
    "Thorn",
    "germandbls",
    "agrave",
    "aacute",
    "acircumflex",
    "atilde",
    "adieresis",
    "aring",
    "ae",
    "ccedilla",
    "egrave",
    "eacute",
    "ecircumflex",
    "edieresis",
    "igrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "eth",
    "ntilde",
    "ograve",
    "oacute",
    "ocircumflex",
    "otilde",
    "odieresis",
    "divide",
    "oslash",
    "ugrave",
    "uacute",
    "ucircumflex",
    "udieresis",
    "yacute",
    "thorn",
    "ydieresis"
], fn = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "universal",
    "numbersign",
    "existential",
    "percent",
    "ampersand",
    "suchthat",
    "parenleft",
    "parenright",
    "asteriskmath",
    "plus",
    "comma",
    "minus",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "congruent",
    "Alpha",
    "Beta",
    "Chi",
    "Delta",
    "Epsilon",
    "Phi",
    "Gamma",
    "Eta",
    "Iota",
    "theta1",
    "Kappa",
    "Lambda",
    "Mu",
    "Nu",
    "Omicron",
    "Pi",
    "Theta",
    "Rho",
    "Sigma",
    "Tau",
    "Upsilon",
    "sigma1",
    "Omega",
    "Xi",
    "Psi",
    "Zeta",
    "bracketleft",
    "therefore",
    "bracketright",
    "perpendicular",
    "underscore",
    "radicalex",
    "alpha",
    "beta",
    "chi",
    "delta",
    "epsilon",
    "phi",
    "gamma",
    "eta",
    "iota",
    "phi1",
    "kappa",
    "lambda",
    "mu",
    "nu",
    "omicron",
    "pi",
    "theta",
    "rho",
    "sigma",
    "tau",
    "upsilon",
    "omega1",
    "omega",
    "xi",
    "psi",
    "zeta",
    "braceleft",
    "bar",
    "braceright",
    "similar",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Euro",
    "Upsilon1",
    "minute",
    "lessequal",
    "fraction",
    "infinity",
    "florin",
    "club",
    "diamond",
    "heart",
    "spade",
    "arrowboth",
    "arrowleft",
    "arrowup",
    "arrowright",
    "arrowdown",
    "degree",
    "plusminus",
    "second",
    "greaterequal",
    "multiply",
    "proportional",
    "partialdiff",
    "bullet",
    "divide",
    "notequal",
    "equivalence",
    "approxequal",
    "ellipsis",
    "arrowvertex",
    "arrowhorizex",
    "carriagereturn",
    "aleph",
    "Ifraktur",
    "Rfraktur",
    "weierstrass",
    "circlemultiply",
    "circleplus",
    "emptyset",
    "intersection",
    "union",
    "propersuperset",
    "reflexsuperset",
    "notsubset",
    "propersubset",
    "reflexsubset",
    "element",
    "notelement",
    "angle",
    "gradient",
    "registerserif",
    "copyrightserif",
    "trademarkserif",
    "product",
    "radical",
    "dotmath",
    "logicalnot",
    "logicaland",
    "logicalor",
    "arrowdblboth",
    "arrowdblleft",
    "arrowdblup",
    "arrowdblright",
    "arrowdbldown",
    "lozenge",
    "angleleft",
    "registersans",
    "copyrightsans",
    "trademarksans",
    "summation",
    "parenlefttp",
    "parenleftex",
    "parenleftbt",
    "bracketlefttp",
    "bracketleftex",
    "bracketleftbt",
    "bracelefttp",
    "braceleftmid",
    "braceleftbt",
    "braceex",
    "",
    "angleright",
    "integral",
    "integraltp",
    "integralex",
    "integralbt",
    "parenrighttp",
    "parenrightex",
    "parenrightbt",
    "bracketrighttp",
    "bracketrightex",
    "bracketrightbt",
    "bracerighttp",
    "bracerightmid",
    "bracerightbt",
    ""
], pn = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "a1",
    "a2",
    "a202",
    "a3",
    "a4",
    "a5",
    "a119",
    "a118",
    "a117",
    "a11",
    "a12",
    "a13",
    "a14",
    "a15",
    "a16",
    "a105",
    "a17",
    "a18",
    "a19",
    "a20",
    "a21",
    "a22",
    "a23",
    "a24",
    "a25",
    "a26",
    "a27",
    "a28",
    "a6",
    "a7",
    "a8",
    "a9",
    "a10",
    "a29",
    "a30",
    "a31",
    "a32",
    "a33",
    "a34",
    "a35",
    "a36",
    "a37",
    "a38",
    "a39",
    "a40",
    "a41",
    "a42",
    "a43",
    "a44",
    "a45",
    "a46",
    "a47",
    "a48",
    "a49",
    "a50",
    "a51",
    "a52",
    "a53",
    "a54",
    "a55",
    "a56",
    "a57",
    "a58",
    "a59",
    "a60",
    "a61",
    "a62",
    "a63",
    "a64",
    "a65",
    "a66",
    "a67",
    "a68",
    "a69",
    "a70",
    "a71",
    "a72",
    "a73",
    "a74",
    "a203",
    "a75",
    "a204",
    "a76",
    "a77",
    "a78",
    "a79",
    "a81",
    "a82",
    "a83",
    "a84",
    "a97",
    "a98",
    "a99",
    "a100",
    "",
    "a89",
    "a90",
    "a93",
    "a94",
    "a91",
    "a92",
    "a205",
    "a85",
    "a206",
    "a86",
    "a87",
    "a88",
    "a95",
    "a96",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "a101",
    "a102",
    "a103",
    "a104",
    "a106",
    "a107",
    "a108",
    "a112",
    "a111",
    "a110",
    "a109",
    "a120",
    "a121",
    "a122",
    "a123",
    "a124",
    "a125",
    "a126",
    "a127",
    "a128",
    "a129",
    "a130",
    "a131",
    "a132",
    "a133",
    "a134",
    "a135",
    "a136",
    "a137",
    "a138",
    "a139",
    "a140",
    "a141",
    "a142",
    "a143",
    "a144",
    "a145",
    "a146",
    "a147",
    "a148",
    "a149",
    "a150",
    "a151",
    "a152",
    "a153",
    "a154",
    "a155",
    "a156",
    "a157",
    "a158",
    "a159",
    "a160",
    "a161",
    "a163",
    "a164",
    "a196",
    "a165",
    "a192",
    "a166",
    "a167",
    "a168",
    "a169",
    "a170",
    "a171",
    "a172",
    "a173",
    "a162",
    "a174",
    "a175",
    "a176",
    "a177",
    "a178",
    "a179",
    "a193",
    "a180",
    "a199",
    "a181",
    "a200",
    "a182",
    "",
    "a201",
    "a183",
    "a184",
    "a197",
    "a185",
    "a194",
    "a198",
    "a186",
    "a195",
    "a187",
    "a188",
    "a189",
    "a190",
    "a191",
    ""
];
function getEncoding(e1) {
    switch(e1){
        case "WinAnsiEncoding":
            return gn;
        case "StandardEncoding":
            return un;
        case "MacRomanEncoding":
            return dn;
        case "SymbolSetEncoding":
            return fn;
        case "ZapfDingbatsEncoding":
            return pn;
        case "ExpertEncoding":
            return cn;
        case "MacExpertEncoding":
            return hn;
        default:
            return null;
    }
}
const mn = getLookupTableFactory(function(e1) {
    e1.A = 65, e1.AE = 198, e1.AEacute = 508, e1.AEmacron = 482, e1.AEsmall = 63462, e1.Aacute = 193, e1.Aacutesmall = 63457, e1.Abreve = 258, e1.Abreveacute = 7854, e1.Abrevecyrillic = 1232, e1.Abrevedotbelow = 7862, e1.Abrevegrave = 7856, e1.Abrevehookabove = 7858, e1.Abrevetilde = 7860, e1.Acaron = 461, e1.Acircle = 9398, e1.Acircumflex = 194, e1.Acircumflexacute = 7844, e1.Acircumflexdotbelow = 7852, e1.Acircumflexgrave = 7846, e1.Acircumflexhookabove = 7848, e1.Acircumflexsmall = 63458, e1.Acircumflextilde = 7850, e1.Acute = 63177, e1.Acutesmall = 63412, e1.Acyrillic = 1040, e1.Adblgrave = 512, e1.Adieresis = 196, e1.Adieresiscyrillic = 1234, e1.Adieresismacron = 478, e1.Adieresissmall = 63460, e1.Adotbelow = 7840, e1.Adotmacron = 480, e1.Agrave = 192, e1.Agravesmall = 63456, e1.Ahookabove = 7842, e1.Aiecyrillic = 1236, e1.Ainvertedbreve = 514, e1.Alpha = 913, e1.Alphatonos = 902, e1.Amacron = 256, e1.Amonospace = 65313, e1.Aogonek = 260, e1.Aring = 197, e1.Aringacute = 506, e1.Aringbelow = 7680, e1.Aringsmall = 63461, e1.Asmall = 63329, e1.Atilde = 195, e1.Atildesmall = 63459, e1.Aybarmenian = 1329, e1.B = 66, e1.Bcircle = 9399, e1.Bdotaccent = 7682, e1.Bdotbelow = 7684, e1.Becyrillic = 1041, e1.Benarmenian = 1330, e1.Beta = 914, e1.Bhook = 385, e1.Blinebelow = 7686, e1.Bmonospace = 65314, e1.Brevesmall = 63220, e1.Bsmall = 63330, e1.Btopbar = 386, e1.C = 67, e1.Caarmenian = 1342, e1.Cacute = 262, e1.Caron = 63178, e1.Caronsmall = 63221, e1.Ccaron = 268, e1.Ccedilla = 199, e1.Ccedillaacute = 7688, e1.Ccedillasmall = 63463, e1.Ccircle = 9400, e1.Ccircumflex = 264, e1.Cdot = 266, e1.Cdotaccent = 266, e1.Cedillasmall = 63416, e1.Chaarmenian = 1353, e1.Cheabkhasiancyrillic = 1212, e1.Checyrillic = 1063, e1.Chedescenderabkhasiancyrillic = 1214, e1.Chedescendercyrillic = 1206, e1.Chedieresiscyrillic = 1268, e1.Cheharmenian = 1347, e1.Chekhakassiancyrillic = 1227, e1.Cheverticalstrokecyrillic = 1208, e1.Chi = 935, e1.Chook = 391, e1.Circumflexsmall = 63222, e1.Cmonospace = 65315, e1.Coarmenian = 1361, e1.Csmall = 63331, e1.D = 68, e1.DZ = 497, e1.DZcaron = 452, e1.Daarmenian = 1332, e1.Dafrican = 393, e1.Dcaron = 270, e1.Dcedilla = 7696, e1.Dcircle = 9401, e1.Dcircumflexbelow = 7698, e1.Dcroat = 272, e1.Ddotaccent = 7690, e1.Ddotbelow = 7692, e1.Decyrillic = 1044, e1.Deicoptic = 1006, e1.Delta = 8710, e1.Deltagreek = 916, e1.Dhook = 394, e1.Dieresis = 63179, e1.DieresisAcute = 63180, e1.DieresisGrave = 63181, e1.Dieresissmall = 63400, e1.Digammagreek = 988, e1.Djecyrillic = 1026, e1.Dlinebelow = 7694, e1.Dmonospace = 65316, e1.Dotaccentsmall = 63223, e1.Dslash = 272, e1.Dsmall = 63332, e1.Dtopbar = 395, e1.Dz = 498, e1.Dzcaron = 453, e1.Dzeabkhasiancyrillic = 1248, e1.Dzecyrillic = 1029, e1.Dzhecyrillic = 1039, e1.E = 69, e1.Eacute = 201, e1.Eacutesmall = 63465, e1.Ebreve = 276, e1.Ecaron = 282, e1.Ecedillabreve = 7708, e1.Echarmenian = 1333, e1.Ecircle = 9402, e1.Ecircumflex = 202, e1.Ecircumflexacute = 7870, e1.Ecircumflexbelow = 7704, e1.Ecircumflexdotbelow = 7878, e1.Ecircumflexgrave = 7872, e1.Ecircumflexhookabove = 7874, e1.Ecircumflexsmall = 63466, e1.Ecircumflextilde = 7876, e1.Ecyrillic = 1028, e1.Edblgrave = 516, e1.Edieresis = 203, e1.Edieresissmall = 63467, e1.Edot = 278, e1.Edotaccent = 278, e1.Edotbelow = 7864, e1.Efcyrillic = 1060, e1.Egrave = 200, e1.Egravesmall = 63464, e1.Eharmenian = 1335, e1.Ehookabove = 7866, e1.Eightroman = 8551, e1.Einvertedbreve = 518, e1.Eiotifiedcyrillic = 1124, e1.Elcyrillic = 1051, e1.Elevenroman = 8554, e1.Emacron = 274, e1.Emacronacute = 7702, e1.Emacrongrave = 7700, e1.Emcyrillic = 1052, e1.Emonospace = 65317, e1.Encyrillic = 1053, e1.Endescendercyrillic = 1186, e1.Eng = 330, e1.Enghecyrillic = 1188, e1.Enhookcyrillic = 1223, e1.Eogonek = 280, e1.Eopen = 400, e1.Epsilon = 917, e1.Epsilontonos = 904, e1.Ercyrillic = 1056, e1.Ereversed = 398, e1.Ereversedcyrillic = 1069, e1.Escyrillic = 1057, e1.Esdescendercyrillic = 1194, e1.Esh = 425, e1.Esmall = 63333, e1.Eta = 919, e1.Etarmenian = 1336, e1.Etatonos = 905, e1.Eth = 208, e1.Ethsmall = 63472, e1.Etilde = 7868, e1.Etildebelow = 7706, e1.Euro = 8364, e1.Ezh = 439, e1.Ezhcaron = 494, e1.Ezhreversed = 440, e1.F = 70, e1.Fcircle = 9403, e1.Fdotaccent = 7710, e1.Feharmenian = 1366, e1.Feicoptic = 996, e1.Fhook = 401, e1.Fitacyrillic = 1138, e1.Fiveroman = 8548, e1.Fmonospace = 65318, e1.Fourroman = 8547, e1.Fsmall = 63334, e1.G = 71, e1.GBsquare = 13191, e1.Gacute = 500, e1.Gamma = 915, e1.Gammaafrican = 404, e1.Gangiacoptic = 1002, e1.Gbreve = 286, e1.Gcaron = 486, e1.Gcedilla = 290, e1.Gcircle = 9404, e1.Gcircumflex = 284, e1.Gcommaaccent = 290, e1.Gdot = 288, e1.Gdotaccent = 288, e1.Gecyrillic = 1043, e1.Ghadarmenian = 1346, e1.Ghemiddlehookcyrillic = 1172, e1.Ghestrokecyrillic = 1170, e1.Gheupturncyrillic = 1168, e1.Ghook = 403, e1.Gimarmenian = 1331, e1.Gjecyrillic = 1027, e1.Gmacron = 7712, e1.Gmonospace = 65319, e1.Grave = 63182, e1.Gravesmall = 63328, e1.Gsmall = 63335, e1.Gsmallhook = 667, e1.Gstroke = 484, e1.H = 72, e1.H18533 = 9679, e1.H18543 = 9642, e1.H18551 = 9643, e1.H22073 = 9633, e1.HPsquare = 13259, e1.Haabkhasiancyrillic = 1192, e1.Hadescendercyrillic = 1202, e1.Hardsigncyrillic = 1066, e1.Hbar = 294, e1.Hbrevebelow = 7722, e1.Hcedilla = 7720, e1.Hcircle = 9405, e1.Hcircumflex = 292, e1.Hdieresis = 7718, e1.Hdotaccent = 7714, e1.Hdotbelow = 7716, e1.Hmonospace = 65320, e1.Hoarmenian = 1344, e1.Horicoptic = 1e3, e1.Hsmall = 63336, e1.Hungarumlaut = 63183, e1.Hungarumlautsmall = 63224, e1.Hzsquare = 13200, e1.I = 73, e1.IAcyrillic = 1071, e1.IJ = 306, e1.IUcyrillic = 1070, e1.Iacute = 205, e1.Iacutesmall = 63469, e1.Ibreve = 300, e1.Icaron = 463, e1.Icircle = 9406, e1.Icircumflex = 206, e1.Icircumflexsmall = 63470, e1.Icyrillic = 1030, e1.Idblgrave = 520, e1.Idieresis = 207, e1.Idieresisacute = 7726, e1.Idieresiscyrillic = 1252, e1.Idieresissmall = 63471, e1.Idot = 304, e1.Idotaccent = 304, e1.Idotbelow = 7882, e1.Iebrevecyrillic = 1238, e1.Iecyrillic = 1045, e1.Ifraktur = 8465, e1.Igrave = 204, e1.Igravesmall = 63468, e1.Ihookabove = 7880, e1.Iicyrillic = 1048, e1.Iinvertedbreve = 522, e1.Iishortcyrillic = 1049, e1.Imacron = 298, e1.Imacroncyrillic = 1250, e1.Imonospace = 65321, e1.Iniarmenian = 1339, e1.Iocyrillic = 1025, e1.Iogonek = 302, e1.Iota = 921, e1.Iotaafrican = 406, e1.Iotadieresis = 938, e1.Iotatonos = 906, e1.Ismall = 63337, e1.Istroke = 407, e1.Itilde = 296, e1.Itildebelow = 7724, e1.Izhitsacyrillic = 1140, e1.Izhitsadblgravecyrillic = 1142, e1.J = 74, e1.Jaarmenian = 1345, e1.Jcircle = 9407, e1.Jcircumflex = 308, e1.Jecyrillic = 1032, e1.Jheharmenian = 1355, e1.Jmonospace = 65322, e1.Jsmall = 63338, e1.K = 75, e1.KBsquare = 13189, e1.KKsquare = 13261, e1.Kabashkircyrillic = 1184, e1.Kacute = 7728, e1.Kacyrillic = 1050, e1.Kadescendercyrillic = 1178, e1.Kahookcyrillic = 1219, e1.Kappa = 922, e1.Kastrokecyrillic = 1182, e1.Kaverticalstrokecyrillic = 1180, e1.Kcaron = 488, e1.Kcedilla = 310, e1.Kcircle = 9408, e1.Kcommaaccent = 310, e1.Kdotbelow = 7730, e1.Keharmenian = 1364, e1.Kenarmenian = 1343, e1.Khacyrillic = 1061, e1.Kheicoptic = 998, e1.Khook = 408, e1.Kjecyrillic = 1036, e1.Klinebelow = 7732, e1.Kmonospace = 65323, e1.Koppacyrillic = 1152, e1.Koppagreek = 990, e1.Ksicyrillic = 1134, e1.Ksmall = 63339, e1.L = 76, e1.LJ = 455, e1.LL = 63167, e1.Lacute = 313, e1.Lambda = 923, e1.Lcaron = 317, e1.Lcedilla = 315, e1.Lcircle = 9409, e1.Lcircumflexbelow = 7740, e1.Lcommaaccent = 315, e1.Ldot = 319, e1.Ldotaccent = 319, e1.Ldotbelow = 7734, e1.Ldotbelowmacron = 7736, e1.Liwnarmenian = 1340, e1.Lj = 456, e1.Ljecyrillic = 1033, e1.Llinebelow = 7738, e1.Lmonospace = 65324, e1.Lslash = 321, e1.Lslashsmall = 63225, e1.Lsmall = 63340, e1.M = 77, e1.MBsquare = 13190, e1.Macron = 63184, e1.Macronsmall = 63407, e1.Macute = 7742, e1.Mcircle = 9410, e1.Mdotaccent = 7744, e1.Mdotbelow = 7746, e1.Menarmenian = 1348, e1.Mmonospace = 65325, e1.Msmall = 63341, e1.Mturned = 412, e1.Mu = 924, e1.N = 78, e1.NJ = 458, e1.Nacute = 323, e1.Ncaron = 327, e1.Ncedilla = 325, e1.Ncircle = 9411, e1.Ncircumflexbelow = 7754, e1.Ncommaaccent = 325, e1.Ndotaccent = 7748, e1.Ndotbelow = 7750, e1.Nhookleft = 413, e1.Nineroman = 8552, e1.Nj = 459, e1.Njecyrillic = 1034, e1.Nlinebelow = 7752, e1.Nmonospace = 65326, e1.Nowarmenian = 1350, e1.Nsmall = 63342, e1.Ntilde = 209, e1.Ntildesmall = 63473, e1.Nu = 925, e1.O = 79, e1.OE = 338, e1.OEsmall = 63226, e1.Oacute = 211, e1.Oacutesmall = 63475, e1.Obarredcyrillic = 1256, e1.Obarreddieresiscyrillic = 1258, e1.Obreve = 334, e1.Ocaron = 465, e1.Ocenteredtilde = 415, e1.Ocircle = 9412, e1.Ocircumflex = 212, e1.Ocircumflexacute = 7888, e1.Ocircumflexdotbelow = 7896, e1.Ocircumflexgrave = 7890, e1.Ocircumflexhookabove = 7892, e1.Ocircumflexsmall = 63476, e1.Ocircumflextilde = 7894, e1.Ocyrillic = 1054, e1.Odblacute = 336, e1.Odblgrave = 524, e1.Odieresis = 214, e1.Odieresiscyrillic = 1254, e1.Odieresissmall = 63478, e1.Odotbelow = 7884, e1.Ogoneksmall = 63227, e1.Ograve = 210, e1.Ogravesmall = 63474, e1.Oharmenian = 1365, e1.Ohm = 8486, e1.Ohookabove = 7886, e1.Ohorn = 416, e1.Ohornacute = 7898, e1.Ohorndotbelow = 7906, e1.Ohorngrave = 7900, e1.Ohornhookabove = 7902, e1.Ohorntilde = 7904, e1.Ohungarumlaut = 336, e1.Oi = 418, e1.Oinvertedbreve = 526, e1.Omacron = 332, e1.Omacronacute = 7762, e1.Omacrongrave = 7760, e1.Omega = 8486, e1.Omegacyrillic = 1120, e1.Omegagreek = 937, e1.Omegaroundcyrillic = 1146, e1.Omegatitlocyrillic = 1148, e1.Omegatonos = 911, e1.Omicron = 927, e1.Omicrontonos = 908, e1.Omonospace = 65327, e1.Oneroman = 8544, e1.Oogonek = 490, e1.Oogonekmacron = 492, e1.Oopen = 390, e1.Oslash = 216, e1.Oslashacute = 510, e1.Oslashsmall = 63480, e1.Osmall = 63343, e1.Ostrokeacute = 510, e1.Otcyrillic = 1150, e1.Otilde = 213, e1.Otildeacute = 7756, e1.Otildedieresis = 7758, e1.Otildesmall = 63477, e1.P = 80, e1.Pacute = 7764, e1.Pcircle = 9413, e1.Pdotaccent = 7766, e1.Pecyrillic = 1055, e1.Peharmenian = 1354, e1.Pemiddlehookcyrillic = 1190, e1.Phi = 934, e1.Phook = 420, e1.Pi = 928, e1.Piwrarmenian = 1363, e1.Pmonospace = 65328, e1.Psi = 936, e1.Psicyrillic = 1136, e1.Psmall = 63344, e1.Q = 81, e1.Qcircle = 9414, e1.Qmonospace = 65329, e1.Qsmall = 63345, e1.R = 82, e1.Raarmenian = 1356, e1.Racute = 340, e1.Rcaron = 344, e1.Rcedilla = 342, e1.Rcircle = 9415, e1.Rcommaaccent = 342, e1.Rdblgrave = 528, e1.Rdotaccent = 7768, e1.Rdotbelow = 7770, e1.Rdotbelowmacron = 7772, e1.Reharmenian = 1360, e1.Rfraktur = 8476, e1.Rho = 929, e1.Ringsmall = 63228, e1.Rinvertedbreve = 530, e1.Rlinebelow = 7774, e1.Rmonospace = 65330, e1.Rsmall = 63346, e1.Rsmallinverted = 641, e1.Rsmallinvertedsuperior = 694, e1.S = 83, e1.SF010000 = 9484, e1.SF020000 = 9492, e1.SF030000 = 9488, e1.SF040000 = 9496, e1.SF050000 = 9532, e1.SF060000 = 9516, e1.SF070000 = 9524, e1.SF080000 = 9500, e1.SF090000 = 9508, e1.SF100000 = 9472, e1.SF110000 = 9474, e1.SF190000 = 9569, e1.SF200000 = 9570, e1.SF210000 = 9558, e1.SF220000 = 9557, e1.SF230000 = 9571, e1.SF240000 = 9553, e1.SF250000 = 9559, e1.SF260000 = 9565, e1.SF270000 = 9564, e1.SF280000 = 9563, e1.SF360000 = 9566, e1.SF370000 = 9567, e1.SF380000 = 9562, e1.SF390000 = 9556, e1.SF400000 = 9577, e1.SF410000 = 9574, e1.SF420000 = 9568, e1.SF430000 = 9552, e1.SF440000 = 9580, e1.SF450000 = 9575, e1.SF460000 = 9576, e1.SF470000 = 9572, e1.SF480000 = 9573, e1.SF490000 = 9561, e1.SF500000 = 9560, e1.SF510000 = 9554, e1.SF520000 = 9555, e1.SF530000 = 9579, e1.SF540000 = 9578, e1.Sacute = 346, e1.Sacutedotaccent = 7780, e1.Sampigreek = 992, e1.Scaron = 352, e1.Scarondotaccent = 7782, e1.Scaronsmall = 63229, e1.Scedilla = 350, e1.Schwa = 399, e1.Schwacyrillic = 1240, e1.Schwadieresiscyrillic = 1242, e1.Scircle = 9416, e1.Scircumflex = 348, e1.Scommaaccent = 536, e1.Sdotaccent = 7776, e1.Sdotbelow = 7778, e1.Sdotbelowdotaccent = 7784, e1.Seharmenian = 1357, e1.Sevenroman = 8550, e1.Shaarmenian = 1351, e1.Shacyrillic = 1064, e1.Shchacyrillic = 1065, e1.Sheicoptic = 994, e1.Shhacyrillic = 1210, e1.Shimacoptic = 1004, e1.Sigma = 931, e1.Sixroman = 8549, e1.Smonospace = 65331, e1.Softsigncyrillic = 1068, e1.Ssmall = 63347, e1.Stigmagreek = 986, e1.T = 84, e1.Tau = 932, e1.Tbar = 358, e1.Tcaron = 356, e1.Tcedilla = 354, e1.Tcircle = 9417, e1.Tcircumflexbelow = 7792, e1.Tcommaaccent = 354, e1.Tdotaccent = 7786, e1.Tdotbelow = 7788, e1.Tecyrillic = 1058, e1.Tedescendercyrillic = 1196, e1.Tenroman = 8553, e1.Tetsecyrillic = 1204, e1.Theta = 920, e1.Thook = 428, e1.Thorn = 222, e1.Thornsmall = 63486, e1.Threeroman = 8546, e1.Tildesmall = 63230, e1.Tiwnarmenian = 1359, e1.Tlinebelow = 7790, e1.Tmonospace = 65332, e1.Toarmenian = 1337, e1.Tonefive = 444, e1.Tonesix = 388, e1.Tonetwo = 423, e1.Tretroflexhook = 430, e1.Tsecyrillic = 1062, e1.Tshecyrillic = 1035, e1.Tsmall = 63348, e1.Twelveroman = 8555, e1.Tworoman = 8545, e1.U = 85, e1.Uacute = 218, e1.Uacutesmall = 63482, e1.Ubreve = 364, e1.Ucaron = 467, e1.Ucircle = 9418, e1.Ucircumflex = 219, e1.Ucircumflexbelow = 7798, e1.Ucircumflexsmall = 63483, e1.Ucyrillic = 1059, e1.Udblacute = 368, e1.Udblgrave = 532, e1.Udieresis = 220, e1.Udieresisacute = 471, e1.Udieresisbelow = 7794, e1.Udieresiscaron = 473, e1.Udieresiscyrillic = 1264, e1.Udieresisgrave = 475, e1.Udieresismacron = 469, e1.Udieresissmall = 63484, e1.Udotbelow = 7908, e1.Ugrave = 217, e1.Ugravesmall = 63481, e1.Uhookabove = 7910, e1.Uhorn = 431, e1.Uhornacute = 7912, e1.Uhorndotbelow = 7920, e1.Uhorngrave = 7914, e1.Uhornhookabove = 7916, e1.Uhorntilde = 7918, e1.Uhungarumlaut = 368, e1.Uhungarumlautcyrillic = 1266, e1.Uinvertedbreve = 534, e1.Ukcyrillic = 1144, e1.Umacron = 362, e1.Umacroncyrillic = 1262, e1.Umacrondieresis = 7802, e1.Umonospace = 65333, e1.Uogonek = 370, e1.Upsilon = 933, e1.Upsilon1 = 978, e1.Upsilonacutehooksymbolgreek = 979, e1.Upsilonafrican = 433, e1.Upsilondieresis = 939, e1.Upsilondieresishooksymbolgreek = 980, e1.Upsilonhooksymbol = 978, e1.Upsilontonos = 910, e1.Uring = 366, e1.Ushortcyrillic = 1038, e1.Usmall = 63349, e1.Ustraightcyrillic = 1198, e1.Ustraightstrokecyrillic = 1200, e1.Utilde = 360, e1.Utildeacute = 7800, e1.Utildebelow = 7796, e1.V = 86, e1.Vcircle = 9419, e1.Vdotbelow = 7806, e1.Vecyrillic = 1042, e1.Vewarmenian = 1358, e1.Vhook = 434, e1.Vmonospace = 65334, e1.Voarmenian = 1352, e1.Vsmall = 63350, e1.Vtilde = 7804, e1.W = 87, e1.Wacute = 7810, e1.Wcircle = 9420, e1.Wcircumflex = 372, e1.Wdieresis = 7812, e1.Wdotaccent = 7814, e1.Wdotbelow = 7816, e1.Wgrave = 7808, e1.Wmonospace = 65335, e1.Wsmall = 63351, e1.X = 88, e1.Xcircle = 9421, e1.Xdieresis = 7820, e1.Xdotaccent = 7818, e1.Xeharmenian = 1341, e1.Xi = 926, e1.Xmonospace = 65336, e1.Xsmall = 63352, e1.Y = 89, e1.Yacute = 221, e1.Yacutesmall = 63485, e1.Yatcyrillic = 1122, e1.Ycircle = 9422, e1.Ycircumflex = 374, e1.Ydieresis = 376, e1.Ydieresissmall = 63487, e1.Ydotaccent = 7822, e1.Ydotbelow = 7924, e1.Yericyrillic = 1067, e1.Yerudieresiscyrillic = 1272, e1.Ygrave = 7922, e1.Yhook = 435, e1.Yhookabove = 7926, e1.Yiarmenian = 1349, e1.Yicyrillic = 1031, e1.Yiwnarmenian = 1362, e1.Ymonospace = 65337, e1.Ysmall = 63353, e1.Ytilde = 7928, e1.Yusbigcyrillic = 1130, e1.Yusbigiotifiedcyrillic = 1132, e1.Yuslittlecyrillic = 1126, e1.Yuslittleiotifiedcyrillic = 1128, e1.Z = 90, e1.Zaarmenian = 1334, e1.Zacute = 377, e1.Zcaron = 381, e1.Zcaronsmall = 63231, e1.Zcircle = 9423, e1.Zcircumflex = 7824, e1.Zdot = 379, e1.Zdotaccent = 379, e1.Zdotbelow = 7826, e1.Zecyrillic = 1047, e1.Zedescendercyrillic = 1176, e1.Zedieresiscyrillic = 1246, e1.Zeta = 918, e1.Zhearmenian = 1338, e1.Zhebrevecyrillic = 1217, e1.Zhecyrillic = 1046, e1.Zhedescendercyrillic = 1174, e1.Zhedieresiscyrillic = 1244, e1.Zlinebelow = 7828, e1.Zmonospace = 65338, e1.Zsmall = 63354, e1.Zstroke = 437, e1.a = 97, e1.aabengali = 2438, e1.aacute = 225, e1.aadeva = 2310, e1.aagujarati = 2694, e1.aagurmukhi = 2566, e1.aamatragurmukhi = 2622, e1.aarusquare = 13059, e1.aavowelsignbengali = 2494, e1.aavowelsigndeva = 2366, e1.aavowelsigngujarati = 2750, e1.abbreviationmarkarmenian = 1375, e1.abbreviationsigndeva = 2416, e1.abengali = 2437, e1.abopomofo = 12570, e1.abreve = 259, e1.abreveacute = 7855, e1.abrevecyrillic = 1233, e1.abrevedotbelow = 7863, e1.abrevegrave = 7857, e1.abrevehookabove = 7859, e1.abrevetilde = 7861, e1.acaron = 462, e1.acircle = 9424, e1.acircumflex = 226, e1.acircumflexacute = 7845, e1.acircumflexdotbelow = 7853, e1.acircumflexgrave = 7847, e1.acircumflexhookabove = 7849, e1.acircumflextilde = 7851, e1.acute = 180, e1.acutebelowcmb = 791, e1.acutecmb = 769, e1.acutecomb = 769, e1.acutedeva = 2388, e1.acutelowmod = 719, e1.acutetonecmb = 833, e1.acyrillic = 1072, e1.adblgrave = 513, e1.addakgurmukhi = 2673, e1.adeva = 2309, e1.adieresis = 228, e1.adieresiscyrillic = 1235, e1.adieresismacron = 479, e1.adotbelow = 7841, e1.adotmacron = 481, e1.ae = 230, e1.aeacute = 509, e1.aekorean = 12624, e1.aemacron = 483, e1.afii00208 = 8213, e1.afii08941 = 8356, e1.afii10017 = 1040, e1.afii10018 = 1041, e1.afii10019 = 1042, e1.afii10020 = 1043, e1.afii10021 = 1044, e1.afii10022 = 1045, e1.afii10023 = 1025, e1.afii10024 = 1046, e1.afii10025 = 1047, e1.afii10026 = 1048, e1.afii10027 = 1049, e1.afii10028 = 1050, e1.afii10029 = 1051, e1.afii10030 = 1052;
    e1.afii10031 = 1053, e1.afii10032 = 1054, e1.afii10033 = 1055, e1.afii10034 = 1056, e1.afii10035 = 1057, e1.afii10036 = 1058, e1.afii10037 = 1059, e1.afii10038 = 1060, e1.afii10039 = 1061, e1.afii10040 = 1062, e1.afii10041 = 1063, e1.afii10042 = 1064, e1.afii10043 = 1065, e1.afii10044 = 1066, e1.afii10045 = 1067, e1.afii10046 = 1068, e1.afii10047 = 1069, e1.afii10048 = 1070, e1.afii10049 = 1071, e1.afii10050 = 1168, e1.afii10051 = 1026, e1.afii10052 = 1027, e1.afii10053 = 1028, e1.afii10054 = 1029, e1.afii10055 = 1030, e1.afii10056 = 1031, e1.afii10057 = 1032, e1.afii10058 = 1033, e1.afii10059 = 1034, e1.afii10060 = 1035, e1.afii10061 = 1036, e1.afii10062 = 1038, e1.afii10063 = 63172, e1.afii10064 = 63173, e1.afii10065 = 1072, e1.afii10066 = 1073, e1.afii10067 = 1074, e1.afii10068 = 1075, e1.afii10069 = 1076, e1.afii10070 = 1077, e1.afii10071 = 1105, e1.afii10072 = 1078, e1.afii10073 = 1079, e1.afii10074 = 1080, e1.afii10075 = 1081, e1.afii10076 = 1082, e1.afii10077 = 1083, e1.afii10078 = 1084, e1.afii10079 = 1085, e1.afii10080 = 1086, e1.afii10081 = 1087, e1.afii10082 = 1088, e1.afii10083 = 1089, e1.afii10084 = 1090, e1.afii10085 = 1091, e1.afii10086 = 1092, e1.afii10087 = 1093, e1.afii10088 = 1094, e1.afii10089 = 1095, e1.afii10090 = 1096, e1.afii10091 = 1097, e1.afii10092 = 1098, e1.afii10093 = 1099, e1.afii10094 = 1100, e1.afii10095 = 1101, e1.afii10096 = 1102, e1.afii10097 = 1103, e1.afii10098 = 1169, e1.afii10099 = 1106, e1.afii10100 = 1107, e1.afii10101 = 1108, e1.afii10102 = 1109, e1.afii10103 = 1110, e1.afii10104 = 1111, e1.afii10105 = 1112, e1.afii10106 = 1113, e1.afii10107 = 1114, e1.afii10108 = 1115, e1.afii10109 = 1116, e1.afii10110 = 1118, e1.afii10145 = 1039, e1.afii10146 = 1122, e1.afii10147 = 1138, e1.afii10148 = 1140, e1.afii10192 = 63174, e1.afii10193 = 1119, e1.afii10194 = 1123, e1.afii10195 = 1139, e1.afii10196 = 1141, e1.afii10831 = 63175, e1.afii10832 = 63176, e1.afii10846 = 1241, e1.afii299 = 8206, e1.afii300 = 8207, e1.afii301 = 8205, e1.afii57381 = 1642, e1.afii57388 = 1548, e1.afii57392 = 1632, e1.afii57393 = 1633, e1.afii57394 = 1634, e1.afii57395 = 1635, e1.afii57396 = 1636, e1.afii57397 = 1637, e1.afii57398 = 1638, e1.afii57399 = 1639, e1.afii57400 = 1640, e1.afii57401 = 1641, e1.afii57403 = 1563, e1.afii57407 = 1567, e1.afii57409 = 1569, e1.afii57410 = 1570, e1.afii57411 = 1571, e1.afii57412 = 1572, e1.afii57413 = 1573, e1.afii57414 = 1574, e1.afii57415 = 1575, e1.afii57416 = 1576, e1.afii57417 = 1577, e1.afii57418 = 1578, e1.afii57419 = 1579, e1.afii57420 = 1580, e1.afii57421 = 1581, e1.afii57422 = 1582, e1.afii57423 = 1583, e1.afii57424 = 1584, e1.afii57425 = 1585, e1.afii57426 = 1586, e1.afii57427 = 1587, e1.afii57428 = 1588, e1.afii57429 = 1589, e1.afii57430 = 1590, e1.afii57431 = 1591, e1.afii57432 = 1592, e1.afii57433 = 1593, e1.afii57434 = 1594, e1.afii57440 = 1600, e1.afii57441 = 1601, e1.afii57442 = 1602, e1.afii57443 = 1603, e1.afii57444 = 1604, e1.afii57445 = 1605, e1.afii57446 = 1606, e1.afii57448 = 1608, e1.afii57449 = 1609, e1.afii57450 = 1610, e1.afii57451 = 1611, e1.afii57452 = 1612, e1.afii57453 = 1613, e1.afii57454 = 1614, e1.afii57455 = 1615, e1.afii57456 = 1616, e1.afii57457 = 1617, e1.afii57458 = 1618, e1.afii57470 = 1607, e1.afii57505 = 1700, e1.afii57506 = 1662, e1.afii57507 = 1670, e1.afii57508 = 1688, e1.afii57509 = 1711, e1.afii57511 = 1657, e1.afii57512 = 1672, e1.afii57513 = 1681, e1.afii57514 = 1722, e1.afii57519 = 1746, e1.afii57534 = 1749, e1.afii57636 = 8362, e1.afii57645 = 1470, e1.afii57658 = 1475, e1.afii57664 = 1488, e1.afii57665 = 1489, e1.afii57666 = 1490, e1.afii57667 = 1491, e1.afii57668 = 1492, e1.afii57669 = 1493, e1.afii57670 = 1494, e1.afii57671 = 1495, e1.afii57672 = 1496, e1.afii57673 = 1497, e1.afii57674 = 1498, e1.afii57675 = 1499, e1.afii57676 = 1500, e1.afii57677 = 1501, e1.afii57678 = 1502, e1.afii57679 = 1503, e1.afii57680 = 1504, e1.afii57681 = 1505, e1.afii57682 = 1506, e1.afii57683 = 1507, e1.afii57684 = 1508, e1.afii57685 = 1509, e1.afii57686 = 1510, e1.afii57687 = 1511, e1.afii57688 = 1512, e1.afii57689 = 1513, e1.afii57690 = 1514, e1.afii57694 = 64298, e1.afii57695 = 64299, e1.afii57700 = 64331, e1.afii57705 = 64287, e1.afii57716 = 1520, e1.afii57717 = 1521, e1.afii57718 = 1522, e1.afii57723 = 64309, e1.afii57793 = 1460, e1.afii57794 = 1461, e1.afii57795 = 1462, e1.afii57796 = 1467, e1.afii57797 = 1464, e1.afii57798 = 1463, e1.afii57799 = 1456, e1.afii57800 = 1458, e1.afii57801 = 1457, e1.afii57802 = 1459, e1.afii57803 = 1474, e1.afii57804 = 1473, e1.afii57806 = 1465, e1.afii57807 = 1468, e1.afii57839 = 1469, e1.afii57841 = 1471, e1.afii57842 = 1472, e1.afii57929 = 700, e1.afii61248 = 8453, e1.afii61289 = 8467, e1.afii61352 = 8470, e1.afii61573 = 8236, e1.afii61574 = 8237, e1.afii61575 = 8238, e1.afii61664 = 8204, e1.afii63167 = 1645, e1.afii64937 = 701, e1.agrave = 224, e1.agujarati = 2693, e1.agurmukhi = 2565, e1.ahiragana = 12354, e1.ahookabove = 7843, e1.aibengali = 2448, e1.aibopomofo = 12574, e1.aideva = 2320, e1.aiecyrillic = 1237, e1.aigujarati = 2704, e1.aigurmukhi = 2576, e1.aimatragurmukhi = 2632, e1.ainarabic = 1593, e1.ainfinalarabic = 65226, e1.aininitialarabic = 65227, e1.ainmedialarabic = 65228, e1.ainvertedbreve = 515, e1.aivowelsignbengali = 2504, e1.aivowelsigndeva = 2376, e1.aivowelsigngujarati = 2760, e1.akatakana = 12450, e1.akatakanahalfwidth = 65393, e1.akorean = 12623, e1.alef = 1488, e1.alefarabic = 1575, e1.alefdageshhebrew = 64304, e1.aleffinalarabic = 65166, e1.alefhamzaabovearabic = 1571, e1.alefhamzaabovefinalarabic = 65156, e1.alefhamzabelowarabic = 1573, e1.alefhamzabelowfinalarabic = 65160, e1.alefhebrew = 1488, e1.aleflamedhebrew = 64335, e1.alefmaddaabovearabic = 1570, e1.alefmaddaabovefinalarabic = 65154, e1.alefmaksuraarabic = 1609, e1.alefmaksurafinalarabic = 65264, e1.alefmaksurainitialarabic = 65267, e1.alefmaksuramedialarabic = 65268, e1.alefpatahhebrew = 64302, e1.alefqamatshebrew = 64303, e1.aleph = 8501, e1.allequal = 8780, e1.alpha = 945, e1.alphatonos = 940, e1.amacron = 257, e1.amonospace = 65345, e1.ampersand = 38, e1.ampersandmonospace = 65286, e1.ampersandsmall = 63270, e1.amsquare = 13250, e1.anbopomofo = 12578, e1.angbopomofo = 12580, e1.angbracketleft = 12296, e1.angbracketright = 12297, e1.angkhankhuthai = 3674, e1.angle = 8736, e1.anglebracketleft = 12296, e1.anglebracketleftvertical = 65087, e1.anglebracketright = 12297, e1.anglebracketrightvertical = 65088, e1.angleleft = 9001, e1.angleright = 9002, e1.angstrom = 8491, e1.anoteleia = 903, e1.anudattadeva = 2386, e1.anusvarabengali = 2434, e1.anusvaradeva = 2306, e1.anusvaragujarati = 2690, e1.aogonek = 261, e1.apaatosquare = 13056, e1.aparen = 9372, e1.apostrophearmenian = 1370, e1.apostrophemod = 700, e1.apple = 63743, e1.approaches = 8784, e1.approxequal = 8776, e1.approxequalorimage = 8786, e1.approximatelyequal = 8773, e1.araeaekorean = 12686, e1.araeakorean = 12685, e1.arc = 8978, e1.arighthalfring = 7834, e1.aring = 229, e1.aringacute = 507, e1.aringbelow = 7681, e1.arrowboth = 8596, e1.arrowdashdown = 8675, e1.arrowdashleft = 8672, e1.arrowdashright = 8674, e1.arrowdashup = 8673, e1.arrowdblboth = 8660, e1.arrowdbldown = 8659, e1.arrowdblleft = 8656, e1.arrowdblright = 8658, e1.arrowdblup = 8657, e1.arrowdown = 8595, e1.arrowdownleft = 8601, e1.arrowdownright = 8600, e1.arrowdownwhite = 8681, e1.arrowheaddownmod = 709, e1.arrowheadleftmod = 706, e1.arrowheadrightmod = 707, e1.arrowheadupmod = 708, e1.arrowhorizex = 63719, e1.arrowleft = 8592, e1.arrowleftdbl = 8656, e1.arrowleftdblstroke = 8653, e1.arrowleftoverright = 8646, e1.arrowleftwhite = 8678, e1.arrowright = 8594, e1.arrowrightdblstroke = 8655, e1.arrowrightheavy = 10142, e1.arrowrightoverleft = 8644, e1.arrowrightwhite = 8680, e1.arrowtableft = 8676, e1.arrowtabright = 8677, e1.arrowup = 8593, e1.arrowupdn = 8597, e1.arrowupdnbse = 8616, e1.arrowupdownbase = 8616, e1.arrowupleft = 8598, e1.arrowupleftofdown = 8645, e1.arrowupright = 8599, e1.arrowupwhite = 8679, e1.arrowvertex = 63718, e1.asciicircum = 94, e1.asciicircummonospace = 65342, e1.asciitilde = 126, e1.asciitildemonospace = 65374, e1.ascript = 593, e1.ascriptturned = 594, e1.asmallhiragana = 12353, e1.asmallkatakana = 12449, e1.asmallkatakanahalfwidth = 65383, e1.asterisk = 42, e1.asteriskaltonearabic = 1645, e1.asteriskarabic = 1645, e1.asteriskmath = 8727, e1.asteriskmonospace = 65290, e1.asterisksmall = 65121, e1.asterism = 8258, e1.asuperior = 63209, e1.asymptoticallyequal = 8771, e1.at = 64, e1.atilde = 227, e1.atmonospace = 65312, e1.atsmall = 65131, e1.aturned = 592, e1.aubengali = 2452, e1.aubopomofo = 12576, e1.audeva = 2324, e1.augujarati = 2708, e1.augurmukhi = 2580, e1.aulengthmarkbengali = 2519, e1.aumatragurmukhi = 2636, e1.auvowelsignbengali = 2508, e1.auvowelsigndeva = 2380, e1.auvowelsigngujarati = 2764, e1.avagrahadeva = 2365, e1.aybarmenian = 1377, e1.ayin = 1506, e1.ayinaltonehebrew = 64288, e1.ayinhebrew = 1506, e1.b = 98, e1.babengali = 2476, e1.backslash = 92, e1.backslashmonospace = 65340, e1.badeva = 2348, e1.bagujarati = 2732, e1.bagurmukhi = 2604, e1.bahiragana = 12400, e1.bahtthai = 3647, e1.bakatakana = 12496, e1.bar = 124, e1.barmonospace = 65372, e1.bbopomofo = 12549, e1.bcircle = 9425, e1.bdotaccent = 7683, e1.bdotbelow = 7685, e1.beamedsixteenthnotes = 9836, e1.because = 8757, e1.becyrillic = 1073, e1.beharabic = 1576, e1.behfinalarabic = 65168, e1.behinitialarabic = 65169, e1.behiragana = 12409, e1.behmedialarabic = 65170, e1.behmeeminitialarabic = 64671, e1.behmeemisolatedarabic = 64520, e1.behnoonfinalarabic = 64621, e1.bekatakana = 12505, e1.benarmenian = 1378, e1.bet = 1489, e1.beta = 946, e1.betasymbolgreek = 976, e1.betdagesh = 64305, e1.betdageshhebrew = 64305, e1.bethebrew = 1489, e1.betrafehebrew = 64332, e1.bhabengali = 2477, e1.bhadeva = 2349, e1.bhagujarati = 2733, e1.bhagurmukhi = 2605, e1.bhook = 595, e1.bihiragana = 12403, e1.bikatakana = 12499, e1.bilabialclick = 664, e1.bindigurmukhi = 2562, e1.birusquare = 13105, e1.blackcircle = 9679, e1.blackdiamond = 9670, e1.blackdownpointingtriangle = 9660, e1.blackleftpointingpointer = 9668, e1.blackleftpointingtriangle = 9664, e1.blacklenticularbracketleft = 12304, e1.blacklenticularbracketleftvertical = 65083, e1.blacklenticularbracketright = 12305, e1.blacklenticularbracketrightvertical = 65084, e1.blacklowerlefttriangle = 9699, e1.blacklowerrighttriangle = 9698, e1.blackrectangle = 9644, e1.blackrightpointingpointer = 9658, e1.blackrightpointingtriangle = 9654, e1.blacksmallsquare = 9642, e1.blacksmilingface = 9787, e1.blacksquare = 9632, e1.blackstar = 9733, e1.blackupperlefttriangle = 9700, e1.blackupperrighttriangle = 9701, e1.blackuppointingsmalltriangle = 9652, e1.blackuppointingtriangle = 9650, e1.blank = 9251, e1.blinebelow = 7687, e1.block = 9608, e1.bmonospace = 65346, e1.bobaimaithai = 3610, e1.bohiragana = 12412, e1.bokatakana = 12508, e1.bparen = 9373, e1.bqsquare = 13251, e1.braceex = 63732, e1.braceleft = 123, e1.braceleftbt = 63731, e1.braceleftmid = 63730, e1.braceleftmonospace = 65371, e1.braceleftsmall = 65115, e1.bracelefttp = 63729, e1.braceleftvertical = 65079, e1.braceright = 125, e1.bracerightbt = 63742, e1.bracerightmid = 63741, e1.bracerightmonospace = 65373, e1.bracerightsmall = 65116, e1.bracerighttp = 63740, e1.bracerightvertical = 65080, e1.bracketleft = 91, e1.bracketleftbt = 63728, e1.bracketleftex = 63727, e1.bracketleftmonospace = 65339, e1.bracketlefttp = 63726, e1.bracketright = 93, e1.bracketrightbt = 63739, e1.bracketrightex = 63738, e1.bracketrightmonospace = 65341, e1.bracketrighttp = 63737, e1.breve = 728, e1.brevebelowcmb = 814, e1.brevecmb = 774, e1.breveinvertedbelowcmb = 815, e1.breveinvertedcmb = 785, e1.breveinverteddoublecmb = 865, e1.bridgebelowcmb = 810, e1.bridgeinvertedbelowcmb = 826, e1.brokenbar = 166, e1.bstroke = 384, e1.bsuperior = 63210, e1.btopbar = 387, e1.buhiragana = 12406, e1.bukatakana = 12502, e1.bullet = 8226, e1.bulletinverse = 9688, e1.bulletoperator = 8729, e1.bullseye = 9678, e1.c = 99, e1.caarmenian = 1390, e1.cabengali = 2458, e1.cacute = 263, e1.cadeva = 2330, e1.cagujarati = 2714, e1.cagurmukhi = 2586, e1.calsquare = 13192, e1.candrabindubengali = 2433, e1.candrabinducmb = 784, e1.candrabindudeva = 2305, e1.candrabindugujarati = 2689, e1.capslock = 8682, e1.careof = 8453, e1.caron = 711, e1.caronbelowcmb = 812, e1.caroncmb = 780, e1.carriagereturn = 8629, e1.cbopomofo = 12568, e1.ccaron = 269, e1.ccedilla = 231, e1.ccedillaacute = 7689, e1.ccircle = 9426, e1.ccircumflex = 265, e1.ccurl = 597, e1.cdot = 267, e1.cdotaccent = 267, e1.cdsquare = 13253, e1.cedilla = 184, e1.cedillacmb = 807, e1.cent = 162, e1.centigrade = 8451, e1.centinferior = 63199, e1.centmonospace = 65504, e1.centoldstyle = 63394, e1.centsuperior = 63200, e1.chaarmenian = 1401, e1.chabengali = 2459, e1.chadeva = 2331, e1.chagujarati = 2715, e1.chagurmukhi = 2587, e1.chbopomofo = 12564, e1.cheabkhasiancyrillic = 1213, e1.checkmark = 10003, e1.checyrillic = 1095, e1.chedescenderabkhasiancyrillic = 1215, e1.chedescendercyrillic = 1207, e1.chedieresiscyrillic = 1269, e1.cheharmenian = 1395, e1.chekhakassiancyrillic = 1228, e1.cheverticalstrokecyrillic = 1209, e1.chi = 967, e1.chieuchacirclekorean = 12919, e1.chieuchaparenkorean = 12823, e1.chieuchcirclekorean = 12905, e1.chieuchkorean = 12618, e1.chieuchparenkorean = 12809, e1.chochangthai = 3594, e1.chochanthai = 3592, e1.chochingthai = 3593, e1.chochoethai = 3596, e1.chook = 392, e1.cieucacirclekorean = 12918, e1.cieucaparenkorean = 12822, e1.cieuccirclekorean = 12904, e1.cieuckorean = 12616, e1.cieucparenkorean = 12808, e1.cieucuparenkorean = 12828, e1.circle = 9675, e1.circlecopyrt = 169, e1.circlemultiply = 8855, e1.circleot = 8857, e1.circleplus = 8853, e1.circlepostalmark = 12342, e1.circlewithlefthalfblack = 9680, e1.circlewithrighthalfblack = 9681, e1.circumflex = 710, e1.circumflexbelowcmb = 813, e1.circumflexcmb = 770, e1.clear = 8999, e1.clickalveolar = 450, e1.clickdental = 448, e1.clicklateral = 449, e1.clickretroflex = 451, e1.club = 9827, e1.clubsuitblack = 9827, e1.clubsuitwhite = 9831, e1.cmcubedsquare = 13220, e1.cmonospace = 65347, e1.cmsquaredsquare = 13216, e1.coarmenian = 1409, e1.colon = 58, e1.colonmonetary = 8353, e1.colonmonospace = 65306, e1.colonsign = 8353, e1.colonsmall = 65109, e1.colontriangularhalfmod = 721, e1.colontriangularmod = 720, e1.comma = 44, e1.commaabovecmb = 787, e1.commaaboverightcmb = 789, e1.commaaccent = 63171, e1.commaarabic = 1548, e1.commaarmenian = 1373, e1.commainferior = 63201, e1.commamonospace = 65292, e1.commareversedabovecmb = 788, e1.commareversedmod = 701, e1.commasmall = 65104, e1.commasuperior = 63202, e1.commaturnedabovecmb = 786, e1.commaturnedmod = 699, e1.compass = 9788, e1.congruent = 8773, e1.contourintegral = 8750, e1.control = 8963, e1.controlACK = 6, e1.controlBEL = 7, e1.controlBS = 8, e1.controlCAN = 24, e1.controlCR = 13, e1.controlDC1 = 17, e1.controlDC2 = 18, e1.controlDC3 = 19, e1.controlDC4 = 20, e1.controlDEL = 127, e1.controlDLE = 16, e1.controlEM = 25, e1.controlENQ = 5, e1.controlEOT = 4, e1.controlESC = 27, e1.controlETB = 23, e1.controlETX = 3, e1.controlFF = 12, e1.controlFS = 28, e1.controlGS = 29, e1.controlHT = 9, e1.controlLF = 10, e1.controlNAK = 21, e1.controlNULL = 0, e1.controlRS = 30, e1.controlSI = 15, e1.controlSO = 14, e1.controlSOT = 2, e1.controlSTX = 1, e1.controlSUB = 26, e1.controlSYN = 22, e1.controlUS = 31, e1.controlVT = 11, e1.copyright = 169, e1.copyrightsans = 63721, e1.copyrightserif = 63193, e1.cornerbracketleft = 12300, e1.cornerbracketlefthalfwidth = 65378, e1.cornerbracketleftvertical = 65089, e1.cornerbracketright = 12301, e1.cornerbracketrighthalfwidth = 65379, e1.cornerbracketrightvertical = 65090, e1.corporationsquare = 13183, e1.cosquare = 13255, e1.coverkgsquare = 13254, e1.cparen = 9374, e1.cruzeiro = 8354, e1.cstretched = 663, e1.curlyand = 8911, e1.curlyor = 8910, e1.currency = 164, e1.cyrBreve = 63185, e1.cyrFlex = 63186, e1.cyrbreve = 63188, e1.cyrflex = 63189, e1.d = 100, e1.daarmenian = 1380, e1.dabengali = 2470, e1.dadarabic = 1590, e1.dadeva = 2342, e1.dadfinalarabic = 65214, e1.dadinitialarabic = 65215, e1.dadmedialarabic = 65216, e1.dagesh = 1468, e1.dageshhebrew = 1468, e1.dagger = 8224, e1.daggerdbl = 8225, e1.dagujarati = 2726, e1.dagurmukhi = 2598, e1.dahiragana = 12384, e1.dakatakana = 12480, e1.dalarabic = 1583, e1.dalet = 1491, e1.daletdagesh = 64307, e1.daletdageshhebrew = 64307, e1.dalethebrew = 1491, e1.dalfinalarabic = 65194, e1.dammaarabic = 1615, e1.dammalowarabic = 1615, e1.dammatanaltonearabic = 1612, e1.dammatanarabic = 1612, e1.danda = 2404, e1.dargahebrew = 1447, e1.dargalefthebrew = 1447, e1.dasiapneumatacyrilliccmb = 1157, e1.dblGrave = 63187, e1.dblanglebracketleft = 12298, e1.dblanglebracketleftvertical = 65085, e1.dblanglebracketright = 12299, e1.dblanglebracketrightvertical = 65086, e1.dblarchinvertedbelowcmb = 811, e1.dblarrowleft = 8660, e1.dblarrowright = 8658, e1.dbldanda = 2405, e1.dblgrave = 63190, e1.dblgravecmb = 783, e1.dblintegral = 8748, e1.dbllowline = 8215, e1.dbllowlinecmb = 819, e1.dbloverlinecmb = 831, e1.dblprimemod = 698, e1.dblverticalbar = 8214, e1.dblverticallineabovecmb = 782, e1.dbopomofo = 12553, e1.dbsquare = 13256, e1.dcaron = 271, e1.dcedilla = 7697, e1.dcircle = 9427, e1.dcircumflexbelow = 7699, e1.dcroat = 273, e1.ddabengali = 2465, e1.ddadeva = 2337, e1.ddagujarati = 2721, e1.ddagurmukhi = 2593, e1.ddalarabic = 1672, e1.ddalfinalarabic = 64393, e1.dddhadeva = 2396, e1.ddhabengali = 2466, e1.ddhadeva = 2338, e1.ddhagujarati = 2722, e1.ddhagurmukhi = 2594, e1.ddotaccent = 7691, e1.ddotbelow = 7693, e1.decimalseparatorarabic = 1643, e1.decimalseparatorpersian = 1643, e1.decyrillic = 1076, e1.degree = 176, e1.dehihebrew = 1453, e1.dehiragana = 12391, e1.deicoptic = 1007, e1.dekatakana = 12487, e1.deleteleft = 9003, e1.deleteright = 8998, e1.delta = 948, e1.deltaturned = 397, e1.denominatorminusonenumeratorbengali = 2552, e1.dezh = 676, e1.dhabengali = 2471, e1.dhadeva = 2343, e1.dhagujarati = 2727, e1.dhagurmukhi = 2599, e1.dhook = 599, e1.dialytikatonos = 901, e1.dialytikatonoscmb = 836, e1.diamond = 9830, e1.diamondsuitwhite = 9826, e1.dieresis = 168, e1.dieresisacute = 63191, e1.dieresisbelowcmb = 804, e1.dieresiscmb = 776, e1.dieresisgrave = 63192, e1.dieresistonos = 901, e1.dihiragana = 12386, e1.dikatakana = 12482, e1.dittomark = 12291, e1.divide = 247, e1.divides = 8739, e1.divisionslash = 8725, e1.djecyrillic = 1106, e1.dkshade = 9619, e1.dlinebelow = 7695, e1.dlsquare = 13207, e1.dmacron = 273, e1.dmonospace = 65348, e1.dnblock = 9604, e1.dochadathai = 3598, e1.dodekthai = 3604, e1.dohiragana = 12393, e1.dokatakana = 12489, e1.dollar = 36;
    e1.dollarinferior = 63203, e1.dollarmonospace = 65284, e1.dollaroldstyle = 63268, e1.dollarsmall = 65129, e1.dollarsuperior = 63204, e1.dong = 8363, e1.dorusquare = 13094, e1.dotaccent = 729, e1.dotaccentcmb = 775, e1.dotbelowcmb = 803, e1.dotbelowcomb = 803, e1.dotkatakana = 12539, e1.dotlessi = 305, e1.dotlessj = 63166, e1.dotlessjstrokehook = 644, e1.dotmath = 8901, e1.dottedcircle = 9676, e1.doubleyodpatah = 64287, e1.doubleyodpatahhebrew = 64287, e1.downtackbelowcmb = 798, e1.downtackmod = 725, e1.dparen = 9375, e1.dsuperior = 63211, e1.dtail = 598, e1.dtopbar = 396, e1.duhiragana = 12389, e1.dukatakana = 12485, e1.dz = 499, e1.dzaltone = 675, e1.dzcaron = 454, e1.dzcurl = 677, e1.dzeabkhasiancyrillic = 1249, e1.dzecyrillic = 1109, e1.dzhecyrillic = 1119, e1.e = 101, e1.eacute = 233, e1.earth = 9793, e1.ebengali = 2447, e1.ebopomofo = 12572, e1.ebreve = 277, e1.ecandradeva = 2317, e1.ecandragujarati = 2701, e1.ecandravowelsigndeva = 2373, e1.ecandravowelsigngujarati = 2757, e1.ecaron = 283, e1.ecedillabreve = 7709, e1.echarmenian = 1381, e1.echyiwnarmenian = 1415, e1.ecircle = 9428, e1.ecircumflex = 234, e1.ecircumflexacute = 7871, e1.ecircumflexbelow = 7705, e1.ecircumflexdotbelow = 7879, e1.ecircumflexgrave = 7873, e1.ecircumflexhookabove = 7875, e1.ecircumflextilde = 7877, e1.ecyrillic = 1108, e1.edblgrave = 517, e1.edeva = 2319, e1.edieresis = 235, e1.edot = 279, e1.edotaccent = 279, e1.edotbelow = 7865, e1.eegurmukhi = 2575, e1.eematragurmukhi = 2631, e1.efcyrillic = 1092, e1.egrave = 232, e1.egujarati = 2703, e1.eharmenian = 1383, e1.ehbopomofo = 12573, e1.ehiragana = 12360, e1.ehookabove = 7867, e1.eibopomofo = 12575, e1.eight = 56, e1.eightarabic = 1640, e1.eightbengali = 2542, e1.eightcircle = 9319, e1.eightcircleinversesansserif = 10129, e1.eightdeva = 2414, e1.eighteencircle = 9329, e1.eighteenparen = 9349, e1.eighteenperiod = 9369, e1.eightgujarati = 2798, e1.eightgurmukhi = 2670, e1.eighthackarabic = 1640, e1.eighthangzhou = 12328, e1.eighthnotebeamed = 9835, e1.eightideographicparen = 12839, e1.eightinferior = 8328, e1.eightmonospace = 65304, e1.eightoldstyle = 63288, e1.eightparen = 9339, e1.eightperiod = 9359, e1.eightpersian = 1784, e1.eightroman = 8567, e1.eightsuperior = 8312, e1.eightthai = 3672, e1.einvertedbreve = 519, e1.eiotifiedcyrillic = 1125, e1.ekatakana = 12456, e1.ekatakanahalfwidth = 65396, e1.ekonkargurmukhi = 2676, e1.ekorean = 12628, e1.elcyrillic = 1083, e1.element = 8712, e1.elevencircle = 9322, e1.elevenparen = 9342, e1.elevenperiod = 9362, e1.elevenroman = 8570, e1.ellipsis = 8230, e1.ellipsisvertical = 8942, e1.emacron = 275, e1.emacronacute = 7703, e1.emacrongrave = 7701, e1.emcyrillic = 1084, e1.emdash = 8212, e1.emdashvertical = 65073, e1.emonospace = 65349, e1.emphasismarkarmenian = 1371, e1.emptyset = 8709, e1.enbopomofo = 12579, e1.encyrillic = 1085, e1.endash = 8211, e1.endashvertical = 65074, e1.endescendercyrillic = 1187, e1.eng = 331, e1.engbopomofo = 12581, e1.enghecyrillic = 1189, e1.enhookcyrillic = 1224, e1.enspace = 8194, e1.eogonek = 281, e1.eokorean = 12627, e1.eopen = 603, e1.eopenclosed = 666, e1.eopenreversed = 604, e1.eopenreversedclosed = 606, e1.eopenreversedhook = 605, e1.eparen = 9376, e1.epsilon = 949, e1.epsilontonos = 941, e1.equal = 61, e1.equalmonospace = 65309, e1.equalsmall = 65126, e1.equalsuperior = 8316, e1.equivalence = 8801, e1.erbopomofo = 12582, e1.ercyrillic = 1088, e1.ereversed = 600, e1.ereversedcyrillic = 1101, e1.escyrillic = 1089, e1.esdescendercyrillic = 1195, e1.esh = 643, e1.eshcurl = 646, e1.eshortdeva = 2318, e1.eshortvowelsigndeva = 2374, e1.eshreversedloop = 426, e1.eshsquatreversed = 645, e1.esmallhiragana = 12359, e1.esmallkatakana = 12455, e1.esmallkatakanahalfwidth = 65386, e1.estimated = 8494, e1.esuperior = 63212, e1.eta = 951, e1.etarmenian = 1384, e1.etatonos = 942, e1.eth = 240, e1.etilde = 7869, e1.etildebelow = 7707, e1.etnahtafoukhhebrew = 1425, e1.etnahtafoukhlefthebrew = 1425, e1.etnahtahebrew = 1425, e1.etnahtalefthebrew = 1425, e1.eturned = 477, e1.eukorean = 12641, e1.euro = 8364, e1.evowelsignbengali = 2503, e1.evowelsigndeva = 2375, e1.evowelsigngujarati = 2759, e1.exclam = 33, e1.exclamarmenian = 1372, e1.exclamdbl = 8252, e1.exclamdown = 161, e1.exclamdownsmall = 63393, e1.exclammonospace = 65281, e1.exclamsmall = 63265, e1.existential = 8707, e1.ezh = 658, e1.ezhcaron = 495, e1.ezhcurl = 659, e1.ezhreversed = 441, e1.ezhtail = 442, e1.f = 102, e1.fadeva = 2398, e1.fagurmukhi = 2654, e1.fahrenheit = 8457, e1.fathaarabic = 1614, e1.fathalowarabic = 1614, e1.fathatanarabic = 1611, e1.fbopomofo = 12552, e1.fcircle = 9429, e1.fdotaccent = 7711, e1.feharabic = 1601, e1.feharmenian = 1414, e1.fehfinalarabic = 65234, e1.fehinitialarabic = 65235, e1.fehmedialarabic = 65236, e1.feicoptic = 997, e1.female = 9792, e1.ff = 64256, e1.f_f = 64256, e1.ffi = 64259, e1.f_f_i = 64259, e1.ffl = 64260, e1.f_f_l = 64260, e1.fi = 64257, e1.f_i = 64257, e1.fifteencircle = 9326, e1.fifteenparen = 9346, e1.fifteenperiod = 9366, e1.figuredash = 8210, e1.filledbox = 9632, e1.filledrect = 9644, e1.finalkaf = 1498, e1.finalkafdagesh = 64314, e1.finalkafdageshhebrew = 64314, e1.finalkafhebrew = 1498, e1.finalmem = 1501, e1.finalmemhebrew = 1501, e1.finalnun = 1503, e1.finalnunhebrew = 1503, e1.finalpe = 1507, e1.finalpehebrew = 1507, e1.finaltsadi = 1509, e1.finaltsadihebrew = 1509, e1.firsttonechinese = 713, e1.fisheye = 9673, e1.fitacyrillic = 1139, e1.five = 53, e1.fivearabic = 1637, e1.fivebengali = 2539, e1.fivecircle = 9316, e1.fivecircleinversesansserif = 10126, e1.fivedeva = 2411, e1.fiveeighths = 8541, e1.fivegujarati = 2795, e1.fivegurmukhi = 2667, e1.fivehackarabic = 1637, e1.fivehangzhou = 12325, e1.fiveideographicparen = 12836, e1.fiveinferior = 8325, e1.fivemonospace = 65301, e1.fiveoldstyle = 63285, e1.fiveparen = 9336, e1.fiveperiod = 9356, e1.fivepersian = 1781, e1.fiveroman = 8564, e1.fivesuperior = 8309, e1.fivethai = 3669, e1.fl = 64258, e1.f_l = 64258, e1.florin = 402, e1.fmonospace = 65350, e1.fmsquare = 13209, e1.fofanthai = 3615, e1.fofathai = 3613, e1.fongmanthai = 3663, e1.forall = 8704, e1.four = 52, e1.fourarabic = 1636, e1.fourbengali = 2538, e1.fourcircle = 9315, e1.fourcircleinversesansserif = 10125, e1.fourdeva = 2410, e1.fourgujarati = 2794, e1.fourgurmukhi = 2666, e1.fourhackarabic = 1636, e1.fourhangzhou = 12324, e1.fourideographicparen = 12835, e1.fourinferior = 8324, e1.fourmonospace = 65300, e1.fournumeratorbengali = 2551, e1.fouroldstyle = 63284, e1.fourparen = 9335, e1.fourperiod = 9355, e1.fourpersian = 1780, e1.fourroman = 8563, e1.foursuperior = 8308, e1.fourteencircle = 9325, e1.fourteenparen = 9345, e1.fourteenperiod = 9365, e1.fourthai = 3668, e1.fourthtonechinese = 715, e1.fparen = 9377, e1.fraction = 8260, e1.franc = 8355, e1.g = 103, e1.gabengali = 2455, e1.gacute = 501, e1.gadeva = 2327, e1.gafarabic = 1711, e1.gaffinalarabic = 64403, e1.gafinitialarabic = 64404, e1.gafmedialarabic = 64405, e1.gagujarati = 2711, e1.gagurmukhi = 2583, e1.gahiragana = 12364, e1.gakatakana = 12460, e1.gamma = 947, e1.gammalatinsmall = 611, e1.gammasuperior = 736, e1.gangiacoptic = 1003, e1.gbopomofo = 12557, e1.gbreve = 287, e1.gcaron = 487, e1.gcedilla = 291, e1.gcircle = 9430, e1.gcircumflex = 285, e1.gcommaaccent = 291, e1.gdot = 289, e1.gdotaccent = 289, e1.gecyrillic = 1075, e1.gehiragana = 12370, e1.gekatakana = 12466, e1.geometricallyequal = 8785, e1.gereshaccenthebrew = 1436, e1.gereshhebrew = 1523, e1.gereshmuqdamhebrew = 1437, e1.germandbls = 223, e1.gershayimaccenthebrew = 1438, e1.gershayimhebrew = 1524, e1.getamark = 12307, e1.ghabengali = 2456, e1.ghadarmenian = 1394, e1.ghadeva = 2328, e1.ghagujarati = 2712, e1.ghagurmukhi = 2584, e1.ghainarabic = 1594, e1.ghainfinalarabic = 65230, e1.ghaininitialarabic = 65231, e1.ghainmedialarabic = 65232, e1.ghemiddlehookcyrillic = 1173, e1.ghestrokecyrillic = 1171, e1.gheupturncyrillic = 1169, e1.ghhadeva = 2394, e1.ghhagurmukhi = 2650, e1.ghook = 608, e1.ghzsquare = 13203, e1.gihiragana = 12366, e1.gikatakana = 12462, e1.gimarmenian = 1379, e1.gimel = 1490, e1.gimeldagesh = 64306, e1.gimeldageshhebrew = 64306, e1.gimelhebrew = 1490, e1.gjecyrillic = 1107, e1.glottalinvertedstroke = 446, e1.glottalstop = 660, e1.glottalstopinverted = 662, e1.glottalstopmod = 704, e1.glottalstopreversed = 661, e1.glottalstopreversedmod = 705, e1.glottalstopreversedsuperior = 740, e1.glottalstopstroke = 673, e1.glottalstopstrokereversed = 674, e1.gmacron = 7713, e1.gmonospace = 65351, e1.gohiragana = 12372, e1.gokatakana = 12468, e1.gparen = 9378, e1.gpasquare = 13228, e1.gradient = 8711, e1.grave = 96, e1.gravebelowcmb = 790, e1.gravecmb = 768, e1.gravecomb = 768, e1.gravedeva = 2387, e1.gravelowmod = 718, e1.gravemonospace = 65344, e1.gravetonecmb = 832, e1.greater = 62, e1.greaterequal = 8805, e1.greaterequalorless = 8923, e1.greatermonospace = 65310, e1.greaterorequivalent = 8819, e1.greaterorless = 8823, e1.greateroverequal = 8807, e1.greatersmall = 65125, e1.gscript = 609, e1.gstroke = 485, e1.guhiragana = 12368, e1.guillemotleft = 171, e1.guillemotright = 187, e1.guilsinglleft = 8249, e1.guilsinglright = 8250, e1.gukatakana = 12464, e1.guramusquare = 13080, e1.gysquare = 13257, e1.h = 104, e1.haabkhasiancyrillic = 1193, e1.haaltonearabic = 1729, e1.habengali = 2489, e1.hadescendercyrillic = 1203, e1.hadeva = 2361, e1.hagujarati = 2745, e1.hagurmukhi = 2617, e1.haharabic = 1581, e1.hahfinalarabic = 65186, e1.hahinitialarabic = 65187, e1.hahiragana = 12399, e1.hahmedialarabic = 65188, e1.haitusquare = 13098, e1.hakatakana = 12495, e1.hakatakanahalfwidth = 65418, e1.halantgurmukhi = 2637, e1.hamzaarabic = 1569, e1.hamzalowarabic = 1569, e1.hangulfiller = 12644, e1.hardsigncyrillic = 1098, e1.harpoonleftbarbup = 8636, e1.harpoonrightbarbup = 8640, e1.hasquare = 13258, e1.hatafpatah = 1458, e1.hatafpatah16 = 1458, e1.hatafpatah23 = 1458, e1.hatafpatah2f = 1458, e1.hatafpatahhebrew = 1458, e1.hatafpatahnarrowhebrew = 1458, e1.hatafpatahquarterhebrew = 1458, e1.hatafpatahwidehebrew = 1458, e1.hatafqamats = 1459, e1.hatafqamats1b = 1459, e1.hatafqamats28 = 1459, e1.hatafqamats34 = 1459, e1.hatafqamatshebrew = 1459, e1.hatafqamatsnarrowhebrew = 1459, e1.hatafqamatsquarterhebrew = 1459, e1.hatafqamatswidehebrew = 1459, e1.hatafsegol = 1457, e1.hatafsegol17 = 1457, e1.hatafsegol24 = 1457, e1.hatafsegol30 = 1457, e1.hatafsegolhebrew = 1457, e1.hatafsegolnarrowhebrew = 1457, e1.hatafsegolquarterhebrew = 1457, e1.hatafsegolwidehebrew = 1457, e1.hbar = 295, e1.hbopomofo = 12559, e1.hbrevebelow = 7723, e1.hcedilla = 7721, e1.hcircle = 9431, e1.hcircumflex = 293, e1.hdieresis = 7719, e1.hdotaccent = 7715, e1.hdotbelow = 7717, e1.he = 1492, e1.heart = 9829, e1.heartsuitblack = 9829, e1.heartsuitwhite = 9825, e1.hedagesh = 64308, e1.hedageshhebrew = 64308, e1.hehaltonearabic = 1729, e1.heharabic = 1607, e1.hehebrew = 1492, e1.hehfinalaltonearabic = 64423, e1.hehfinalalttwoarabic = 65258, e1.hehfinalarabic = 65258, e1.hehhamzaabovefinalarabic = 64421, e1.hehhamzaaboveisolatedarabic = 64420, e1.hehinitialaltonearabic = 64424, e1.hehinitialarabic = 65259, e1.hehiragana = 12408, e1.hehmedialaltonearabic = 64425, e1.hehmedialarabic = 65260, e1.heiseierasquare = 13179, e1.hekatakana = 12504, e1.hekatakanahalfwidth = 65421, e1.hekutaarusquare = 13110, e1.henghook = 615, e1.herutusquare = 13113, e1.het = 1495, e1.hethebrew = 1495, e1.hhook = 614, e1.hhooksuperior = 689, e1.hieuhacirclekorean = 12923, e1.hieuhaparenkorean = 12827, e1.hieuhcirclekorean = 12909, e1.hieuhkorean = 12622, e1.hieuhparenkorean = 12813, e1.hihiragana = 12402, e1.hikatakana = 12498, e1.hikatakanahalfwidth = 65419, e1.hiriq = 1460, e1.hiriq14 = 1460, e1.hiriq21 = 1460, e1.hiriq2d = 1460, e1.hiriqhebrew = 1460, e1.hiriqnarrowhebrew = 1460, e1.hiriqquarterhebrew = 1460, e1.hiriqwidehebrew = 1460, e1.hlinebelow = 7830, e1.hmonospace = 65352, e1.hoarmenian = 1392, e1.hohipthai = 3627, e1.hohiragana = 12411, e1.hokatakana = 12507, e1.hokatakanahalfwidth = 65422, e1.holam = 1465, e1.holam19 = 1465, e1.holam26 = 1465, e1.holam32 = 1465, e1.holamhebrew = 1465, e1.holamnarrowhebrew = 1465, e1.holamquarterhebrew = 1465, e1.holamwidehebrew = 1465, e1.honokhukthai = 3630, e1.hookabovecomb = 777, e1.hookcmb = 777, e1.hookpalatalizedbelowcmb = 801, e1.hookretroflexbelowcmb = 802, e1.hoonsquare = 13122, e1.horicoptic = 1001, e1.horizontalbar = 8213, e1.horncmb = 795, e1.hotsprings = 9832, e1.house = 8962, e1.hparen = 9379, e1.hsuperior = 688, e1.hturned = 613, e1.huhiragana = 12405, e1.huiitosquare = 13107, e1.hukatakana = 12501, e1.hukatakanahalfwidth = 65420, e1.hungarumlaut = 733, e1.hungarumlautcmb = 779, e1.hv = 405, e1.hyphen = 45, e1.hypheninferior = 63205, e1.hyphenmonospace = 65293, e1.hyphensmall = 65123, e1.hyphensuperior = 63206, e1.hyphentwo = 8208, e1.i = 105, e1.iacute = 237, e1.iacyrillic = 1103, e1.ibengali = 2439, e1.ibopomofo = 12583, e1.ibreve = 301, e1.icaron = 464, e1.icircle = 9432, e1.icircumflex = 238, e1.icyrillic = 1110, e1.idblgrave = 521, e1.ideographearthcircle = 12943, e1.ideographfirecircle = 12939, e1.ideographicallianceparen = 12863, e1.ideographiccallparen = 12858, e1.ideographiccentrecircle = 12965, e1.ideographicclose = 12294, e1.ideographiccomma = 12289, e1.ideographiccommaleft = 65380, e1.ideographiccongratulationparen = 12855, e1.ideographiccorrectcircle = 12963, e1.ideographicearthparen = 12847, e1.ideographicenterpriseparen = 12861, e1.ideographicexcellentcircle = 12957, e1.ideographicfestivalparen = 12864, e1.ideographicfinancialcircle = 12950, e1.ideographicfinancialparen = 12854, e1.ideographicfireparen = 12843, e1.ideographichaveparen = 12850, e1.ideographichighcircle = 12964, e1.ideographiciterationmark = 12293, e1.ideographiclaborcircle = 12952, e1.ideographiclaborparen = 12856, e1.ideographicleftcircle = 12967, e1.ideographiclowcircle = 12966, e1.ideographicmedicinecircle = 12969, e1.ideographicmetalparen = 12846, e1.ideographicmoonparen = 12842, e1.ideographicnameparen = 12852, e1.ideographicperiod = 12290, e1.ideographicprintcircle = 12958, e1.ideographicreachparen = 12867, e1.ideographicrepresentparen = 12857, e1.ideographicresourceparen = 12862, e1.ideographicrightcircle = 12968, e1.ideographicsecretcircle = 12953, e1.ideographicselfparen = 12866, e1.ideographicsocietyparen = 12851, e1.ideographicspace = 12288, e1.ideographicspecialparen = 12853, e1.ideographicstockparen = 12849, e1.ideographicstudyparen = 12859, e1.ideographicsunparen = 12848, e1.ideographicsuperviseparen = 12860, e1.ideographicwaterparen = 12844, e1.ideographicwoodparen = 12845, e1.ideographiczero = 12295, e1.ideographmetalcircle = 12942, e1.ideographmooncircle = 12938, e1.ideographnamecircle = 12948, e1.ideographsuncircle = 12944, e1.ideographwatercircle = 12940, e1.ideographwoodcircle = 12941, e1.ideva = 2311, e1.idieresis = 239, e1.idieresisacute = 7727, e1.idieresiscyrillic = 1253, e1.idotbelow = 7883, e1.iebrevecyrillic = 1239, e1.iecyrillic = 1077, e1.ieungacirclekorean = 12917, e1.ieungaparenkorean = 12821, e1.ieungcirclekorean = 12903, e1.ieungkorean = 12615, e1.ieungparenkorean = 12807, e1.igrave = 236, e1.igujarati = 2695, e1.igurmukhi = 2567, e1.ihiragana = 12356, e1.ihookabove = 7881, e1.iibengali = 2440, e1.iicyrillic = 1080, e1.iideva = 2312, e1.iigujarati = 2696, e1.iigurmukhi = 2568, e1.iimatragurmukhi = 2624, e1.iinvertedbreve = 523, e1.iishortcyrillic = 1081, e1.iivowelsignbengali = 2496, e1.iivowelsigndeva = 2368, e1.iivowelsigngujarati = 2752, e1.ij = 307, e1.ikatakana = 12452, e1.ikatakanahalfwidth = 65394, e1.ikorean = 12643, e1.ilde = 732, e1.iluyhebrew = 1452, e1.imacron = 299, e1.imacroncyrillic = 1251, e1.imageorapproximatelyequal = 8787, e1.imatragurmukhi = 2623, e1.imonospace = 65353, e1.increment = 8710, e1.infinity = 8734, e1.iniarmenian = 1387, e1.integral = 8747, e1.integralbottom = 8993, e1.integralbt = 8993, e1.integralex = 63733, e1.integraltop = 8992, e1.integraltp = 8992, e1.intersection = 8745, e1.intisquare = 13061, e1.invbullet = 9688, e1.invcircle = 9689, e1.invsmileface = 9787, e1.iocyrillic = 1105, e1.iogonek = 303, e1.iota = 953, e1.iotadieresis = 970, e1.iotadieresistonos = 912, e1.iotalatin = 617, e1.iotatonos = 943, e1.iparen = 9380, e1.irigurmukhi = 2674, e1.ismallhiragana = 12355, e1.ismallkatakana = 12451, e1.ismallkatakanahalfwidth = 65384, e1.issharbengali = 2554, e1.istroke = 616, e1.isuperior = 63213, e1.iterationhiragana = 12445, e1.iterationkatakana = 12541, e1.itilde = 297, e1.itildebelow = 7725, e1.iubopomofo = 12585, e1.iucyrillic = 1102, e1.ivowelsignbengali = 2495, e1.ivowelsigndeva = 2367, e1.ivowelsigngujarati = 2751, e1.izhitsacyrillic = 1141, e1.izhitsadblgravecyrillic = 1143, e1.j = 106, e1.jaarmenian = 1393, e1.jabengali = 2460, e1.jadeva = 2332, e1.jagujarati = 2716, e1.jagurmukhi = 2588, e1.jbopomofo = 12560, e1.jcaron = 496, e1.jcircle = 9433, e1.jcircumflex = 309, e1.jcrossedtail = 669, e1.jdotlessstroke = 607, e1.jecyrillic = 1112, e1.jeemarabic = 1580, e1.jeemfinalarabic = 65182, e1.jeeminitialarabic = 65183, e1.jeemmedialarabic = 65184, e1.jeharabic = 1688, e1.jehfinalarabic = 64395, e1.jhabengali = 2461, e1.jhadeva = 2333, e1.jhagujarati = 2717, e1.jhagurmukhi = 2589, e1.jheharmenian = 1403, e1.jis = 12292, e1.jmonospace = 65354, e1.jparen = 9381, e1.jsuperior = 690, e1.k = 107, e1.kabashkircyrillic = 1185, e1.kabengali = 2453, e1.kacute = 7729, e1.kacyrillic = 1082, e1.kadescendercyrillic = 1179, e1.kadeva = 2325, e1.kaf = 1499, e1.kafarabic = 1603, e1.kafdagesh = 64315, e1.kafdageshhebrew = 64315, e1.kaffinalarabic = 65242, e1.kafhebrew = 1499, e1.kafinitialarabic = 65243, e1.kafmedialarabic = 65244, e1.kafrafehebrew = 64333, e1.kagujarati = 2709, e1.kagurmukhi = 2581, e1.kahiragana = 12363, e1.kahookcyrillic = 1220, e1.kakatakana = 12459, e1.kakatakanahalfwidth = 65398, e1.kappa = 954, e1.kappasymbolgreek = 1008, e1.kapyeounmieumkorean = 12657, e1.kapyeounphieuphkorean = 12676, e1.kapyeounpieupkorean = 12664, e1.kapyeounssangpieupkorean = 12665, e1.karoriisquare = 13069, e1.kashidaautoarabic = 1600, e1.kashidaautonosidebearingarabic = 1600, e1.kasmallkatakana = 12533, e1.kasquare = 13188, e1.kasraarabic = 1616, e1.kasratanarabic = 1613, e1.kastrokecyrillic = 1183, e1.katahiraprolongmarkhalfwidth = 65392, e1.kaverticalstrokecyrillic = 1181, e1.kbopomofo = 12558, e1.kcalsquare = 13193, e1.kcaron = 489, e1.kcedilla = 311, e1.kcircle = 9434, e1.kcommaaccent = 311, e1.kdotbelow = 7731, e1.keharmenian = 1412, e1.kehiragana = 12369, e1.kekatakana = 12465, e1.kekatakanahalfwidth = 65401, e1.kenarmenian = 1391, e1.kesmallkatakana = 12534, e1.kgreenlandic = 312, e1.khabengali = 2454, e1.khacyrillic = 1093, e1.khadeva = 2326, e1.khagujarati = 2710, e1.khagurmukhi = 2582, e1.khaharabic = 1582, e1.khahfinalarabic = 65190, e1.khahinitialarabic = 65191, e1.khahmedialarabic = 65192, e1.kheicoptic = 999, e1.khhadeva = 2393, e1.khhagurmukhi = 2649, e1.khieukhacirclekorean = 12920, e1.khieukhaparenkorean = 12824, e1.khieukhcirclekorean = 12906, e1.khieukhkorean = 12619, e1.khieukhparenkorean = 12810, e1.khokhaithai = 3586, e1.khokhonthai = 3589, e1.khokhuatthai = 3587, e1.khokhwaithai = 3588, e1.khomutthai = 3675, e1.khook = 409, e1.khorakhangthai = 3590, e1.khzsquare = 13201, e1.kihiragana = 12365, e1.kikatakana = 12461, e1.kikatakanahalfwidth = 65399, e1.kiroguramusquare = 13077, e1.kiromeetorusquare = 13078, e1.kirosquare = 13076, e1.kiyeokacirclekorean = 12910, e1.kiyeokaparenkorean = 12814, e1.kiyeokcirclekorean = 12896, e1.kiyeokkorean = 12593, e1.kiyeokparenkorean = 12800, e1.kiyeoksioskorean = 12595;
    e1.kjecyrillic = 1116, e1.klinebelow = 7733, e1.klsquare = 13208, e1.kmcubedsquare = 13222, e1.kmonospace = 65355, e1.kmsquaredsquare = 13218, e1.kohiragana = 12371, e1.kohmsquare = 13248, e1.kokaithai = 3585, e1.kokatakana = 12467, e1.kokatakanahalfwidth = 65402, e1.kooposquare = 13086, e1.koppacyrillic = 1153, e1.koreanstandardsymbol = 12927, e1.koroniscmb = 835, e1.kparen = 9382, e1.kpasquare = 13226, e1.ksicyrillic = 1135, e1.ktsquare = 13263, e1.kturned = 670, e1.kuhiragana = 12367, e1.kukatakana = 12463, e1.kukatakanahalfwidth = 65400, e1.kvsquare = 13240, e1.kwsquare = 13246, e1.l = 108, e1.labengali = 2482, e1.lacute = 314, e1.ladeva = 2354, e1.lagujarati = 2738, e1.lagurmukhi = 2610, e1.lakkhangyaothai = 3653, e1.lamaleffinalarabic = 65276, e1.lamalefhamzaabovefinalarabic = 65272, e1.lamalefhamzaaboveisolatedarabic = 65271, e1.lamalefhamzabelowfinalarabic = 65274, e1.lamalefhamzabelowisolatedarabic = 65273, e1.lamalefisolatedarabic = 65275, e1.lamalefmaddaabovefinalarabic = 65270, e1.lamalefmaddaaboveisolatedarabic = 65269, e1.lamarabic = 1604, e1.lambda = 955, e1.lambdastroke = 411, e1.lamed = 1500, e1.lameddagesh = 64316, e1.lameddageshhebrew = 64316, e1.lamedhebrew = 1500, e1.lamfinalarabic = 65246, e1.lamhahinitialarabic = 64714, e1.laminitialarabic = 65247, e1.lamjeeminitialarabic = 64713, e1.lamkhahinitialarabic = 64715, e1.lamlamhehisolatedarabic = 65010, e1.lammedialarabic = 65248, e1.lammeemhahinitialarabic = 64904, e1.lammeeminitialarabic = 64716, e1.largecircle = 9711, e1.lbar = 410, e1.lbelt = 620, e1.lbopomofo = 12556, e1.lcaron = 318, e1.lcedilla = 316, e1.lcircle = 9435, e1.lcircumflexbelow = 7741, e1.lcommaaccent = 316, e1.ldot = 320, e1.ldotaccent = 320, e1.ldotbelow = 7735, e1.ldotbelowmacron = 7737, e1.leftangleabovecmb = 794, e1.lefttackbelowcmb = 792, e1.less = 60, e1.lessequal = 8804, e1.lessequalorgreater = 8922, e1.lessmonospace = 65308, e1.lessorequivalent = 8818, e1.lessorgreater = 8822, e1.lessoverequal = 8806, e1.lesssmall = 65124, e1.lezh = 622, e1.lfblock = 9612, e1.lhookretroflex = 621, e1.lira = 8356, e1.liwnarmenian = 1388, e1.lj = 457, e1.ljecyrillic = 1113, e1.ll = 63168, e1.lladeva = 2355, e1.llagujarati = 2739, e1.llinebelow = 7739, e1.llladeva = 2356, e1.llvocalicbengali = 2529, e1.llvocalicdeva = 2401, e1.llvocalicvowelsignbengali = 2531, e1.llvocalicvowelsigndeva = 2403, e1.lmiddletilde = 619, e1.lmonospace = 65356, e1.lmsquare = 13264, e1.lochulathai = 3628, e1.logicaland = 8743, e1.logicalnot = 172, e1.logicalnotreversed = 8976, e1.logicalor = 8744, e1.lolingthai = 3621, e1.longs = 383, e1.lowlinecenterline = 65102, e1.lowlinecmb = 818, e1.lowlinedashed = 65101, e1.lozenge = 9674, e1.lparen = 9383, e1.lslash = 322, e1.lsquare = 8467, e1.lsuperior = 63214, e1.ltshade = 9617, e1.luthai = 3622, e1.lvocalicbengali = 2444, e1.lvocalicdeva = 2316, e1.lvocalicvowelsignbengali = 2530, e1.lvocalicvowelsigndeva = 2402, e1.lxsquare = 13267, e1.m = 109, e1.mabengali = 2478, e1.macron = 175, e1.macronbelowcmb = 817, e1.macroncmb = 772, e1.macronlowmod = 717, e1.macronmonospace = 65507, e1.macute = 7743, e1.madeva = 2350, e1.magujarati = 2734, e1.magurmukhi = 2606, e1.mahapakhhebrew = 1444, e1.mahapakhlefthebrew = 1444, e1.mahiragana = 12414, e1.maichattawalowleftthai = 63637, e1.maichattawalowrightthai = 63636, e1.maichattawathai = 3659, e1.maichattawaupperleftthai = 63635, e1.maieklowleftthai = 63628, e1.maieklowrightthai = 63627, e1.maiekthai = 3656, e1.maiekupperleftthai = 63626, e1.maihanakatleftthai = 63620, e1.maihanakatthai = 3633, e1.maitaikhuleftthai = 63625, e1.maitaikhuthai = 3655, e1.maitholowleftthai = 63631, e1.maitholowrightthai = 63630, e1.maithothai = 3657, e1.maithoupperleftthai = 63629, e1.maitrilowleftthai = 63634, e1.maitrilowrightthai = 63633, e1.maitrithai = 3658, e1.maitriupperleftthai = 63632, e1.maiyamokthai = 3654, e1.makatakana = 12510, e1.makatakanahalfwidth = 65423, e1.male = 9794, e1.mansyonsquare = 13127, e1.maqafhebrew = 1470, e1.mars = 9794, e1.masoracirclehebrew = 1455, e1.masquare = 13187, e1.mbopomofo = 12551, e1.mbsquare = 13268, e1.mcircle = 9436, e1.mcubedsquare = 13221, e1.mdotaccent = 7745, e1.mdotbelow = 7747, e1.meemarabic = 1605, e1.meemfinalarabic = 65250, e1.meeminitialarabic = 65251, e1.meemmedialarabic = 65252, e1.meemmeeminitialarabic = 64721, e1.meemmeemisolatedarabic = 64584, e1.meetorusquare = 13133, e1.mehiragana = 12417, e1.meizierasquare = 13182, e1.mekatakana = 12513, e1.mekatakanahalfwidth = 65426, e1.mem = 1502, e1.memdagesh = 64318, e1.memdageshhebrew = 64318, e1.memhebrew = 1502, e1.menarmenian = 1396, e1.merkhahebrew = 1445, e1.merkhakefulahebrew = 1446, e1.merkhakefulalefthebrew = 1446, e1.merkhalefthebrew = 1445, e1.mhook = 625, e1.mhzsquare = 13202, e1.middledotkatakanahalfwidth = 65381, e1.middot = 183, e1.mieumacirclekorean = 12914, e1.mieumaparenkorean = 12818, e1.mieumcirclekorean = 12900, e1.mieumkorean = 12609, e1.mieumpansioskorean = 12656, e1.mieumparenkorean = 12804, e1.mieumpieupkorean = 12654, e1.mieumsioskorean = 12655, e1.mihiragana = 12415, e1.mikatakana = 12511, e1.mikatakanahalfwidth = 65424, e1.minus = 8722, e1.minusbelowcmb = 800, e1.minuscircle = 8854, e1.minusmod = 727, e1.minusplus = 8723, e1.minute = 8242, e1.miribaarusquare = 13130, e1.mirisquare = 13129, e1.mlonglegturned = 624, e1.mlsquare = 13206, e1.mmcubedsquare = 13219, e1.mmonospace = 65357, e1.mmsquaredsquare = 13215, e1.mohiragana = 12418, e1.mohmsquare = 13249, e1.mokatakana = 12514, e1.mokatakanahalfwidth = 65427, e1.molsquare = 13270, e1.momathai = 3617, e1.moverssquare = 13223, e1.moverssquaredsquare = 13224, e1.mparen = 9384, e1.mpasquare = 13227, e1.mssquare = 13235, e1.msuperior = 63215, e1.mturned = 623, e1.mu = 181, e1.mu1 = 181, e1.muasquare = 13186, e1.muchgreater = 8811, e1.muchless = 8810, e1.mufsquare = 13196, e1.mugreek = 956, e1.mugsquare = 13197, e1.muhiragana = 12416, e1.mukatakana = 12512, e1.mukatakanahalfwidth = 65425, e1.mulsquare = 13205, e1.multiply = 215, e1.mumsquare = 13211, e1.munahhebrew = 1443, e1.munahlefthebrew = 1443, e1.musicalnote = 9834, e1.musicalnotedbl = 9835, e1.musicflatsign = 9837, e1.musicsharpsign = 9839, e1.mussquare = 13234, e1.muvsquare = 13238, e1.muwsquare = 13244, e1.mvmegasquare = 13241, e1.mvsquare = 13239, e1.mwmegasquare = 13247, e1.mwsquare = 13245, e1.n = 110, e1.nabengali = 2472, e1.nabla = 8711, e1.nacute = 324, e1.nadeva = 2344, e1.nagujarati = 2728, e1.nagurmukhi = 2600, e1.nahiragana = 12394, e1.nakatakana = 12490, e1.nakatakanahalfwidth = 65413, e1.napostrophe = 329, e1.nasquare = 13185, e1.nbopomofo = 12555, e1.nbspace = 160, e1.ncaron = 328, e1.ncedilla = 326, e1.ncircle = 9437, e1.ncircumflexbelow = 7755, e1.ncommaaccent = 326, e1.ndotaccent = 7749, e1.ndotbelow = 7751, e1.nehiragana = 12397, e1.nekatakana = 12493, e1.nekatakanahalfwidth = 65416, e1.newsheqelsign = 8362, e1.nfsquare = 13195, e1.ngabengali = 2457, e1.ngadeva = 2329, e1.ngagujarati = 2713, e1.ngagurmukhi = 2585, e1.ngonguthai = 3591, e1.nhiragana = 12435, e1.nhookleft = 626, e1.nhookretroflex = 627, e1.nieunacirclekorean = 12911, e1.nieunaparenkorean = 12815, e1.nieuncieuckorean = 12597, e1.nieuncirclekorean = 12897, e1.nieunhieuhkorean = 12598, e1.nieunkorean = 12596, e1.nieunpansioskorean = 12648, e1.nieunparenkorean = 12801, e1.nieunsioskorean = 12647, e1.nieuntikeutkorean = 12646, e1.nihiragana = 12395, e1.nikatakana = 12491, e1.nikatakanahalfwidth = 65414, e1.nikhahitleftthai = 63641, e1.nikhahitthai = 3661, e1.nine = 57, e1.ninearabic = 1641, e1.ninebengali = 2543, e1.ninecircle = 9320, e1.ninecircleinversesansserif = 10130, e1.ninedeva = 2415, e1.ninegujarati = 2799, e1.ninegurmukhi = 2671, e1.ninehackarabic = 1641, e1.ninehangzhou = 12329, e1.nineideographicparen = 12840, e1.nineinferior = 8329, e1.ninemonospace = 65305, e1.nineoldstyle = 63289, e1.nineparen = 9340, e1.nineperiod = 9360, e1.ninepersian = 1785, e1.nineroman = 8568, e1.ninesuperior = 8313, e1.nineteencircle = 9330, e1.nineteenparen = 9350, e1.nineteenperiod = 9370, e1.ninethai = 3673, e1.nj = 460, e1.njecyrillic = 1114, e1.nkatakana = 12531, e1.nkatakanahalfwidth = 65437, e1.nlegrightlong = 414, e1.nlinebelow = 7753, e1.nmonospace = 65358, e1.nmsquare = 13210, e1.nnabengali = 2467, e1.nnadeva = 2339, e1.nnagujarati = 2723, e1.nnagurmukhi = 2595, e1.nnnadeva = 2345, e1.nohiragana = 12398, e1.nokatakana = 12494, e1.nokatakanahalfwidth = 65417, e1.nonbreakingspace = 160, e1.nonenthai = 3603, e1.nonuthai = 3609, e1.noonarabic = 1606, e1.noonfinalarabic = 65254, e1.noonghunnaarabic = 1722, e1.noonghunnafinalarabic = 64415, e1.nooninitialarabic = 65255, e1.noonjeeminitialarabic = 64722, e1.noonjeemisolatedarabic = 64587, e1.noonmedialarabic = 65256, e1.noonmeeminitialarabic = 64725, e1.noonmeemisolatedarabic = 64590, e1.noonnoonfinalarabic = 64653, e1.notcontains = 8716, e1.notelement = 8713, e1.notelementof = 8713, e1.notequal = 8800, e1.notgreater = 8815, e1.notgreaternorequal = 8817, e1.notgreaternorless = 8825, e1.notidentical = 8802, e1.notless = 8814, e1.notlessnorequal = 8816, e1.notparallel = 8742, e1.notprecedes = 8832, e1.notsubset = 8836, e1.notsucceeds = 8833, e1.notsuperset = 8837, e1.nowarmenian = 1398, e1.nparen = 9385, e1.nssquare = 13233, e1.nsuperior = 8319, e1.ntilde = 241, e1.nu = 957, e1.nuhiragana = 12396, e1.nukatakana = 12492, e1.nukatakanahalfwidth = 65415, e1.nuktabengali = 2492, e1.nuktadeva = 2364, e1.nuktagujarati = 2748, e1.nuktagurmukhi = 2620, e1.numbersign = 35, e1.numbersignmonospace = 65283, e1.numbersignsmall = 65119, e1.numeralsigngreek = 884, e1.numeralsignlowergreek = 885, e1.numero = 8470, e1.nun = 1504, e1.nundagesh = 64320, e1.nundageshhebrew = 64320, e1.nunhebrew = 1504, e1.nvsquare = 13237, e1.nwsquare = 13243, e1.nyabengali = 2462, e1.nyadeva = 2334, e1.nyagujarati = 2718, e1.nyagurmukhi = 2590, e1.o = 111, e1.oacute = 243, e1.oangthai = 3629, e1.obarred = 629, e1.obarredcyrillic = 1257, e1.obarreddieresiscyrillic = 1259, e1.obengali = 2451, e1.obopomofo = 12571, e1.obreve = 335, e1.ocandradeva = 2321, e1.ocandragujarati = 2705, e1.ocandravowelsigndeva = 2377, e1.ocandravowelsigngujarati = 2761, e1.ocaron = 466, e1.ocircle = 9438, e1.ocircumflex = 244, e1.ocircumflexacute = 7889, e1.ocircumflexdotbelow = 7897, e1.ocircumflexgrave = 7891, e1.ocircumflexhookabove = 7893, e1.ocircumflextilde = 7895, e1.ocyrillic = 1086, e1.odblacute = 337, e1.odblgrave = 525, e1.odeva = 2323, e1.odieresis = 246, e1.odieresiscyrillic = 1255, e1.odotbelow = 7885, e1.oe = 339, e1.oekorean = 12634, e1.ogonek = 731, e1.ogonekcmb = 808, e1.ograve = 242, e1.ogujarati = 2707, e1.oharmenian = 1413, e1.ohiragana = 12362, e1.ohookabove = 7887, e1.ohorn = 417, e1.ohornacute = 7899, e1.ohorndotbelow = 7907, e1.ohorngrave = 7901, e1.ohornhookabove = 7903, e1.ohorntilde = 7905, e1.ohungarumlaut = 337, e1.oi = 419, e1.oinvertedbreve = 527, e1.okatakana = 12458, e1.okatakanahalfwidth = 65397, e1.okorean = 12631, e1.olehebrew = 1451, e1.omacron = 333, e1.omacronacute = 7763, e1.omacrongrave = 7761, e1.omdeva = 2384, e1.omega = 969, e1.omega1 = 982, e1.omegacyrillic = 1121, e1.omegalatinclosed = 631, e1.omegaroundcyrillic = 1147, e1.omegatitlocyrillic = 1149, e1.omegatonos = 974, e1.omgujarati = 2768, e1.omicron = 959, e1.omicrontonos = 972, e1.omonospace = 65359, e1.one = 49, e1.onearabic = 1633, e1.onebengali = 2535, e1.onecircle = 9312, e1.onecircleinversesansserif = 10122, e1.onedeva = 2407, e1.onedotenleader = 8228, e1.oneeighth = 8539, e1.onefitted = 63196, e1.onegujarati = 2791, e1.onegurmukhi = 2663, e1.onehackarabic = 1633, e1.onehalf = 189, e1.onehangzhou = 12321, e1.oneideographicparen = 12832, e1.oneinferior = 8321, e1.onemonospace = 65297, e1.onenumeratorbengali = 2548, e1.oneoldstyle = 63281, e1.oneparen = 9332, e1.oneperiod = 9352, e1.onepersian = 1777, e1.onequarter = 188, e1.oneroman = 8560, e1.onesuperior = 185, e1.onethai = 3665, e1.onethird = 8531, e1.oogonek = 491, e1.oogonekmacron = 493, e1.oogurmukhi = 2579, e1.oomatragurmukhi = 2635, e1.oopen = 596, e1.oparen = 9386, e1.openbullet = 9702, e1.option = 8997, e1.ordfeminine = 170, e1.ordmasculine = 186, e1.orthogonal = 8735, e1.oshortdeva = 2322, e1.oshortvowelsigndeva = 2378, e1.oslash = 248, e1.oslashacute = 511, e1.osmallhiragana = 12361, e1.osmallkatakana = 12457, e1.osmallkatakanahalfwidth = 65387, e1.ostrokeacute = 511, e1.osuperior = 63216, e1.otcyrillic = 1151, e1.otilde = 245, e1.otildeacute = 7757, e1.otildedieresis = 7759, e1.oubopomofo = 12577, e1.overline = 8254, e1.overlinecenterline = 65098, e1.overlinecmb = 773, e1.overlinedashed = 65097, e1.overlinedblwavy = 65100, e1.overlinewavy = 65099, e1.overscore = 175, e1.ovowelsignbengali = 2507, e1.ovowelsigndeva = 2379, e1.ovowelsigngujarati = 2763, e1.p = 112, e1.paampssquare = 13184, e1.paasentosquare = 13099, e1.pabengali = 2474, e1.pacute = 7765, e1.padeva = 2346, e1.pagedown = 8671, e1.pageup = 8670, e1.pagujarati = 2730, e1.pagurmukhi = 2602, e1.pahiragana = 12401, e1.paiyannoithai = 3631, e1.pakatakana = 12497, e1.palatalizationcyrilliccmb = 1156, e1.palochkacyrillic = 1216, e1.pansioskorean = 12671, e1.paragraph = 182, e1.parallel = 8741, e1.parenleft = 40, e1.parenleftaltonearabic = 64830, e1.parenleftbt = 63725, e1.parenleftex = 63724, e1.parenleftinferior = 8333, e1.parenleftmonospace = 65288, e1.parenleftsmall = 65113, e1.parenleftsuperior = 8317, e1.parenlefttp = 63723, e1.parenleftvertical = 65077, e1.parenright = 41, e1.parenrightaltonearabic = 64831, e1.parenrightbt = 63736, e1.parenrightex = 63735, e1.parenrightinferior = 8334, e1.parenrightmonospace = 65289, e1.parenrightsmall = 65114, e1.parenrightsuperior = 8318, e1.parenrighttp = 63734, e1.parenrightvertical = 65078, e1.partialdiff = 8706, e1.paseqhebrew = 1472, e1.pashtahebrew = 1433, e1.pasquare = 13225, e1.patah = 1463, e1.patah11 = 1463, e1.patah1d = 1463, e1.patah2a = 1463, e1.patahhebrew = 1463, e1.patahnarrowhebrew = 1463, e1.patahquarterhebrew = 1463, e1.patahwidehebrew = 1463, e1.pazerhebrew = 1441, e1.pbopomofo = 12550, e1.pcircle = 9439, e1.pdotaccent = 7767, e1.pe = 1508, e1.pecyrillic = 1087, e1.pedagesh = 64324, e1.pedageshhebrew = 64324, e1.peezisquare = 13115, e1.pefinaldageshhebrew = 64323, e1.peharabic = 1662, e1.peharmenian = 1402, e1.pehebrew = 1508, e1.pehfinalarabic = 64343, e1.pehinitialarabic = 64344, e1.pehiragana = 12410, e1.pehmedialarabic = 64345, e1.pekatakana = 12506, e1.pemiddlehookcyrillic = 1191, e1.perafehebrew = 64334, e1.percent = 37, e1.percentarabic = 1642, e1.percentmonospace = 65285, e1.percentsmall = 65130, e1.period = 46, e1.periodarmenian = 1417, e1.periodcentered = 183, e1.periodhalfwidth = 65377, e1.periodinferior = 63207, e1.periodmonospace = 65294, e1.periodsmall = 65106, e1.periodsuperior = 63208, e1.perispomenigreekcmb = 834, e1.perpendicular = 8869, e1.perthousand = 8240, e1.peseta = 8359, e1.pfsquare = 13194, e1.phabengali = 2475, e1.phadeva = 2347, e1.phagujarati = 2731, e1.phagurmukhi = 2603, e1.phi = 966, e1.phi1 = 981, e1.phieuphacirclekorean = 12922, e1.phieuphaparenkorean = 12826, e1.phieuphcirclekorean = 12908, e1.phieuphkorean = 12621, e1.phieuphparenkorean = 12812, e1.philatin = 632, e1.phinthuthai = 3642, e1.phisymbolgreek = 981, e1.phook = 421, e1.phophanthai = 3614, e1.phophungthai = 3612, e1.phosamphaothai = 3616, e1.pi = 960, e1.pieupacirclekorean = 12915, e1.pieupaparenkorean = 12819, e1.pieupcieuckorean = 12662, e1.pieupcirclekorean = 12901, e1.pieupkiyeokkorean = 12658, e1.pieupkorean = 12610, e1.pieupparenkorean = 12805, e1.pieupsioskiyeokkorean = 12660, e1.pieupsioskorean = 12612, e1.pieupsiostikeutkorean = 12661, e1.pieupthieuthkorean = 12663, e1.pieuptikeutkorean = 12659, e1.pihiragana = 12404, e1.pikatakana = 12500, e1.pisymbolgreek = 982, e1.piwrarmenian = 1411, e1.planckover2pi = 8463, e1.planckover2pi1 = 8463, e1.plus = 43, e1.plusbelowcmb = 799, e1.pluscircle = 8853, e1.plusminus = 177, e1.plusmod = 726, e1.plusmonospace = 65291, e1.plussmall = 65122, e1.plussuperior = 8314, e1.pmonospace = 65360, e1.pmsquare = 13272, e1.pohiragana = 12413, e1.pointingindexdownwhite = 9759, e1.pointingindexleftwhite = 9756, e1.pointingindexrightwhite = 9758, e1.pointingindexupwhite = 9757, e1.pokatakana = 12509, e1.poplathai = 3611, e1.postalmark = 12306, e1.postalmarkface = 12320, e1.pparen = 9387, e1.precedes = 8826, e1.prescription = 8478, e1.primemod = 697, e1.primereversed = 8245, e1.product = 8719, e1.projective = 8965, e1.prolongedkana = 12540, e1.propellor = 8984, e1.propersubset = 8834, e1.propersuperset = 8835, e1.proportion = 8759, e1.proportional = 8733, e1.psi = 968, e1.psicyrillic = 1137, e1.psilipneumatacyrilliccmb = 1158, e1.pssquare = 13232, e1.puhiragana = 12407, e1.pukatakana = 12503, e1.pvsquare = 13236, e1.pwsquare = 13242, e1.q = 113, e1.qadeva = 2392, e1.qadmahebrew = 1448, e1.qafarabic = 1602, e1.qaffinalarabic = 65238, e1.qafinitialarabic = 65239, e1.qafmedialarabic = 65240, e1.qamats = 1464, e1.qamats10 = 1464, e1.qamats1a = 1464, e1.qamats1c = 1464, e1.qamats27 = 1464, e1.qamats29 = 1464, e1.qamats33 = 1464, e1.qamatsde = 1464, e1.qamatshebrew = 1464, e1.qamatsnarrowhebrew = 1464, e1.qamatsqatanhebrew = 1464, e1.qamatsqatannarrowhebrew = 1464, e1.qamatsqatanquarterhebrew = 1464, e1.qamatsqatanwidehebrew = 1464, e1.qamatsquarterhebrew = 1464, e1.qamatswidehebrew = 1464, e1.qarneyparahebrew = 1439, e1.qbopomofo = 12561, e1.qcircle = 9440, e1.qhook = 672, e1.qmonospace = 65361, e1.qof = 1511, e1.qofdagesh = 64327, e1.qofdageshhebrew = 64327, e1.qofhebrew = 1511, e1.qparen = 9388, e1.quarternote = 9833, e1.qubuts = 1467, e1.qubuts18 = 1467, e1.qubuts25 = 1467, e1.qubuts31 = 1467, e1.qubutshebrew = 1467, e1.qubutsnarrowhebrew = 1467, e1.qubutsquarterhebrew = 1467, e1.qubutswidehebrew = 1467, e1.question = 63, e1.questionarabic = 1567, e1.questionarmenian = 1374, e1.questiondown = 191, e1.questiondownsmall = 63423, e1.questiongreek = 894, e1.questionmonospace = 65311, e1.questionsmall = 63295, e1.quotedbl = 34, e1.quotedblbase = 8222, e1.quotedblleft = 8220, e1.quotedblmonospace = 65282, e1.quotedblprime = 12318, e1.quotedblprimereversed = 12317, e1.quotedblright = 8221, e1.quoteleft = 8216, e1.quoteleftreversed = 8219, e1.quotereversed = 8219, e1.quoteright = 8217, e1.quoterightn = 329, e1.quotesinglbase = 8218, e1.quotesingle = 39, e1.quotesinglemonospace = 65287, e1.r = 114, e1.raarmenian = 1404, e1.rabengali = 2480, e1.racute = 341, e1.radeva = 2352, e1.radical = 8730, e1.radicalex = 63717, e1.radoverssquare = 13230, e1.radoverssquaredsquare = 13231, e1.radsquare = 13229, e1.rafe = 1471, e1.rafehebrew = 1471, e1.ragujarati = 2736, e1.ragurmukhi = 2608, e1.rahiragana = 12425, e1.rakatakana = 12521, e1.rakatakanahalfwidth = 65431, e1.ralowerdiagonalbengali = 2545, e1.ramiddlediagonalbengali = 2544, e1.ramshorn = 612, e1.ratio = 8758, e1.rbopomofo = 12566, e1.rcaron = 345, e1.rcedilla = 343, e1.rcircle = 9441, e1.rcommaaccent = 343, e1.rdblgrave = 529, e1.rdotaccent = 7769, e1.rdotbelow = 7771, e1.rdotbelowmacron = 7773, e1.referencemark = 8251, e1.reflexsubset = 8838, e1.reflexsuperset = 8839, e1.registered = 174, e1.registersans = 63720, e1.registerserif = 63194, e1.reharabic = 1585, e1.reharmenian = 1408, e1.rehfinalarabic = 65198, e1.rehiragana = 12428, e1.rekatakana = 12524;
    e1.rekatakanahalfwidth = 65434, e1.resh = 1512, e1.reshdageshhebrew = 64328, e1.reshhebrew = 1512, e1.reversedtilde = 8765, e1.reviahebrew = 1431, e1.reviamugrashhebrew = 1431, e1.revlogicalnot = 8976, e1.rfishhook = 638, e1.rfishhookreversed = 639, e1.rhabengali = 2525, e1.rhadeva = 2397, e1.rho = 961, e1.rhook = 637, e1.rhookturned = 635, e1.rhookturnedsuperior = 693, e1.rhosymbolgreek = 1009, e1.rhotichookmod = 734, e1.rieulacirclekorean = 12913, e1.rieulaparenkorean = 12817, e1.rieulcirclekorean = 12899, e1.rieulhieuhkorean = 12608, e1.rieulkiyeokkorean = 12602, e1.rieulkiyeoksioskorean = 12649, e1.rieulkorean = 12601, e1.rieulmieumkorean = 12603, e1.rieulpansioskorean = 12652, e1.rieulparenkorean = 12803, e1.rieulphieuphkorean = 12607, e1.rieulpieupkorean = 12604, e1.rieulpieupsioskorean = 12651, e1.rieulsioskorean = 12605, e1.rieulthieuthkorean = 12606, e1.rieultikeutkorean = 12650, e1.rieulyeorinhieuhkorean = 12653, e1.rightangle = 8735, e1.righttackbelowcmb = 793, e1.righttriangle = 8895, e1.rihiragana = 12426, e1.rikatakana = 12522, e1.rikatakanahalfwidth = 65432, e1.ring = 730, e1.ringbelowcmb = 805, e1.ringcmb = 778, e1.ringhalfleft = 703, e1.ringhalfleftarmenian = 1369, e1.ringhalfleftbelowcmb = 796, e1.ringhalfleftcentered = 723, e1.ringhalfright = 702, e1.ringhalfrightbelowcmb = 825, e1.ringhalfrightcentered = 722, e1.rinvertedbreve = 531, e1.rittorusquare = 13137, e1.rlinebelow = 7775, e1.rlongleg = 636, e1.rlonglegturned = 634, e1.rmonospace = 65362, e1.rohiragana = 12429, e1.rokatakana = 12525, e1.rokatakanahalfwidth = 65435, e1.roruathai = 3619, e1.rparen = 9389, e1.rrabengali = 2524, e1.rradeva = 2353, e1.rragurmukhi = 2652, e1.rreharabic = 1681, e1.rrehfinalarabic = 64397, e1.rrvocalicbengali = 2528, e1.rrvocalicdeva = 2400, e1.rrvocalicgujarati = 2784, e1.rrvocalicvowelsignbengali = 2500, e1.rrvocalicvowelsigndeva = 2372, e1.rrvocalicvowelsigngujarati = 2756, e1.rsuperior = 63217, e1.rtblock = 9616, e1.rturned = 633, e1.rturnedsuperior = 692, e1.ruhiragana = 12427, e1.rukatakana = 12523, e1.rukatakanahalfwidth = 65433, e1.rupeemarkbengali = 2546, e1.rupeesignbengali = 2547, e1.rupiah = 63197, e1.ruthai = 3620, e1.rvocalicbengali = 2443, e1.rvocalicdeva = 2315, e1.rvocalicgujarati = 2699, e1.rvocalicvowelsignbengali = 2499, e1.rvocalicvowelsigndeva = 2371, e1.rvocalicvowelsigngujarati = 2755, e1.s = 115, e1.sabengali = 2488, e1.sacute = 347, e1.sacutedotaccent = 7781, e1.sadarabic = 1589, e1.sadeva = 2360, e1.sadfinalarabic = 65210, e1.sadinitialarabic = 65211, e1.sadmedialarabic = 65212, e1.sagujarati = 2744, e1.sagurmukhi = 2616, e1.sahiragana = 12373, e1.sakatakana = 12469, e1.sakatakanahalfwidth = 65403, e1.sallallahoualayhewasallamarabic = 65018, e1.samekh = 1505, e1.samekhdagesh = 64321, e1.samekhdageshhebrew = 64321, e1.samekhhebrew = 1505, e1.saraaathai = 3634, e1.saraaethai = 3649, e1.saraaimaimalaithai = 3652, e1.saraaimaimuanthai = 3651, e1.saraamthai = 3635, e1.saraathai = 3632, e1.saraethai = 3648, e1.saraiileftthai = 63622, e1.saraiithai = 3637, e1.saraileftthai = 63621, e1.saraithai = 3636, e1.saraothai = 3650, e1.saraueeleftthai = 63624, e1.saraueethai = 3639, e1.saraueleftthai = 63623, e1.sarauethai = 3638, e1.sarauthai = 3640, e1.sarauuthai = 3641, e1.sbopomofo = 12569, e1.scaron = 353, e1.scarondotaccent = 7783, e1.scedilla = 351, e1.schwa = 601, e1.schwacyrillic = 1241, e1.schwadieresiscyrillic = 1243, e1.schwahook = 602, e1.scircle = 9442, e1.scircumflex = 349, e1.scommaaccent = 537, e1.sdotaccent = 7777, e1.sdotbelow = 7779, e1.sdotbelowdotaccent = 7785, e1.seagullbelowcmb = 828, e1.second = 8243, e1.secondtonechinese = 714, e1.section = 167, e1.seenarabic = 1587, e1.seenfinalarabic = 65202, e1.seeninitialarabic = 65203, e1.seenmedialarabic = 65204, e1.segol = 1462, e1.segol13 = 1462, e1.segol1f = 1462, e1.segol2c = 1462, e1.segolhebrew = 1462, e1.segolnarrowhebrew = 1462, e1.segolquarterhebrew = 1462, e1.segoltahebrew = 1426, e1.segolwidehebrew = 1462, e1.seharmenian = 1405, e1.sehiragana = 12379, e1.sekatakana = 12475, e1.sekatakanahalfwidth = 65406, e1.semicolon = 59, e1.semicolonarabic = 1563, e1.semicolonmonospace = 65307, e1.semicolonsmall = 65108, e1.semivoicedmarkkana = 12444, e1.semivoicedmarkkanahalfwidth = 65439, e1.sentisquare = 13090, e1.sentosquare = 13091, e1.seven = 55, e1.sevenarabic = 1639, e1.sevenbengali = 2541, e1.sevencircle = 9318, e1.sevencircleinversesansserif = 10128, e1.sevendeva = 2413, e1.seveneighths = 8542, e1.sevengujarati = 2797, e1.sevengurmukhi = 2669, e1.sevenhackarabic = 1639, e1.sevenhangzhou = 12327, e1.sevenideographicparen = 12838, e1.seveninferior = 8327, e1.sevenmonospace = 65303, e1.sevenoldstyle = 63287, e1.sevenparen = 9338, e1.sevenperiod = 9358, e1.sevenpersian = 1783, e1.sevenroman = 8566, e1.sevensuperior = 8311, e1.seventeencircle = 9328, e1.seventeenparen = 9348, e1.seventeenperiod = 9368, e1.seventhai = 3671, e1.sfthyphen = 173, e1.shaarmenian = 1399, e1.shabengali = 2486, e1.shacyrillic = 1096, e1.shaddaarabic = 1617, e1.shaddadammaarabic = 64609, e1.shaddadammatanarabic = 64606, e1.shaddafathaarabic = 64608, e1.shaddakasraarabic = 64610, e1.shaddakasratanarabic = 64607, e1.shade = 9618, e1.shadedark = 9619, e1.shadelight = 9617, e1.shademedium = 9618, e1.shadeva = 2358, e1.shagujarati = 2742, e1.shagurmukhi = 2614, e1.shalshelethebrew = 1427, e1.shbopomofo = 12565, e1.shchacyrillic = 1097, e1.sheenarabic = 1588, e1.sheenfinalarabic = 65206, e1.sheeninitialarabic = 65207, e1.sheenmedialarabic = 65208, e1.sheicoptic = 995, e1.sheqel = 8362, e1.sheqelhebrew = 8362, e1.sheva = 1456, e1.sheva115 = 1456, e1.sheva15 = 1456, e1.sheva22 = 1456, e1.sheva2e = 1456, e1.shevahebrew = 1456, e1.shevanarrowhebrew = 1456, e1.shevaquarterhebrew = 1456, e1.shevawidehebrew = 1456, e1.shhacyrillic = 1211, e1.shimacoptic = 1005, e1.shin = 1513, e1.shindagesh = 64329, e1.shindageshhebrew = 64329, e1.shindageshshindot = 64300, e1.shindageshshindothebrew = 64300, e1.shindageshsindot = 64301, e1.shindageshsindothebrew = 64301, e1.shindothebrew = 1473, e1.shinhebrew = 1513, e1.shinshindot = 64298, e1.shinshindothebrew = 64298, e1.shinsindot = 64299, e1.shinsindothebrew = 64299, e1.shook = 642, e1.sigma = 963, e1.sigma1 = 962, e1.sigmafinal = 962, e1.sigmalunatesymbolgreek = 1010, e1.sihiragana = 12375, e1.sikatakana = 12471, e1.sikatakanahalfwidth = 65404, e1.siluqhebrew = 1469, e1.siluqlefthebrew = 1469, e1.similar = 8764, e1.sindothebrew = 1474, e1.siosacirclekorean = 12916, e1.siosaparenkorean = 12820, e1.sioscieuckorean = 12670, e1.sioscirclekorean = 12902, e1.sioskiyeokkorean = 12666, e1.sioskorean = 12613, e1.siosnieunkorean = 12667, e1.siosparenkorean = 12806, e1.siospieupkorean = 12669, e1.siostikeutkorean = 12668, e1.six = 54, e1.sixarabic = 1638, e1.sixbengali = 2540, e1.sixcircle = 9317, e1.sixcircleinversesansserif = 10127, e1.sixdeva = 2412, e1.sixgujarati = 2796, e1.sixgurmukhi = 2668, e1.sixhackarabic = 1638, e1.sixhangzhou = 12326, e1.sixideographicparen = 12837, e1.sixinferior = 8326, e1.sixmonospace = 65302, e1.sixoldstyle = 63286, e1.sixparen = 9337, e1.sixperiod = 9357, e1.sixpersian = 1782, e1.sixroman = 8565, e1.sixsuperior = 8310, e1.sixteencircle = 9327, e1.sixteencurrencydenominatorbengali = 2553, e1.sixteenparen = 9347, e1.sixteenperiod = 9367, e1.sixthai = 3670, e1.slash = 47, e1.slashmonospace = 65295, e1.slong = 383, e1.slongdotaccent = 7835, e1.smileface = 9786, e1.smonospace = 65363, e1.sofpasuqhebrew = 1475, e1.softhyphen = 173, e1.softsigncyrillic = 1100, e1.sohiragana = 12381, e1.sokatakana = 12477, e1.sokatakanahalfwidth = 65407, e1.soliduslongoverlaycmb = 824, e1.solidusshortoverlaycmb = 823, e1.sorusithai = 3625, e1.sosalathai = 3624, e1.sosothai = 3595, e1.sosuathai = 3626, e1.space = 32, e1.spacehackarabic = 32, e1.spade = 9824, e1.spadesuitblack = 9824, e1.spadesuitwhite = 9828, e1.sparen = 9390, e1.squarebelowcmb = 827, e1.squarecc = 13252, e1.squarecm = 13213, e1.squarediagonalcrosshatchfill = 9641, e1.squarehorizontalfill = 9636, e1.squarekg = 13199, e1.squarekm = 13214, e1.squarekmcapital = 13262, e1.squareln = 13265, e1.squarelog = 13266, e1.squaremg = 13198, e1.squaremil = 13269, e1.squaremm = 13212, e1.squaremsquared = 13217, e1.squareorthogonalcrosshatchfill = 9638, e1.squareupperlefttolowerrightfill = 9639, e1.squareupperrighttolowerleftfill = 9640, e1.squareverticalfill = 9637, e1.squarewhitewithsmallblack = 9635, e1.srsquare = 13275, e1.ssabengali = 2487, e1.ssadeva = 2359, e1.ssagujarati = 2743, e1.ssangcieuckorean = 12617, e1.ssanghieuhkorean = 12677, e1.ssangieungkorean = 12672, e1.ssangkiyeokkorean = 12594, e1.ssangnieunkorean = 12645, e1.ssangpieupkorean = 12611, e1.ssangsioskorean = 12614, e1.ssangtikeutkorean = 12600, e1.ssuperior = 63218, e1.sterling = 163, e1.sterlingmonospace = 65505, e1.strokelongoverlaycmb = 822, e1.strokeshortoverlaycmb = 821, e1.subset = 8834, e1.subsetnotequal = 8842, e1.subsetorequal = 8838, e1.succeeds = 8827, e1.suchthat = 8715, e1.suhiragana = 12377, e1.sukatakana = 12473, e1.sukatakanahalfwidth = 65405, e1.sukunarabic = 1618, e1.summation = 8721, e1.sun = 9788, e1.superset = 8835, e1.supersetnotequal = 8843, e1.supersetorequal = 8839, e1.svsquare = 13276, e1.syouwaerasquare = 13180, e1.t = 116, e1.tabengali = 2468, e1.tackdown = 8868, e1.tackleft = 8867, e1.tadeva = 2340, e1.tagujarati = 2724, e1.tagurmukhi = 2596, e1.taharabic = 1591, e1.tahfinalarabic = 65218, e1.tahinitialarabic = 65219, e1.tahiragana = 12383, e1.tahmedialarabic = 65220, e1.taisyouerasquare = 13181, e1.takatakana = 12479, e1.takatakanahalfwidth = 65408, e1.tatweelarabic = 1600, e1.tau = 964, e1.tav = 1514, e1.tavdages = 64330, e1.tavdagesh = 64330, e1.tavdageshhebrew = 64330, e1.tavhebrew = 1514, e1.tbar = 359, e1.tbopomofo = 12554, e1.tcaron = 357, e1.tccurl = 680, e1.tcedilla = 355, e1.tcheharabic = 1670, e1.tchehfinalarabic = 64379, e1.tchehinitialarabic = 64380, e1.tchehmedialarabic = 64381, e1.tcircle = 9443, e1.tcircumflexbelow = 7793, e1.tcommaaccent = 355, e1.tdieresis = 7831, e1.tdotaccent = 7787, e1.tdotbelow = 7789, e1.tecyrillic = 1090, e1.tedescendercyrillic = 1197, e1.teharabic = 1578, e1.tehfinalarabic = 65174, e1.tehhahinitialarabic = 64674, e1.tehhahisolatedarabic = 64524, e1.tehinitialarabic = 65175, e1.tehiragana = 12390, e1.tehjeeminitialarabic = 64673, e1.tehjeemisolatedarabic = 64523, e1.tehmarbutaarabic = 1577, e1.tehmarbutafinalarabic = 65172, e1.tehmedialarabic = 65176, e1.tehmeeminitialarabic = 64676, e1.tehmeemisolatedarabic = 64526, e1.tehnoonfinalarabic = 64627, e1.tekatakana = 12486, e1.tekatakanahalfwidth = 65411, e1.telephone = 8481, e1.telephoneblack = 9742, e1.telishagedolahebrew = 1440, e1.telishaqetanahebrew = 1449, e1.tencircle = 9321, e1.tenideographicparen = 12841, e1.tenparen = 9341, e1.tenperiod = 9361, e1.tenroman = 8569, e1.tesh = 679, e1.tet = 1496, e1.tetdagesh = 64312, e1.tetdageshhebrew = 64312, e1.tethebrew = 1496, e1.tetsecyrillic = 1205, e1.tevirhebrew = 1435, e1.tevirlefthebrew = 1435, e1.thabengali = 2469, e1.thadeva = 2341, e1.thagujarati = 2725, e1.thagurmukhi = 2597, e1.thalarabic = 1584, e1.thalfinalarabic = 65196, e1.thanthakhatlowleftthai = 63640, e1.thanthakhatlowrightthai = 63639, e1.thanthakhatthai = 3660, e1.thanthakhatupperleftthai = 63638, e1.theharabic = 1579, e1.thehfinalarabic = 65178, e1.thehinitialarabic = 65179, e1.thehmedialarabic = 65180, e1.thereexists = 8707, e1.therefore = 8756, e1.theta = 952, e1.theta1 = 977, e1.thetasymbolgreek = 977, e1.thieuthacirclekorean = 12921, e1.thieuthaparenkorean = 12825, e1.thieuthcirclekorean = 12907, e1.thieuthkorean = 12620, e1.thieuthparenkorean = 12811, e1.thirteencircle = 9324, e1.thirteenparen = 9344, e1.thirteenperiod = 9364, e1.thonangmonthothai = 3601, e1.thook = 429, e1.thophuthaothai = 3602, e1.thorn = 254, e1.thothahanthai = 3607, e1.thothanthai = 3600, e1.thothongthai = 3608, e1.thothungthai = 3606, e1.thousandcyrillic = 1154, e1.thousandsseparatorarabic = 1644, e1.thousandsseparatorpersian = 1644, e1.three = 51, e1.threearabic = 1635, e1.threebengali = 2537, e1.threecircle = 9314, e1.threecircleinversesansserif = 10124, e1.threedeva = 2409, e1.threeeighths = 8540, e1.threegujarati = 2793, e1.threegurmukhi = 2665, e1.threehackarabic = 1635, e1.threehangzhou = 12323, e1.threeideographicparen = 12834, e1.threeinferior = 8323, e1.threemonospace = 65299, e1.threenumeratorbengali = 2550, e1.threeoldstyle = 63283, e1.threeparen = 9334, e1.threeperiod = 9354, e1.threepersian = 1779, e1.threequarters = 190, e1.threequartersemdash = 63198, e1.threeroman = 8562, e1.threesuperior = 179, e1.threethai = 3667, e1.thzsquare = 13204, e1.tihiragana = 12385, e1.tikatakana = 12481, e1.tikatakanahalfwidth = 65409, e1.tikeutacirclekorean = 12912, e1.tikeutaparenkorean = 12816, e1.tikeutcirclekorean = 12898, e1.tikeutkorean = 12599, e1.tikeutparenkorean = 12802, e1.tilde = 732, e1.tildebelowcmb = 816, e1.tildecmb = 771, e1.tildecomb = 771, e1.tildedoublecmb = 864, e1.tildeoperator = 8764, e1.tildeoverlaycmb = 820, e1.tildeverticalcmb = 830, e1.timescircle = 8855, e1.tipehahebrew = 1430, e1.tipehalefthebrew = 1430, e1.tippigurmukhi = 2672, e1.titlocyrilliccmb = 1155, e1.tiwnarmenian = 1407, e1.tlinebelow = 7791, e1.tmonospace = 65364, e1.toarmenian = 1385, e1.tohiragana = 12392, e1.tokatakana = 12488, e1.tokatakanahalfwidth = 65412, e1.tonebarextrahighmod = 741, e1.tonebarextralowmod = 745, e1.tonebarhighmod = 742, e1.tonebarlowmod = 744, e1.tonebarmidmod = 743, e1.tonefive = 445, e1.tonesix = 389, e1.tonetwo = 424, e1.tonos = 900, e1.tonsquare = 13095, e1.topatakthai = 3599, e1.tortoiseshellbracketleft = 12308, e1.tortoiseshellbracketleftsmall = 65117, e1.tortoiseshellbracketleftvertical = 65081, e1.tortoiseshellbracketright = 12309, e1.tortoiseshellbracketrightsmall = 65118, e1.tortoiseshellbracketrightvertical = 65082, e1.totaothai = 3605, e1.tpalatalhook = 427, e1.tparen = 9391, e1.trademark = 8482, e1.trademarksans = 63722, e1.trademarkserif = 63195, e1.tretroflexhook = 648, e1.triagdn = 9660, e1.triaglf = 9668, e1.triagrt = 9658, e1.triagup = 9650, e1.ts = 678, e1.tsadi = 1510, e1.tsadidagesh = 64326, e1.tsadidageshhebrew = 64326, e1.tsadihebrew = 1510, e1.tsecyrillic = 1094, e1.tsere = 1461, e1.tsere12 = 1461, e1.tsere1e = 1461, e1.tsere2b = 1461, e1.tserehebrew = 1461, e1.tserenarrowhebrew = 1461, e1.tserequarterhebrew = 1461, e1.tserewidehebrew = 1461, e1.tshecyrillic = 1115, e1.tsuperior = 63219, e1.ttabengali = 2463, e1.ttadeva = 2335, e1.ttagujarati = 2719, e1.ttagurmukhi = 2591, e1.tteharabic = 1657, e1.ttehfinalarabic = 64359, e1.ttehinitialarabic = 64360, e1.ttehmedialarabic = 64361, e1.tthabengali = 2464, e1.tthadeva = 2336, e1.tthagujarati = 2720, e1.tthagurmukhi = 2592, e1.tturned = 647, e1.tuhiragana = 12388, e1.tukatakana = 12484, e1.tukatakanahalfwidth = 65410, e1.tusmallhiragana = 12387, e1.tusmallkatakana = 12483, e1.tusmallkatakanahalfwidth = 65391, e1.twelvecircle = 9323, e1.twelveparen = 9343, e1.twelveperiod = 9363, e1.twelveroman = 8571, e1.twentycircle = 9331, e1.twentyhangzhou = 21316, e1.twentyparen = 9351, e1.twentyperiod = 9371, e1.two = 50, e1.twoarabic = 1634, e1.twobengali = 2536, e1.twocircle = 9313, e1.twocircleinversesansserif = 10123, e1.twodeva = 2408, e1.twodotenleader = 8229, e1.twodotleader = 8229, e1.twodotleadervertical = 65072, e1.twogujarati = 2792, e1.twogurmukhi = 2664, e1.twohackarabic = 1634, e1.twohangzhou = 12322, e1.twoideographicparen = 12833, e1.twoinferior = 8322, e1.twomonospace = 65298, e1.twonumeratorbengali = 2549, e1.twooldstyle = 63282, e1.twoparen = 9333, e1.twoperiod = 9353, e1.twopersian = 1778, e1.tworoman = 8561, e1.twostroke = 443, e1.twosuperior = 178, e1.twothai = 3666, e1.twothirds = 8532, e1.u = 117, e1.uacute = 250, e1.ubar = 649, e1.ubengali = 2441, e1.ubopomofo = 12584, e1.ubreve = 365, e1.ucaron = 468, e1.ucircle = 9444, e1.ucircumflex = 251, e1.ucircumflexbelow = 7799, e1.ucyrillic = 1091, e1.udattadeva = 2385, e1.udblacute = 369, e1.udblgrave = 533, e1.udeva = 2313, e1.udieresis = 252, e1.udieresisacute = 472, e1.udieresisbelow = 7795, e1.udieresiscaron = 474, e1.udieresiscyrillic = 1265, e1.udieresisgrave = 476, e1.udieresismacron = 470, e1.udotbelow = 7909, e1.ugrave = 249, e1.ugujarati = 2697, e1.ugurmukhi = 2569, e1.uhiragana = 12358, e1.uhookabove = 7911, e1.uhorn = 432, e1.uhornacute = 7913, e1.uhorndotbelow = 7921, e1.uhorngrave = 7915, e1.uhornhookabove = 7917, e1.uhorntilde = 7919, e1.uhungarumlaut = 369, e1.uhungarumlautcyrillic = 1267, e1.uinvertedbreve = 535, e1.ukatakana = 12454, e1.ukatakanahalfwidth = 65395, e1.ukcyrillic = 1145, e1.ukorean = 12636, e1.umacron = 363, e1.umacroncyrillic = 1263, e1.umacrondieresis = 7803, e1.umatragurmukhi = 2625, e1.umonospace = 65365, e1.underscore = 95, e1.underscoredbl = 8215, e1.underscoremonospace = 65343, e1.underscorevertical = 65075, e1.underscorewavy = 65103, e1.union = 8746, e1.universal = 8704, e1.uogonek = 371, e1.uparen = 9392, e1.upblock = 9600, e1.upperdothebrew = 1476, e1.upsilon = 965, e1.upsilondieresis = 971, e1.upsilondieresistonos = 944, e1.upsilonlatin = 650, e1.upsilontonos = 973, e1.uptackbelowcmb = 797, e1.uptackmod = 724, e1.uragurmukhi = 2675, e1.uring = 367, e1.ushortcyrillic = 1118, e1.usmallhiragana = 12357, e1.usmallkatakana = 12453, e1.usmallkatakanahalfwidth = 65385, e1.ustraightcyrillic = 1199, e1.ustraightstrokecyrillic = 1201, e1.utilde = 361, e1.utildeacute = 7801, e1.utildebelow = 7797, e1.uubengali = 2442, e1.uudeva = 2314, e1.uugujarati = 2698, e1.uugurmukhi = 2570, e1.uumatragurmukhi = 2626, e1.uuvowelsignbengali = 2498, e1.uuvowelsigndeva = 2370, e1.uuvowelsigngujarati = 2754, e1.uvowelsignbengali = 2497, e1.uvowelsigndeva = 2369, e1.uvowelsigngujarati = 2753, e1.v = 118, e1.vadeva = 2357, e1.vagujarati = 2741, e1.vagurmukhi = 2613, e1.vakatakana = 12535, e1.vav = 1493, e1.vavdagesh = 64309, e1.vavdagesh65 = 64309, e1.vavdageshhebrew = 64309, e1.vavhebrew = 1493, e1.vavholam = 64331, e1.vavholamhebrew = 64331, e1.vavvavhebrew = 1520, e1.vavyodhebrew = 1521, e1.vcircle = 9445, e1.vdotbelow = 7807, e1.vecyrillic = 1074, e1.veharabic = 1700, e1.vehfinalarabic = 64363, e1.vehinitialarabic = 64364, e1.vehmedialarabic = 64365, e1.vekatakana = 12537, e1.venus = 9792, e1.verticalbar = 124, e1.verticallineabovecmb = 781, e1.verticallinebelowcmb = 809, e1.verticallinelowmod = 716, e1.verticallinemod = 712, e1.vewarmenian = 1406, e1.vhook = 651, e1.vikatakana = 12536, e1.viramabengali = 2509, e1.viramadeva = 2381, e1.viramagujarati = 2765, e1.visargabengali = 2435, e1.visargadeva = 2307, e1.visargagujarati = 2691, e1.vmonospace = 65366, e1.voarmenian = 1400, e1.voicediterationhiragana = 12446, e1.voicediterationkatakana = 12542, e1.voicedmarkkana = 12443, e1.voicedmarkkanahalfwidth = 65438, e1.vokatakana = 12538, e1.vparen = 9393, e1.vtilde = 7805, e1.vturned = 652, e1.vuhiragana = 12436, e1.vukatakana = 12532, e1.w = 119, e1.wacute = 7811, e1.waekorean = 12633, e1.wahiragana = 12431, e1.wakatakana = 12527, e1.wakatakanahalfwidth = 65436, e1.wakorean = 12632, e1.wasmallhiragana = 12430, e1.wasmallkatakana = 12526, e1.wattosquare = 13143, e1.wavedash = 12316, e1.wavyunderscorevertical = 65076, e1.wawarabic = 1608, e1.wawfinalarabic = 65262, e1.wawhamzaabovearabic = 1572, e1.wawhamzaabovefinalarabic = 65158, e1.wbsquare = 13277, e1.wcircle = 9446, e1.wcircumflex = 373, e1.wdieresis = 7813, e1.wdotaccent = 7815, e1.wdotbelow = 7817, e1.wehiragana = 12433, e1.weierstrass = 8472, e1.wekatakana = 12529, e1.wekorean = 12638, e1.weokorean = 12637, e1.wgrave = 7809, e1.whitebullet = 9702, e1.whitecircle = 9675, e1.whitecircleinverse = 9689, e1.whitecornerbracketleft = 12302, e1.whitecornerbracketleftvertical = 65091, e1.whitecornerbracketright = 12303, e1.whitecornerbracketrightvertical = 65092, e1.whitediamond = 9671, e1.whitediamondcontainingblacksmalldiamond = 9672, e1.whitedownpointingsmalltriangle = 9663;
    e1.whitedownpointingtriangle = 9661, e1.whiteleftpointingsmalltriangle = 9667, e1.whiteleftpointingtriangle = 9665, e1.whitelenticularbracketleft = 12310, e1.whitelenticularbracketright = 12311, e1.whiterightpointingsmalltriangle = 9657, e1.whiterightpointingtriangle = 9655, e1.whitesmallsquare = 9643, e1.whitesmilingface = 9786, e1.whitesquare = 9633, e1.whitestar = 9734, e1.whitetelephone = 9743, e1.whitetortoiseshellbracketleft = 12312, e1.whitetortoiseshellbracketright = 12313, e1.whiteuppointingsmalltriangle = 9653, e1.whiteuppointingtriangle = 9651, e1.wihiragana = 12432, e1.wikatakana = 12528, e1.wikorean = 12639, e1.wmonospace = 65367, e1.wohiragana = 12434, e1.wokatakana = 12530, e1.wokatakanahalfwidth = 65382, e1.won = 8361, e1.wonmonospace = 65510, e1.wowaenthai = 3623, e1.wparen = 9394, e1.wring = 7832, e1.wsuperior = 695, e1.wturned = 653, e1.wynn = 447, e1.x = 120, e1.xabovecmb = 829, e1.xbopomofo = 12562, e1.xcircle = 9447, e1.xdieresis = 7821, e1.xdotaccent = 7819, e1.xeharmenian = 1389, e1.xi = 958, e1.xmonospace = 65368, e1.xparen = 9395, e1.xsuperior = 739, e1.y = 121, e1.yaadosquare = 13134, e1.yabengali = 2479, e1.yacute = 253, e1.yadeva = 2351, e1.yaekorean = 12626, e1.yagujarati = 2735, e1.yagurmukhi = 2607, e1.yahiragana = 12420, e1.yakatakana = 12516, e1.yakatakanahalfwidth = 65428, e1.yakorean = 12625, e1.yamakkanthai = 3662, e1.yasmallhiragana = 12419, e1.yasmallkatakana = 12515, e1.yasmallkatakanahalfwidth = 65388, e1.yatcyrillic = 1123, e1.ycircle = 9448, e1.ycircumflex = 375, e1.ydieresis = 255, e1.ydotaccent = 7823, e1.ydotbelow = 7925, e1.yeharabic = 1610, e1.yehbarreearabic = 1746, e1.yehbarreefinalarabic = 64431, e1.yehfinalarabic = 65266, e1.yehhamzaabovearabic = 1574, e1.yehhamzaabovefinalarabic = 65162, e1.yehhamzaaboveinitialarabic = 65163, e1.yehhamzaabovemedialarabic = 65164, e1.yehinitialarabic = 65267, e1.yehmedialarabic = 65268, e1.yehmeeminitialarabic = 64733, e1.yehmeemisolatedarabic = 64600, e1.yehnoonfinalarabic = 64660, e1.yehthreedotsbelowarabic = 1745, e1.yekorean = 12630, e1.yen = 165, e1.yenmonospace = 65509, e1.yeokorean = 12629, e1.yeorinhieuhkorean = 12678, e1.yerahbenyomohebrew = 1450, e1.yerahbenyomolefthebrew = 1450, e1.yericyrillic = 1099, e1.yerudieresiscyrillic = 1273, e1.yesieungkorean = 12673, e1.yesieungpansioskorean = 12675, e1.yesieungsioskorean = 12674, e1.yetivhebrew = 1434, e1.ygrave = 7923, e1.yhook = 436, e1.yhookabove = 7927, e1.yiarmenian = 1397, e1.yicyrillic = 1111, e1.yikorean = 12642, e1.yinyang = 9775, e1.yiwnarmenian = 1410, e1.ymonospace = 65369, e1.yod = 1497, e1.yoddagesh = 64313, e1.yoddageshhebrew = 64313, e1.yodhebrew = 1497, e1.yodyodhebrew = 1522, e1.yodyodpatahhebrew = 64287, e1.yohiragana = 12424, e1.yoikorean = 12681, e1.yokatakana = 12520, e1.yokatakanahalfwidth = 65430, e1.yokorean = 12635, e1.yosmallhiragana = 12423, e1.yosmallkatakana = 12519, e1.yosmallkatakanahalfwidth = 65390, e1.yotgreek = 1011, e1.yoyaekorean = 12680, e1.yoyakorean = 12679, e1.yoyakthai = 3618, e1.yoyingthai = 3597, e1.yparen = 9396, e1.ypogegrammeni = 890, e1.ypogegrammenigreekcmb = 837, e1.yr = 422, e1.yring = 7833, e1.ysuperior = 696, e1.ytilde = 7929, e1.yturned = 654, e1.yuhiragana = 12422, e1.yuikorean = 12684, e1.yukatakana = 12518, e1.yukatakanahalfwidth = 65429, e1.yukorean = 12640, e1.yusbigcyrillic = 1131, e1.yusbigiotifiedcyrillic = 1133, e1.yuslittlecyrillic = 1127, e1.yuslittleiotifiedcyrillic = 1129, e1.yusmallhiragana = 12421, e1.yusmallkatakana = 12517, e1.yusmallkatakanahalfwidth = 65389, e1.yuyekorean = 12683, e1.yuyeokorean = 12682, e1.yyabengali = 2527, e1.yyadeva = 2399, e1.z = 122, e1.zaarmenian = 1382, e1.zacute = 378, e1.zadeva = 2395, e1.zagurmukhi = 2651, e1.zaharabic = 1592, e1.zahfinalarabic = 65222, e1.zahinitialarabic = 65223, e1.zahiragana = 12374, e1.zahmedialarabic = 65224, e1.zainarabic = 1586, e1.zainfinalarabic = 65200, e1.zakatakana = 12470, e1.zaqefgadolhebrew = 1429, e1.zaqefqatanhebrew = 1428, e1.zarqahebrew = 1432, e1.zayin = 1494, e1.zayindagesh = 64310, e1.zayindageshhebrew = 64310, e1.zayinhebrew = 1494, e1.zbopomofo = 12567, e1.zcaron = 382, e1.zcircle = 9449, e1.zcircumflex = 7825, e1.zcurl = 657, e1.zdot = 380, e1.zdotaccent = 380, e1.zdotbelow = 7827, e1.zecyrillic = 1079, e1.zedescendercyrillic = 1177, e1.zedieresiscyrillic = 1247, e1.zehiragana = 12380, e1.zekatakana = 12476, e1.zero = 48, e1.zeroarabic = 1632, e1.zerobengali = 2534, e1.zerodeva = 2406, e1.zerogujarati = 2790, e1.zerogurmukhi = 2662, e1.zerohackarabic = 1632, e1.zeroinferior = 8320, e1.zeromonospace = 65296, e1.zerooldstyle = 63280, e1.zeropersian = 1776, e1.zerosuperior = 8304, e1.zerothai = 3664, e1.zerowidthjoiner = 65279, e1.zerowidthnonjoiner = 8204, e1.zerowidthspace = 8203, e1.zeta = 950, e1.zhbopomofo = 12563, e1.zhearmenian = 1386, e1.zhebrevecyrillic = 1218, e1.zhecyrillic = 1078, e1.zhedescendercyrillic = 1175, e1.zhedieresiscyrillic = 1245, e1.zihiragana = 12376, e1.zikatakana = 12472, e1.zinorhebrew = 1454, e1.zlinebelow = 7829, e1.zmonospace = 65370, e1.zohiragana = 12382, e1.zokatakana = 12478, e1.zparen = 9397, e1.zretroflexhook = 656, e1.zstroke = 438, e1.zuhiragana = 12378, e1.zukatakana = 12474, e1[".notdef"] = 0, e1.angbracketleftbig = 9001, e1.angbracketleftBig = 9001, e1.angbracketleftbigg = 9001, e1.angbracketleftBigg = 9001, e1.angbracketrightBig = 9002, e1.angbracketrightbig = 9002, e1.angbracketrightBigg = 9002, e1.angbracketrightbigg = 9002, e1.arrowhookleft = 8618, e1.arrowhookright = 8617, e1.arrowlefttophalf = 8636, e1.arrowleftbothalf = 8637, e1.arrownortheast = 8599, e1.arrownorthwest = 8598, e1.arrowrighttophalf = 8640, e1.arrowrightbothalf = 8641, e1.arrowsoutheast = 8600, e1.arrowsouthwest = 8601, e1.backslashbig = 8726, e1.backslashBig = 8726, e1.backslashBigg = 8726, e1.backslashbigg = 8726, e1.bardbl = 8214, e1.bracehtipdownleft = 65079, e1.bracehtipdownright = 65079, e1.bracehtipupleft = 65080, e1.bracehtipupright = 65080, e1.braceleftBig = 123, e1.braceleftbig = 123, e1.braceleftbigg = 123, e1.braceleftBigg = 123, e1.bracerightBig = 125, e1.bracerightbig = 125, e1.bracerightbigg = 125, e1.bracerightBigg = 125, e1.bracketleftbig = 91, e1.bracketleftBig = 91, e1.bracketleftbigg = 91, e1.bracketleftBigg = 91, e1.bracketrightBig = 93, e1.bracketrightbig = 93, e1.bracketrightbigg = 93, e1.bracketrightBigg = 93, e1.ceilingleftbig = 8968, e1.ceilingleftBig = 8968, e1.ceilingleftBigg = 8968, e1.ceilingleftbigg = 8968, e1.ceilingrightbig = 8969, e1.ceilingrightBig = 8969, e1.ceilingrightbigg = 8969, e1.ceilingrightBigg = 8969, e1.circledotdisplay = 8857, e1.circledottext = 8857, e1.circlemultiplydisplay = 8855, e1.circlemultiplytext = 8855, e1.circleplusdisplay = 8853, e1.circleplustext = 8853, e1.contintegraldisplay = 8750, e1.contintegraltext = 8750, e1.coproductdisplay = 8720, e1.coproducttext = 8720, e1.floorleftBig = 8970, e1.floorleftbig = 8970, e1.floorleftbigg = 8970, e1.floorleftBigg = 8970, e1.floorrightbig = 8971, e1.floorrightBig = 8971, e1.floorrightBigg = 8971, e1.floorrightbigg = 8971, e1.hatwide = 770, e1.hatwider = 770, e1.hatwidest = 770, e1.intercal = 7488, e1.integraldisplay = 8747, e1.integraltext = 8747, e1.intersectiondisplay = 8898, e1.intersectiontext = 8898, e1.logicalanddisplay = 8743, e1.logicalandtext = 8743, e1.logicalordisplay = 8744, e1.logicalortext = 8744, e1.parenleftBig = 40, e1.parenleftbig = 40, e1.parenleftBigg = 40, e1.parenleftbigg = 40, e1.parenrightBig = 41, e1.parenrightbig = 41, e1.parenrightBigg = 41, e1.parenrightbigg = 41, e1.prime = 8242, e1.productdisplay = 8719, e1.producttext = 8719, e1.radicalbig = 8730, e1.radicalBig = 8730, e1.radicalBigg = 8730, e1.radicalbigg = 8730, e1.radicalbt = 8730, e1.radicaltp = 8730, e1.radicalvertex = 8730, e1.slashbig = 47, e1.slashBig = 47, e1.slashBigg = 47, e1.slashbigg = 47, e1.summationdisplay = 8721, e1.summationtext = 8721, e1.tildewide = 732, e1.tildewider = 732, e1.tildewidest = 732, e1.uniondisplay = 8899, e1.unionmultidisplay = 8846, e1.unionmultitext = 8846, e1.unionsqdisplay = 8852, e1.unionsqtext = 8852, e1.uniontext = 8899, e1.vextenddouble = 8741, e1.vextendsingle = 8739;
}), bn = getLookupTableFactory(function(e1) {
    e1.space = 32, e1.a1 = 9985, e1.a2 = 9986, e1.a202 = 9987, e1.a3 = 9988, e1.a4 = 9742, e1.a5 = 9990, e1.a119 = 9991, e1.a118 = 9992, e1.a117 = 9993, e1.a11 = 9755, e1.a12 = 9758, e1.a13 = 9996, e1.a14 = 9997, e1.a15 = 9998, e1.a16 = 9999, e1.a105 = 1e4, e1.a17 = 10001, e1.a18 = 10002, e1.a19 = 10003, e1.a20 = 10004, e1.a21 = 10005, e1.a22 = 10006, e1.a23 = 10007, e1.a24 = 10008, e1.a25 = 10009, e1.a26 = 10010, e1.a27 = 10011, e1.a28 = 10012, e1.a6 = 10013, e1.a7 = 10014, e1.a8 = 10015, e1.a9 = 10016, e1.a10 = 10017, e1.a29 = 10018, e1.a30 = 10019, e1.a31 = 10020, e1.a32 = 10021, e1.a33 = 10022, e1.a34 = 10023, e1.a35 = 9733, e1.a36 = 10025, e1.a37 = 10026, e1.a38 = 10027, e1.a39 = 10028, e1.a40 = 10029, e1.a41 = 10030, e1.a42 = 10031, e1.a43 = 10032, e1.a44 = 10033, e1.a45 = 10034, e1.a46 = 10035, e1.a47 = 10036, e1.a48 = 10037, e1.a49 = 10038, e1.a50 = 10039, e1.a51 = 10040, e1.a52 = 10041, e1.a53 = 10042, e1.a54 = 10043, e1.a55 = 10044, e1.a56 = 10045, e1.a57 = 10046, e1.a58 = 10047, e1.a59 = 10048, e1.a60 = 10049, e1.a61 = 10050, e1.a62 = 10051, e1.a63 = 10052, e1.a64 = 10053, e1.a65 = 10054, e1.a66 = 10055, e1.a67 = 10056, e1.a68 = 10057, e1.a69 = 10058, e1.a70 = 10059, e1.a71 = 9679, e1.a72 = 10061, e1.a73 = 9632, e1.a74 = 10063, e1.a203 = 10064, e1.a75 = 10065, e1.a204 = 10066, e1.a76 = 9650, e1.a77 = 9660, e1.a78 = 9670, e1.a79 = 10070, e1.a81 = 9687, e1.a82 = 10072, e1.a83 = 10073, e1.a84 = 10074, e1.a97 = 10075, e1.a98 = 10076, e1.a99 = 10077, e1.a100 = 10078, e1.a101 = 10081, e1.a102 = 10082, e1.a103 = 10083, e1.a104 = 10084, e1.a106 = 10085, e1.a107 = 10086, e1.a108 = 10087, e1.a112 = 9827, e1.a111 = 9830, e1.a110 = 9829, e1.a109 = 9824, e1.a120 = 9312, e1.a121 = 9313, e1.a122 = 9314, e1.a123 = 9315, e1.a124 = 9316, e1.a125 = 9317, e1.a126 = 9318, e1.a127 = 9319, e1.a128 = 9320, e1.a129 = 9321, e1.a130 = 10102, e1.a131 = 10103, e1.a132 = 10104, e1.a133 = 10105, e1.a134 = 10106, e1.a135 = 10107, e1.a136 = 10108, e1.a137 = 10109, e1.a138 = 10110, e1.a139 = 10111, e1.a140 = 10112, e1.a141 = 10113, e1.a142 = 10114, e1.a143 = 10115, e1.a144 = 10116, e1.a145 = 10117, e1.a146 = 10118, e1.a147 = 10119, e1.a148 = 10120, e1.a149 = 10121, e1.a150 = 10122, e1.a151 = 10123, e1.a152 = 10124, e1.a153 = 10125, e1.a154 = 10126, e1.a155 = 10127, e1.a156 = 10128, e1.a157 = 10129, e1.a158 = 10130, e1.a159 = 10131, e1.a160 = 10132, e1.a161 = 8594, e1.a163 = 8596, e1.a164 = 8597, e1.a196 = 10136, e1.a165 = 10137, e1.a192 = 10138, e1.a166 = 10139, e1.a167 = 10140, e1.a168 = 10141, e1.a169 = 10142, e1.a170 = 10143, e1.a171 = 10144, e1.a172 = 10145, e1.a173 = 10146, e1.a162 = 10147, e1.a174 = 10148, e1.a175 = 10149, e1.a176 = 10150, e1.a177 = 10151, e1.a178 = 10152, e1.a179 = 10153, e1.a193 = 10154, e1.a180 = 10155, e1.a199 = 10156, e1.a181 = 10157, e1.a200 = 10158, e1.a182 = 10159, e1.a201 = 10161, e1.a183 = 10162, e1.a184 = 10163, e1.a197 = 10164, e1.a185 = 10165, e1.a194 = 10166, e1.a198 = 10167, e1.a186 = 10168, e1.a195 = 10169, e1.a187 = 10170, e1.a188 = 10171, e1.a189 = 10172, e1.a190 = 10173, e1.a191 = 10174, e1.a89 = 10088, e1.a90 = 10089, e1.a93 = 10090, e1.a94 = 10091, e1.a91 = 10092, e1.a92 = 10093, e1.a205 = 10094, e1.a85 = 10095, e1.a206 = 10096, e1.a86 = 10097, e1.a87 = 10098, e1.a88 = 10099, e1.a95 = 10100, e1.a96 = 10101, e1[".notdef"] = 0;
}), yn = getLookupTableFactory(function(e1) {
    e1[63721] = 169, e1[63193] = 169, e1[63720] = 174, e1[63194] = 174, e1[63722] = 8482, e1[63195] = 8482, e1[63729] = 9127, e1[63730] = 9128, e1[63731] = 9129, e1[63740] = 9131, e1[63741] = 9132, e1[63742] = 9133, e1[63726] = 9121, e1[63727] = 9122, e1[63728] = 9123, e1[63737] = 9124, e1[63738] = 9125, e1[63739] = 9126, e1[63723] = 9115, e1[63724] = 9116, e1[63725] = 9117, e1[63734] = 9118, e1[63735] = 9119, e1[63736] = 9120;
});
function getUnicodeForGlyph(e1, t) {
    let i = t[e1];
    if (void 0 !== i) return i;
    if (!e1) return -1;
    if ("u" === e1[0]) {
        const t = e1.length;
        let n;
        if (7 === t && "n" === e1[1] && "i" === e1[2]) n = e1.substring(3);
        else {
            if (!(t >= 5 && t <= 7)) return -1;
            n = e1.substring(1);
        }
        if (n === n.toUpperCase() && (i = parseInt(n, 16), i >= 0)) return i;
    }
    return -1;
}
const wn = [
    [
        0,
        127
    ],
    [
        128,
        255
    ],
    [
        256,
        383
    ],
    [
        384,
        591
    ],
    [
        592,
        687,
        7424,
        7551,
        7552,
        7615
    ],
    [
        688,
        767,
        42752,
        42783
    ],
    [
        768,
        879,
        7616,
        7679
    ],
    [
        880,
        1023
    ],
    [
        11392,
        11519
    ],
    [
        1024,
        1279,
        1280,
        1327,
        11744,
        11775,
        42560,
        42655
    ],
    [
        1328,
        1423
    ],
    [
        1424,
        1535
    ],
    [
        42240,
        42559
    ],
    [
        1536,
        1791,
        1872,
        1919
    ],
    [
        1984,
        2047
    ],
    [
        2304,
        2431
    ],
    [
        2432,
        2559
    ],
    [
        2560,
        2687
    ],
    [
        2688,
        2815
    ],
    [
        2816,
        2943
    ],
    [
        2944,
        3071
    ],
    [
        3072,
        3199
    ],
    [
        3200,
        3327
    ],
    [
        3328,
        3455
    ],
    [
        3584,
        3711
    ],
    [
        3712,
        3839
    ],
    [
        4256,
        4351,
        11520,
        11567
    ],
    [
        6912,
        7039
    ],
    [
        4352,
        4607
    ],
    [
        7680,
        7935,
        11360,
        11391,
        42784,
        43007
    ],
    [
        7936,
        8191
    ],
    [
        8192,
        8303,
        11776,
        11903
    ],
    [
        8304,
        8351
    ],
    [
        8352,
        8399
    ],
    [
        8400,
        8447
    ],
    [
        8448,
        8527
    ],
    [
        8528,
        8591
    ],
    [
        8592,
        8703,
        10224,
        10239,
        10496,
        10623,
        11008,
        11263
    ],
    [
        8704,
        8959,
        10752,
        11007,
        10176,
        10223,
        10624,
        10751
    ],
    [
        8960,
        9215
    ],
    [
        9216,
        9279
    ],
    [
        9280,
        9311
    ],
    [
        9312,
        9471
    ],
    [
        9472,
        9599
    ],
    [
        9600,
        9631
    ],
    [
        9632,
        9727
    ],
    [
        9728,
        9983
    ],
    [
        9984,
        10175
    ],
    [
        12288,
        12351
    ],
    [
        12352,
        12447
    ],
    [
        12448,
        12543,
        12784,
        12799
    ],
    [
        12544,
        12591,
        12704,
        12735
    ],
    [
        12592,
        12687
    ],
    [
        43072,
        43135
    ],
    [
        12800,
        13055
    ],
    [
        13056,
        13311
    ],
    [
        44032,
        55215
    ],
    [
        55296,
        57343
    ],
    [
        67840,
        67871
    ],
    [
        19968,
        40959,
        11904,
        12031,
        12032,
        12255,
        12272,
        12287,
        13312,
        19903,
        131072,
        173791,
        12688,
        12703
    ],
    [
        57344,
        63743
    ],
    [
        12736,
        12783,
        63744,
        64255,
        194560,
        195103
    ],
    [
        64256,
        64335
    ],
    [
        64336,
        65023
    ],
    [
        65056,
        65071
    ],
    [
        65040,
        65055
    ],
    [
        65104,
        65135
    ],
    [
        65136,
        65279
    ],
    [
        65280,
        65519
    ],
    [
        65520,
        65535
    ],
    [
        3840,
        4095
    ],
    [
        1792,
        1871
    ],
    [
        1920,
        1983
    ],
    [
        3456,
        3583
    ],
    [
        4096,
        4255
    ],
    [
        4608,
        4991,
        4992,
        5023,
        11648,
        11743
    ],
    [
        5024,
        5119
    ],
    [
        5120,
        5759
    ],
    [
        5760,
        5791
    ],
    [
        5792,
        5887
    ],
    [
        6016,
        6143
    ],
    [
        6144,
        6319
    ],
    [
        10240,
        10495
    ],
    [
        40960,
        42127
    ],
    [
        5888,
        5919,
        5920,
        5951,
        5952,
        5983,
        5984,
        6015
    ],
    [
        66304,
        66351
    ],
    [
        66352,
        66383
    ],
    [
        66560,
        66639
    ],
    [
        118784,
        119039,
        119040,
        119295,
        119296,
        119375
    ],
    [
        119808,
        120831
    ],
    [
        1044480,
        1048573
    ],
    [
        65024,
        65039,
        917760,
        917999
    ],
    [
        917504,
        917631
    ],
    [
        6400,
        6479
    ],
    [
        6480,
        6527
    ],
    [
        6528,
        6623
    ],
    [
        6656,
        6687
    ],
    [
        11264,
        11359
    ],
    [
        11568,
        11647
    ],
    [
        19904,
        19967
    ],
    [
        43008,
        43055
    ],
    [
        65536,
        65663,
        65664,
        65791,
        65792,
        65855
    ],
    [
        65856,
        65935
    ],
    [
        66432,
        66463
    ],
    [
        66464,
        66527
    ],
    [
        66640,
        66687
    ],
    [
        66688,
        66735
    ],
    [
        67584,
        67647
    ],
    [
        68096,
        68191
    ],
    [
        119552,
        119647
    ],
    [
        73728,
        74751,
        74752,
        74879
    ],
    [
        119648,
        119679
    ],
    [
        7040,
        7103
    ],
    [
        7168,
        7247
    ],
    [
        7248,
        7295
    ],
    [
        43136,
        43231
    ],
    [
        43264,
        43311
    ],
    [
        43312,
        43359
    ],
    [
        43520,
        43615
    ],
    [
        65936,
        65999
    ],
    [
        66e3,
        66047
    ],
    [
        66208,
        66271,
        66176,
        66207,
        67872,
        67903
    ],
    [
        127024,
        127135,
        126976,
        127023
    ]
];
function getUnicodeRangeFor(e1, t = -1) {
    if (-1 !== t) {
        const i = wn[t];
        for(let n = 0, a = i.length; n < a; n += 2)if (e1 >= i[n] && e1 <= i[n + 1]) return t;
    }
    for(let t = 0, i = wn.length; t < i; t++){
        const i = wn[t];
        for(let n = 0, a = i.length; n < a; n += 2)if (e1 >= i[n] && e1 <= i[n + 1]) return t;
    }
    return -1;
}
const An = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), xn = new Map;
const Sn = !0, vn = 1, Cn = 2, kn = 4, Tn = 32, Fn = [
    ".notdef",
    ".null",
    "nonmarkingreturn",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "Adieresis",
    "Aring",
    "Ccedilla",
    "Eacute",
    "Ntilde",
    "Odieresis",
    "Udieresis",
    "aacute",
    "agrave",
    "acircumflex",
    "adieresis",
    "atilde",
    "aring",
    "ccedilla",
    "eacute",
    "egrave",
    "ecircumflex",
    "edieresis",
    "iacute",
    "igrave",
    "icircumflex",
    "idieresis",
    "ntilde",
    "oacute",
    "ograve",
    "ocircumflex",
    "odieresis",
    "otilde",
    "uacute",
    "ugrave",
    "ucircumflex",
    "udieresis",
    "dagger",
    "degree",
    "cent",
    "sterling",
    "section",
    "bullet",
    "paragraph",
    "germandbls",
    "registered",
    "copyright",
    "trademark",
    "acute",
    "dieresis",
    "notequal",
    "AE",
    "Oslash",
    "infinity",
    "plusminus",
    "lessequal",
    "greaterequal",
    "yen",
    "mu",
    "partialdiff",
    "summation",
    "product",
    "pi",
    "integral",
    "ordfeminine",
    "ordmasculine",
    "Omega",
    "ae",
    "oslash",
    "questiondown",
    "exclamdown",
    "logicalnot",
    "radical",
    "florin",
    "approxequal",
    "Delta",
    "guillemotleft",
    "guillemotright",
    "ellipsis",
    "nonbreakingspace",
    "Agrave",
    "Atilde",
    "Otilde",
    "OE",
    "oe",
    "endash",
    "emdash",
    "quotedblleft",
    "quotedblright",
    "quoteleft",
    "quoteright",
    "divide",
    "lozenge",
    "ydieresis",
    "Ydieresis",
    "fraction",
    "currency",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "daggerdbl",
    "periodcentered",
    "quotesinglbase",
    "quotedblbase",
    "perthousand",
    "Acircumflex",
    "Ecircumflex",
    "Aacute",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Oacute",
    "Ocircumflex",
    "apple",
    "Ograve",
    "Uacute",
    "Ucircumflex",
    "Ugrave",
    "dotlessi",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "Lslash",
    "lslash",
    "Scaron",
    "scaron",
    "Zcaron",
    "zcaron",
    "brokenbar",
    "Eth",
    "eth",
    "Yacute",
    "yacute",
    "Thorn",
    "thorn",
    "minus",
    "multiply",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "onehalf",
    "onequarter",
    "threequarters",
    "franc",
    "Gbreve",
    "gbreve",
    "Idotaccent",
    "Scedilla",
    "scedilla",
    "Cacute",
    "cacute",
    "Ccaron",
    "ccaron",
    "dcroat"
];
function recoverGlyphName(e1, t) {
    if (void 0 !== t[e1]) return e1;
    const i = getUnicodeForGlyph(e1, t);
    if (-1 !== i) {
        for(const e1 in t)if (t[e1] === i) return e1;
    }
    return info$1("Unable to recover a standard glyph name for: " + e1), e1;
}
function type1FontGlyphMapping(e1, t, i) {
    const n = Object.create(null);
    let a, s, r;
    const o = !!(e1.flags & kn);
    if (e1.isInternalFont) for(r = t, s = 0; s < r.length; s++)a = i.indexOf(r[s]), n[s] = a >= 0 ? a : 0;
    else if (e1.baseEncodingName) for(r = getEncoding(e1.baseEncodingName), s = 0; s < r.length; s++)a = i.indexOf(r[s]), n[s] = a >= 0 ? a : 0;
    else if (o) for(s in t)n[s] = t[s];
    else for(r = un, s = 0; s < r.length; s++)a = i.indexOf(r[s]), n[s] = a >= 0 ? a : 0;
    const l = e1.differences;
    let c;
    if (l) for(s in l){
        const e1 = l[s];
        if (a = i.indexOf(e1), -1 === a) {
            c || (c = mn());
            const t = recoverGlyphName(e1, c);
            t !== e1 && (a = i.indexOf(t));
        }
        n[s] = a >= 0 ? a : 0;
    }
    return n;
}
function normalizeFontName(e1) {
    return e1.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
const In = getLookupTableFactory((e1)=>{
    e1[8211] = 65074, e1[8212] = 65073, e1[8229] = 65072, e1[8230] = 65049, e1[12289] = 65041, e1[12290] = 65042, e1[12296] = 65087, e1[12297] = 65088, e1[12298] = 65085, e1[12299] = 65086, e1[12300] = 65089, e1[12301] = 65090, e1[12302] = 65091, e1[12303] = 65092, e1[12304] = 65083, e1[12305] = 65084, e1[12308] = 65081, e1[12309] = 65082, e1[12310] = 65047, e1[12311] = 65048, e1[65103] = 65076, e1[65281] = 65045, e1[65288] = 65077, e1[65289] = 65078, e1[65292] = 65040, e1[65306] = 65043, e1[65307] = 65044, e1[65311] = 65046, e1[65339] = 65095, e1[65341] = 65096, e1[65343] = 65075, e1[65371] = 65079, e1[65373] = 65080;
});
const En = [
    ".notdef",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "questiondown",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "AE",
    "ordfeminine",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "ae",
    "dotlessi",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "onesuperior",
    "logicalnot",
    "mu",
    "trademark",
    "Eth",
    "onehalf",
    "plusminus",
    "Thorn",
    "onequarter",
    "divide",
    "brokenbar",
    "degree",
    "thorn",
    "threequarters",
    "twosuperior",
    "registered",
    "minus",
    "eth",
    "multiply",
    "threesuperior",
    "copyright",
    "Aacute",
    "Acircumflex",
    "Adieresis",
    "Agrave",
    "Aring",
    "Atilde",
    "Ccedilla",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Ntilde",
    "Oacute",
    "Ocircumflex",
    "Odieresis",
    "Ograve",
    "Otilde",
    "Scaron",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Ugrave",
    "Yacute",
    "Ydieresis",
    "Zcaron",
    "aacute",
    "acircumflex",
    "adieresis",
    "agrave",
    "aring",
    "atilde",
    "ccedilla",
    "eacute",
    "ecircumflex",
    "edieresis",
    "egrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "igrave",
    "ntilde",
    "oacute",
    "ocircumflex",
    "odieresis",
    "ograve",
    "otilde",
    "scaron",
    "uacute",
    "ucircumflex",
    "udieresis",
    "ugrave",
    "yacute",
    "ydieresis",
    "zcaron"
], Mn = [
    ".notdef",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "Dotaccentsmall",
    "Macronsmall",
    "figuredash",
    "hypheninferior",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall"
], Dn = [
    ".notdef",
    "space",
    "dollaroldstyle",
    "dollarsuperior",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "hyphensuperior",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "centoldstyle",
    "figuredash",
    "hypheninferior",
    "onequarter",
    "onehalf",
    "threequarters",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior"
], On = [
    ".notdef",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "questiondown",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "AE",
    "ordfeminine",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "ae",
    "dotlessi",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "onesuperior",
    "logicalnot",
    "mu",
    "trademark",
    "Eth",
    "onehalf",
    "plusminus",
    "Thorn",
    "onequarter",
    "divide",
    "brokenbar",
    "degree",
    "thorn",
    "threequarters",
    "twosuperior",
    "registered",
    "minus",
    "eth",
    "multiply",
    "threesuperior",
    "copyright",
    "Aacute",
    "Acircumflex",
    "Adieresis",
    "Agrave",
    "Aring",
    "Atilde",
    "Ccedilla",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Ntilde",
    "Oacute",
    "Ocircumflex",
    "Odieresis",
    "Ograve",
    "Otilde",
    "Scaron",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Ugrave",
    "Yacute",
    "Ydieresis",
    "Zcaron",
    "aacute",
    "acircumflex",
    "adieresis",
    "agrave",
    "aring",
    "atilde",
    "ccedilla",
    "eacute",
    "ecircumflex",
    "edieresis",
    "egrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "igrave",
    "ntilde",
    "oacute",
    "ocircumflex",
    "odieresis",
    "ograve",
    "otilde",
    "scaron",
    "uacute",
    "ucircumflex",
    "udieresis",
    "ugrave",
    "yacute",
    "ydieresis",
    "zcaron",
    "exclamsmall",
    "Hungarumlautsmall",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "Dotaccentsmall",
    "Macronsmall",
    "figuredash",
    "hypheninferior",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall",
    "001.000",
    "001.001",
    "001.002",
    "001.003",
    "Black",
    "Bold",
    "Book",
    "Light",
    "Medium",
    "Regular",
    "Roman",
    "Semibold"
], _n = 391, Pn = [
    null,
    {
        id: "hstem",
        min: 2,
        stackClearing: !0,
        stem: !0
    },
    null,
    {
        id: "vstem",
        min: 2,
        stackClearing: !0,
        stem: !0
    },
    {
        id: "vmoveto",
        min: 1,
        stackClearing: !0
    },
    {
        id: "rlineto",
        min: 2,
        resetStack: !0
    },
    {
        id: "hlineto",
        min: 1,
        resetStack: !0
    },
    {
        id: "vlineto",
        min: 1,
        resetStack: !0
    },
    {
        id: "rrcurveto",
        min: 6,
        resetStack: !0
    },
    null,
    {
        id: "callsubr",
        min: 1,
        undefStack: !0
    },
    {
        id: "return",
        min: 0,
        undefStack: !0
    },
    null,
    null,
    {
        id: "endchar",
        min: 0,
        stackClearing: !0
    },
    null,
    null,
    null,
    {
        id: "hstemhm",
        min: 2,
        stackClearing: !0,
        stem: !0
    },
    {
        id: "hintmask",
        min: 0,
        stackClearing: !0
    },
    {
        id: "cntrmask",
        min: 0,
        stackClearing: !0
    },
    {
        id: "rmoveto",
        min: 2,
        stackClearing: !0
    },
    {
        id: "hmoveto",
        min: 1,
        stackClearing: !0
    },
    {
        id: "vstemhm",
        min: 2,
        stackClearing: !0,
        stem: !0
    },
    {
        id: "rcurveline",
        min: 8,
        resetStack: !0
    },
    {
        id: "rlinecurve",
        min: 8,
        resetStack: !0
    },
    {
        id: "vvcurveto",
        min: 4,
        resetStack: !0
    },
    {
        id: "hhcurveto",
        min: 4,
        resetStack: !0
    },
    null,
    {
        id: "callgsubr",
        min: 1,
        undefStack: !0
    },
    {
        id: "vhcurveto",
        min: 4,
        resetStack: !0
    },
    {
        id: "hvcurveto",
        min: 4,
        resetStack: !0
    }
], Rn = [
    null,
    null,
    null,
    {
        id: "and",
        min: 2,
        stackDelta: -1
    },
    {
        id: "or",
        min: 2,
        stackDelta: -1
    },
    {
        id: "not",
        min: 1,
        stackDelta: 0
    },
    null,
    null,
    null,
    {
        id: "abs",
        min: 1,
        stackDelta: 0
    },
    {
        id: "add",
        min: 2,
        stackDelta: -1,
        stackFn (e1, t) {
            e1[t - 2] = e1[t - 2] + e1[t - 1];
        }
    },
    {
        id: "sub",
        min: 2,
        stackDelta: -1,
        stackFn (e1, t) {
            e1[t - 2] = e1[t - 2] - e1[t - 1];
        }
    },
    {
        id: "div",
        min: 2,
        stackDelta: -1,
        stackFn (e1, t) {
            e1[t - 2] = e1[t - 2] / e1[t - 1];
        }
    },
    null,
    {
        id: "neg",
        min: 1,
        stackDelta: 0,
        stackFn (e1, t) {
            e1[t - 1] = -e1[t - 1];
        }
    },
    {
        id: "eq",
        min: 2,
        stackDelta: -1
    },
    null,
    null,
    {
        id: "drop",
        min: 1,
        stackDelta: -1
    },
    null,
    {
        id: "put",
        min: 2,
        stackDelta: -2
    },
    {
        id: "get",
        min: 1,
        stackDelta: 0
    },
    {
        id: "ifelse",
        min: 4,
        stackDelta: -3
    },
    {
        id: "random",
        min: 0,
        stackDelta: 1
    },
    {
        id: "mul",
        min: 2,
        stackDelta: -1,
        stackFn (e1, t) {
            e1[t - 2] = e1[t - 2] * e1[t - 1];
        }
    },
    null,
    {
        id: "sqrt",
        min: 1,
        stackDelta: 0
    },
    {
        id: "dup",
        min: 1,
        stackDelta: 1
    },
    {
        id: "exch",
        min: 2,
        stackDelta: 0
    },
    {
        id: "index",
        min: 2,
        stackDelta: 0
    },
    {
        id: "roll",
        min: 3,
        stackDelta: -2
    },
    null,
    null,
    null,
    {
        id: "hflex",
        min: 7,
        resetStack: !0
    },
    {
        id: "flex",
        min: 13,
        resetStack: !0
    },
    {
        id: "hflex1",
        min: 9,
        resetStack: !0
    },
    {
        id: "flex1",
        min: 11,
        resetStack: !0
    }
];
class CFFParser {
    constructor(e1, t, i){
        this.bytes = e1.getBytes(), this.properties = t, this.seacAnalysisEnabled = !!i;
    }
    parse() {
        const e1 = this.properties, t = new CFF;
        this.cff = t;
        const i = this.parseHeader(), n = this.parseIndex(i.endPos), a = this.parseIndex(n.endPos), s = this.parseIndex(a.endPos), r = this.parseIndex(s.endPos), o = this.parseDict(a.obj.get(0)), l = this.createDict(CFFTopDict, o, t.strings);
        t.header = i.obj, t.names = this.parseNameIndex(n.obj), t.strings = this.parseStringIndex(s.obj), t.topDict = l, t.globalSubrIndex = r.obj, this.parsePrivateDict(t.topDict), t.isCIDFont = l.hasName("ROS");
        const c = l.getByName("CharStrings"), h = this.parseIndex(c).obj, d = l.getByName("FontMatrix");
        d && (e1.fontMatrix = d);
        const u = l.getByName("FontBBox");
        let g, f;
        if (u && (e1.ascent = Math.max(u[3], u[1]), e1.descent = Math.min(u[1], u[3]), e1.ascentScaled = !0), t.isCIDFont) {
            const e1 = this.parseIndex(l.getByName("FDArray")).obj;
            for(let i = 0, n = e1.count; i < n; ++i){
                const n = e1.get(i), a = this.createDict(CFFTopDict, this.parseDict(n), t.strings);
                this.parsePrivateDict(a), t.fdArray.push(a);
            }
            f = null, g = this.parseCharsets(l.getByName("charset"), h.count, t.strings, !0), t.fdSelect = this.parseFDSelect(l.getByName("FDSelect"), h.count);
        } else g = this.parseCharsets(l.getByName("charset"), h.count, t.strings, !1), f = this.parseEncoding(l.getByName("Encoding"), e1, t.strings, g.charset);
        t.charset = g, t.encoding = f;
        const p = this.parseCharStrings({
            charStrings: h,
            localSubrIndex: l.privateDict.subrsIndex,
            globalSubrIndex: r.obj,
            fdSelect: t.fdSelect,
            fdArray: t.fdArray,
            privateDict: l.privateDict
        });
        return t.charStrings = p.charStrings, t.seacs = p.seacs, t.widths = p.widths, t;
    }
    parseHeader() {
        let e1 = this.bytes;
        const t = e1.length;
        let i = 0;
        for(; i < t && 1 !== e1[i];)++i;
        if (i >= t) throw new ti("Invalid CFF header");
        0 !== i && (info$1("cff data is shifted"), e1 = e1.subarray(i), this.bytes = e1);
        const n = e1[0], a = e1[1], s = e1[2], r = e1[3];
        return {
            obj: new CFFHeader(n, a, s, r),
            endPos: s
        };
    }
    parseDict(e1) {
        let t = 0;
        function parseOperand() {
            let i = e1[t++];
            return 30 === i ? function() {
                let i = "";
                const n = 15, a = [
                    "0",
                    "1",
                    "2",
                    "3",
                    "4",
                    "5",
                    "6",
                    "7",
                    "8",
                    "9",
                    ".",
                    "E",
                    "E-",
                    null,
                    "-"
                ], s = e1.length;
                for(; t < s;){
                    const s = e1[t++], r = s >> 4, o = 15 & s;
                    if (r === n) break;
                    if (i += a[r], o === n) break;
                    i += a[o];
                }
                return parseFloat(i);
            }() : 28 === i ? (i = readInt16(e1, t), t += 2, i) : 29 === i ? (i = e1[t++], i = i << 8 | e1[t++], i = i << 8 | e1[t++], i = i << 8 | e1[t++], i) : i >= 32 && i <= 246 ? i - 139 : i >= 247 && i <= 250 ? 256 * (i - 247) + e1[t++] + 108 : i >= 251 && i <= 254 ? -256 * (i - 251) - e1[t++] - 108 : (warn$1('CFFParser_parseDict: "' + i + '" is a reserved command.'), NaN);
        }
        let i = [];
        const n = [];
        t = 0;
        const a = e1.length;
        for(; t < a;){
            let a = e1[t];
            a <= 21 ? (12 === a && (a = a << 8 | e1[++t]), n.push([
                a,
                i
            ]), i = [], ++t) : i.push(parseOperand());
        }
        return n;
    }
    parseIndex(e1) {
        const t = new CFFIndex, i = this.bytes, n = i[e1++] << 8 | i[e1++], a = [];
        let s, r, o = e1;
        if (0 !== n) {
            const t = i[e1++], l = e1 + (n + 1) * t - 1;
            for(s = 0, r = n + 1; s < r; ++s){
                let n = 0;
                for(let a = 0; a < t; ++a)n <<= 8, n += i[e1++];
                a.push(l + n);
            }
            o = a[n];
        }
        for(s = 0, r = a.length - 1; s < r; ++s){
            const e1 = a[s], n = a[s + 1];
            t.add(i.subarray(e1, n));
        }
        return {
            obj: t,
            endPos: o
        };
    }
    parseNameIndex(e1) {
        const t = [];
        for(let i = 0, n = e1.count; i < n; ++i){
            const n = e1.get(i);
            t.push(bytesToString$1(n));
        }
        return t;
    }
    parseStringIndex(e1) {
        const t = new CFFStrings;
        for(let i = 0, n = e1.count; i < n; ++i){
            const n = e1.get(i);
            t.add(bytesToString$1(n));
        }
        return t;
    }
    createDict(e1, t, i) {
        const n = new e1(i);
        for (const [e1, i] of t)n.setByKey(e1, i);
        return n;
    }
    parseCharString(e1, t, i, n) {
        if (!t || e1.callDepth > 10) return !1;
        let a = e1.stackSize;
        const s = e1.stack;
        let r = t.length;
        for(let o = 0; o < r;){
            const l = t[o++];
            let c = null;
            if (12 === l) {
                const e1 = t[o++];
                0 === e1 ? (t[o - 2] = 139, t[o - 1] = 22, a = 0) : c = Rn[e1];
            } else if (28 === l) s[a] = readInt16(t, o), o += 2, a++;
            else if (14 === l) {
                if (a >= 4 && (a -= 4, this.seacAnalysisEnabled)) return e1.seac = s.slice(a, a + 4), !1;
                c = Pn[l];
            } else if (l >= 32 && l <= 246) s[a] = l - 139, a++;
            else if (l >= 247 && l <= 254) s[a] = l < 251 ? (l - 247 << 8) + t[o] + 108 : -(l - 251 << 8) - t[o] - 108, o++, a++;
            else if (255 === l) s[a] = (t[o] << 24 | t[o + 1] << 16 | t[o + 2] << 8 | t[o + 3]) / 65536, o += 4, a++;
            else if (19 === l || 20 === l) {
                if (e1.hints += a >> 1, 0 === e1.hints) {
                    t.copyWithin(o - 1, o, -1), o -= 1, r -= 1;
                    continue;
                }
                o += e1.hints + 7 >> 3, a %= 2, c = Pn[l];
            } else {
                if (10 === l || 29 === l) {
                    const t = 10 === l ? i : n;
                    if (!t) return c = Pn[l], warn$1("Missing subrsIndex for " + c.id), !1;
                    let r = 32768;
                    t.count < 1240 ? r = 107 : t.count < 33900 && (r = 1131);
                    const o = s[--a] + r;
                    if (o < 0 || o >= t.count || isNaN(o)) return c = Pn[l], warn$1("Out of bounds subrIndex for " + c.id), !1;
                    e1.stackSize = a, e1.callDepth++;
                    if (!this.parseCharString(e1, t.get(o), i, n)) return !1;
                    e1.callDepth--, a = e1.stackSize;
                    continue;
                }
                if (11 === l) return e1.stackSize = a, !0;
                if (0 === l && o === t.length) t[o - 1] = 14, c = Pn[14];
                else {
                    if (9 === l) {
                        t.copyWithin(o - 1, o, -1), o -= 1, r -= 1;
                        continue;
                    }
                    c = Pn[l];
                }
            }
            if (c) {
                if (c.stem && (e1.hints += a >> 1, 3 === l || 23 === l ? e1.hasVStems = !0 : !e1.hasVStems || 1 !== l && 18 !== l || (warn$1("CFF stem hints are in wrong order"), t[o - 1] = 1 === l ? 3 : 23)), "min" in c && !e1.undefStack && a < c.min) return warn$1("Not enough parameters for " + c.id + "; actual: " + a + ", expected: " + c.min), 0 === a && (t[o - 1] = 14, !0);
                e1.firstStackClearing && c.stackClearing && (e1.firstStackClearing = !1, a -= c.min, a >= 2 && c.stem ? a %= 2 : a > 1 && warn$1("Found too many parameters for stack-clearing command"), a > 0 && (e1.width = s[a - 1])), "stackDelta" in c ? ("stackFn" in c && c.stackFn(s, a), a += c.stackDelta) : c.stackClearing ? a = 0 : c.resetStack ? (a = 0, e1.undefStack = !1) : c.undefStack && (a = 0, e1.undefStack = !0, e1.firstStackClearing = !1);
            }
        }
        return r < t.length && t.fill(14, r), e1.stackSize = a, !0;
    }
    parseCharStrings({ charStrings: e1, localSubrIndex: t, globalSubrIndex: i, fdSelect: n, fdArray: a, privateDict: s }) {
        const r = [], o = [], l = e1.count;
        for(let c = 0; c < l; c++){
            const l = e1.get(c), h = {
                callDepth: 0,
                stackSize: 0,
                stack: [],
                undefStack: !0,
                hints: 0,
                firstStackClearing: !0,
                seac: null,
                width: null,
                hasVStems: !1
            };
            let d = !0, u = null, g = s;
            if (n && a.length) {
                const e1 = n.getFDIndex(c);
                -1 === e1 && (warn$1("Glyph index is not in fd select."), d = !1), e1 >= a.length && (warn$1("Invalid fd index for glyph index."), d = !1), d && (g = a[e1].privateDict, u = g.subrsIndex);
            } else t && (u = t);
            if (d && (d = this.parseCharString(h, l, u, i)), null !== h.width) {
                const e1 = g.getByName("nominalWidthX");
                o[c] = e1 + h.width;
            } else {
                const e1 = g.getByName("defaultWidthX");
                o[c] = e1;
            }
            null !== h.seac && (r[c] = h.seac), d || e1.set(c, new Uint8Array([
                14
            ]));
        }
        return {
            charStrings: e1,
            seacs: r,
            widths: o
        };
    }
    emptyPrivateDictionary(e1) {
        const t = this.createDict(CFFPrivateDict, [], e1.strings);
        e1.setByKey(18, [
            0,
            0
        ]), e1.privateDict = t;
    }
    parsePrivateDict(e1) {
        if (!e1.hasName("Private")) return void this.emptyPrivateDictionary(e1);
        const t = e1.getByName("Private");
        if (!Array.isArray(t) || 2 !== t.length) return void e1.removeByName("Private");
        const i = t[0], n = t[1];
        if (0 === i || n >= this.bytes.length) return void this.emptyPrivateDictionary(e1);
        const a = n + i, s = this.bytes.subarray(n, a), r = this.parseDict(s), o = this.createDict(CFFPrivateDict, r, e1.strings);
        if (e1.privateDict = o, 0 === o.getByName("ExpansionFactor") && o.setByName("ExpansionFactor", .06), !o.getByName("Subrs")) return;
        const l = o.getByName("Subrs"), c = n + l;
        if (0 === l || c >= this.bytes.length) return void this.emptyPrivateDictionary(e1);
        const h = this.parseIndex(c);
        o.subrsIndex = h.obj;
    }
    parseCharsets(e1, t, i, n) {
        if (0 === e1) return new CFFCharset(!0, Ln.ISO_ADOBE, En);
        if (1 === e1) return new CFFCharset(!0, Ln.EXPERT, Mn);
        if (2 === e1) return new CFFCharset(!0, Ln.EXPERT_SUBSET, Dn);
        const a = this.bytes, s = e1, r = a[e1++], o = [
            n ? 0 : ".notdef"
        ];
        let l, c, h;
        switch(t -= 1, r){
            case 0:
                for(h = 0; h < t; h++)l = a[e1++] << 8 | a[e1++], o.push(n ? l : i.get(l));
                break;
            case 1:
                for(; o.length <= t;)for(l = a[e1++] << 8 | a[e1++], c = a[e1++], h = 0; h <= c; h++)o.push(n ? l++ : i.get(l++));
                break;
            case 2:
                for(; o.length <= t;)for(l = a[e1++] << 8 | a[e1++], c = a[e1++] << 8 | a[e1++], h = 0; h <= c; h++)o.push(n ? l++ : i.get(l++));
                break;
            default:
                throw new ti("Unknown charset format");
        }
        const d = e1, u = a.subarray(s, d);
        return new CFFCharset(!1, r, o, u);
    }
    parseEncoding(e1, t, i, n) {
        const a = Object.create(null), s = this.bytes;
        let r, o, l, c = !1, h = null;
        if (0 === e1 || 1 === e1) {
            c = !0, r = e1;
            const t = e1 ? cn : un;
            for(o = 0, l = n.length; o < l; o++){
                const e1 = t.indexOf(n[o]);
                -1 !== e1 && (a[e1] = o);
            }
        } else {
            const t = e1;
            switch(r = s[e1++], 127 & r){
                case 0:
                    const t1 = s[e1++];
                    for(o = 1; o <= t1; o++)a[s[e1++]] = o;
                    break;
                case 1:
                    const i1 = s[e1++];
                    let n1 = 1;
                    for(o = 0; o < i1; o++){
                        const t = s[e1++], i = s[e1++];
                        for(let e1 = t; e1 <= t + i; e1++)a[e1] = n1++;
                    }
                    break;
                default:
                    throw new ti(`Unknown encoding format: ${r} in CFF`);
            }
            const l = e1;
            128 & r && (s[t] &= 127, function() {
                const t = s[e1++];
                for(o = 0; o < t; o++){
                    const t = s[e1++], r = (s[e1++] << 8) + (255 & s[e1++]);
                    a[t] = n.indexOf(i.get(r));
                }
            }()), h = s.subarray(t, l);
        }
        return r &= 127, new CFFEncoding(c, r, a, h);
    }
    parseFDSelect(e1, t) {
        const i = this.bytes, n = i[e1++], a = [];
        let s;
        switch(n){
            case 0:
                for(s = 0; s < t; ++s){
                    const t = i[e1++];
                    a.push(t);
                }
                break;
            case 3:
                const r = i[e1++] << 8 | i[e1++];
                for(s = 0; s < r; ++s){
                    let t = i[e1++] << 8 | i[e1++];
                    0 === s && 0 !== t && (warn$1("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), t = 0);
                    const n = i[e1++], r = i[e1] << 8 | i[e1 + 1];
                    for(let e1 = t; e1 < r; ++e1)a.push(n);
                }
                e1 += 2;
                break;
            default:
                throw new ti(`parseFDSelect: Unknown format "${n}".`);
        }
        if (a.length !== t) throw new ti("parseFDSelect: Invalid font data.");
        return new CFFFDSelect(n, a);
    }
}
class CFF {
    constructor(){
        this.header = null, this.names = [], this.topDict = null, this.strings = new CFFStrings, this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = !1;
    }
    duplicateFirstGlyph() {
        if (this.charStrings.count >= 65535) return void warn$1("Not enough space in charstrings to duplicate first glyph.");
        const e1 = this.charStrings.get(0);
        this.charStrings.add(e1), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
    }
    hasGlyphId(e1) {
        if (e1 < 0 || e1 >= this.charStrings.count) return !1;
        return this.charStrings.get(e1).length > 0;
    }
}
class CFFHeader {
    constructor(e1, t, i, n){
        this.major = e1, this.minor = t, this.hdrSize = i, this.offSize = n;
    }
}
class CFFStrings {
    constructor(){
        this.strings = [];
    }
    get(e1) {
        return e1 >= 0 && e1 <= 390 ? On[e1] : e1 - _n <= this.strings.length ? this.strings[e1 - _n] : On[0];
    }
    getSID(e1) {
        let t = On.indexOf(e1);
        return -1 !== t ? t : (t = this.strings.indexOf(e1), -1 !== t ? t + _n : -1);
    }
    add(e1) {
        this.strings.push(e1);
    }
    get count() {
        return this.strings.length;
    }
}
class CFFIndex {
    constructor(){
        this.objects = [], this.length = 0;
    }
    add(e1) {
        this.length += e1.length, this.objects.push(e1);
    }
    set(e1, t) {
        this.length += t.length - this.objects[e1].length, this.objects[e1] = t;
    }
    get(e1) {
        return this.objects[e1];
    }
    get count() {
        return this.objects.length;
    }
}
class CFFDict {
    constructor(e1, t){
        this.keyToNameMap = e1.keyToNameMap, this.nameToKeyMap = e1.nameToKeyMap, this.defaults = e1.defaults, this.types = e1.types, this.opcodes = e1.opcodes, this.order = e1.order, this.strings = t, this.values = Object.create(null);
    }
    setByKey(e1, t) {
        if (!(e1 in this.keyToNameMap)) return !1;
        if (0 === t.length) return !0;
        for (const i of t)if (isNaN(i)) return warn$1(`Invalid CFFDict value: "${t}" for key "${e1}".`), !0;
        const i = this.types[e1];
        return "num" !== i && "sid" !== i && "offset" !== i || (t = t[0]), this.values[e1] = t, !0;
    }
    setByName(e1, t) {
        if (!(e1 in this.nameToKeyMap)) throw new ti(`Invalid dictionary name "${e1}"`);
        this.values[this.nameToKeyMap[e1]] = t;
    }
    hasName(e1) {
        return this.nameToKeyMap[e1] in this.values;
    }
    getByName(e1) {
        if (!(e1 in this.nameToKeyMap)) throw new ti(`Invalid dictionary name ${e1}"`);
        const t = this.nameToKeyMap[e1];
        return t in this.values ? this.values[t] : this.defaults[t];
    }
    removeByName(e1) {
        delete this.values[this.nameToKeyMap[e1]];
    }
    static createTables(e1) {
        const t = {
            keyToNameMap: {},
            nameToKeyMap: {},
            defaults: {},
            types: {},
            opcodes: {},
            order: []
        };
        for (const i of e1){
            const e1 = Array.isArray(i[0]) ? (i[0][0] << 8) + i[0][1] : i[0];
            t.keyToNameMap[e1] = i[1], t.nameToKeyMap[i[1]] = e1, t.types[e1] = i[2], t.defaults[e1] = i[3], t.opcodes[e1] = Array.isArray(i[0]) ? i[0] : [
                i[0]
            ], t.order.push(e1);
        }
        return t;
    }
}
const Bn = [
    [
        [
            12,
            30
        ],
        "ROS",
        [
            "sid",
            "sid",
            "num"
        ],
        null
    ],
    [
        [
            12,
            20
        ],
        "SyntheticBase",
        "num",
        null
    ],
    [
        0,
        "version",
        "sid",
        null
    ],
    [
        1,
        "Notice",
        "sid",
        null
    ],
    [
        [
            12,
            0
        ],
        "Copyright",
        "sid",
        null
    ],
    [
        2,
        "FullName",
        "sid",
        null
    ],
    [
        3,
        "FamilyName",
        "sid",
        null
    ],
    [
        4,
        "Weight",
        "sid",
        null
    ],
    [
        [
            12,
            1
        ],
        "isFixedPitch",
        "num",
        0
    ],
    [
        [
            12,
            2
        ],
        "ItalicAngle",
        "num",
        0
    ],
    [
        [
            12,
            3
        ],
        "UnderlinePosition",
        "num",
        -100
    ],
    [
        [
            12,
            4
        ],
        "UnderlineThickness",
        "num",
        50
    ],
    [
        [
            12,
            5
        ],
        "PaintType",
        "num",
        0
    ],
    [
        [
            12,
            6
        ],
        "CharstringType",
        "num",
        2
    ],
    [
        [
            12,
            7
        ],
        "FontMatrix",
        [
            "num",
            "num",
            "num",
            "num",
            "num",
            "num"
        ],
        [
            .001,
            0,
            0,
            .001,
            0,
            0
        ]
    ],
    [
        13,
        "UniqueID",
        "num",
        null
    ],
    [
        5,
        "FontBBox",
        [
            "num",
            "num",
            "num",
            "num"
        ],
        [
            0,
            0,
            0,
            0
        ]
    ],
    [
        [
            12,
            8
        ],
        "StrokeWidth",
        "num",
        0
    ],
    [
        14,
        "XUID",
        "array",
        null
    ],
    [
        15,
        "charset",
        "offset",
        0
    ],
    [
        16,
        "Encoding",
        "offset",
        0
    ],
    [
        17,
        "CharStrings",
        "offset",
        0
    ],
    [
        18,
        "Private",
        [
            "offset",
            "offset"
        ],
        null
    ],
    [
        [
            12,
            21
        ],
        "PostScript",
        "sid",
        null
    ],
    [
        [
            12,
            22
        ],
        "BaseFontName",
        "sid",
        null
    ],
    [
        [
            12,
            23
        ],
        "BaseFontBlend",
        "delta",
        null
    ],
    [
        [
            12,
            31
        ],
        "CIDFontVersion",
        "num",
        0
    ],
    [
        [
            12,
            32
        ],
        "CIDFontRevision",
        "num",
        0
    ],
    [
        [
            12,
            33
        ],
        "CIDFontType",
        "num",
        0
    ],
    [
        [
            12,
            34
        ],
        "CIDCount",
        "num",
        8720
    ],
    [
        [
            12,
            35
        ],
        "UIDBase",
        "num",
        null
    ],
    [
        [
            12,
            37
        ],
        "FDSelect",
        "offset",
        null
    ],
    [
        [
            12,
            36
        ],
        "FDArray",
        "offset",
        null
    ],
    [
        [
            12,
            38
        ],
        "FontName",
        "sid",
        null
    ]
];
class CFFTopDict extends CFFDict {
    static get tables() {
        return shadow$1(this, "tables", this.createTables(Bn));
    }
    constructor(e1){
        super(CFFTopDict.tables, e1), this.privateDict = null;
    }
}
const Nn = [
    [
        6,
        "BlueValues",
        "delta",
        null
    ],
    [
        7,
        "OtherBlues",
        "delta",
        null
    ],
    [
        8,
        "FamilyBlues",
        "delta",
        null
    ],
    [
        9,
        "FamilyOtherBlues",
        "delta",
        null
    ],
    [
        [
            12,
            9
        ],
        "BlueScale",
        "num",
        .039625
    ],
    [
        [
            12,
            10
        ],
        "BlueShift",
        "num",
        7
    ],
    [
        [
            12,
            11
        ],
        "BlueFuzz",
        "num",
        1
    ],
    [
        10,
        "StdHW",
        "num",
        null
    ],
    [
        11,
        "StdVW",
        "num",
        null
    ],
    [
        [
            12,
            12
        ],
        "StemSnapH",
        "delta",
        null
    ],
    [
        [
            12,
            13
        ],
        "StemSnapV",
        "delta",
        null
    ],
    [
        [
            12,
            14
        ],
        "ForceBold",
        "num",
        0
    ],
    [
        [
            12,
            17
        ],
        "LanguageGroup",
        "num",
        0
    ],
    [
        [
            12,
            18
        ],
        "ExpansionFactor",
        "num",
        .06
    ],
    [
        [
            12,
            19
        ],
        "initialRandomSeed",
        "num",
        0
    ],
    [
        20,
        "defaultWidthX",
        "num",
        0
    ],
    [
        21,
        "nominalWidthX",
        "num",
        0
    ],
    [
        19,
        "Subrs",
        "offset",
        null
    ]
];
class CFFPrivateDict extends CFFDict {
    static get tables() {
        return shadow$1(this, "tables", this.createTables(Nn));
    }
    constructor(e1){
        super(CFFPrivateDict.tables, e1), this.subrsIndex = null;
    }
}
const Ln = {
    ISO_ADOBE: 0,
    EXPERT: 1,
    EXPERT_SUBSET: 2
};
class CFFCharset {
    constructor(e1, t, i, n){
        this.predefined = e1, this.format = t, this.charset = i, this.raw = n;
    }
}
class CFFEncoding {
    constructor(e1, t, i, n){
        this.predefined = e1, this.format = t, this.encoding = i, this.raw = n;
    }
}
class CFFFDSelect {
    constructor(e1, t){
        this.format = e1, this.fdSelect = t;
    }
    getFDIndex(e1) {
        return e1 < 0 || e1 >= this.fdSelect.length ? -1 : this.fdSelect[e1];
    }
}
class CFFOffsetTracker {
    constructor(){
        this.offsets = Object.create(null);
    }
    isTracking(e1) {
        return e1 in this.offsets;
    }
    track(e1, t) {
        if (e1 in this.offsets) throw new ti(`Already tracking location of ${e1}`);
        this.offsets[e1] = t;
    }
    offset(e1) {
        for(const t in this.offsets)this.offsets[t] += e1;
    }
    setEntryLocation(e1, t, i) {
        if (!(e1 in this.offsets)) throw new ti(`Not tracking location of ${e1}`);
        const n = i.data, a = this.offsets[e1];
        for(let e1 = 0, i = t.length; e1 < i; ++e1){
            const i = 5 * e1 + a, s = i + 1, r = i + 2, o = i + 3, l = i + 4;
            if (29 !== n[i] || 0 !== n[s] || 0 !== n[r] || 0 !== n[o] || 0 !== n[l]) throw new ti("writing to an offset that is not empty");
            const c = t[e1];
            n[i] = 29, n[s] = c >> 24 & 255, n[r] = c >> 16 & 255, n[o] = c >> 8 & 255, n[l] = 255 & c;
        }
    }
}
class CFFCompiler {
    constructor(e1){
        this.cff = e1;
    }
    compile() {
        const e1 = this.cff, t = {
            data: [],
            length: 0,
            add (e1) {
                try {
                    this.data.push(...e1);
                } catch  {
                    this.data = this.data.concat(e1);
                }
                this.length = this.data.length;
            }
        }, i = this.compileHeader(e1.header);
        t.add(i);
        const n = this.compileNameIndex(e1.names);
        if (t.add(n), e1.isCIDFont && e1.topDict.hasName("FontMatrix")) {
            const t = e1.topDict.getByName("FontMatrix");
            e1.topDict.removeByName("FontMatrix");
            for (const i of e1.fdArray){
                let e1 = t.slice(0);
                i.hasName("FontMatrix") && (e1 = ai.transform(e1, i.getByName("FontMatrix"))), i.setByName("FontMatrix", e1);
            }
        }
        const a = e1.topDict.getByName("XUID");
        a?.length > 16 && e1.topDict.removeByName("XUID"), e1.topDict.setByName("charset", 0);
        let s = this.compileTopDicts([
            e1.topDict
        ], t.length, e1.isCIDFont);
        t.add(s.output);
        const r = s.trackers[0], o = this.compileStringIndex(e1.strings.strings);
        t.add(o);
        const l = this.compileIndex(e1.globalSubrIndex);
        if (t.add(l), e1.encoding && e1.topDict.hasName("Encoding")) if (e1.encoding.predefined) r.setEntryLocation("Encoding", [
            e1.encoding.format
        ], t);
        else {
            const i = this.compileEncoding(e1.encoding);
            r.setEntryLocation("Encoding", [
                t.length
            ], t), t.add(i);
        }
        const c = this.compileCharset(e1.charset, e1.charStrings.count, e1.strings, e1.isCIDFont);
        r.setEntryLocation("charset", [
            t.length
        ], t), t.add(c);
        const h = this.compileCharStrings(e1.charStrings);
        if (r.setEntryLocation("CharStrings", [
            t.length
        ], t), t.add(h), e1.isCIDFont) {
            r.setEntryLocation("FDSelect", [
                t.length
            ], t);
            const i = this.compileFDSelect(e1.fdSelect);
            t.add(i), s = this.compileTopDicts(e1.fdArray, t.length, !0), r.setEntryLocation("FDArray", [
                t.length
            ], t), t.add(s.output);
            const n = s.trackers;
            this.compilePrivateDicts(e1.fdArray, n, t);
        }
        return this.compilePrivateDicts([
            e1.topDict
        ], [
            r
        ], t), t.add([
            0
        ]), t.data;
    }
    encodeNumber(e1) {
        return Number.isInteger(e1) ? this.encodeInteger(e1) : this.encodeFloat(e1);
    }
    static get EncodeFloatRegExp() {
        return shadow$1(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
    }
    encodeFloat(e1) {
        let t = e1.toString();
        const i = CFFCompiler.EncodeFloatRegExp.exec(t);
        if (i) {
            const n = parseFloat("1e" + ((i[2] ? +i[2] : 0) + i[1].length));
            t = (Math.round(e1 * n) / n).toString();
        }
        let n, a, s = "";
        for(n = 0, a = t.length; n < a; ++n){
            const e1 = t[n];
            s += "e" === e1 ? "-" === t[++n] ? "c" : "b" : "." === e1 ? "a" : "-" === e1 ? "e" : e1;
        }
        s += 1 & s.length ? "f" : "ff";
        const r = [
            30
        ];
        for(n = 0, a = s.length; n < a; n += 2)r.push(parseInt(s.substring(n, n + 2), 16));
        return r;
    }
    encodeInteger(e1) {
        let t;
        return t = e1 >= -107 && e1 <= 107 ? [
            e1 + 139
        ] : e1 >= 108 && e1 <= 1131 ? [
            247 + ((e1 -= 108) >> 8),
            255 & e1
        ] : e1 >= -1131 && e1 <= -108 ? [
            251 + ((e1 = -e1 - 108) >> 8),
            255 & e1
        ] : e1 >= -32768 && e1 <= 32767 ? [
            28,
            e1 >> 8 & 255,
            255 & e1
        ] : [
            29,
            e1 >> 24 & 255,
            e1 >> 16 & 255,
            e1 >> 8 & 255,
            255 & e1
        ], t;
    }
    compileHeader(e1) {
        return [
            e1.major,
            e1.minor,
            4,
            e1.offSize
        ];
    }
    compileNameIndex(e1) {
        const t = new CFFIndex;
        for (const i of e1){
            const e1 = Math.min(i.length, 127);
            let n = new Array(e1);
            for(let t = 0; t < e1; t++){
                let e1 = i[t];
                (e1 < "!" || e1 > "~" || "[" === e1 || "]" === e1 || "(" === e1 || ")" === e1 || "{" === e1 || "}" === e1 || "<" === e1 || ">" === e1 || "/" === e1 || "%" === e1) && (e1 = "_"), n[t] = e1;
            }
            n = n.join(""), "" === n && (n = "Bad_Font_Name"), t.add(stringToBytes$1(n));
        }
        return this.compileIndex(t);
    }
    compileTopDicts(e1, t, i) {
        const n = [];
        let a = new CFFIndex;
        for (const s of e1){
            i && (s.removeByName("CIDFontVersion"), s.removeByName("CIDFontRevision"), s.removeByName("CIDFontType"), s.removeByName("CIDCount"), s.removeByName("UIDBase"));
            const e1 = new CFFOffsetTracker, r = this.compileDict(s, e1);
            n.push(e1), a.add(r), e1.offset(t);
        }
        return a = this.compileIndex(a, n), {
            trackers: n,
            output: a
        };
    }
    compilePrivateDicts(e1, t, i) {
        for(let n = 0, a = e1.length; n < a; ++n){
            const a = e1[n], s = a.privateDict;
            if (!s || !a.hasName("Private")) throw new ti("There must be a private dictionary.");
            const r = new CFFOffsetTracker, o = this.compileDict(s, r);
            let l = i.length;
            if (r.offset(l), o.length || (l = 0), t[n].setEntryLocation("Private", [
                o.length,
                l
            ], i), i.add(o), s.subrsIndex && s.hasName("Subrs")) {
                const e1 = this.compileIndex(s.subrsIndex);
                r.setEntryLocation("Subrs", [
                    o.length
                ], i), i.add(e1);
            }
        }
    }
    compileDict(e1, t) {
        const i = [];
        for (const n of e1.order){
            if (!(n in e1.values)) continue;
            let a = e1.values[n], s = e1.types[n];
            if (Array.isArray(s) || (s = [
                s
            ]), Array.isArray(a) || (a = [
                a
            ]), 0 !== a.length) {
                for(let r = 0, o = s.length; r < o; ++r){
                    const o = s[r], l = a[r];
                    switch(o){
                        case "num":
                        case "sid":
                            i.push(...this.encodeNumber(l));
                            break;
                        case "offset":
                            const s1 = e1.keyToNameMap[n];
                            t.isTracking(s1) || t.track(s1, i.length), i.push(29, 0, 0, 0, 0);
                            break;
                        case "array":
                        case "delta":
                            i.push(...this.encodeNumber(l));
                            for(let e1 = 1, t = a.length; e1 < t; ++e1)i.push(...this.encodeNumber(a[e1]));
                            break;
                        default:
                            throw new ti(`Unknown data type of ${o}`);
                    }
                }
                i.push(...e1.opcodes[n]);
            }
        }
        return i;
    }
    compileStringIndex(e1) {
        const t = new CFFIndex;
        for (const i of e1)t.add(stringToBytes$1(i));
        return this.compileIndex(t);
    }
    compileCharStrings(e1) {
        const t = new CFFIndex;
        for(let i = 0; i < e1.count; i++){
            const n = e1.get(i);
            0 !== n.length ? t.add(n) : t.add(new Uint8Array([
                139,
                14
            ]));
        }
        return this.compileIndex(t);
    }
    compileCharset(e1, t, i, n) {
        let a;
        const s = t - 1;
        if (n) {
            const e1 = s - 1;
            a = new Uint8Array([
                2,
                0,
                1,
                e1 >> 8 & 255,
                255 & e1
            ]);
        } else {
            a = new Uint8Array(1 + 2 * s), a[0] = 0;
            let t = 0;
            const n = e1.charset.length;
            let r = !1;
            for(let s = 1; s < a.length; s += 2){
                let o = 0;
                if (t < n) {
                    const n = e1.charset[t++];
                    o = i.getSID(n), -1 === o && (o = 0, r || (r = !0, warn$1(`Couldn't find ${n} in CFF strings`)));
                }
                a[s] = o >> 8 & 255, a[s + 1] = 255 & o;
            }
        }
        return this.compileTypedArray(a);
    }
    compileEncoding(e1) {
        return this.compileTypedArray(e1.raw);
    }
    compileFDSelect(e1) {
        const t = e1.format;
        let i, n;
        switch(t){
            case 0:
                for(i = new Uint8Array(1 + e1.fdSelect.length), i[0] = t, n = 0; n < e1.fdSelect.length; n++)i[n + 1] = e1.fdSelect[n];
                break;
            case 3:
                const a = 0;
                let s = e1.fdSelect[0];
                const r = [
                    t,
                    0,
                    0,
                    a >> 8 & 255,
                    255 & a,
                    s
                ];
                for(n = 1; n < e1.fdSelect.length; n++){
                    const t = e1.fdSelect[n];
                    t !== s && (r.push(n >> 8 & 255, 255 & n, t), s = t);
                }
                const o = (r.length - 3) / 3;
                r[1] = o >> 8 & 255, r[2] = 255 & o, r.push(n >> 8 & 255, 255 & n), i = new Uint8Array(r);
        }
        return this.compileTypedArray(i);
    }
    compileTypedArray(e1) {
        return Array.from(e1);
    }
    compileIndex(e1, t = []) {
        const i = e1.objects, n = i.length;
        if (0 === n) return [
            0,
            0
        ];
        const a = [
            n >> 8 & 255,
            255 & n
        ];
        let s, r, o = 1;
        for(s = 0; s < n; ++s)o += i[s].length;
        r = o < 256 ? 1 : o < 65536 ? 2 : o < 16777216 ? 3 : 4, a.push(r);
        let l = 1;
        for(s = 0; s < n + 1; s++)1 === r ? a.push(255 & l) : 2 === r ? a.push(l >> 8 & 255, 255 & l) : 3 === r ? a.push(l >> 16 & 255, l >> 8 & 255, 255 & l) : a.push(l >>> 24 & 255, l >> 16 & 255, l >> 8 & 255, 255 & l), i[s] && (l += i[s].length);
        for(s = 0; s < n; s++)t[s] && t[s].offset(a.length), a.push(...i[s]);
        return a;
    }
}
const Un = getLookupTableFactory(function(e1) {
    e1["Times-Roman"] = "Times-Roman", e1.Helvetica = "Helvetica", e1.Courier = "Courier", e1.Symbol = "Symbol", e1["Times-Bold"] = "Times-Bold", e1["Helvetica-Bold"] = "Helvetica-Bold", e1["Courier-Bold"] = "Courier-Bold", e1.ZapfDingbats = "ZapfDingbats", e1["Times-Italic"] = "Times-Italic", e1["Helvetica-Oblique"] = "Helvetica-Oblique", e1["Courier-Oblique"] = "Courier-Oblique", e1["Times-BoldItalic"] = "Times-BoldItalic", e1["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", e1["Courier-BoldOblique"] = "Courier-BoldOblique", e1.ArialNarrow = "Helvetica", e1["ArialNarrow-Bold"] = "Helvetica-Bold", e1["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", e1["ArialNarrow-Italic"] = "Helvetica-Oblique", e1.ArialBlack = "Helvetica", e1["ArialBlack-Bold"] = "Helvetica-Bold", e1["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", e1["ArialBlack-Italic"] = "Helvetica-Oblique", e1["Arial-Black"] = "Helvetica", e1["Arial-Black-Bold"] = "Helvetica-Bold", e1["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", e1["Arial-Black-Italic"] = "Helvetica-Oblique", e1.Arial = "Helvetica", e1["Arial-Bold"] = "Helvetica-Bold", e1["Arial-BoldItalic"] = "Helvetica-BoldOblique", e1["Arial-Italic"] = "Helvetica-Oblique", e1.ArialMT = "Helvetica", e1["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", e1["Arial-BoldMT"] = "Helvetica-Bold", e1["Arial-ItalicMT"] = "Helvetica-Oblique", e1["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique", e1["Arial-BoldMT-Bold"] = "Helvetica-Bold", e1["Arial-ItalicMT-Italic"] = "Helvetica-Oblique", e1.ArialUnicodeMS = "Helvetica", e1["ArialUnicodeMS-Bold"] = "Helvetica-Bold", e1["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", e1["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", e1["Courier-BoldItalic"] = "Courier-BoldOblique", e1["Courier-Italic"] = "Courier-Oblique", e1.CourierNew = "Courier", e1["CourierNew-Bold"] = "Courier-Bold", e1["CourierNew-BoldItalic"] = "Courier-BoldOblique", e1["CourierNew-Italic"] = "Courier-Oblique", e1["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", e1["CourierNewPS-BoldMT"] = "Courier-Bold", e1["CourierNewPS-ItalicMT"] = "Courier-Oblique", e1.CourierNewPSMT = "Courier", e1["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", e1["Helvetica-Italic"] = "Helvetica-Oblique", e1["HelveticaLTStd-Bold"] = "Helvetica-Bold", e1["Symbol-Bold"] = "Symbol", e1["Symbol-BoldItalic"] = "Symbol", e1["Symbol-Italic"] = "Symbol", e1.TimesNewRoman = "Times-Roman", e1["TimesNewRoman-Bold"] = "Times-Bold", e1["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", e1["TimesNewRoman-Italic"] = "Times-Italic", e1.TimesNewRomanPS = "Times-Roman", e1["TimesNewRomanPS-Bold"] = "Times-Bold", e1["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", e1["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", e1["TimesNewRomanPS-BoldMT"] = "Times-Bold", e1["TimesNewRomanPS-Italic"] = "Times-Italic", e1["TimesNewRomanPS-ItalicMT"] = "Times-Italic", e1.TimesNewRomanPSMT = "Times-Roman", e1["TimesNewRomanPSMT-Bold"] = "Times-Bold", e1["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", e1["TimesNewRomanPSMT-Italic"] = "Times-Italic";
}), jn = getLookupTableFactory(function(e1) {
    e1.Courier = "FoxitFixed.pfb", e1["Courier-Bold"] = "FoxitFixedBold.pfb", e1["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", e1["Courier-Oblique"] = "FoxitFixedItalic.pfb", e1.Helvetica = "LiberationSans-Regular.ttf", e1["Helvetica-Bold"] = "LiberationSans-Bold.ttf", e1["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf", e1["Helvetica-Oblique"] = "LiberationSans-Italic.ttf", e1["Times-Roman"] = "FoxitSerif.pfb", e1["Times-Bold"] = "FoxitSerifBold.pfb", e1["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", e1["Times-Italic"] = "FoxitSerifItalic.pfb", e1.Symbol = "FoxitSymbol.pfb", e1.ZapfDingbats = "FoxitDingbats.pfb", e1["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", e1["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", e1["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", e1["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
}), $n = getLookupTableFactory(function(e1) {
    e1.Calibri = "Helvetica", e1["Calibri-Bold"] = "Helvetica-Bold", e1["Calibri-BoldItalic"] = "Helvetica-BoldOblique", e1["Calibri-Italic"] = "Helvetica-Oblique", e1.CenturyGothic = "Helvetica", e1["CenturyGothic-Bold"] = "Helvetica-Bold", e1["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", e1["CenturyGothic-Italic"] = "Helvetica-Oblique", e1.ComicSansMS = "Comic Sans MS", e1["ComicSansMS-Bold"] = "Comic Sans MS-Bold", e1["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", e1["ComicSansMS-Italic"] = "Comic Sans MS-Italic", e1.GillSansMT = "Helvetica", e1["GillSansMT-Bold"] = "Helvetica-Bold", e1["GillSansMT-BoldItalic"] = "Helvetica-BoldOblique", e1["GillSansMT-Italic"] = "Helvetica-Oblique", e1.Impact = "Helvetica", e1["ItcSymbol-Bold"] = "Helvetica-Bold", e1["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", e1["ItcSymbol-Book"] = "Helvetica", e1["ItcSymbol-BookItalic"] = "Helvetica-Oblique", e1["ItcSymbol-Medium"] = "Helvetica", e1["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", e1.LucidaConsole = "Courier", e1["LucidaConsole-Bold"] = "Courier-Bold", e1["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", e1["LucidaConsole-Italic"] = "Courier-Oblique", e1["LucidaSans-Demi"] = "Helvetica-Bold", e1["MS-Gothic"] = "MS Gothic", e1["MS-Gothic-Bold"] = "MS Gothic-Bold", e1["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", e1["MS-Gothic-Italic"] = "MS Gothic-Italic", e1["MS-Mincho"] = "MS Mincho", e1["MS-Mincho-Bold"] = "MS Mincho-Bold", e1["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", e1["MS-Mincho-Italic"] = "MS Mincho-Italic", e1["MS-PGothic"] = "MS PGothic", e1["MS-PGothic-Bold"] = "MS PGothic-Bold", e1["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", e1["MS-PGothic-Italic"] = "MS PGothic-Italic", e1["MS-PMincho"] = "MS PMincho", e1["MS-PMincho-Bold"] = "MS PMincho-Bold", e1["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", e1["MS-PMincho-Italic"] = "MS PMincho-Italic", e1.NuptialScript = "Times-Italic", e1.SegoeUISymbol = "Helvetica";
}), Hn = getLookupTableFactory(function(e1) {
    e1["Adobe Jenson"] = !0, e1["Adobe Text"] = !0, e1.Albertus = !0, e1.Aldus = !0, e1.Alexandria = !0, e1.Algerian = !0, e1["American Typewriter"] = !0, e1.Antiqua = !0, e1.Apex = !0, e1.Arno = !0, e1.Aster = !0, e1.Aurora = !0, e1.Baskerville = !0, e1.Bell = !0, e1.Bembo = !0, e1["Bembo Schoolbook"] = !0, e1.Benguiat = !0, e1["Berkeley Old Style"] = !0, e1["Bernhard Modern"] = !0, e1["Berthold City"] = !0, e1.Bodoni = !0, e1["Bauer Bodoni"] = !0, e1["Book Antiqua"] = !0, e1.Bookman = !0, e1["Bordeaux Roman"] = !0, e1["Californian FB"] = !0, e1.Calisto = !0, e1.Calvert = !0, e1.Capitals = !0, e1.Cambria = !0, e1.Cartier = !0, e1.Caslon = !0, e1.Catull = !0, e1.Centaur = !0, e1["Century Old Style"] = !0, e1["Century Schoolbook"] = !0, e1.Chaparral = !0, e1["Charis SIL"] = !0, e1.Cheltenham = !0, e1["Cholla Slab"] = !0, e1.Clarendon = !0, e1.Clearface = !0, e1.Cochin = !0, e1.Colonna = !0, e1["Computer Modern"] = !0, e1["Concrete Roman"] = !0, e1.Constantia = !0, e1["Cooper Black"] = !0, e1.Corona = !0, e1.Ecotype = !0, e1.Egyptienne = !0, e1.Elephant = !0, e1.Excelsior = !0, e1.Fairfield = !0, e1["FF Scala"] = !0, e1.Folkard = !0, e1.Footlight = !0, e1.FreeSerif = !0, e1["Friz Quadrata"] = !0, e1.Garamond = !0, e1.Gentium = !0, e1.Georgia = !0, e1.Gloucester = !0, e1["Goudy Old Style"] = !0, e1["Goudy Schoolbook"] = !0, e1["Goudy Pro Font"] = !0, e1.Granjon = !0, e1["Guardian Egyptian"] = !0, e1.Heather = !0, e1.Hercules = !0, e1["High Tower Text"] = !0, e1.Hiroshige = !0, e1["Hoefler Text"] = !0, e1["Humana Serif"] = !0, e1.Imprint = !0, e1["Ionic No. 5"] = !0, e1.Janson = !0, e1.Joanna = !0, e1.Korinna = !0, e1.Lexicon = !0, e1.LiberationSerif = !0, e1["Liberation Serif"] = !0, e1["Linux Libertine"] = !0, e1.Literaturnaya = !0, e1.Lucida = !0, e1["Lucida Bright"] = !0, e1.Melior = !0, e1.Memphis = !0, e1.Miller = !0, e1.Minion = !0, e1.Modern = !0, e1["Mona Lisa"] = !0, e1["Mrs Eaves"] = !0, e1["MS Serif"] = !0, e1["Museo Slab"] = !0, e1["New York"] = !0, e1["Nimbus Roman"] = !0, e1["NPS Rawlinson Roadway"] = !0, e1.NuptialScript = !0, e1.Palatino = !0, e1.Perpetua = !0, e1.Plantin = !0, e1["Plantin Schoolbook"] = !0, e1.Playbill = !0, e1["Poor Richard"] = !0, e1["Rawlinson Roadway"] = !0, e1.Renault = !0, e1.Requiem = !0, e1.Rockwell = !0, e1.Roman = !0, e1["Rotis Serif"] = !0, e1.Sabon = !0, e1.Scala = !0, e1.Seagull = !0, e1.Sistina = !0, e1.Souvenir = !0, e1.STIX = !0, e1["Stone Informal"] = !0, e1["Stone Serif"] = !0, e1.Sylfaen = !0, e1.Times = !0, e1.Trajan = !0, e1["TrinitÃ©"] = !0, e1["Trump Mediaeval"] = !0, e1.Utopia = !0, e1["Vale Type"] = !0, e1["Bitstream Vera"] = !0, e1["Vera Serif"] = !0, e1.Versailles = !0, e1.Wanted = !0, e1.Weiss = !0, e1["Wide Latin"] = !0, e1.Windsor = !0, e1.XITS = !0;
}), Xn = getLookupTableFactory(function(e1) {
    e1.Dingbats = !0, e1.Symbol = !0, e1.ZapfDingbats = !0, e1.Wingdings = !0, e1["Wingdings-Bold"] = !0, e1["Wingdings-Regular"] = !0;
}), qn = getLookupTableFactory(function(e1) {
    e1[2] = 10, e1[3] = 32, e1[4] = 33, e1[5] = 34, e1[6] = 35, e1[7] = 36, e1[8] = 37, e1[9] = 38, e1[10] = 39, e1[11] = 40, e1[12] = 41, e1[13] = 42, e1[14] = 43, e1[15] = 44, e1[16] = 45, e1[17] = 46, e1[18] = 47, e1[19] = 48, e1[20] = 49, e1[21] = 50, e1[22] = 51, e1[23] = 52, e1[24] = 53, e1[25] = 54, e1[26] = 55, e1[27] = 56, e1[28] = 57, e1[29] = 58, e1[30] = 894, e1[31] = 60, e1[32] = 61, e1[33] = 62, e1[34] = 63, e1[35] = 64, e1[36] = 65, e1[37] = 66, e1[38] = 67, e1[39] = 68, e1[40] = 69, e1[41] = 70, e1[42] = 71, e1[43] = 72, e1[44] = 73, e1[45] = 74, e1[46] = 75, e1[47] = 76, e1[48] = 77, e1[49] = 78, e1[50] = 79, e1[51] = 80, e1[52] = 81, e1[53] = 82, e1[54] = 83, e1[55] = 84, e1[56] = 85, e1[57] = 86, e1[58] = 87, e1[59] = 88, e1[60] = 89, e1[61] = 90, e1[62] = 91, e1[63] = 92, e1[64] = 93, e1[65] = 94, e1[66] = 95, e1[67] = 96, e1[68] = 97, e1[69] = 98, e1[70] = 99, e1[71] = 100, e1[72] = 101, e1[73] = 102, e1[74] = 103, e1[75] = 104, e1[76] = 105, e1[77] = 106, e1[78] = 107, e1[79] = 108, e1[80] = 109, e1[81] = 110, e1[82] = 111, e1[83] = 112, e1[84] = 113, e1[85] = 114, e1[86] = 115, e1[87] = 116, e1[88] = 117, e1[89] = 118, e1[90] = 119, e1[91] = 120, e1[92] = 121, e1[93] = 122, e1[94] = 123, e1[95] = 124, e1[96] = 125, e1[97] = 126, e1[98] = 196, e1[99] = 197, e1[100] = 199, e1[101] = 201, e1[102] = 209, e1[103] = 214, e1[104] = 220, e1[105] = 225, e1[106] = 224, e1[107] = 226, e1[108] = 228, e1[109] = 227, e1[110] = 229, e1[111] = 231, e1[112] = 233, e1[113] = 232, e1[114] = 234, e1[115] = 235, e1[116] = 237, e1[117] = 236, e1[118] = 238, e1[119] = 239, e1[120] = 241, e1[121] = 243, e1[122] = 242, e1[123] = 244, e1[124] = 246, e1[125] = 245, e1[126] = 250, e1[127] = 249, e1[128] = 251, e1[129] = 252, e1[130] = 8224, e1[131] = 176, e1[132] = 162, e1[133] = 163, e1[134] = 167, e1[135] = 8226, e1[136] = 182, e1[137] = 223, e1[138] = 174, e1[139] = 169, e1[140] = 8482, e1[141] = 180, e1[142] = 168, e1[143] = 8800, e1[144] = 198, e1[145] = 216, e1[146] = 8734, e1[147] = 177, e1[148] = 8804, e1[149] = 8805, e1[150] = 165, e1[151] = 181, e1[152] = 8706, e1[153] = 8721, e1[154] = 8719, e1[156] = 8747, e1[157] = 170, e1[158] = 186, e1[159] = 8486, e1[160] = 230, e1[161] = 248, e1[162] = 191, e1[163] = 161, e1[164] = 172, e1[165] = 8730, e1[166] = 402, e1[167] = 8776, e1[168] = 8710, e1[169] = 171, e1[170] = 187, e1[171] = 8230, e1[179] = 8220, e1[180] = 8221, e1[181] = 8216, e1[182] = 8217, e1[200] = 193, e1[203] = 205, e1[207] = 211, e1[210] = 218, e1[223] = 711, e1[224] = 321, e1[225] = 322, e1[226] = 352, e1[227] = 353, e1[228] = 381, e1[229] = 382, e1[233] = 221, e1[234] = 253, e1[252] = 263, e1[253] = 268, e1[254] = 269, e1[258] = 258, e1[260] = 260, e1[261] = 261, e1[265] = 280, e1[266] = 281, e1[267] = 282, e1[268] = 283, e1[269] = 313, e1[275] = 323, e1[276] = 324, e1[278] = 328, e1[283] = 344, e1[284] = 345, e1[285] = 346, e1[286] = 347, e1[292] = 367, e1[295] = 377, e1[296] = 378, e1[298] = 380, e1[305] = 963, e1[306] = 964, e1[307] = 966, e1[308] = 8215, e1[309] = 8252, e1[310] = 8319, e1[311] = 8359, e1[312] = 8592, e1[313] = 8593, e1[337] = 9552, e1[493] = 1039, e1[494] = 1040, e1[570] = 1040, e1[571] = 1041, e1[572] = 1042, e1[573] = 1043, e1[574] = 1044, e1[575] = 1045, e1[576] = 1046, e1[577] = 1047, e1[578] = 1048, e1[579] = 1049, e1[580] = 1050, e1[581] = 1051, e1[582] = 1052, e1[583] = 1053, e1[584] = 1054, e1[585] = 1055, e1[586] = 1056, e1[587] = 1057, e1[588] = 1058, e1[589] = 1059, e1[590] = 1060, e1[591] = 1061, e1[592] = 1062, e1[593] = 1063, e1[594] = 1064, e1[595] = 1065, e1[596] = 1066, e1[597] = 1067, e1[598] = 1068, e1[599] = 1069, e1[600] = 1070, e1[672] = 1488, e1[673] = 1489, e1[674] = 1490, e1[675] = 1491, e1[676] = 1492, e1[677] = 1493, e1[678] = 1494, e1[679] = 1495, e1[680] = 1496, e1[681] = 1497, e1[682] = 1498, e1[683] = 1499, e1[684] = 1500, e1[685] = 1501, e1[686] = 1502, e1[687] = 1503, e1[688] = 1504, e1[689] = 1505, e1[690] = 1506, e1[691] = 1507, e1[692] = 1508, e1[693] = 1509, e1[694] = 1510, e1[695] = 1511, e1[696] = 1512, e1[697] = 1513, e1[698] = 1514, e1[705] = 1524, e1[706] = 8362, e1[710] = 64288, e1[711] = 64298, e1[759] = 1617, e1[761] = 1776, e1[763] = 1778, e1[775] = 1652, e1[777] = 1764, e1[778] = 1780, e1[779] = 1781, e1[780] = 1782, e1[782] = 771, e1[783] = 64726, e1[786] = 8363, e1[788] = 8532, e1[790] = 768, e1[791] = 769, e1[792] = 768, e1[795] = 803, e1[797] = 64336, e1[798] = 64337, e1[799] = 64342, e1[800] = 64343, e1[801] = 64344, e1[802] = 64345, e1[803] = 64362, e1[804] = 64363, e1[805] = 64364, e1[2424] = 7821, e1[2425] = 7822, e1[2426] = 7823, e1[2427] = 7824, e1[2428] = 7825, e1[2429] = 7826, e1[2430] = 7827, e1[2433] = 7682, e1[2678] = 8045, e1[2679] = 8046, e1[2830] = 1552, e1[2838] = 686, e1[2840] = 751, e1[2842] = 753, e1[2843] = 754, e1[2844] = 755, e1[2846] = 757, e1[2856] = 767, e1[2857] = 848, e1[2858] = 849, e1[2862] = 853, e1[2863] = 854, e1[2864] = 855, e1[2865] = 861, e1[2866] = 862, e1[2906] = 7460, e1[2908] = 7462, e1[2909] = 7463, e1[2910] = 7464, e1[2912] = 7466, e1[2913] = 7467, e1[2914] = 7468, e1[2916] = 7470, e1[2917] = 7471, e1[2918] = 7472, e1[2920] = 7474, e1[2921] = 7475, e1[2922] = 7476, e1[2924] = 7478, e1[2925] = 7479, e1[2926] = 7480, e1[2928] = 7482, e1[2929] = 7483, e1[2930] = 7484, e1[2932] = 7486, e1[2933] = 7487, e1[2934] = 7488, e1[2936] = 7490, e1[2937] = 7491, e1[2938] = 7492, e1[2940] = 7494, e1[2941] = 7495, e1[2942] = 7496, e1[2944] = 7498, e1[2946] = 7500, e1[2948] = 7502, e1[2950] = 7504, e1[2951] = 7505, e1[2952] = 7506, e1[2954] = 7508, e1[2955] = 7509, e1[2956] = 7510, e1[2958] = 7512, e1[2959] = 7513, e1[2960] = 7514, e1[2962] = 7516, e1[2963] = 7517, e1[2964] = 7518, e1[2966] = 7520, e1[2967] = 7521, e1[2968] = 7522, e1[2970] = 7524, e1[2971] = 7525, e1[2972] = 7526, e1[2974] = 7528, e1[2975] = 7529, e1[2976] = 7530, e1[2978] = 1537, e1[2979] = 1538, e1[2980] = 1539, e1[2982] = 1549, e1[2983] = 1551, e1[2984] = 1552, e1[2986] = 1554, e1[2987] = 1555, e1[2988] = 1556, e1[2990] = 1623, e1[2991] = 1624, e1[2995] = 1775, e1[2999] = 1791, e1[3002] = 64290, e1[3003] = 64291, e1[3004] = 64292, e1[3006] = 64294, e1[3007] = 64295, e1[3008] = 64296, e1[3011] = 1900, e1[3014] = 8223, e1[3015] = 8244, e1[3017] = 7532, e1[3018] = 7533, e1[3019] = 7534, e1[3075] = 7590, e1[3076] = 7591, e1[3079] = 7594, e1[3080] = 7595, e1[3083] = 7598, e1[3084] = 7599, e1[3087] = 7602, e1[3088] = 7603, e1[3091] = 7606, e1[3092] = 7607, e1[3095] = 7610, e1[3096] = 7611, e1[3099] = 7614, e1[3100] = 7615, e1[3103] = 7618, e1[3104] = 7619, e1[3107] = 8337, e1[3108] = 8338, e1[3116] = 1884, e1[3119] = 1885, e1[3120] = 1885, e1[3123] = 1886, e1[3124] = 1886, e1[3127] = 1887, e1[3128] = 1887, e1[3131] = 1888, e1[3132] = 1888, e1[3135] = 1889, e1[3136] = 1889, e1[3139] = 1890, e1[3140] = 1890, e1[3143] = 1891, e1[3144] = 1891, e1[3147] = 1892, e1[3148] = 1892, e1[3153] = 580, e1[3154] = 581, e1[3157] = 584, e1[3158] = 585, e1[3161] = 588, e1[3162] = 589, e1[3165] = 891, e1[3166] = 892, e1[3169] = 1274, e1[3170] = 1275, e1[3173] = 1278, e1[3174] = 1279, e1[3181] = 7622, e1[3182] = 7623, e1[3282] = 11799, e1[3316] = 578, e1[3379] = 42785, e1[3393] = 1159, e1[3416] = 8377;
}), zn = getLookupTableFactory(function(e1) {
    e1[227] = 322, e1[264] = 261, e1[291] = 346;
}), Wn = getLookupTableFactory(function(e1) {
    e1[1] = 32, e1[4] = 65, e1[5] = 192, e1[6] = 193, e1[9] = 196, e1[17] = 66, e1[18] = 67, e1[21] = 268, e1[24] = 68, e1[28] = 69, e1[29] = 200, e1[30] = 201, e1[32] = 282, e1[38] = 70, e1[39] = 71, e1[44] = 72, e1[47] = 73, e1[48] = 204, e1[49] = 205, e1[58] = 74, e1[60] = 75, e1[62] = 76, e1[68] = 77, e1[69] = 78, e1[75] = 79, e1[76] = 210, e1[80] = 214, e1[87] = 80, e1[89] = 81, e1[90] = 82, e1[92] = 344, e1[94] = 83, e1[97] = 352, e1[100] = 84, e1[104] = 85, e1[109] = 220, e1[115] = 86, e1[116] = 87, e1[121] = 88, e1[122] = 89, e1[124] = 221, e1[127] = 90, e1[129] = 381, e1[258] = 97, e1[259] = 224, e1[260] = 225, e1[263] = 228, e1[268] = 261, e1[271] = 98, e1[272] = 99, e1[273] = 263, e1[275] = 269, e1[282] = 100, e1[286] = 101, e1[287] = 232, e1[288] = 233, e1[290] = 283, e1[295] = 281, e1[296] = 102, e1[336] = 103, e1[346] = 104, e1[349] = 105, e1[350] = 236, e1[351] = 237, e1[361] = 106, e1[364] = 107, e1[367] = 108, e1[371] = 322, e1[373] = 109, e1[374] = 110, e1[381] = 111, e1[382] = 242, e1[383] = 243, e1[386] = 246, e1[393] = 112, e1[395] = 113, e1[396] = 114, e1[398] = 345, e1[400] = 115, e1[401] = 347, e1[403] = 353, e1[410] = 116, e1[437] = 117, e1[442] = 252, e1[448] = 118, e1[449] = 119, e1[454] = 120, e1[455] = 121, e1[457] = 253, e1[460] = 122, e1[462] = 382, e1[463] = 380, e1[853] = 44, e1[855] = 58, e1[856] = 46, e1[876] = 47, e1[878] = 45, e1[882] = 45, e1[894] = 40, e1[895] = 41, e1[896] = 91, e1[897] = 93, e1[923] = 64, e1[940] = 163, e1[1004] = 48, e1[1005] = 49, e1[1006] = 50, e1[1007] = 51, e1[1008] = 52, e1[1009] = 53, e1[1010] = 54, e1[1011] = 55, e1[1012] = 56, e1[1013] = 57, e1[1081] = 37, e1[1085] = 43, e1[1086] = 45;
});
function getStandardFontName(e1) {
    const t = normalizeFontName(e1);
    return Un()[t];
}
function isKnownFontName(e1) {
    const t = normalizeFontName(e1);
    return !!(Un()[t] || $n()[t] || Hn()[t] || Xn()[t]);
}
class ToUnicodeMap {
    constructor(e1 = []){
        this._map = e1;
    }
    get length() {
        return this._map.length;
    }
    forEach(e1) {
        for(const t in this._map)e1(t, this._map[t].codePointAt(0));
    }
    has(e1) {
        return void 0 !== this._map[e1];
    }
    get(e1) {
        return this._map[e1];
    }
    charCodeOf(e1) {
        const t = this._map;
        if (t.length <= 65536) return t.indexOf(e1);
        for(const i in t)if (t[i] === e1) return 0 | i;
        return -1;
    }
    amend(e1) {
        for(const t in e1)this._map[t] = e1[t];
    }
}
class IdentityToUnicodeMap {
    constructor(e1, t){
        this.firstChar = e1, this.lastChar = t;
    }
    get length() {
        return this.lastChar + 1 - this.firstChar;
    }
    forEach(e1) {
        for(let t = this.firstChar, i = this.lastChar; t <= i; t++)e1(t, t);
    }
    has(e1) {
        return this.firstChar <= e1 && e1 <= this.lastChar;
    }
    get(e1) {
        if (this.firstChar <= e1 && e1 <= this.lastChar) return String.fromCharCode(e1);
    }
    charCodeOf(e1) {
        return Number.isInteger(e1) && e1 >= this.firstChar && e1 <= this.lastChar ? e1 : -1;
    }
    amend(e1) {
        unreachable$1("Should not call amend()");
    }
}
class CFFFont {
    constructor(e1, t){
        this.properties = t;
        const i = new CFFParser(e1, t, Sn);
        this.cff = i.parse(), this.cff.duplicateFirstGlyph();
        const n = new CFFCompiler(this.cff);
        this.seacs = this.cff.seacs;
        try {
            this.data = n.compile();
        } catch  {
            warn$1("Failed to compile font " + t.loadedName), this.data = e1;
        }
        this._createBuiltInEncoding();
    }
    get numGlyphs() {
        return this.cff.charStrings.count;
    }
    getCharset() {
        return this.cff.charset.charset;
    }
    getGlyphMapping() {
        const e1 = this.cff, t = this.properties, { cidToGidMap: i, cMap: n } = t, a = e1.charset.charset;
        let s, r;
        if (t.composite) {
            let t, o;
            if (i?.length > 0) {
                t = Object.create(null);
                for(let e1 = 0, n = i.length; e1 < n; e1++){
                    const n = i[e1];
                    void 0 !== n && (t[n] = e1);
                }
            }
            if (s = Object.create(null), e1.isCIDFont) for(r = 0; r < a.length; r++){
                const e1 = a[r];
                o = n.charCodeOf(e1), void 0 !== t?.[o] && (o = t[o]), s[o] = r;
            }
            else for(r = 0; r < e1.charStrings.count; r++)o = n.charCodeOf(r), s[o] = r;
            return s;
        }
        let o = e1.encoding ? e1.encoding.encoding : null;
        return t.isInternalFont && (o = t.defaultEncoding), s = type1FontGlyphMapping(t, o, a), s;
    }
    hasGlyphId(e1) {
        return this.cff.hasGlyphId(e1);
    }
    _createBuiltInEncoding() {
        const { charset: e1, encoding: t } = this.cff;
        if (!e1 || !t) return;
        const i = e1.charset, n = t.encoding, a = [];
        for(const e1 in n){
            const t = n[e1];
            if (t >= 0) {
                const n = i[t];
                n && (a[e1] = n);
            }
        }
        a.length > 0 && (this.properties.builtInEncoding = a);
    }
}
function getFloat214(e1, t) {
    return readInt16(e1, t) / 16384;
}
function getSubroutineBias(e1) {
    const t = e1.length;
    let i = 32768;
    return t < 1240 ? i = 107 : t < 33900 && (i = 1131), i;
}
function parseCmap(e1, t, i) {
    const n = 1 === readUint16(e1, t + 2) ? readUint32(e1, t + 8) : readUint32(e1, t + 16), a = readUint16(e1, t + n);
    let s, r, o;
    if (4 === a) {
        readUint16(e1, t + n + 2);
        const i = readUint16(e1, t + n + 6) >> 1;
        for(r = t + n + 14, s = [], o = 0; o < i; o++, r += 2)s[o] = {
            end: readUint16(e1, r)
        };
        for(r += 2, o = 0; o < i; o++, r += 2)s[o].start = readUint16(e1, r);
        for(o = 0; o < i; o++, r += 2)s[o].idDelta = readUint16(e1, r);
        for(o = 0; o < i; o++, r += 2){
            let t = readUint16(e1, r);
            if (0 !== t) {
                s[o].ids = [];
                for(let i = 0, n = s[o].end - s[o].start + 1; i < n; i++)s[o].ids[i] = readUint16(e1, r + t), t += 2;
            }
        }
        return s;
    }
    if (12 === a) {
        const i = readUint32(e1, t + n + 12);
        for(r = t + n + 16, s = [], o = 0; o < i; o++)t = readUint32(e1, r), s.push({
            start: t,
            end: readUint32(e1, r + 4),
            idDelta: readUint32(e1, r + 8) - t
        }), r += 12;
        return s;
    }
    throw new ti(`unsupported cmap: ${a}`);
}
function parseCff(e1, t, i, n) {
    const a = new CFFParser(new Stream(e1, t, i - t), {}, n).parse();
    return {
        glyphs: a.charStrings.objects,
        subrs: a.topDict.privateDict?.subrsIndex?.objects,
        gsubrs: a.globalSubrIndex?.objects,
        isCFFCIDFont: a.isCIDFont,
        fdSelect: a.fdSelect,
        fdArray: a.fdArray
    };
}
function lookupCmap(e1, t) {
    const i = t.codePointAt(0);
    let n = 0, a = 0, s = e1.length - 1;
    for(; a < s;){
        const t = a + s + 1 >> 1;
        i < e1[t].start ? s = t - 1 : a = t;
    }
    return e1[a].start <= i && i <= e1[a].end && (n = e1[a].idDelta + (e1[a].ids ? e1[a].ids[i - e1[a].start] : i) & 65535), {
        charCode: i,
        glyphId: n
    };
}
function compileGlyf(e1, t, i) {
    function moveTo(e1, i) {
        r && t.add("L", r), r = [
            e1,
            i
        ], t.add("M", [
            e1,
            i
        ]);
    }
    function lineTo(e1, i) {
        t.add("L", [
            e1,
            i
        ]);
    }
    function quadraticCurveTo(e1, i, n, a) {
        t.add("Q", [
            e1,
            i,
            n,
            a
        ]);
    }
    let n = 0;
    const a = readInt16(e1, n);
    let s, r = null, o = 0, l = 0;
    if (n += 10, a < 0) do {
        s = readUint16(e1, n);
        const a = readUint16(e1, n + 2);
        let r, c;
        n += 4, 1 & s ? (2 & s ? (r = readInt16(e1, n), c = readInt16(e1, n + 2)) : (r = readUint16(e1, n), c = readUint16(e1, n + 2)), n += 4) : 2 & s ? (r = readInt8(e1, n++), c = readInt8(e1, n++)) : (r = e1[n++], c = e1[n++]), 2 & s ? (o = r, l = c) : (o = 0, l = 0);
        let h = 1, d = 1, u = 0, g = 0;
        8 & s ? (h = d = getFloat214(e1, n), n += 2) : 64 & s ? (h = getFloat214(e1, n), d = getFloat214(e1, n + 2), n += 4) : 128 & s && (h = getFloat214(e1, n), u = getFloat214(e1, n + 2), g = getFloat214(e1, n + 4), d = getFloat214(e1, n + 6), n += 8);
        const f = i.glyphs[a];
        f && (t.save(), t.transform([
            h,
            u,
            g,
            d,
            o,
            l
        ]), compileGlyf(f, t, i), t.restore());
    }while (32 & s)
    else {
        const t = [];
        let i, r;
        for(i = 0; i < a; i++)t.push(readUint16(e1, n)), n += 2;
        n += 2 + readUint16(e1, n);
        const c = t.at(-1) + 1, h = [];
        for(; h.length < c;){
            s = e1[n++];
            let t = 1;
            for(8 & s && (t += e1[n++]); t-- > 0;)h.push({
                flags: s
            });
        }
        for(i = 0; i < c; i++){
            switch(18 & h[i].flags){
                case 0:
                    o += readInt16(e1, n), n += 2;
                    break;
                case 2:
                    o -= e1[n++];
                    break;
                case 18:
                    o += e1[n++];
            }
            h[i].x = o;
        }
        for(i = 0; i < c; i++){
            switch(36 & h[i].flags){
                case 0:
                    l += readInt16(e1, n), n += 2;
                    break;
                case 4:
                    l -= e1[n++];
                    break;
                case 36:
                    l += e1[n++];
            }
            h[i].y = l;
        }
        let d = 0;
        for(n = 0; n < a; n++){
            const e1 = t[n], a = h.slice(d, e1 + 1);
            if (1 & a[0].flags) a.push(a[0]);
            else if (1 & a.at(-1).flags) a.unshift(a.at(-1));
            else {
                const e1 = {
                    flags: 1,
                    x: (a[0].x + a.at(-1).x) / 2,
                    y: (a[0].y + a.at(-1).y) / 2
                };
                a.unshift(e1), a.push(e1);
            }
            for(moveTo(a[0].x, a[0].y), i = 1, r = a.length; i < r; i++)1 & a[i].flags ? lineTo(a[i].x, a[i].y) : 1 & a[i + 1].flags ? (quadraticCurveTo(a[i].x, a[i].y, a[i + 1].x, a[i + 1].y), i++) : quadraticCurveTo(a[i].x, a[i].y, (a[i].x + a[i + 1].x) / 2, (a[i].y + a[i + 1].y) / 2);
            d = e1 + 1;
        }
    }
}
function compileCharString(e1, t, i, n) {
    function moveTo(e1, i) {
        l && t.add("L", l), l = [
            e1,
            i
        ], t.add("M", [
            e1,
            i
        ]);
    }
    function lineTo(e1, i) {
        t.add("L", [
            e1,
            i
        ]);
    }
    function bezierCurveTo(e1, i, n, a, s, r) {
        t.add("C", [
            e1,
            i,
            n,
            a,
            s,
            r
        ]);
    }
    const a = [];
    let s = 0, r = 0, o = 0, l = null;
    !function parse(e1) {
        let l = 0;
        for(; l < e1.length;){
            let c, h, d, u, g, f, p, m, b, y = !1, w = e1[l++];
            switch(w){
                case 1:
                case 3:
                case 18:
                case 23:
                    o += a.length >> 1, y = !0;
                    break;
                case 4:
                    r += a.pop(), moveTo(s, r), y = !0;
                    break;
                case 5:
                    for(; a.length > 0;)s += a.shift(), r += a.shift(), lineTo(s, r);
                    break;
                case 6:
                    for(; a.length > 0 && (s += a.shift(), lineTo(s, r), 0 !== a.length);)r += a.shift(), lineTo(s, r);
                    break;
                case 7:
                    for(; a.length > 0 && (r += a.shift(), lineTo(s, r), 0 !== a.length);)s += a.shift(), lineTo(s, r);
                    break;
                case 8:
                    for(; a.length > 0;)c = s + a.shift(), d = r + a.shift(), h = c + a.shift(), u = d + a.shift(), s = h + a.shift(), r = u + a.shift(), bezierCurveTo(c, d, h, u, s, r);
                    break;
                case 10:
                    if (m = a.pop(), b = null, i.isCFFCIDFont) {
                        const e1 = i.fdSelect.getFDIndex(n);
                        if (e1 >= 0 && e1 < i.fdArray.length) {
                            const t = i.fdArray[e1];
                            let n;
                            t.privateDict?.subrsIndex && (n = t.privateDict.subrsIndex.objects), n && (m += getSubroutineBias(n), b = n[m]);
                        } else warn$1("Invalid fd index for glyph index.");
                    } else b = i.subrs[m + i.subrsBias];
                    b && parse(b);
                    break;
                case 11:
                    return;
                case 12:
                    switch(w = e1[l++], w){
                        case 34:
                            c = s + a.shift(), h = c + a.shift(), g = r + a.shift(), s = h + a.shift(), bezierCurveTo(c, r, h, g, s, g), c = s + a.shift(), h = c + a.shift(), s = h + a.shift(), bezierCurveTo(c, g, h, r, s, r);
                            break;
                        case 35:
                            c = s + a.shift(), d = r + a.shift(), h = c + a.shift(), u = d + a.shift(), s = h + a.shift(), r = u + a.shift(), bezierCurveTo(c, d, h, u, s, r), c = s + a.shift(), d = r + a.shift(), h = c + a.shift(), u = d + a.shift(), s = h + a.shift(), r = u + a.shift(), bezierCurveTo(c, d, h, u, s, r), a.pop();
                            break;
                        case 36:
                            c = s + a.shift(), g = r + a.shift(), h = c + a.shift(), f = g + a.shift(), s = h + a.shift(), bezierCurveTo(c, g, h, f, s, f), c = s + a.shift(), h = c + a.shift(), p = f + a.shift(), s = h + a.shift(), bezierCurveTo(c, f, h, p, s, r);
                            break;
                        case 37:
                            const e2 = s, t1 = r;
                            c = s + a.shift(), d = r + a.shift(), h = c + a.shift(), u = d + a.shift(), s = h + a.shift(), r = u + a.shift(), bezierCurveTo(c, d, h, u, s, r), c = s + a.shift(), d = r + a.shift(), h = c + a.shift(), u = d + a.shift(), s = h, r = u, Math.abs(s - e2) > Math.abs(r - t1) ? s += a.shift() : r += a.shift(), bezierCurveTo(c, d, h, u, s, r);
                            break;
                        default:
                            throw new ti(`unknown operator: 12 ${w}`);
                    }
                    break;
                case 14:
                    if (a.length >= 4) {
                        const e1 = a.pop(), n = a.pop();
                        r = a.pop(), s = a.pop(), t.save(), t.translate(s, r);
                        let o = lookupCmap(i.cmap, String.fromCharCode(i.glyphNameMap[un[e1]]));
                        compileCharString(i.glyphs[o.glyphId], t, i, o.glyphId), t.restore(), o = lookupCmap(i.cmap, String.fromCharCode(i.glyphNameMap[un[n]])), compileCharString(i.glyphs[o.glyphId], t, i, o.glyphId);
                    }
                    return;
                case 19:
                case 20:
                    o += a.length >> 1, l += o + 7 >> 3, y = !0;
                    break;
                case 21:
                    r += a.pop(), s += a.pop(), moveTo(s, r), y = !0;
                    break;
                case 22:
                    s += a.pop(), moveTo(s, r), y = !0;
                    break;
                case 24:
                    for(; a.length > 2;)c = s + a.shift(), d = r + a.shift(), h = c + a.shift(), u = d + a.shift(), s = h + a.shift(), r = u + a.shift(), bezierCurveTo(c, d, h, u, s, r);
                    s += a.shift(), r += a.shift(), lineTo(s, r);
                    break;
                case 25:
                    for(; a.length > 6;)s += a.shift(), r += a.shift(), lineTo(s, r);
                    c = s + a.shift(), d = r + a.shift(), h = c + a.shift(), u = d + a.shift(), s = h + a.shift(), r = u + a.shift(), bezierCurveTo(c, d, h, u, s, r);
                    break;
                case 26:
                    for(a.length % 2 && (s += a.shift()); a.length > 0;)c = s, d = r + a.shift(), h = c + a.shift(), u = d + a.shift(), s = h, r = u + a.shift(), bezierCurveTo(c, d, h, u, s, r);
                    break;
                case 27:
                    for(a.length % 2 && (r += a.shift()); a.length > 0;)c = s + a.shift(), d = r, h = c + a.shift(), u = d + a.shift(), s = h + a.shift(), r = u, bezierCurveTo(c, d, h, u, s, r);
                    break;
                case 28:
                    a.push(readInt16(e1, l)), l += 2;
                    break;
                case 29:
                    m = a.pop() + i.gsubrsBias, b = i.gsubrs[m], b && parse(b);
                    break;
                case 30:
                    for(; a.length > 0 && (c = s, d = r + a.shift(), h = c + a.shift(), u = d + a.shift(), s = h + a.shift(), r = u + (1 === a.length ? a.shift() : 0), bezierCurveTo(c, d, h, u, s, r), 0 !== a.length);)c = s + a.shift(), d = r, h = c + a.shift(), u = d + a.shift(), r = u + a.shift(), s = h + (1 === a.length ? a.shift() : 0), bezierCurveTo(c, d, h, u, s, r);
                    break;
                case 31:
                    for(; a.length > 0 && (c = s + a.shift(), d = r, h = c + a.shift(), u = d + a.shift(), r = u + a.shift(), s = h + (1 === a.length ? a.shift() : 0), bezierCurveTo(c, d, h, u, s, r), 0 !== a.length);)c = s, d = r + a.shift(), h = c + a.shift(), u = d + a.shift(), s = h + a.shift(), r = u + (1 === a.length ? a.shift() : 0), bezierCurveTo(c, d, h, u, s, r);
                    break;
                default:
                    if (w < 32) throw new ti(`unknown operator: ${w}`);
                    w < 247 ? a.push(w - 139) : w < 251 ? a.push(256 * (w - 247) + e1[l++] + 108) : w < 255 ? a.push(256 * -(w - 251) - e1[l++] - 108) : (a.push((e1[l] << 24 | e1[l + 1] << 16 | e1[l + 2] << 8 | e1[l + 3]) / 65536), l += 4);
            }
            y && (a.length = 0);
        }
    }(e1);
}
class Commands {
    cmds = [];
    transformStack = [];
    currentTransform = [
        1,
        0,
        0,
        1,
        0,
        0
    ];
    add(e1, t) {
        if (t) {
            const { currentTransform: i } = this;
            for(let e1 = 0, n = t.length; e1 < n; e1 += 2)ai.applyTransform(t, i, e1);
            this.cmds.push(`${e1}${t.join(" ")}`);
        } else this.cmds.push(e1);
    }
    transform(e1) {
        this.currentTransform = ai.transform(this.currentTransform, e1);
    }
    translate(e1, t) {
        this.transform([
            1,
            0,
            0,
            1,
            e1,
            t
        ]);
    }
    save() {
        this.transformStack.push(this.currentTransform.slice());
    }
    restore() {
        this.currentTransform = this.transformStack.pop() || [
            1,
            0,
            0,
            1,
            0,
            0
        ];
    }
    getSVG() {
        return this.cmds.join("");
    }
}
class CompiledFont {
    constructor(e1){
        this.fontMatrix = e1, this.compiledGlyphs = Object.create(null), this.compiledCharCodeToGlyphId = Object.create(null);
    }
    getPathJs(e1) {
        const { charCode: t, glyphId: i } = lookupCmap(this.cmap, e1);
        let n, a = this.compiledGlyphs[i];
        if (void 0 === a) {
            try {
                a = this.compileGlyph(this.glyphs[i], i);
            } catch (e1) {
                a = "", n = e1;
            }
            this.compiledGlyphs[i] = a;
        }
        if (this.compiledCharCodeToGlyphId[t] ??= i, n) throw n;
        return a;
    }
    compileGlyph(e1, i) {
        if (!e1?.length || 14 === e1[0]) return "";
        let n = this.fontMatrix;
        if (this.isCFFCIDFont) {
            const e1 = this.fdSelect.getFDIndex(i);
            if (e1 >= 0 && e1 < this.fdArray.length) {
                n = this.fdArray[e1].getByName("FontMatrix") || t;
            } else warn$1("Invalid fd index for glyph index.");
        }
        assert$1(isNumberArray(n, 6), "Expected a valid fontMatrix.");
        const a = new Commands;
        return a.transform(n.slice()), this.compileGlyphImpl(e1, a, i), a.add("Z"), a.getSVG();
    }
    compileGlyphImpl() {
        unreachable$1("Children classes should implement this.");
    }
    hasBuiltPath(e1) {
        const { charCode: t, glyphId: i } = lookupCmap(this.cmap, e1);
        return void 0 !== this.compiledGlyphs[i] && void 0 !== this.compiledCharCodeToGlyphId[t];
    }
}
class TrueTypeCompiled extends CompiledFont {
    constructor(e1, t, i){
        super(i || [
            488e-6,
            0,
            0,
            488e-6,
            0,
            0
        ]), this.glyphs = e1, this.cmap = t;
    }
    compileGlyphImpl(e1, t) {
        compileGlyf(e1, t, this);
    }
}
class Type2Compiled extends CompiledFont {
    constructor(e1, t, i){
        super(i || [
            .001,
            0,
            0,
            .001,
            0,
            0
        ]), this.glyphs = e1.glyphs, this.gsubrs = e1.gsubrs || [], this.subrs = e1.subrs || [], this.cmap = t, this.glyphNameMap = mn(), this.gsubrsBias = getSubroutineBias(this.gsubrs), this.subrsBias = getSubroutineBias(this.subrs), this.isCFFCIDFont = e1.isCFFCIDFont, this.fdSelect = e1.fdSelect, this.fdArray = e1.fdArray;
    }
    compileGlyphImpl(e1, t, i) {
        compileCharString(e1, t, this, i);
    }
}
class FontRendererFactory {
    static create(e1, t) {
        const i = new Uint8Array(e1.data);
        let n, a, s, r, o, l;
        const c = readUint16(i, 4);
        for(let e1 = 0, h = 12; e1 < c; e1++, h += 16){
            const e1 = bytesToString$1(i.subarray(h, h + 4)), c = readUint32(i, h + 8), d = readUint32(i, h + 12);
            switch(e1){
                case "cmap":
                    n = parseCmap(i, c);
                    break;
                case "glyf":
                    a = i.subarray(c, c + d);
                    break;
                case "loca":
                    s = i.subarray(c, c + d);
                    break;
                case "head":
                    l = readUint16(i, c + 18), o = readUint16(i, c + 50);
                    break;
                case "CFF ":
                    r = parseCff(i, c, c + d, t);
            }
        }
        if (a) {
            const t = l ? [
                1 / l,
                0,
                0,
                1 / l,
                0,
                0
            ] : e1.fontMatrix;
            return new TrueTypeCompiled(function(e1, t, i) {
                let n, a;
                i ? (n = 4, a = readUint32) : (n = 2, a = (e1, t)=>2 * readUint16(e1, t));
                const s = [];
                let r = a(t, 0);
                for(let i = n; i < t.length; i += n){
                    const n = a(t, i);
                    s.push(e1.subarray(r, n)), r = n;
                }
                return s;
            }(a, s, o), n, t);
        }
        return new Type2Compiled(r, n, e1.fontMatrix);
    }
}
const Gn = getLookupTableFactory(function(e1) {
    e1.Courier = 600, e1["Courier-Bold"] = 600, e1["Courier-BoldOblique"] = 600, e1["Courier-Oblique"] = 600, e1.Helvetica = getLookupTableFactory(function(e1) {
        e1.space = 278, e1.exclam = 278, e1.quotedbl = 355, e1.numbersign = 556, e1.dollar = 556, e1.percent = 889, e1.ampersand = 667, e1.quoteright = 222, e1.parenleft = 333, e1.parenright = 333, e1.asterisk = 389, e1.plus = 584, e1.comma = 278, e1.hyphen = 333, e1.period = 278, e1.slash = 278, e1.zero = 556, e1.one = 556, e1.two = 556, e1.three = 556, e1.four = 556, e1.five = 556, e1.six = 556, e1.seven = 556, e1.eight = 556, e1.nine = 556, e1.colon = 278, e1.semicolon = 278, e1.less = 584, e1.equal = 584, e1.greater = 584, e1.question = 556, e1.at = 1015, e1.A = 667, e1.B = 667, e1.C = 722, e1.D = 722, e1.E = 667, e1.F = 611, e1.G = 778, e1.H = 722, e1.I = 278, e1.J = 500, e1.K = 667, e1.L = 556, e1.M = 833, e1.N = 722, e1.O = 778, e1.P = 667, e1.Q = 778, e1.R = 722, e1.S = 667, e1.T = 611, e1.U = 722, e1.V = 667, e1.W = 944, e1.X = 667, e1.Y = 667, e1.Z = 611, e1.bracketleft = 278, e1.backslash = 278, e1.bracketright = 278, e1.asciicircum = 469, e1.underscore = 556, e1.quoteleft = 222, e1.a = 556, e1.b = 556, e1.c = 500, e1.d = 556, e1.e = 556, e1.f = 278, e1.g = 556, e1.h = 556, e1.i = 222, e1.j = 222, e1.k = 500, e1.l = 222, e1.m = 833, e1.n = 556, e1.o = 556, e1.p = 556, e1.q = 556, e1.r = 333, e1.s = 500, e1.t = 278, e1.u = 556, e1.v = 500, e1.w = 722, e1.x = 500, e1.y = 500, e1.z = 500, e1.braceleft = 334, e1.bar = 260, e1.braceright = 334, e1.asciitilde = 584, e1.exclamdown = 333, e1.cent = 556, e1.sterling = 556, e1.fraction = 167, e1.yen = 556, e1.florin = 556, e1.section = 556, e1.currency = 556, e1.quotesingle = 191, e1.quotedblleft = 333, e1.guillemotleft = 556, e1.guilsinglleft = 333, e1.guilsinglright = 333, e1.fi = 500, e1.fl = 500, e1.endash = 556, e1.dagger = 556, e1.daggerdbl = 556, e1.periodcentered = 278, e1.paragraph = 537, e1.bullet = 350, e1.quotesinglbase = 222, e1.quotedblbase = 333, e1.quotedblright = 333, e1.guillemotright = 556, e1.ellipsis = 1e3, e1.perthousand = 1e3, e1.questiondown = 611, e1.grave = 333, e1.acute = 333, e1.circumflex = 333, e1.tilde = 333, e1.macron = 333, e1.breve = 333, e1.dotaccent = 333, e1.dieresis = 333, e1.ring = 333, e1.cedilla = 333, e1.hungarumlaut = 333, e1.ogonek = 333, e1.caron = 333, e1.emdash = 1e3, e1.AE = 1e3, e1.ordfeminine = 370, e1.Lslash = 556, e1.Oslash = 778, e1.OE = 1e3, e1.ordmasculine = 365, e1.ae = 889, e1.dotlessi = 278, e1.lslash = 222, e1.oslash = 611, e1.oe = 944, e1.germandbls = 611, e1.Idieresis = 278, e1.eacute = 556, e1.abreve = 556, e1.uhungarumlaut = 556, e1.ecaron = 556, e1.Ydieresis = 667, e1.divide = 584, e1.Yacute = 667, e1.Acircumflex = 667, e1.aacute = 556, e1.Ucircumflex = 722, e1.yacute = 500, e1.scommaaccent = 500, e1.ecircumflex = 556, e1.Uring = 722, e1.Udieresis = 722, e1.aogonek = 556, e1.Uacute = 722, e1.uogonek = 556, e1.Edieresis = 667, e1.Dcroat = 722, e1.commaaccent = 250, e1.copyright = 737, e1.Emacron = 667, e1.ccaron = 500, e1.aring = 556, e1.Ncommaaccent = 722, e1.lacute = 222, e1.agrave = 556, e1.Tcommaaccent = 611, e1.Cacute = 722, e1.atilde = 556, e1.Edotaccent = 667, e1.scaron = 500, e1.scedilla = 500, e1.iacute = 278, e1.lozenge = 471, e1.Rcaron = 722, e1.Gcommaaccent = 778, e1.ucircumflex = 556, e1.acircumflex = 556, e1.Amacron = 667, e1.rcaron = 333, e1.ccedilla = 500, e1.Zdotaccent = 611, e1.Thorn = 667, e1.Omacron = 778, e1.Racute = 722, e1.Sacute = 667, e1.dcaron = 643, e1.Umacron = 722, e1.uring = 556, e1.threesuperior = 333, e1.Ograve = 778, e1.Agrave = 667, e1.Abreve = 667, e1.multiply = 584, e1.uacute = 556, e1.Tcaron = 611, e1.partialdiff = 476, e1.ydieresis = 500, e1.Nacute = 722, e1.icircumflex = 278, e1.Ecircumflex = 667, e1.adieresis = 556, e1.edieresis = 556, e1.cacute = 500, e1.nacute = 556, e1.umacron = 556, e1.Ncaron = 722, e1.Iacute = 278, e1.plusminus = 584, e1.brokenbar = 260, e1.registered = 737, e1.Gbreve = 778, e1.Idotaccent = 278, e1.summation = 600, e1.Egrave = 667, e1.racute = 333, e1.omacron = 556, e1.Zacute = 611, e1.Zcaron = 611, e1.greaterequal = 549, e1.Eth = 722, e1.Ccedilla = 722, e1.lcommaaccent = 222, e1.tcaron = 317, e1.eogonek = 556, e1.Uogonek = 722, e1.Aacute = 667, e1.Adieresis = 667, e1.egrave = 556, e1.zacute = 500, e1.iogonek = 222, e1.Oacute = 778, e1.oacute = 556, e1.amacron = 556, e1.sacute = 500, e1.idieresis = 278, e1.Ocircumflex = 778, e1.Ugrave = 722, e1.Delta = 612, e1.thorn = 556, e1.twosuperior = 333, e1.Odieresis = 778, e1.mu = 556, e1.igrave = 278, e1.ohungarumlaut = 556, e1.Eogonek = 667, e1.dcroat = 556, e1.threequarters = 834, e1.Scedilla = 667, e1.lcaron = 299, e1.Kcommaaccent = 667, e1.Lacute = 556, e1.trademark = 1e3, e1.edotaccent = 556, e1.Igrave = 278, e1.Imacron = 278, e1.Lcaron = 556, e1.onehalf = 834, e1.lessequal = 549, e1.ocircumflex = 556, e1.ntilde = 556, e1.Uhungarumlaut = 722, e1.Eacute = 667, e1.emacron = 556, e1.gbreve = 556, e1.onequarter = 834, e1.Scaron = 667, e1.Scommaaccent = 667, e1.Ohungarumlaut = 778, e1.degree = 400, e1.ograve = 556, e1.Ccaron = 722, e1.ugrave = 556, e1.radical = 453, e1.Dcaron = 722, e1.rcommaaccent = 333, e1.Ntilde = 722, e1.otilde = 556, e1.Rcommaaccent = 722, e1.Lcommaaccent = 556, e1.Atilde = 667, e1.Aogonek = 667, e1.Aring = 667, e1.Otilde = 778, e1.zdotaccent = 500, e1.Ecaron = 667, e1.Iogonek = 278, e1.kcommaaccent = 500, e1.minus = 584, e1.Icircumflex = 278, e1.ncaron = 556, e1.tcommaaccent = 278, e1.logicalnot = 584, e1.odieresis = 556, e1.udieresis = 556, e1.notequal = 549, e1.gcommaaccent = 556, e1.eth = 556, e1.zcaron = 500, e1.ncommaaccent = 556, e1.onesuperior = 333, e1.imacron = 278, e1.Euro = 556;
    }), e1["Helvetica-Bold"] = getLookupTableFactory(function(e1) {
        e1.space = 278, e1.exclam = 333, e1.quotedbl = 474, e1.numbersign = 556, e1.dollar = 556, e1.percent = 889, e1.ampersand = 722, e1.quoteright = 278, e1.parenleft = 333, e1.parenright = 333, e1.asterisk = 389, e1.plus = 584, e1.comma = 278, e1.hyphen = 333, e1.period = 278, e1.slash = 278, e1.zero = 556, e1.one = 556, e1.two = 556, e1.three = 556, e1.four = 556, e1.five = 556, e1.six = 556, e1.seven = 556, e1.eight = 556, e1.nine = 556, e1.colon = 333, e1.semicolon = 333, e1.less = 584, e1.equal = 584, e1.greater = 584, e1.question = 611, e1.at = 975, e1.A = 722, e1.B = 722, e1.C = 722, e1.D = 722, e1.E = 667, e1.F = 611, e1.G = 778, e1.H = 722, e1.I = 278, e1.J = 556, e1.K = 722, e1.L = 611, e1.M = 833, e1.N = 722, e1.O = 778, e1.P = 667, e1.Q = 778, e1.R = 722, e1.S = 667, e1.T = 611, e1.U = 722, e1.V = 667, e1.W = 944, e1.X = 667, e1.Y = 667, e1.Z = 611, e1.bracketleft = 333, e1.backslash = 278, e1.bracketright = 333, e1.asciicircum = 584, e1.underscore = 556, e1.quoteleft = 278, e1.a = 556, e1.b = 611, e1.c = 556, e1.d = 611, e1.e = 556, e1.f = 333, e1.g = 611, e1.h = 611, e1.i = 278, e1.j = 278, e1.k = 556, e1.l = 278, e1.m = 889, e1.n = 611, e1.o = 611, e1.p = 611, e1.q = 611, e1.r = 389, e1.s = 556, e1.t = 333, e1.u = 611, e1.v = 556, e1.w = 778, e1.x = 556, e1.y = 556, e1.z = 500, e1.braceleft = 389, e1.bar = 280, e1.braceright = 389, e1.asciitilde = 584, e1.exclamdown = 333, e1.cent = 556, e1.sterling = 556, e1.fraction = 167, e1.yen = 556, e1.florin = 556, e1.section = 556, e1.currency = 556, e1.quotesingle = 238, e1.quotedblleft = 500, e1.guillemotleft = 556, e1.guilsinglleft = 333, e1.guilsinglright = 333, e1.fi = 611, e1.fl = 611, e1.endash = 556, e1.dagger = 556, e1.daggerdbl = 556, e1.periodcentered = 278, e1.paragraph = 556, e1.bullet = 350, e1.quotesinglbase = 278, e1.quotedblbase = 500, e1.quotedblright = 500, e1.guillemotright = 556, e1.ellipsis = 1e3, e1.perthousand = 1e3, e1.questiondown = 611, e1.grave = 333, e1.acute = 333, e1.circumflex = 333, e1.tilde = 333, e1.macron = 333, e1.breve = 333, e1.dotaccent = 333, e1.dieresis = 333, e1.ring = 333, e1.cedilla = 333, e1.hungarumlaut = 333, e1.ogonek = 333, e1.caron = 333, e1.emdash = 1e3, e1.AE = 1e3, e1.ordfeminine = 370, e1.Lslash = 611, e1.Oslash = 778, e1.OE = 1e3, e1.ordmasculine = 365, e1.ae = 889, e1.dotlessi = 278, e1.lslash = 278, e1.oslash = 611, e1.oe = 944, e1.germandbls = 611, e1.Idieresis = 278, e1.eacute = 556, e1.abreve = 556, e1.uhungarumlaut = 611, e1.ecaron = 556, e1.Ydieresis = 667, e1.divide = 584, e1.Yacute = 667, e1.Acircumflex = 722, e1.aacute = 556, e1.Ucircumflex = 722, e1.yacute = 556, e1.scommaaccent = 556, e1.ecircumflex = 556, e1.Uring = 722, e1.Udieresis = 722, e1.aogonek = 556, e1.Uacute = 722, e1.uogonek = 611, e1.Edieresis = 667, e1.Dcroat = 722, e1.commaaccent = 250, e1.copyright = 737, e1.Emacron = 667, e1.ccaron = 556, e1.aring = 556, e1.Ncommaaccent = 722, e1.lacute = 278, e1.agrave = 556, e1.Tcommaaccent = 611, e1.Cacute = 722, e1.atilde = 556, e1.Edotaccent = 667, e1.scaron = 556, e1.scedilla = 556, e1.iacute = 278, e1.lozenge = 494, e1.Rcaron = 722, e1.Gcommaaccent = 778, e1.ucircumflex = 611, e1.acircumflex = 556, e1.Amacron = 722, e1.rcaron = 389, e1.ccedilla = 556, e1.Zdotaccent = 611, e1.Thorn = 667, e1.Omacron = 778, e1.Racute = 722, e1.Sacute = 667, e1.dcaron = 743, e1.Umacron = 722, e1.uring = 611, e1.threesuperior = 333, e1.Ograve = 778, e1.Agrave = 722, e1.Abreve = 722, e1.multiply = 584, e1.uacute = 611, e1.Tcaron = 611, e1.partialdiff = 494, e1.ydieresis = 556, e1.Nacute = 722, e1.icircumflex = 278, e1.Ecircumflex = 667, e1.adieresis = 556, e1.edieresis = 556, e1.cacute = 556, e1.nacute = 611, e1.umacron = 611, e1.Ncaron = 722, e1.Iacute = 278, e1.plusminus = 584, e1.brokenbar = 280, e1.registered = 737, e1.Gbreve = 778, e1.Idotaccent = 278, e1.summation = 600, e1.Egrave = 667, e1.racute = 389, e1.omacron = 611, e1.Zacute = 611, e1.Zcaron = 611, e1.greaterequal = 549, e1.Eth = 722, e1.Ccedilla = 722, e1.lcommaaccent = 278, e1.tcaron = 389, e1.eogonek = 556, e1.Uogonek = 722, e1.Aacute = 722, e1.Adieresis = 722, e1.egrave = 556, e1.zacute = 500, e1.iogonek = 278, e1.Oacute = 778, e1.oacute = 611, e1.amacron = 556, e1.sacute = 556, e1.idieresis = 278, e1.Ocircumflex = 778, e1.Ugrave = 722, e1.Delta = 612, e1.thorn = 611, e1.twosuperior = 333, e1.Odieresis = 778, e1.mu = 611, e1.igrave = 278, e1.ohungarumlaut = 611, e1.Eogonek = 667, e1.dcroat = 611, e1.threequarters = 834, e1.Scedilla = 667, e1.lcaron = 400, e1.Kcommaaccent = 722, e1.Lacute = 611, e1.trademark = 1e3, e1.edotaccent = 556, e1.Igrave = 278, e1.Imacron = 278, e1.Lcaron = 611, e1.onehalf = 834, e1.lessequal = 549, e1.ocircumflex = 611, e1.ntilde = 611, e1.Uhungarumlaut = 722, e1.Eacute = 667, e1.emacron = 556, e1.gbreve = 611, e1.onequarter = 834, e1.Scaron = 667, e1.Scommaaccent = 667, e1.Ohungarumlaut = 778, e1.degree = 400, e1.ograve = 611, e1.Ccaron = 722, e1.ugrave = 611, e1.radical = 549, e1.Dcaron = 722, e1.rcommaaccent = 389, e1.Ntilde = 722, e1.otilde = 611, e1.Rcommaaccent = 722, e1.Lcommaaccent = 611, e1.Atilde = 722, e1.Aogonek = 722, e1.Aring = 722, e1.Otilde = 778, e1.zdotaccent = 500, e1.Ecaron = 667, e1.Iogonek = 278, e1.kcommaaccent = 556, e1.minus = 584, e1.Icircumflex = 278, e1.ncaron = 611, e1.tcommaaccent = 333, e1.logicalnot = 584, e1.odieresis = 611, e1.udieresis = 611, e1.notequal = 549, e1.gcommaaccent = 611, e1.eth = 611, e1.zcaron = 500, e1.ncommaaccent = 611, e1.onesuperior = 333, e1.imacron = 278, e1.Euro = 556;
    }), e1["Helvetica-BoldOblique"] = getLookupTableFactory(function(e1) {
        e1.space = 278, e1.exclam = 333, e1.quotedbl = 474, e1.numbersign = 556, e1.dollar = 556, e1.percent = 889, e1.ampersand = 722, e1.quoteright = 278, e1.parenleft = 333, e1.parenright = 333, e1.asterisk = 389, e1.plus = 584, e1.comma = 278, e1.hyphen = 333, e1.period = 278, e1.slash = 278, e1.zero = 556, e1.one = 556, e1.two = 556, e1.three = 556, e1.four = 556, e1.five = 556, e1.six = 556, e1.seven = 556, e1.eight = 556, e1.nine = 556, e1.colon = 333, e1.semicolon = 333, e1.less = 584, e1.equal = 584, e1.greater = 584, e1.question = 611, e1.at = 975, e1.A = 722, e1.B = 722, e1.C = 722, e1.D = 722, e1.E = 667, e1.F = 611, e1.G = 778, e1.H = 722, e1.I = 278, e1.J = 556, e1.K = 722, e1.L = 611, e1.M = 833, e1.N = 722, e1.O = 778, e1.P = 667, e1.Q = 778, e1.R = 722, e1.S = 667, e1.T = 611, e1.U = 722, e1.V = 667, e1.W = 944, e1.X = 667, e1.Y = 667, e1.Z = 611, e1.bracketleft = 333, e1.backslash = 278, e1.bracketright = 333, e1.asciicircum = 584, e1.underscore = 556, e1.quoteleft = 278, e1.a = 556, e1.b = 611, e1.c = 556, e1.d = 611, e1.e = 556, e1.f = 333, e1.g = 611, e1.h = 611, e1.i = 278, e1.j = 278, e1.k = 556, e1.l = 278, e1.m = 889, e1.n = 611, e1.o = 611, e1.p = 611, e1.q = 611, e1.r = 389, e1.s = 556, e1.t = 333, e1.u = 611, e1.v = 556, e1.w = 778, e1.x = 556, e1.y = 556, e1.z = 500, e1.braceleft = 389, e1.bar = 280, e1.braceright = 389, e1.asciitilde = 584, e1.exclamdown = 333, e1.cent = 556, e1.sterling = 556, e1.fraction = 167, e1.yen = 556, e1.florin = 556, e1.section = 556, e1.currency = 556, e1.quotesingle = 238, e1.quotedblleft = 500, e1.guillemotleft = 556, e1.guilsinglleft = 333, e1.guilsinglright = 333, e1.fi = 611, e1.fl = 611, e1.endash = 556, e1.dagger = 556, e1.daggerdbl = 556, e1.periodcentered = 278, e1.paragraph = 556, e1.bullet = 350, e1.quotesinglbase = 278, e1.quotedblbase = 500, e1.quotedblright = 500, e1.guillemotright = 556, e1.ellipsis = 1e3, e1.perthousand = 1e3, e1.questiondown = 611, e1.grave = 333, e1.acute = 333, e1.circumflex = 333, e1.tilde = 333, e1.macron = 333, e1.breve = 333, e1.dotaccent = 333, e1.dieresis = 333, e1.ring = 333, e1.cedilla = 333, e1.hungarumlaut = 333, e1.ogonek = 333, e1.caron = 333, e1.emdash = 1e3, e1.AE = 1e3, e1.ordfeminine = 370, e1.Lslash = 611, e1.Oslash = 778, e1.OE = 1e3, e1.ordmasculine = 365, e1.ae = 889, e1.dotlessi = 278, e1.lslash = 278, e1.oslash = 611, e1.oe = 944, e1.germandbls = 611, e1.Idieresis = 278, e1.eacute = 556, e1.abreve = 556, e1.uhungarumlaut = 611, e1.ecaron = 556, e1.Ydieresis = 667, e1.divide = 584, e1.Yacute = 667, e1.Acircumflex = 722, e1.aacute = 556, e1.Ucircumflex = 722, e1.yacute = 556, e1.scommaaccent = 556, e1.ecircumflex = 556, e1.Uring = 722, e1.Udieresis = 722, e1.aogonek = 556, e1.Uacute = 722, e1.uogonek = 611, e1.Edieresis = 667, e1.Dcroat = 722, e1.commaaccent = 250, e1.copyright = 737, e1.Emacron = 667, e1.ccaron = 556, e1.aring = 556, e1.Ncommaaccent = 722, e1.lacute = 278, e1.agrave = 556, e1.Tcommaaccent = 611, e1.Cacute = 722, e1.atilde = 556, e1.Edotaccent = 667, e1.scaron = 556, e1.scedilla = 556, e1.iacute = 278, e1.lozenge = 494, e1.Rcaron = 722, e1.Gcommaaccent = 778, e1.ucircumflex = 611, e1.acircumflex = 556, e1.Amacron = 722, e1.rcaron = 389, e1.ccedilla = 556, e1.Zdotaccent = 611, e1.Thorn = 667, e1.Omacron = 778, e1.Racute = 722, e1.Sacute = 667, e1.dcaron = 743, e1.Umacron = 722, e1.uring = 611, e1.threesuperior = 333, e1.Ograve = 778, e1.Agrave = 722, e1.Abreve = 722, e1.multiply = 584, e1.uacute = 611, e1.Tcaron = 611, e1.partialdiff = 494, e1.ydieresis = 556, e1.Nacute = 722, e1.icircumflex = 278, e1.Ecircumflex = 667, e1.adieresis = 556, e1.edieresis = 556, e1.cacute = 556, e1.nacute = 611, e1.umacron = 611, e1.Ncaron = 722, e1.Iacute = 278, e1.plusminus = 584, e1.brokenbar = 280, e1.registered = 737, e1.Gbreve = 778, e1.Idotaccent = 278, e1.summation = 600, e1.Egrave = 667, e1.racute = 389, e1.omacron = 611, e1.Zacute = 611, e1.Zcaron = 611, e1.greaterequal = 549, e1.Eth = 722, e1.Ccedilla = 722, e1.lcommaaccent = 278, e1.tcaron = 389, e1.eogonek = 556, e1.Uogonek = 722, e1.Aacute = 722, e1.Adieresis = 722, e1.egrave = 556, e1.zacute = 500, e1.iogonek = 278, e1.Oacute = 778, e1.oacute = 611, e1.amacron = 556, e1.sacute = 556, e1.idieresis = 278, e1.Ocircumflex = 778, e1.Ugrave = 722, e1.Delta = 612, e1.thorn = 611, e1.twosuperior = 333, e1.Odieresis = 778, e1.mu = 611, e1.igrave = 278, e1.ohungarumlaut = 611, e1.Eogonek = 667, e1.dcroat = 611, e1.threequarters = 834, e1.Scedilla = 667, e1.lcaron = 400, e1.Kcommaaccent = 722, e1.Lacute = 611, e1.trademark = 1e3, e1.edotaccent = 556, e1.Igrave = 278, e1.Imacron = 278, e1.Lcaron = 611, e1.onehalf = 834, e1.lessequal = 549, e1.ocircumflex = 611, e1.ntilde = 611, e1.Uhungarumlaut = 722, e1.Eacute = 667, e1.emacron = 556, e1.gbreve = 611, e1.onequarter = 834, e1.Scaron = 667, e1.Scommaaccent = 667, e1.Ohungarumlaut = 778, e1.degree = 400, e1.ograve = 611, e1.Ccaron = 722, e1.ugrave = 611, e1.radical = 549, e1.Dcaron = 722, e1.rcommaaccent = 389, e1.Ntilde = 722, e1.otilde = 611, e1.Rcommaaccent = 722, e1.Lcommaaccent = 611, e1.Atilde = 722, e1.Aogonek = 722, e1.Aring = 722, e1.Otilde = 778, e1.zdotaccent = 500, e1.Ecaron = 667, e1.Iogonek = 278, e1.kcommaaccent = 556, e1.minus = 584, e1.Icircumflex = 278, e1.ncaron = 611, e1.tcommaaccent = 333, e1.logicalnot = 584, e1.odieresis = 611, e1.udieresis = 611, e1.notequal = 549, e1.gcommaaccent = 611, e1.eth = 611, e1.zcaron = 500, e1.ncommaaccent = 611, e1.onesuperior = 333, e1.imacron = 278, e1.Euro = 556;
    }), e1["Helvetica-Oblique"] = getLookupTableFactory(function(e1) {
        e1.space = 278, e1.exclam = 278, e1.quotedbl = 355, e1.numbersign = 556, e1.dollar = 556, e1.percent = 889, e1.ampersand = 667, e1.quoteright = 222, e1.parenleft = 333, e1.parenright = 333, e1.asterisk = 389, e1.plus = 584, e1.comma = 278, e1.hyphen = 333, e1.period = 278, e1.slash = 278, e1.zero = 556, e1.one = 556, e1.two = 556, e1.three = 556, e1.four = 556, e1.five = 556, e1.six = 556, e1.seven = 556, e1.eight = 556, e1.nine = 556, e1.colon = 278, e1.semicolon = 278, e1.less = 584, e1.equal = 584, e1.greater = 584, e1.question = 556, e1.at = 1015, e1.A = 667, e1.B = 667, e1.C = 722, e1.D = 722, e1.E = 667, e1.F = 611, e1.G = 778, e1.H = 722, e1.I = 278, e1.J = 500, e1.K = 667, e1.L = 556, e1.M = 833, e1.N = 722, e1.O = 778, e1.P = 667, e1.Q = 778, e1.R = 722, e1.S = 667, e1.T = 611, e1.U = 722, e1.V = 667, e1.W = 944, e1.X = 667, e1.Y = 667, e1.Z = 611, e1.bracketleft = 278, e1.backslash = 278, e1.bracketright = 278, e1.asciicircum = 469, e1.underscore = 556, e1.quoteleft = 222, e1.a = 556, e1.b = 556, e1.c = 500, e1.d = 556, e1.e = 556, e1.f = 278, e1.g = 556, e1.h = 556, e1.i = 222, e1.j = 222, e1.k = 500, e1.l = 222, e1.m = 833, e1.n = 556, e1.o = 556, e1.p = 556, e1.q = 556, e1.r = 333, e1.s = 500, e1.t = 278, e1.u = 556, e1.v = 500, e1.w = 722, e1.x = 500, e1.y = 500, e1.z = 500, e1.braceleft = 334, e1.bar = 260, e1.braceright = 334, e1.asciitilde = 584, e1.exclamdown = 333, e1.cent = 556, e1.sterling = 556, e1.fraction = 167, e1.yen = 556, e1.florin = 556, e1.section = 556, e1.currency = 556, e1.quotesingle = 191, e1.quotedblleft = 333, e1.guillemotleft = 556, e1.guilsinglleft = 333, e1.guilsinglright = 333, e1.fi = 500, e1.fl = 500, e1.endash = 556, e1.dagger = 556, e1.daggerdbl = 556, e1.periodcentered = 278, e1.paragraph = 537, e1.bullet = 350, e1.quotesinglbase = 222, e1.quotedblbase = 333, e1.quotedblright = 333, e1.guillemotright = 556, e1.ellipsis = 1e3, e1.perthousand = 1e3, e1.questiondown = 611, e1.grave = 333, e1.acute = 333, e1.circumflex = 333, e1.tilde = 333, e1.macron = 333, e1.breve = 333, e1.dotaccent = 333, e1.dieresis = 333, e1.ring = 333, e1.cedilla = 333, e1.hungarumlaut = 333, e1.ogonek = 333, e1.caron = 333, e1.emdash = 1e3, e1.AE = 1e3, e1.ordfeminine = 370, e1.Lslash = 556, e1.Oslash = 778, e1.OE = 1e3, e1.ordmasculine = 365, e1.ae = 889, e1.dotlessi = 278, e1.lslash = 222, e1.oslash = 611, e1.oe = 944, e1.germandbls = 611, e1.Idieresis = 278, e1.eacute = 556, e1.abreve = 556, e1.uhungarumlaut = 556, e1.ecaron = 556, e1.Ydieresis = 667, e1.divide = 584, e1.Yacute = 667, e1.Acircumflex = 667, e1.aacute = 556, e1.Ucircumflex = 722, e1.yacute = 500, e1.scommaaccent = 500, e1.ecircumflex = 556, e1.Uring = 722, e1.Udieresis = 722, e1.aogonek = 556, e1.Uacute = 722, e1.uogonek = 556, e1.Edieresis = 667, e1.Dcroat = 722, e1.commaaccent = 250, e1.copyright = 737, e1.Emacron = 667, e1.ccaron = 500, e1.aring = 556, e1.Ncommaaccent = 722, e1.lacute = 222, e1.agrave = 556, e1.Tcommaaccent = 611, e1.Cacute = 722, e1.atilde = 556, e1.Edotaccent = 667, e1.scaron = 500, e1.scedilla = 500, e1.iacute = 278, e1.lozenge = 471, e1.Rcaron = 722, e1.Gcommaaccent = 778, e1.ucircumflex = 556, e1.acircumflex = 556, e1.Amacron = 667, e1.rcaron = 333, e1.ccedilla = 500, e1.Zdotaccent = 611, e1.Thorn = 667, e1.Omacron = 778, e1.Racute = 722, e1.Sacute = 667, e1.dcaron = 643, e1.Umacron = 722, e1.uring = 556, e1.threesuperior = 333, e1.Ograve = 778, e1.Agrave = 667, e1.Abreve = 667, e1.multiply = 584, e1.uacute = 556, e1.Tcaron = 611, e1.partialdiff = 476, e1.ydieresis = 500, e1.Nacute = 722, e1.icircumflex = 278, e1.Ecircumflex = 667, e1.adieresis = 556, e1.edieresis = 556, e1.cacute = 500, e1.nacute = 556, e1.umacron = 556, e1.Ncaron = 722, e1.Iacute = 278, e1.plusminus = 584, e1.brokenbar = 260, e1.registered = 737, e1.Gbreve = 778, e1.Idotaccent = 278, e1.summation = 600, e1.Egrave = 667, e1.racute = 333, e1.omacron = 556, e1.Zacute = 611, e1.Zcaron = 611, e1.greaterequal = 549, e1.Eth = 722, e1.Ccedilla = 722, e1.lcommaaccent = 222, e1.tcaron = 317, e1.eogonek = 556, e1.Uogonek = 722, e1.Aacute = 667, e1.Adieresis = 667, e1.egrave = 556, e1.zacute = 500, e1.iogonek = 222, e1.Oacute = 778, e1.oacute = 556, e1.amacron = 556, e1.sacute = 500, e1.idieresis = 278, e1.Ocircumflex = 778, e1.Ugrave = 722, e1.Delta = 612, e1.thorn = 556, e1.twosuperior = 333, e1.Odieresis = 778, e1.mu = 556, e1.igrave = 278, e1.ohungarumlaut = 556, e1.Eogonek = 667, e1.dcroat = 556, e1.threequarters = 834, e1.Scedilla = 667, e1.lcaron = 299, e1.Kcommaaccent = 667, e1.Lacute = 556, e1.trademark = 1e3, e1.edotaccent = 556, e1.Igrave = 278, e1.Imacron = 278, e1.Lcaron = 556, e1.onehalf = 834, e1.lessequal = 549, e1.ocircumflex = 556, e1.ntilde = 556, e1.Uhungarumlaut = 722, e1.Eacute = 667, e1.emacron = 556, e1.gbreve = 556, e1.onequarter = 834, e1.Scaron = 667, e1.Scommaaccent = 667, e1.Ohungarumlaut = 778, e1.degree = 400, e1.ograve = 556, e1.Ccaron = 722, e1.ugrave = 556, e1.radical = 453, e1.Dcaron = 722, e1.rcommaaccent = 333, e1.Ntilde = 722, e1.otilde = 556, e1.Rcommaaccent = 722, e1.Lcommaaccent = 556, e1.Atilde = 667, e1.Aogonek = 667, e1.Aring = 667, e1.Otilde = 778, e1.zdotaccent = 500, e1.Ecaron = 667, e1.Iogonek = 278, e1.kcommaaccent = 500, e1.minus = 584, e1.Icircumflex = 278, e1.ncaron = 556, e1.tcommaaccent = 278, e1.logicalnot = 584, e1.odieresis = 556, e1.udieresis = 556, e1.notequal = 549, e1.gcommaaccent = 556, e1.eth = 556, e1.zcaron = 500, e1.ncommaaccent = 556, e1.onesuperior = 333, e1.imacron = 278, e1.Euro = 556;
    }), e1.Symbol = getLookupTableFactory(function(e1) {
        e1.space = 250, e1.exclam = 333, e1.universal = 713, e1.numbersign = 500, e1.existential = 549, e1.percent = 833, e1.ampersand = 778, e1.suchthat = 439, e1.parenleft = 333, e1.parenright = 333, e1.asteriskmath = 500, e1.plus = 549, e1.comma = 250, e1.minus = 549, e1.period = 250, e1.slash = 278, e1.zero = 500, e1.one = 500, e1.two = 500, e1.three = 500, e1.four = 500, e1.five = 500, e1.six = 500, e1.seven = 500, e1.eight = 500, e1.nine = 500, e1.colon = 278, e1.semicolon = 278, e1.less = 549, e1.equal = 549, e1.greater = 549, e1.question = 444, e1.congruent = 549, e1.Alpha = 722, e1.Beta = 667, e1.Chi = 722, e1.Delta = 612, e1.Epsilon = 611, e1.Phi = 763, e1.Gamma = 603, e1.Eta = 722, e1.Iota = 333, e1.theta1 = 631, e1.Kappa = 722, e1.Lambda = 686, e1.Mu = 889, e1.Nu = 722, e1.Omicron = 722, e1.Pi = 768, e1.Theta = 741, e1.Rho = 556, e1.Sigma = 592, e1.Tau = 611, e1.Upsilon = 690, e1.sigma1 = 439, e1.Omega = 768, e1.Xi = 645, e1.Psi = 795, e1.Zeta = 611, e1.bracketleft = 333, e1.therefore = 863, e1.bracketright = 333, e1.perpendicular = 658, e1.underscore = 500, e1.radicalex = 500, e1.alpha = 631, e1.beta = 549, e1.chi = 549, e1.delta = 494, e1.epsilon = 439, e1.phi = 521, e1.gamma = 411, e1.eta = 603, e1.iota = 329, e1.phi1 = 603, e1.kappa = 549, e1.lambda = 549, e1.mu = 576, e1.nu = 521, e1.omicron = 549, e1.pi = 549, e1.theta = 521, e1.rho = 549, e1.sigma = 603, e1.tau = 439, e1.upsilon = 576, e1.omega1 = 713, e1.omega = 686, e1.xi = 493, e1.psi = 686, e1.zeta = 494, e1.braceleft = 480, e1.bar = 200, e1.braceright = 480, e1.similar = 549, e1.Euro = 750, e1.Upsilon1 = 620, e1.minute = 247, e1.lessequal = 549, e1.fraction = 167, e1.infinity = 713, e1.florin = 500, e1.club = 753, e1.diamond = 753, e1.heart = 753, e1.spade = 753, e1.arrowboth = 1042, e1.arrowleft = 987, e1.arrowup = 603, e1.arrowright = 987, e1.arrowdown = 603, e1.degree = 400, e1.plusminus = 549, e1.second = 411, e1.greaterequal = 549, e1.multiply = 549, e1.proportional = 713, e1.partialdiff = 494, e1.bullet = 460, e1.divide = 549, e1.notequal = 549, e1.equivalence = 549, e1.approxequal = 549, e1.ellipsis = 1e3, e1.arrowvertex = 603, e1.arrowhorizex = 1e3, e1.carriagereturn = 658, e1.aleph = 823, e1.Ifraktur = 686, e1.Rfraktur = 795, e1.weierstrass = 987, e1.circlemultiply = 768, e1.circleplus = 768, e1.emptyset = 823, e1.intersection = 768, e1.union = 768, e1.propersuperset = 713, e1.reflexsuperset = 713, e1.notsubset = 713, e1.propersubset = 713, e1.reflexsubset = 713, e1.element = 713, e1.notelement = 713, e1.angle = 768, e1.gradient = 713, e1.registerserif = 790, e1.copyrightserif = 790, e1.trademarkserif = 890, e1.product = 823, e1.radical = 549, e1.dotmath = 250, e1.logicalnot = 713, e1.logicaland = 603, e1.logicalor = 603, e1.arrowdblboth = 1042, e1.arrowdblleft = 987, e1.arrowdblup = 603, e1.arrowdblright = 987, e1.arrowdbldown = 603, e1.lozenge = 494, e1.angleleft = 329, e1.registersans = 790, e1.copyrightsans = 790, e1.trademarksans = 786, e1.summation = 713, e1.parenlefttp = 384, e1.parenleftex = 384, e1.parenleftbt = 384, e1.bracketlefttp = 384, e1.bracketleftex = 384, e1.bracketleftbt = 384, e1.bracelefttp = 494, e1.braceleftmid = 494, e1.braceleftbt = 494, e1.braceex = 494, e1.angleright = 329, e1.integral = 274, e1.integraltp = 686, e1.integralex = 686, e1.integralbt = 686, e1.parenrighttp = 384, e1.parenrightex = 384, e1.parenrightbt = 384, e1.bracketrighttp = 384, e1.bracketrightex = 384, e1.bracketrightbt = 384, e1.bracerighttp = 494, e1.bracerightmid = 494, e1.bracerightbt = 494, e1.apple = 790;
    }), e1["Times-Roman"] = getLookupTableFactory(function(e1) {
        e1.space = 250, e1.exclam = 333, e1.quotedbl = 408, e1.numbersign = 500, e1.dollar = 500, e1.percent = 833, e1.ampersand = 778, e1.quoteright = 333, e1.parenleft = 333, e1.parenright = 333, e1.asterisk = 500, e1.plus = 564, e1.comma = 250, e1.hyphen = 333, e1.period = 250, e1.slash = 278, e1.zero = 500, e1.one = 500, e1.two = 500, e1.three = 500, e1.four = 500, e1.five = 500, e1.six = 500, e1.seven = 500, e1.eight = 500, e1.nine = 500, e1.colon = 278, e1.semicolon = 278, e1.less = 564, e1.equal = 564, e1.greater = 564, e1.question = 444, e1.at = 921, e1.A = 722, e1.B = 667, e1.C = 667, e1.D = 722, e1.E = 611, e1.F = 556, e1.G = 722, e1.H = 722, e1.I = 333, e1.J = 389, e1.K = 722, e1.L = 611, e1.M = 889, e1.N = 722, e1.O = 722, e1.P = 556, e1.Q = 722, e1.R = 667, e1.S = 556, e1.T = 611, e1.U = 722, e1.V = 722, e1.W = 944, e1.X = 722, e1.Y = 722, e1.Z = 611, e1.bracketleft = 333, e1.backslash = 278, e1.bracketright = 333, e1.asciicircum = 469, e1.underscore = 500, e1.quoteleft = 333, e1.a = 444, e1.b = 500, e1.c = 444, e1.d = 500, e1.e = 444, e1.f = 333, e1.g = 500, e1.h = 500, e1.i = 278, e1.j = 278, e1.k = 500, e1.l = 278, e1.m = 778, e1.n = 500, e1.o = 500, e1.p = 500, e1.q = 500, e1.r = 333, e1.s = 389, e1.t = 278, e1.u = 500, e1.v = 500, e1.w = 722, e1.x = 500, e1.y = 500, e1.z = 444, e1.braceleft = 480, e1.bar = 200, e1.braceright = 480, e1.asciitilde = 541, e1.exclamdown = 333, e1.cent = 500, e1.sterling = 500, e1.fraction = 167, e1.yen = 500, e1.florin = 500, e1.section = 500, e1.currency = 500, e1.quotesingle = 180, e1.quotedblleft = 444, e1.guillemotleft = 500, e1.guilsinglleft = 333, e1.guilsinglright = 333, e1.fi = 556, e1.fl = 556, e1.endash = 500, e1.dagger = 500, e1.daggerdbl = 500, e1.periodcentered = 250, e1.paragraph = 453, e1.bullet = 350, e1.quotesinglbase = 333, e1.quotedblbase = 444, e1.quotedblright = 444, e1.guillemotright = 500, e1.ellipsis = 1e3, e1.perthousand = 1e3, e1.questiondown = 444, e1.grave = 333, e1.acute = 333, e1.circumflex = 333, e1.tilde = 333, e1.macron = 333, e1.breve = 333, e1.dotaccent = 333, e1.dieresis = 333, e1.ring = 333, e1.cedilla = 333, e1.hungarumlaut = 333, e1.ogonek = 333, e1.caron = 333, e1.emdash = 1e3, e1.AE = 889, e1.ordfeminine = 276, e1.Lslash = 611, e1.Oslash = 722, e1.OE = 889, e1.ordmasculine = 310, e1.ae = 667, e1.dotlessi = 278, e1.lslash = 278, e1.oslash = 500, e1.oe = 722, e1.germandbls = 500, e1.Idieresis = 333, e1.eacute = 444, e1.abreve = 444, e1.uhungarumlaut = 500, e1.ecaron = 444, e1.Ydieresis = 722, e1.divide = 564, e1.Yacute = 722, e1.Acircumflex = 722, e1.aacute = 444, e1.Ucircumflex = 722, e1.yacute = 500, e1.scommaaccent = 389, e1.ecircumflex = 444, e1.Uring = 722, e1.Udieresis = 722, e1.aogonek = 444, e1.Uacute = 722, e1.uogonek = 500, e1.Edieresis = 611, e1.Dcroat = 722, e1.commaaccent = 250, e1.copyright = 760, e1.Emacron = 611, e1.ccaron = 444, e1.aring = 444, e1.Ncommaaccent = 722, e1.lacute = 278, e1.agrave = 444, e1.Tcommaaccent = 611, e1.Cacute = 667, e1.atilde = 444, e1.Edotaccent = 611, e1.scaron = 389, e1.scedilla = 389, e1.iacute = 278, e1.lozenge = 471, e1.Rcaron = 667, e1.Gcommaaccent = 722, e1.ucircumflex = 500, e1.acircumflex = 444, e1.Amacron = 722, e1.rcaron = 333, e1.ccedilla = 444, e1.Zdotaccent = 611, e1.Thorn = 556, e1.Omacron = 722, e1.Racute = 667, e1.Sacute = 556, e1.dcaron = 588, e1.Umacron = 722, e1.uring = 500, e1.threesuperior = 300, e1.Ograve = 722, e1.Agrave = 722, e1.Abreve = 722, e1.multiply = 564, e1.uacute = 500, e1.Tcaron = 611, e1.partialdiff = 476, e1.ydieresis = 500, e1.Nacute = 722, e1.icircumflex = 278, e1.Ecircumflex = 611, e1.adieresis = 444, e1.edieresis = 444, e1.cacute = 444, e1.nacute = 500, e1.umacron = 500, e1.Ncaron = 722, e1.Iacute = 333, e1.plusminus = 564, e1.brokenbar = 200, e1.registered = 760, e1.Gbreve = 722, e1.Idotaccent = 333, e1.summation = 600, e1.Egrave = 611, e1.racute = 333, e1.omacron = 500, e1.Zacute = 611, e1.Zcaron = 611, e1.greaterequal = 549, e1.Eth = 722, e1.Ccedilla = 667, e1.lcommaaccent = 278, e1.tcaron = 326, e1.eogonek = 444, e1.Uogonek = 722, e1.Aacute = 722, e1.Adieresis = 722, e1.egrave = 444, e1.zacute = 444, e1.iogonek = 278, e1.Oacute = 722, e1.oacute = 500, e1.amacron = 444, e1.sacute = 389, e1.idieresis = 278, e1.Ocircumflex = 722, e1.Ugrave = 722, e1.Delta = 612, e1.thorn = 500, e1.twosuperior = 300, e1.Odieresis = 722, e1.mu = 500, e1.igrave = 278, e1.ohungarumlaut = 500, e1.Eogonek = 611, e1.dcroat = 500, e1.threequarters = 750, e1.Scedilla = 556, e1.lcaron = 344, e1.Kcommaaccent = 722, e1.Lacute = 611, e1.trademark = 980, e1.edotaccent = 444, e1.Igrave = 333, e1.Imacron = 333, e1.Lcaron = 611, e1.onehalf = 750, e1.lessequal = 549, e1.ocircumflex = 500, e1.ntilde = 500, e1.Uhungarumlaut = 722, e1.Eacute = 611, e1.emacron = 444, e1.gbreve = 500, e1.onequarter = 750, e1.Scaron = 556, e1.Scommaaccent = 556, e1.Ohungarumlaut = 722, e1.degree = 400, e1.ograve = 500, e1.Ccaron = 667, e1.ugrave = 500, e1.radical = 453, e1.Dcaron = 722, e1.rcommaaccent = 333, e1.Ntilde = 722, e1.otilde = 500, e1.Rcommaaccent = 667, e1.Lcommaaccent = 611, e1.Atilde = 722, e1.Aogonek = 722, e1.Aring = 722, e1.Otilde = 722, e1.zdotaccent = 444, e1.Ecaron = 611, e1.Iogonek = 333, e1.kcommaaccent = 500, e1.minus = 564, e1.Icircumflex = 333, e1.ncaron = 500, e1.tcommaaccent = 278, e1.logicalnot = 564, e1.odieresis = 500, e1.udieresis = 500, e1.notequal = 549, e1.gcommaaccent = 500, e1.eth = 500, e1.zcaron = 444, e1.ncommaaccent = 500, e1.onesuperior = 300, e1.imacron = 278, e1.Euro = 500;
    }), e1["Times-Bold"] = getLookupTableFactory(function(e1) {
        e1.space = 250, e1.exclam = 333, e1.quotedbl = 555, e1.numbersign = 500, e1.dollar = 500, e1.percent = 1e3, e1.ampersand = 833, e1.quoteright = 333, e1.parenleft = 333, e1.parenright = 333, e1.asterisk = 500, e1.plus = 570, e1.comma = 250, e1.hyphen = 333, e1.period = 250, e1.slash = 278, e1.zero = 500, e1.one = 500, e1.two = 500, e1.three = 500, e1.four = 500, e1.five = 500, e1.six = 500, e1.seven = 500, e1.eight = 500, e1.nine = 500, e1.colon = 333, e1.semicolon = 333, e1.less = 570, e1.equal = 570, e1.greater = 570, e1.question = 500, e1.at = 930, e1.A = 722, e1.B = 667, e1.C = 722, e1.D = 722, e1.E = 667, e1.F = 611, e1.G = 778, e1.H = 778, e1.I = 389, e1.J = 500, e1.K = 778, e1.L = 667, e1.M = 944, e1.N = 722, e1.O = 778, e1.P = 611, e1.Q = 778, e1.R = 722, e1.S = 556, e1.T = 667, e1.U = 722, e1.V = 722, e1.W = 1e3, e1.X = 722, e1.Y = 722, e1.Z = 667, e1.bracketleft = 333, e1.backslash = 278, e1.bracketright = 333, e1.asciicircum = 581, e1.underscore = 500, e1.quoteleft = 333, e1.a = 500, e1.b = 556, e1.c = 444, e1.d = 556, e1.e = 444, e1.f = 333, e1.g = 500, e1.h = 556, e1.i = 278, e1.j = 333, e1.k = 556, e1.l = 278, e1.m = 833, e1.n = 556, e1.o = 500, e1.p = 556, e1.q = 556, e1.r = 444, e1.s = 389, e1.t = 333, e1.u = 556, e1.v = 500, e1.w = 722, e1.x = 500, e1.y = 500, e1.z = 444, e1.braceleft = 394, e1.bar = 220, e1.braceright = 394, e1.asciitilde = 520, e1.exclamdown = 333, e1.cent = 500, e1.sterling = 500, e1.fraction = 167, e1.yen = 500, e1.florin = 500, e1.section = 500, e1.currency = 500, e1.quotesingle = 278, e1.quotedblleft = 500, e1.guillemotleft = 500, e1.guilsinglleft = 333, e1.guilsinglright = 333, e1.fi = 556, e1.fl = 556, e1.endash = 500, e1.dagger = 500, e1.daggerdbl = 500, e1.periodcentered = 250, e1.paragraph = 540, e1.bullet = 350, e1.quotesinglbase = 333, e1.quotedblbase = 500, e1.quotedblright = 500, e1.guillemotright = 500, e1.ellipsis = 1e3, e1.perthousand = 1e3, e1.questiondown = 500, e1.grave = 333, e1.acute = 333, e1.circumflex = 333, e1.tilde = 333, e1.macron = 333, e1.breve = 333, e1.dotaccent = 333, e1.dieresis = 333, e1.ring = 333, e1.cedilla = 333, e1.hungarumlaut = 333, e1.ogonek = 333, e1.caron = 333, e1.emdash = 1e3, e1.AE = 1e3, e1.ordfeminine = 300, e1.Lslash = 667, e1.Oslash = 778, e1.OE = 1e3, e1.ordmasculine = 330, e1.ae = 722, e1.dotlessi = 278, e1.lslash = 278, e1.oslash = 500, e1.oe = 722, e1.germandbls = 556, e1.Idieresis = 389, e1.eacute = 444, e1.abreve = 500, e1.uhungarumlaut = 556, e1.ecaron = 444, e1.Ydieresis = 722, e1.divide = 570, e1.Yacute = 722, e1.Acircumflex = 722, e1.aacute = 500, e1.Ucircumflex = 722, e1.yacute = 500, e1.scommaaccent = 389, e1.ecircumflex = 444, e1.Uring = 722, e1.Udieresis = 722, e1.aogonek = 500, e1.Uacute = 722, e1.uogonek = 556, e1.Edieresis = 667, e1.Dcroat = 722, e1.commaaccent = 250, e1.copyright = 747, e1.Emacron = 667, e1.ccaron = 444, e1.aring = 500, e1.Ncommaaccent = 722, e1.lacute = 278, e1.agrave = 500, e1.Tcommaaccent = 667, e1.Cacute = 722, e1.atilde = 500, e1.Edotaccent = 667, e1.scaron = 389, e1.scedilla = 389, e1.iacute = 278, e1.lozenge = 494, e1.Rcaron = 722, e1.Gcommaaccent = 778, e1.ucircumflex = 556, e1.acircumflex = 500, e1.Amacron = 722, e1.rcaron = 444, e1.ccedilla = 444, e1.Zdotaccent = 667, e1.Thorn = 611, e1.Omacron = 778, e1.Racute = 722, e1.Sacute = 556, e1.dcaron = 672, e1.Umacron = 722, e1.uring = 556, e1.threesuperior = 300, e1.Ograve = 778, e1.Agrave = 722, e1.Abreve = 722, e1.multiply = 570, e1.uacute = 556, e1.Tcaron = 667, e1.partialdiff = 494, e1.ydieresis = 500, e1.Nacute = 722, e1.icircumflex = 278, e1.Ecircumflex = 667, e1.adieresis = 500, e1.edieresis = 444, e1.cacute = 444, e1.nacute = 556, e1.umacron = 556, e1.Ncaron = 722, e1.Iacute = 389, e1.plusminus = 570, e1.brokenbar = 220, e1.registered = 747, e1.Gbreve = 778, e1.Idotaccent = 389, e1.summation = 600, e1.Egrave = 667, e1.racute = 444, e1.omacron = 500, e1.Zacute = 667, e1.Zcaron = 667, e1.greaterequal = 549, e1.Eth = 722, e1.Ccedilla = 722, e1.lcommaaccent = 278, e1.tcaron = 416, e1.eogonek = 444, e1.Uogonek = 722, e1.Aacute = 722, e1.Adieresis = 722, e1.egrave = 444, e1.zacute = 444, e1.iogonek = 278, e1.Oacute = 778, e1.oacute = 500, e1.amacron = 500, e1.sacute = 389, e1.idieresis = 278, e1.Ocircumflex = 778, e1.Ugrave = 722, e1.Delta = 612, e1.thorn = 556, e1.twosuperior = 300, e1.Odieresis = 778, e1.mu = 556, e1.igrave = 278, e1.ohungarumlaut = 500, e1.Eogonek = 667, e1.dcroat = 556, e1.threequarters = 750, e1.Scedilla = 556, e1.lcaron = 394, e1.Kcommaaccent = 778, e1.Lacute = 667, e1.trademark = 1e3, e1.edotaccent = 444, e1.Igrave = 389, e1.Imacron = 389, e1.Lcaron = 667, e1.onehalf = 750, e1.lessequal = 549, e1.ocircumflex = 500, e1.ntilde = 556, e1.Uhungarumlaut = 722, e1.Eacute = 667, e1.emacron = 444, e1.gbreve = 500, e1.onequarter = 750, e1.Scaron = 556, e1.Scommaaccent = 556, e1.Ohungarumlaut = 778, e1.degree = 400, e1.ograve = 500, e1.Ccaron = 722, e1.ugrave = 556, e1.radical = 549, e1.Dcaron = 722, e1.rcommaaccent = 444, e1.Ntilde = 722, e1.otilde = 500, e1.Rcommaaccent = 722, e1.Lcommaaccent = 667, e1.Atilde = 722, e1.Aogonek = 722, e1.Aring = 722, e1.Otilde = 778, e1.zdotaccent = 444, e1.Ecaron = 667, e1.Iogonek = 389, e1.kcommaaccent = 556, e1.minus = 570, e1.Icircumflex = 389, e1.ncaron = 556, e1.tcommaaccent = 333, e1.logicalnot = 570, e1.odieresis = 500, e1.udieresis = 556, e1.notequal = 549, e1.gcommaaccent = 500, e1.eth = 500, e1.zcaron = 444, e1.ncommaaccent = 556, e1.onesuperior = 300, e1.imacron = 278, e1.Euro = 500;
    }), e1["Times-BoldItalic"] = getLookupTableFactory(function(e1) {
        e1.space = 250, e1.exclam = 389, e1.quotedbl = 555, e1.numbersign = 500, e1.dollar = 500, e1.percent = 833, e1.ampersand = 778, e1.quoteright = 333, e1.parenleft = 333, e1.parenright = 333, e1.asterisk = 500, e1.plus = 570, e1.comma = 250, e1.hyphen = 333, e1.period = 250, e1.slash = 278, e1.zero = 500, e1.one = 500, e1.two = 500, e1.three = 500, e1.four = 500, e1.five = 500, e1.six = 500, e1.seven = 500, e1.eight = 500, e1.nine = 500, e1.colon = 333, e1.semicolon = 333, e1.less = 570, e1.equal = 570, e1.greater = 570, e1.question = 500, e1.at = 832, e1.A = 667, e1.B = 667, e1.C = 667, e1.D = 722, e1.E = 667, e1.F = 667, e1.G = 722, e1.H = 778, e1.I = 389, e1.J = 500, e1.K = 667, e1.L = 611, e1.M = 889, e1.N = 722, e1.O = 722, e1.P = 611, e1.Q = 722, e1.R = 667, e1.S = 556, e1.T = 611, e1.U = 722, e1.V = 667, e1.W = 889, e1.X = 667, e1.Y = 611, e1.Z = 611, e1.bracketleft = 333, e1.backslash = 278, e1.bracketright = 333, e1.asciicircum = 570, e1.underscore = 500, e1.quoteleft = 333, e1.a = 500, e1.b = 500, e1.c = 444, e1.d = 500, e1.e = 444, e1.f = 333, e1.g = 500, e1.h = 556, e1.i = 278, e1.j = 278, e1.k = 500, e1.l = 278, e1.m = 778, e1.n = 556, e1.o = 500, e1.p = 500, e1.q = 500, e1.r = 389, e1.s = 389, e1.t = 278, e1.u = 556, e1.v = 444, e1.w = 667, e1.x = 500, e1.y = 444, e1.z = 389, e1.braceleft = 348, e1.bar = 220, e1.braceright = 348, e1.asciitilde = 570, e1.exclamdown = 389, e1.cent = 500, e1.sterling = 500, e1.fraction = 167, e1.yen = 500, e1.florin = 500, e1.section = 500, e1.currency = 500, e1.quotesingle = 278, e1.quotedblleft = 500, e1.guillemotleft = 500, e1.guilsinglleft = 333, e1.guilsinglright = 333, e1.fi = 556, e1.fl = 556, e1.endash = 500, e1.dagger = 500, e1.daggerdbl = 500, e1.periodcentered = 250, e1.paragraph = 500, e1.bullet = 350, e1.quotesinglbase = 333, e1.quotedblbase = 500, e1.quotedblright = 500, e1.guillemotright = 500, e1.ellipsis = 1e3, e1.perthousand = 1e3, e1.questiondown = 500, e1.grave = 333, e1.acute = 333, e1.circumflex = 333, e1.tilde = 333, e1.macron = 333, e1.breve = 333, e1.dotaccent = 333, e1.dieresis = 333, e1.ring = 333, e1.cedilla = 333, e1.hungarumlaut = 333, e1.ogonek = 333, e1.caron = 333, e1.emdash = 1e3, e1.AE = 944, e1.ordfeminine = 266, e1.Lslash = 611, e1.Oslash = 722, e1.OE = 944, e1.ordmasculine = 300, e1.ae = 722, e1.dotlessi = 278, e1.lslash = 278, e1.oslash = 500, e1.oe = 722, e1.germandbls = 500, e1.Idieresis = 389, e1.eacute = 444, e1.abreve = 500, e1.uhungarumlaut = 556, e1.ecaron = 444, e1.Ydieresis = 611, e1.divide = 570, e1.Yacute = 611, e1.Acircumflex = 667, e1.aacute = 500, e1.Ucircumflex = 722, e1.yacute = 444, e1.scommaaccent = 389, e1.ecircumflex = 444, e1.Uring = 722, e1.Udieresis = 722, e1.aogonek = 500, e1.Uacute = 722, e1.uogonek = 556, e1.Edieresis = 667, e1.Dcroat = 722, e1.commaaccent = 250, e1.copyright = 747, e1.Emacron = 667, e1.ccaron = 444, e1.aring = 500, e1.Ncommaaccent = 722, e1.lacute = 278, e1.agrave = 500, e1.Tcommaaccent = 611, e1.Cacute = 667, e1.atilde = 500, e1.Edotaccent = 667, e1.scaron = 389, e1.scedilla = 389, e1.iacute = 278, e1.lozenge = 494, e1.Rcaron = 667, e1.Gcommaaccent = 722, e1.ucircumflex = 556, e1.acircumflex = 500, e1.Amacron = 667, e1.rcaron = 389, e1.ccedilla = 444, e1.Zdotaccent = 611, e1.Thorn = 611, e1.Omacron = 722, e1.Racute = 667, e1.Sacute = 556, e1.dcaron = 608, e1.Umacron = 722, e1.uring = 556, e1.threesuperior = 300, e1.Ograve = 722, e1.Agrave = 667, e1.Abreve = 667, e1.multiply = 570, e1.uacute = 556, e1.Tcaron = 611, e1.partialdiff = 494, e1.ydieresis = 444, e1.Nacute = 722, e1.icircumflex = 278, e1.Ecircumflex = 667, e1.adieresis = 500, e1.edieresis = 444, e1.cacute = 444, e1.nacute = 556, e1.umacron = 556, e1.Ncaron = 722, e1.Iacute = 389, e1.plusminus = 570, e1.brokenbar = 220, e1.registered = 747, e1.Gbreve = 722, e1.Idotaccent = 389, e1.summation = 600, e1.Egrave = 667, e1.racute = 389, e1.omacron = 500, e1.Zacute = 611, e1.Zcaron = 611, e1.greaterequal = 549, e1.Eth = 722, e1.Ccedilla = 667, e1.lcommaaccent = 278, e1.tcaron = 366, e1.eogonek = 444, e1.Uogonek = 722, e1.Aacute = 667, e1.Adieresis = 667, e1.egrave = 444, e1.zacute = 389, e1.iogonek = 278, e1.Oacute = 722, e1.oacute = 500, e1.amacron = 500, e1.sacute = 389, e1.idieresis = 278, e1.Ocircumflex = 722, e1.Ugrave = 722, e1.Delta = 612, e1.thorn = 500, e1.twosuperior = 300, e1.Odieresis = 722, e1.mu = 576, e1.igrave = 278, e1.ohungarumlaut = 500, e1.Eogonek = 667, e1.dcroat = 500, e1.threequarters = 750, e1.Scedilla = 556, e1.lcaron = 382, e1.Kcommaaccent = 667, e1.Lacute = 611, e1.trademark = 1e3, e1.edotaccent = 444, e1.Igrave = 389, e1.Imacron = 389, e1.Lcaron = 611, e1.onehalf = 750, e1.lessequal = 549, e1.ocircumflex = 500, e1.ntilde = 556, e1.Uhungarumlaut = 722, e1.Eacute = 667, e1.emacron = 444, e1.gbreve = 500, e1.onequarter = 750, e1.Scaron = 556, e1.Scommaaccent = 556, e1.Ohungarumlaut = 722, e1.degree = 400, e1.ograve = 500, e1.Ccaron = 667, e1.ugrave = 556, e1.radical = 549, e1.Dcaron = 722, e1.rcommaaccent = 389, e1.Ntilde = 722, e1.otilde = 500, e1.Rcommaaccent = 667, e1.Lcommaaccent = 611, e1.Atilde = 667, e1.Aogonek = 667, e1.Aring = 667, e1.Otilde = 722, e1.zdotaccent = 389, e1.Ecaron = 667, e1.Iogonek = 389, e1.kcommaaccent = 500, e1.minus = 606, e1.Icircumflex = 389, e1.ncaron = 556, e1.tcommaaccent = 278, e1.logicalnot = 606, e1.odieresis = 500, e1.udieresis = 556, e1.notequal = 549, e1.gcommaaccent = 500, e1.eth = 500, e1.zcaron = 389, e1.ncommaaccent = 556, e1.onesuperior = 300, e1.imacron = 278, e1.Euro = 500;
    }), e1["Times-Italic"] = getLookupTableFactory(function(e1) {
        e1.space = 250, e1.exclam = 333, e1.quotedbl = 420, e1.numbersign = 500, e1.dollar = 500, e1.percent = 833, e1.ampersand = 778, e1.quoteright = 333, e1.parenleft = 333, e1.parenright = 333, e1.asterisk = 500, e1.plus = 675, e1.comma = 250, e1.hyphen = 333, e1.period = 250, e1.slash = 278, e1.zero = 500, e1.one = 500, e1.two = 500, e1.three = 500, e1.four = 500, e1.five = 500, e1.six = 500, e1.seven = 500, e1.eight = 500, e1.nine = 500, e1.colon = 333, e1.semicolon = 333, e1.less = 675, e1.equal = 675, e1.greater = 675, e1.question = 500, e1.at = 920, e1.A = 611, e1.B = 611, e1.C = 667, e1.D = 722, e1.E = 611, e1.F = 611, e1.G = 722, e1.H = 722, e1.I = 333, e1.J = 444, e1.K = 667, e1.L = 556, e1.M = 833, e1.N = 667, e1.O = 722, e1.P = 611, e1.Q = 722, e1.R = 611, e1.S = 500, e1.T = 556, e1.U = 722, e1.V = 611, e1.W = 833, e1.X = 611, e1.Y = 556, e1.Z = 556, e1.bracketleft = 389, e1.backslash = 278, e1.bracketright = 389, e1.asciicircum = 422, e1.underscore = 500, e1.quoteleft = 333, e1.a = 500, e1.b = 500, e1.c = 444, e1.d = 500, e1.e = 444, e1.f = 278, e1.g = 500, e1.h = 500, e1.i = 278, e1.j = 278, e1.k = 444, e1.l = 278, e1.m = 722, e1.n = 500, e1.o = 500, e1.p = 500, e1.q = 500, e1.r = 389, e1.s = 389, e1.t = 278, e1.u = 500, e1.v = 444, e1.w = 667, e1.x = 444, e1.y = 444, e1.z = 389, e1.braceleft = 400, e1.bar = 275, e1.braceright = 400, e1.asciitilde = 541, e1.exclamdown = 389, e1.cent = 500, e1.sterling = 500, e1.fraction = 167, e1.yen = 500, e1.florin = 500, e1.section = 500, e1.currency = 500, e1.quotesingle = 214, e1.quotedblleft = 556, e1.guillemotleft = 500, e1.guilsinglleft = 333, e1.guilsinglright = 333, e1.fi = 500, e1.fl = 500, e1.endash = 500, e1.dagger = 500, e1.daggerdbl = 500, e1.periodcentered = 250, e1.paragraph = 523, e1.bullet = 350, e1.quotesinglbase = 333, e1.quotedblbase = 556, e1.quotedblright = 556, e1.guillemotright = 500, e1.ellipsis = 889, e1.perthousand = 1e3, e1.questiondown = 500, e1.grave = 333, e1.acute = 333, e1.circumflex = 333, e1.tilde = 333, e1.macron = 333, e1.breve = 333, e1.dotaccent = 333, e1.dieresis = 333, e1.ring = 333, e1.cedilla = 333, e1.hungarumlaut = 333, e1.ogonek = 333, e1.caron = 333, e1.emdash = 889, e1.AE = 889, e1.ordfeminine = 276, e1.Lslash = 556, e1.Oslash = 722, e1.OE = 944, e1.ordmasculine = 310, e1.ae = 667, e1.dotlessi = 278, e1.lslash = 278, e1.oslash = 500, e1.oe = 667, e1.germandbls = 500, e1.Idieresis = 333, e1.eacute = 444, e1.abreve = 500, e1.uhungarumlaut = 500, e1.ecaron = 444, e1.Ydieresis = 556, e1.divide = 675, e1.Yacute = 556, e1.Acircumflex = 611, e1.aacute = 500, e1.Ucircumflex = 722, e1.yacute = 444, e1.scommaaccent = 389, e1.ecircumflex = 444, e1.Uring = 722, e1.Udieresis = 722, e1.aogonek = 500, e1.Uacute = 722, e1.uogonek = 500, e1.Edieresis = 611, e1.Dcroat = 722, e1.commaaccent = 250, e1.copyright = 760, e1.Emacron = 611, e1.ccaron = 444, e1.aring = 500, e1.Ncommaaccent = 667, e1.lacute = 278, e1.agrave = 500, e1.Tcommaaccent = 556, e1.Cacute = 667, e1.atilde = 500, e1.Edotaccent = 611, e1.scaron = 389, e1.scedilla = 389, e1.iacute = 278, e1.lozenge = 471, e1.Rcaron = 611, e1.Gcommaaccent = 722, e1.ucircumflex = 500, e1.acircumflex = 500, e1.Amacron = 611, e1.rcaron = 389, e1.ccedilla = 444, e1.Zdotaccent = 556, e1.Thorn = 611, e1.Omacron = 722, e1.Racute = 611, e1.Sacute = 500, e1.dcaron = 544, e1.Umacron = 722, e1.uring = 500, e1.threesuperior = 300, e1.Ograve = 722, e1.Agrave = 611, e1.Abreve = 611, e1.multiply = 675, e1.uacute = 500, e1.Tcaron = 556, e1.partialdiff = 476, e1.ydieresis = 444, e1.Nacute = 667, e1.icircumflex = 278, e1.Ecircumflex = 611, e1.adieresis = 500, e1.edieresis = 444, e1.cacute = 444, e1.nacute = 500, e1.umacron = 500, e1.Ncaron = 667, e1.Iacute = 333, e1.plusminus = 675, e1.brokenbar = 275, e1.registered = 760, e1.Gbreve = 722, e1.Idotaccent = 333, e1.summation = 600, e1.Egrave = 611, e1.racute = 389, e1.omacron = 500, e1.Zacute = 556, e1.Zcaron = 556, e1.greaterequal = 549, e1.Eth = 722, e1.Ccedilla = 667, e1.lcommaaccent = 278, e1.tcaron = 300, e1.eogonek = 444, e1.Uogonek = 722, e1.Aacute = 611, e1.Adieresis = 611, e1.egrave = 444, e1.zacute = 389, e1.iogonek = 278, e1.Oacute = 722, e1.oacute = 500, e1.amacron = 500, e1.sacute = 389, e1.idieresis = 278, e1.Ocircumflex = 722, e1.Ugrave = 722, e1.Delta = 612, e1.thorn = 500, e1.twosuperior = 300, e1.Odieresis = 722, e1.mu = 500, e1.igrave = 278, e1.ohungarumlaut = 500, e1.Eogonek = 611, e1.dcroat = 500, e1.threequarters = 750, e1.Scedilla = 500, e1.lcaron = 300, e1.Kcommaaccent = 667, e1.Lacute = 556, e1.trademark = 980, e1.edotaccent = 444, e1.Igrave = 333, e1.Imacron = 333, e1.Lcaron = 611, e1.onehalf = 750, e1.lessequal = 549, e1.ocircumflex = 500, e1.ntilde = 500, e1.Uhungarumlaut = 722, e1.Eacute = 611, e1.emacron = 444, e1.gbreve = 500, e1.onequarter = 750, e1.Scaron = 500, e1.Scommaaccent = 500, e1.Ohungarumlaut = 722, e1.degree = 400, e1.ograve = 500, e1.Ccaron = 667, e1.ugrave = 500, e1.radical = 453, e1.Dcaron = 722, e1.rcommaaccent = 389, e1.Ntilde = 667, e1.otilde = 500, e1.Rcommaaccent = 611, e1.Lcommaaccent = 556, e1.Atilde = 611, e1.Aogonek = 611, e1.Aring = 611, e1.Otilde = 722, e1.zdotaccent = 389, e1.Ecaron = 611, e1.Iogonek = 333, e1.kcommaaccent = 444, e1.minus = 675, e1.Icircumflex = 333, e1.ncaron = 500, e1.tcommaaccent = 278, e1.logicalnot = 675, e1.odieresis = 500, e1.udieresis = 500, e1.notequal = 549, e1.gcommaaccent = 500, e1.eth = 500, e1.zcaron = 389, e1.ncommaaccent = 500, e1.onesuperior = 300, e1.imacron = 278, e1.Euro = 500;
    }), e1.ZapfDingbats = getLookupTableFactory(function(e1) {
        e1.space = 278, e1.a1 = 974, e1.a2 = 961, e1.a202 = 974, e1.a3 = 980, e1.a4 = 719, e1.a5 = 789, e1.a119 = 790, e1.a118 = 791, e1.a117 = 690, e1.a11 = 960, e1.a12 = 939, e1.a13 = 549, e1.a14 = 855, e1.a15 = 911, e1.a16 = 933, e1.a105 = 911, e1.a17 = 945, e1.a18 = 974, e1.a19 = 755, e1.a20 = 846, e1.a21 = 762, e1.a22 = 761, e1.a23 = 571, e1.a24 = 677, e1.a25 = 763, e1.a26 = 760, e1.a27 = 759, e1.a28 = 754, e1.a6 = 494, e1.a7 = 552, e1.a8 = 537, e1.a9 = 577, e1.a10 = 692, e1.a29 = 786, e1.a30 = 788, e1.a31 = 788, e1.a32 = 790, e1.a33 = 793, e1.a34 = 794, e1.a35 = 816, e1.a36 = 823, e1.a37 = 789, e1.a38 = 841, e1.a39 = 823, e1.a40 = 833, e1.a41 = 816, e1.a42 = 831, e1.a43 = 923, e1.a44 = 744, e1.a45 = 723, e1.a46 = 749, e1.a47 = 790, e1.a48 = 792, e1.a49 = 695, e1.a50 = 776, e1.a51 = 768, e1.a52 = 792, e1.a53 = 759, e1.a54 = 707, e1.a55 = 708, e1.a56 = 682, e1.a57 = 701, e1.a58 = 826, e1.a59 = 815, e1.a60 = 789, e1.a61 = 789, e1.a62 = 707, e1.a63 = 687, e1.a64 = 696, e1.a65 = 689, e1.a66 = 786, e1.a67 = 787, e1.a68 = 713, e1.a69 = 791, e1.a70 = 785, e1.a71 = 791, e1.a72 = 873, e1.a73 = 761, e1.a74 = 762, e1.a203 = 762, e1.a75 = 759, e1.a204 = 759, e1.a76 = 892, e1.a77 = 892, e1.a78 = 788, e1.a79 = 784, e1.a81 = 438, e1.a82 = 138, e1.a83 = 277, e1.a84 = 415, e1.a97 = 392, e1.a98 = 392, e1.a99 = 668, e1.a100 = 668, e1.a89 = 390, e1.a90 = 390, e1.a93 = 317, e1.a94 = 317, e1.a91 = 276, e1.a92 = 276, e1.a205 = 509, e1.a85 = 509, e1.a206 = 410, e1.a86 = 410, e1.a87 = 234, e1.a88 = 234, e1.a95 = 334, e1.a96 = 334, e1.a101 = 732, e1.a102 = 544, e1.a103 = 544, e1.a104 = 910, e1.a106 = 667, e1.a107 = 760, e1.a108 = 760, e1.a112 = 776, e1.a111 = 595, e1.a110 = 694, e1.a109 = 626, e1.a120 = 788, e1.a121 = 788, e1.a122 = 788, e1.a123 = 788, e1.a124 = 788, e1.a125 = 788, e1.a126 = 788, e1.a127 = 788, e1.a128 = 788, e1.a129 = 788, e1.a130 = 788, e1.a131 = 788, e1.a132 = 788, e1.a133 = 788, e1.a134 = 788, e1.a135 = 788, e1.a136 = 788, e1.a137 = 788, e1.a138 = 788, e1.a139 = 788, e1.a140 = 788, e1.a141 = 788, e1.a142 = 788, e1.a143 = 788, e1.a144 = 788, e1.a145 = 788, e1.a146 = 788, e1.a147 = 788, e1.a148 = 788, e1.a149 = 788, e1.a150 = 788, e1.a151 = 788, e1.a152 = 788, e1.a153 = 788, e1.a154 = 788, e1.a155 = 788, e1.a156 = 788, e1.a157 = 788, e1.a158 = 788, e1.a159 = 788, e1.a160 = 894, e1.a161 = 838, e1.a163 = 1016, e1.a164 = 458, e1.a196 = 748, e1.a165 = 924, e1.a192 = 748, e1.a166 = 918, e1.a167 = 927, e1.a168 = 928, e1.a169 = 928, e1.a170 = 834, e1.a171 = 873, e1.a172 = 828, e1.a173 = 924, e1.a162 = 924, e1.a174 = 917, e1.a175 = 930, e1.a176 = 931, e1.a177 = 463, e1.a178 = 883, e1.a179 = 836, e1.a193 = 836, e1.a180 = 867, e1.a199 = 867, e1.a181 = 696, e1.a200 = 696, e1.a182 = 874, e1.a201 = 874, e1.a183 = 760, e1.a184 = 946, e1.a197 = 771, e1.a185 = 865, e1.a194 = 771, e1.a198 = 888, e1.a186 = 967, e1.a195 = 888, e1.a187 = 831, e1.a188 = 873, e1.a189 = 927, e1.a190 = 970, e1.a191 = 918;
    });
}), Vn = getLookupTableFactory(function(e1) {
    e1.Courier = {
        ascent: 629,
        descent: -157,
        capHeight: 562,
        xHeight: -426
    }, e1["Courier-Bold"] = {
        ascent: 629,
        descent: -157,
        capHeight: 562,
        xHeight: 439
    }, e1["Courier-Oblique"] = {
        ascent: 629,
        descent: -157,
        capHeight: 562,
        xHeight: 426
    }, e1["Courier-BoldOblique"] = {
        ascent: 629,
        descent: -157,
        capHeight: 562,
        xHeight: 426
    }, e1.Helvetica = {
        ascent: 718,
        descent: -207,
        capHeight: 718,
        xHeight: 523
    }, e1["Helvetica-Bold"] = {
        ascent: 718,
        descent: -207,
        capHeight: 718,
        xHeight: 532
    }, e1["Helvetica-Oblique"] = {
        ascent: 718,
        descent: -207,
        capHeight: 718,
        xHeight: 523
    }, e1["Helvetica-BoldOblique"] = {
        ascent: 718,
        descent: -207,
        capHeight: 718,
        xHeight: 532
    }, e1["Times-Roman"] = {
        ascent: 683,
        descent: -217,
        capHeight: 662,
        xHeight: 450
    }, e1["Times-Bold"] = {
        ascent: 683,
        descent: -217,
        capHeight: 676,
        xHeight: 461
    }, e1["Times-Italic"] = {
        ascent: 683,
        descent: -217,
        capHeight: 653,
        xHeight: 441
    }, e1["Times-BoldItalic"] = {
        ascent: 683,
        descent: -217,
        capHeight: 669,
        xHeight: 462
    }, e1.Symbol = {
        ascent: Math.NaN,
        descent: Math.NaN,
        capHeight: Math.NaN,
        xHeight: Math.NaN
    }, e1.ZapfDingbats = {
        ascent: Math.NaN,
        descent: Math.NaN,
        capHeight: Math.NaN,
        xHeight: Math.NaN
    };
});
class GlyfTable {
    constructor({ glyfTable: e1, isGlyphLocationsLong: t, locaTable: i, numGlyphs: n }){
        this.glyphs = [];
        const a = new DataView(i.buffer, i.byteOffset, i.byteLength), s = new DataView(e1.buffer, e1.byteOffset, e1.byteLength), r = t ? 4 : 2;
        let o = t ? a.getUint32(0) : 2 * a.getUint16(0), l = 0;
        for(let e1 = 0; e1 < n; e1++){
            l += r;
            const e1 = t ? a.getUint32(l) : 2 * a.getUint16(l);
            if (e1 === o) {
                this.glyphs.push(new Glyph({}));
                continue;
            }
            const i = Glyph.parse(o, s);
            this.glyphs.push(i), o = e1;
        }
    }
    getSize() {
        return Math.sumPrecise(this.glyphs.map((e1)=>e1.getSize() + 3 & -4));
    }
    write() {
        const e1 = this.getSize(), t = new DataView(new ArrayBuffer(e1)), i = e1 > 131070, n = i ? 4 : 2, a = new DataView(new ArrayBuffer((this.glyphs.length + 1) * n));
        i ? a.setUint32(0, 0) : a.setUint16(0, 0);
        let s = 0, r = 0;
        for (const e1 of this.glyphs)s += e1.write(s, t), s = s + 3 & -4, r += n, i ? a.setUint32(r, s) : a.setUint16(r, s >> 1);
        return {
            isLocationLong: i,
            loca: new Uint8Array(a.buffer),
            glyf: new Uint8Array(t.buffer)
        };
    }
    scale(e1) {
        for(let t = 0, i = this.glyphs.length; t < i; t++)this.glyphs[t].scale(e1[t]);
    }
}
class Glyph {
    constructor({ header: e1 = null, simple: t = null, composites: i = null }){
        this.header = e1, this.simple = t, this.composites = i;
    }
    static parse(e1, t) {
        const [i, n] = GlyphHeader.parse(e1, t);
        if (e1 += i, n.numberOfContours < 0) {
            const i = [];
            for(;;){
                const [n, a] = CompositeGlyph.parse(e1, t);
                if (e1 += n, i.push(a), !(32 & a.flags)) break;
            }
            return new Glyph({
                header: n,
                composites: i
            });
        }
        const a = SimpleGlyph.parse(e1, t, n.numberOfContours);
        return new Glyph({
            header: n,
            simple: a
        });
    }
    getSize() {
        if (!this.header) return 0;
        const e1 = this.simple ? this.simple.getSize() : Math.sumPrecise(this.composites.map((e1)=>e1.getSize()));
        return this.header.getSize() + e1;
    }
    write(e1, t) {
        if (!this.header) return 0;
        const i = e1;
        if (e1 += this.header.write(e1, t), this.simple) e1 += this.simple.write(e1, t);
        else for (const i of this.composites)e1 += i.write(e1, t);
        return e1 - i;
    }
    scale(e1) {
        if (!this.header) return;
        const t = (this.header.xMin + this.header.xMax) / 2;
        if (this.header.scale(t, e1), this.simple) this.simple.scale(t, e1);
        else for (const i of this.composites)i.scale(t, e1);
    }
}
class GlyphHeader {
    constructor({ numberOfContours: e1, xMin: t, yMin: i, xMax: n, yMax: a }){
        this.numberOfContours = e1, this.xMin = t, this.yMin = i, this.xMax = n, this.yMax = a;
    }
    static parse(e1, t) {
        return [
            10,
            new GlyphHeader({
                numberOfContours: t.getInt16(e1),
                xMin: t.getInt16(e1 + 2),
                yMin: t.getInt16(e1 + 4),
                xMax: t.getInt16(e1 + 6),
                yMax: t.getInt16(e1 + 8)
            })
        ];
    }
    getSize() {
        return 10;
    }
    write(e1, t) {
        return t.setInt16(e1, this.numberOfContours), t.setInt16(e1 + 2, this.xMin), t.setInt16(e1 + 4, this.yMin), t.setInt16(e1 + 6, this.xMax), t.setInt16(e1 + 8, this.yMax), 10;
    }
    scale(e1, t) {
        this.xMin = Math.round(e1 + (this.xMin - e1) * t), this.xMax = Math.round(e1 + (this.xMax - e1) * t);
    }
}
class Contour {
    constructor({ flags: e1, xCoordinates: t, yCoordinates: i }){
        this.xCoordinates = t, this.yCoordinates = i, this.flags = e1;
    }
}
class SimpleGlyph {
    constructor({ contours: e1, instructions: t }){
        this.contours = e1, this.instructions = t;
    }
    static parse(e1, t, i) {
        const n = [];
        for(let a = 0; a < i; a++){
            const i = t.getUint16(e1);
            e1 += 2, n.push(i);
        }
        const a = n[i - 1] + 1, s = t.getUint16(e1);
        e1 += 2;
        const r = new Uint8Array(t).slice(e1, e1 + s);
        e1 += s;
        const o = [];
        for(let i = 0; i < a; e1++, i++){
            let n = t.getUint8(e1);
            if (o.push(n), 8 & n) {
                const a = t.getUint8(++e1);
                n ^= 8;
                for(let e1 = 0; e1 < a; e1++)o.push(n);
                i += a;
            }
        }
        const l = [];
        let c = [], h = [], d = [];
        const u = [];
        let g = 0, f = 0;
        for(let i = 0; i < a; i++){
            const a = o[i];
            if (2 & a) {
                const i = t.getUint8(e1++);
                f += 16 & a ? i : -i, c.push(f);
            } else 16 & a || (f += t.getInt16(e1), e1 += 2), c.push(f);
            n[g] === i && (g++, l.push(c), c = []);
        }
        f = 0, g = 0;
        for(let i = 0; i < a; i++){
            const a = o[i];
            if (4 & a) {
                const i = t.getUint8(e1++);
                f += 32 & a ? i : -i, h.push(f);
            } else 32 & a || (f += t.getInt16(e1), e1 += 2), h.push(f);
            d.push(1 & a | 64 & a), n[g] === i && (c = l[g], g++, u.push(new Contour({
                flags: d,
                xCoordinates: c,
                yCoordinates: h
            })), h = [], d = []);
        }
        return new SimpleGlyph({
            contours: u,
            instructions: r
        });
    }
    getSize() {
        let e1 = 2 * this.contours.length + 2 + this.instructions.length, t = 0, i = 0;
        for (const n of this.contours){
            e1 += n.flags.length;
            for(let a = 0, s = n.xCoordinates.length; a < s; a++){
                const s = n.xCoordinates[a], r = n.yCoordinates[a];
                let o = Math.abs(s - t);
                o > 255 ? e1 += 2 : o > 0 && (e1 += 1), t = s, o = Math.abs(r - i), o > 255 ? e1 += 2 : o > 0 && (e1 += 1), i = r;
            }
        }
        return e1;
    }
    write(e1, t) {
        const i = e1, n = [], a = [], s = [];
        let r = 0, o = 0;
        for (const i of this.contours){
            for(let e1 = 0, t = i.xCoordinates.length; e1 < t; e1++){
                let t = i.flags[e1];
                const l = i.xCoordinates[e1];
                let c = l - r;
                if (0 === c) t |= 16, n.push(0);
                else {
                    const e1 = Math.abs(c);
                    e1 <= 255 ? (t |= c >= 0 ? 18 : 2, n.push(e1)) : n.push(c);
                }
                r = l;
                const h = i.yCoordinates[e1];
                if (c = h - o, 0 === c) t |= 32, a.push(0);
                else {
                    const e1 = Math.abs(c);
                    e1 <= 255 ? (t |= c >= 0 ? 36 : 4, a.push(e1)) : a.push(c);
                }
                o = h, s.push(t);
            }
            t.setUint16(e1, n.length - 1), e1 += 2;
        }
        t.setUint16(e1, this.instructions.length), e1 += 2, this.instructions.length && (new Uint8Array(t.buffer, 0, t.buffer.byteLength).set(this.instructions, e1), e1 += this.instructions.length);
        for (const i of s)t.setUint8(e1++, i);
        for(let i = 0, a = n.length; i < a; i++){
            const a = n[i], r = s[i];
            2 & r ? t.setUint8(e1++, a) : 16 & r || (t.setInt16(e1, a), e1 += 2);
        }
        for(let i = 0, n = a.length; i < n; i++){
            const n = a[i], r = s[i];
            4 & r ? t.setUint8(e1++, n) : 32 & r || (t.setInt16(e1, n), e1 += 2);
        }
        return e1 - i;
    }
    scale(e1, t) {
        for (const i of this.contours)if (0 !== i.xCoordinates.length) for(let n = 0, a = i.xCoordinates.length; n < a; n++)i.xCoordinates[n] = Math.round(e1 + (i.xCoordinates[n] - e1) * t);
    }
}
class CompositeGlyph {
    constructor({ flags: e1, glyphIndex: t, argument1: i, argument2: n, transf: a, instructions: s }){
        this.flags = e1, this.glyphIndex = t, this.argument1 = i, this.argument2 = n, this.transf = a, this.instructions = s;
    }
    static parse(e1, t) {
        const i = e1, n = [];
        let a = t.getUint16(e1);
        const s = t.getUint16(e1 + 2);
        let r, o;
        e1 += 4, 1 & a ? (2 & a ? (r = t.getInt16(e1), o = t.getInt16(e1 + 2)) : (r = t.getUint16(e1), o = t.getUint16(e1 + 2)), e1 += 4, a ^= 1) : (2 & a ? (r = t.getInt8(e1), o = t.getInt8(e1 + 1)) : (r = t.getUint8(e1), o = t.getUint8(e1 + 1)), e1 += 2), 8 & a ? (n.push(t.getUint16(e1)), e1 += 2) : 64 & a ? (n.push(t.getUint16(e1), t.getUint16(e1 + 2)), e1 += 4) : 128 & a && (n.push(t.getUint16(e1), t.getUint16(e1 + 2), t.getUint16(e1 + 4), t.getUint16(e1 + 6)), e1 += 8);
        let l = null;
        if (256 & a) {
            const i = t.getUint16(e1);
            e1 += 2, l = new Uint8Array(t).slice(e1, e1 + i), e1 += i;
        }
        return [
            e1 - i,
            new CompositeGlyph({
                flags: a,
                glyphIndex: s,
                argument1: r,
                argument2: o,
                transf: n,
                instructions: l
            })
        ];
    }
    getSize() {
        let e1 = 4 + 2 * this.transf.length;
        return 256 & this.flags && (e1 += 2 + this.instructions.length), e1 += 2, 2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e1 += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e1 += 2), e1;
    }
    write(e1, t) {
        const i = e1;
        return 2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1), t.setUint16(e1, this.flags), t.setUint16(e1 + 2, this.glyphIndex), e1 += 4, 1 & this.flags ? (2 & this.flags ? (t.setInt16(e1, this.argument1), t.setInt16(e1 + 2, this.argument2)) : (t.setUint16(e1, this.argument1), t.setUint16(e1 + 2, this.argument2)), e1 += 4) : (t.setUint8(e1, this.argument1), t.setUint8(e1 + 1, this.argument2), e1 += 2), 256 & this.flags && (t.setUint16(e1, this.instructions.length), e1 += 2, this.instructions.length && (new Uint8Array(t.buffer, 0, t.buffer.byteLength).set(this.instructions, e1), e1 += this.instructions.length)), e1 - i;
    }
    scale(e1, t) {}
}
function writeInt16(e1, t, i) {
    e1[t] = i >> 8 & 255, e1[t + 1] = 255 & i;
}
function writeInt32(e1, t, i) {
    e1[t] = i >> 24 & 255, e1[t + 1] = i >> 16 & 255, e1[t + 2] = i >> 8 & 255, e1[t + 3] = 255 & i;
}
function writeData(e1, t, i) {
    if (i instanceof Uint8Array) e1.set(i, t);
    else if ("string" == typeof i) for(let n = 0, a = i.length; n < a; n++)e1[t++] = 255 & i.charCodeAt(n);
    else for (const n of i)e1[t++] = 255 & n;
}
class OpenTypeFileBuilder {
    constructor(e1){
        this.sfnt = e1, this.tables = Object.create(null);
    }
    static getSearchParams(e1, t) {
        let i = 1, n = 0;
        for(; (i ^ e1) > i;)i <<= 1, n++;
        const a = i * t;
        return {
            range: a,
            entry: n,
            rangeShift: t * e1 - a
        };
    }
    toArray() {
        let e1 = this.sfnt;
        const t = this.tables, i = Object.keys(t);
        i.sort();
        const n = i.length;
        let a, s, r, o, l, c = 12 + 16 * n;
        const h = [
            c
        ];
        for(a = 0; a < n; a++){
            o = t[i[a]];
            c += (o.length + 3 & -4) >>> 0, h.push(c);
        }
        const d = new Uint8Array(c);
        for(a = 0; a < n; a++)o = t[i[a]], writeData(d, h[a], o);
        "true" === e1 && (e1 = string32$1(65536)), d[0] = 255 & e1.charCodeAt(0), d[1] = 255 & e1.charCodeAt(1), d[2] = 255 & e1.charCodeAt(2), d[3] = 255 & e1.charCodeAt(3), writeInt16(d, 4, n);
        const u = OpenTypeFileBuilder.getSearchParams(n, 16);
        for(writeInt16(d, 6, u.range), writeInt16(d, 8, u.entry), writeInt16(d, 10, u.rangeShift), c = 12, a = 0; a < n; a++){
            l = i[a], d[c] = 255 & l.charCodeAt(0), d[c + 1] = 255 & l.charCodeAt(1), d[c + 2] = 255 & l.charCodeAt(2), d[c + 3] = 255 & l.charCodeAt(3);
            let e1 = 0;
            for(s = h[a], r = h[a + 1]; s < r; s += 4){
                e1 = e1 + readUint32(d, s) >>> 0;
            }
            writeInt32(d, c + 4, e1), writeInt32(d, c + 8, h[a]), writeInt32(d, c + 12, t[l].length), c += 16;
        }
        return d;
    }
    addTable(e1, t) {
        if (e1 in this.tables) throw new Error("Table " + e1 + " already exists");
        this.tables[e1] = t;
    }
}
const Kn = [
    4
], Yn = [
    5
], Jn = [
    6
], Zn = [
    7
], Qn = [
    8
], ea = [
    12,
    35
], ta = [
    14
], ia = [
    21
], na = [
    22
], aa = [
    30
], sa = [
    31
];
class Type1CharString {
    constructor(){
        this.width = 0, this.lsb = 0, this.flexing = !1, this.output = [], this.stack = [];
    }
    convert(e1, t, i) {
        const n = e1.length;
        let a, s, r, o = !1;
        for(let l = 0; l < n; l++){
            let n = e1[l];
            if (n < 32) {
                switch(12 === n && (n = (n << 8) + e1[++l]), n){
                    case 1:
                    case 3:
                    case 9:
                    case 3072:
                    case 3073:
                    case 3074:
                    case 3105:
                        this.stack = [];
                        break;
                    case 4:
                        if (this.flexing) {
                            if (this.stack.length < 1) {
                                o = !0;
                                break;
                            }
                            const e1 = this.stack.pop();
                            this.stack.push(0, e1);
                            break;
                        }
                        o = this.executeCommand(1, Kn);
                        break;
                    case 5:
                        o = this.executeCommand(2, Yn);
                        break;
                    case 6:
                        o = this.executeCommand(1, Jn);
                        break;
                    case 7:
                        o = this.executeCommand(1, Zn);
                        break;
                    case 8:
                        o = this.executeCommand(6, Qn);
                        break;
                    case 10:
                        if (this.stack.length < 1) {
                            o = !0;
                            break;
                        }
                        if (r = this.stack.pop(), !t[r]) {
                            o = !0;
                            break;
                        }
                        o = this.convert(t[r], t, i);
                        break;
                    case 11:
                        return o;
                    case 13:
                        if (this.stack.length < 2) {
                            o = !0;
                            break;
                        }
                        a = this.stack.pop(), s = this.stack.pop(), this.lsb = s, this.width = a, this.stack.push(a, s), o = this.executeCommand(2, na);
                        break;
                    case 14:
                        this.output.push(ta[0]);
                        break;
                    case 21:
                        if (this.flexing) break;
                        o = this.executeCommand(2, ia);
                        break;
                    case 22:
                        if (this.flexing) {
                            this.stack.push(0);
                            break;
                        }
                        o = this.executeCommand(1, na);
                        break;
                    case 30:
                        o = this.executeCommand(4, aa);
                        break;
                    case 31:
                        o = this.executeCommand(4, sa);
                        break;
                    case 3078:
                        if (i) {
                            const e1 = this.stack.at(-5);
                            this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - e1, o = this.executeCommand(0, ta);
                        } else o = this.executeCommand(4, ta);
                        break;
                    case 3079:
                        if (this.stack.length < 4) {
                            o = !0;
                            break;
                        }
                        this.stack.pop(), a = this.stack.pop();
                        const e2 = this.stack.pop();
                        s = this.stack.pop(), this.lsb = s, this.width = a, this.stack.push(a, s, e2), o = this.executeCommand(3, ia);
                        break;
                    case 3084:
                        if (this.stack.length < 2) {
                            o = !0;
                            break;
                        }
                        const l1 = this.stack.pop(), c = this.stack.pop();
                        this.stack.push(c / l1);
                        break;
                    case 3088:
                        if (this.stack.length < 2) {
                            o = !0;
                            break;
                        }
                        r = this.stack.pop();
                        const h = this.stack.pop();
                        if (0 === r && 3 === h) {
                            const e1 = this.stack.splice(-17, 17);
                            this.stack.push(e1[2] + e1[0], e1[3] + e1[1], e1[4], e1[5], e1[6], e1[7], e1[8], e1[9], e1[10], e1[11], e1[12], e1[13], e1[14]), o = this.executeCommand(13, ea, !0), this.flexing = !1, this.stack.push(e1[15], e1[16]);
                        } else 1 === r && 0 === h && (this.flexing = !0);
                        break;
                    case 3089:
                        break;
                    default:
                        warn$1('Unknown type 1 charstring command of "' + n + '"');
                }
                if (o) break;
            } else n <= 246 ? n -= 139 : n = n <= 250 ? 256 * (n - 247) + e1[++l] + 108 : n <= 254 ? -256 * (n - 251) - e1[++l] - 108 : (255 & e1[++l]) << 24 | (255 & e1[++l]) << 16 | (255 & e1[++l]) << 8 | 255 & e1[++l], this.stack.push(n);
        }
        return o;
    }
    executeCommand(e1, t, i) {
        const n = this.stack.length;
        if (e1 > n) return !0;
        const a = n - e1;
        for(let e1 = a; e1 < n; e1++){
            let t = this.stack[e1];
            Number.isInteger(t) ? this.output.push(28, t >> 8 & 255, 255 & t) : (t = 65536 * t | 0, this.output.push(255, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t));
        }
        return this.output.push(...t), i ? this.stack.splice(a, e1) : this.stack.length = 0, !1;
    }
}
function isHexDigit(e1) {
    return e1 >= 48 && e1 <= 57 || e1 >= 65 && e1 <= 70 || e1 >= 97 && e1 <= 102;
}
function decrypt(e1, t, i) {
    if (i >= e1.length) return new Uint8Array(0);
    let n, a, s = 0 | t;
    for(n = 0; n < i; n++)s = 52845 * (e1[n] + s) + 22719 & 65535;
    const r = e1.length - i, o = new Uint8Array(r);
    for(n = i, a = 0; a < r; n++, a++){
        const t = e1[n];
        o[a] = t ^ s >> 8, s = 52845 * (t + s) + 22719 & 65535;
    }
    return o;
}
function isSpecial(e1) {
    return 47 === e1 || 91 === e1 || 93 === e1 || 123 === e1 || 125 === e1 || 40 === e1 || 41 === e1;
}
class Type1Parser {
    constructor(e1, t, i){
        if (t) {
            const t = e1.getBytes(), i = !((isHexDigit(t[0]) || isWhiteSpace(t[0])) && isHexDigit(t[1]) && isHexDigit(t[2]) && isHexDigit(t[3]) && isHexDigit(t[4]) && isHexDigit(t[5]) && isHexDigit(t[6]) && isHexDigit(t[7]));
            e1 = new Stream(i ? decrypt(t, 55665, 4) : function(e1, t, i) {
                let n = 0 | t;
                const a = e1.length, s = new Uint8Array(a >>> 1);
                let r, o;
                for(r = 0, o = 0; r < a; r++){
                    const t = e1[r];
                    if (!isHexDigit(t)) continue;
                    let i;
                    for(r++; r < a && !isHexDigit(i = e1[r]);)r++;
                    if (r < a) {
                        const e1 = parseInt(String.fromCharCode(t, i), 16);
                        s[o++] = e1 ^ n >> 8, n = 52845 * (e1 + n) + 22719 & 65535;
                    }
                }
                return s.slice(i, o);
            }(t, 55665, 4));
        }
        this.seacAnalysisEnabled = !!i, this.stream = e1, this.nextChar();
    }
    readNumberArray() {
        this.getToken();
        const e1 = [];
        for(;;){
            const t = this.getToken();
            if (null === t || "]" === t || "}" === t) break;
            e1.push(parseFloat(t || 0));
        }
        return e1;
    }
    readNumber() {
        const e1 = this.getToken();
        return parseFloat(e1 || 0);
    }
    readInt() {
        const e1 = this.getToken();
        return 0 | parseInt(e1 || 0, 10);
    }
    readBoolean() {
        return "true" === this.getToken() ? 1 : 0;
    }
    nextChar() {
        return this.currentChar = this.stream.getByte();
    }
    prevChar() {
        return this.stream.skip(-2), this.currentChar = this.stream.getByte();
    }
    getToken() {
        let e1 = !1, t = this.currentChar;
        for(;;){
            if (-1 === t) return null;
            if (e1) 10 !== t && 13 !== t || (e1 = !1);
            else if (37 === t) e1 = !0;
            else if (!isWhiteSpace(t)) break;
            t = this.nextChar();
        }
        if (isSpecial(t)) return this.nextChar(), String.fromCharCode(t);
        let i = "";
        do {
            i += String.fromCharCode(t), t = this.nextChar();
        }while (t >= 0 && !isWhiteSpace(t) && !isSpecial(t))
        return i;
    }
    readCharStrings(e1, t) {
        return -1 === t ? e1 : decrypt(e1, 4330, t);
    }
    extractFontProgram(e1) {
        const t = this.stream, i = [], n = [], a = Object.create(null);
        a.lenIV = 4;
        const s = {
            subrs: [],
            charstrings: [],
            properties: {
                privateData: a
            }
        };
        let r, o, l, c;
        for(; null !== (r = this.getToken());)if ("/" === r) switch(r = this.getToken(), r){
            case "CharStrings":
                for(this.getToken(), this.getToken(), this.getToken(), this.getToken(); r = this.getToken(), null !== r && "end" !== r;){
                    if ("/" !== r) continue;
                    const e1 = this.getToken();
                    o = this.readInt(), this.getToken(), l = o > 0 ? t.getBytes(o) : new Uint8Array(0), c = s.properties.privateData.lenIV;
                    const i = this.readCharStrings(l, c);
                    this.nextChar(), r = this.getToken(), "noaccess" === r ? this.getToken() : "/" === r && this.prevChar(), n.push({
                        glyph: e1,
                        encoded: i
                    });
                }
                break;
            case "Subrs":
                for(this.readInt(), this.getToken(); "dup" === this.getToken();){
                    const e1 = this.readInt();
                    o = this.readInt(), this.getToken(), l = o > 0 ? t.getBytes(o) : new Uint8Array(0), c = s.properties.privateData.lenIV;
                    const n = this.readCharStrings(l, c);
                    this.nextChar(), r = this.getToken(), "noaccess" === r && this.getToken(), i[e1] = n;
                }
                break;
            case "BlueValues":
            case "OtherBlues":
            case "FamilyBlues":
            case "FamilyOtherBlues":
                const e1 = this.readNumberArray();
                e1.length > 0 && e1.length, 0;
                break;
            case "StemSnapH":
            case "StemSnapV":
                s.properties.privateData[r] = this.readNumberArray();
                break;
            case "StdHW":
            case "StdVW":
                s.properties.privateData[r] = this.readNumberArray()[0];
                break;
            case "BlueShift":
            case "lenIV":
            case "BlueFuzz":
            case "BlueScale":
            case "LanguageGroup":
                s.properties.privateData[r] = this.readNumber();
                break;
            case "ExpansionFactor":
                s.properties.privateData[r] = this.readNumber() || .06;
                break;
            case "ForceBold":
                s.properties.privateData[r] = this.readBoolean();
        }
        for (const { encoded: t, glyph: a } of n){
            const n = new Type1CharString, r = n.convert(t, i, this.seacAnalysisEnabled);
            let o = n.output;
            r && (o = [
                14
            ]);
            const l = {
                glyphName: a,
                charstring: o,
                width: n.width,
                lsb: n.lsb,
                seac: n.seac
            };
            if (".notdef" === a ? s.charstrings.unshift(l) : s.charstrings.push(l), e1.builtInEncoding) {
                const t = e1.builtInEncoding.indexOf(a);
                t > -1 && void 0 === e1.widths[t] && t >= e1.firstChar && t <= e1.lastChar && (e1.widths[t] = n.width);
            }
        }
        return s;
    }
    extractFontHeader(e1) {
        let t;
        for(; null !== (t = this.getToken());)if ("/" === t) switch(t = this.getToken(), t){
            case "FontMatrix":
                const i = this.readNumberArray();
                e1.fontMatrix = i;
                break;
            case "Encoding":
                const n = this.getToken();
                let a;
                if (/^\d+$/.test(n)) {
                    a = [];
                    const e1 = 0 | parseInt(n, 10);
                    this.getToken();
                    for(let i = 0; i < e1; i++){
                        for(t = this.getToken(); "dup" !== t && "def" !== t;)if (t = this.getToken(), null === t) return;
                        if ("def" === t) break;
                        const e1 = this.readInt();
                        this.getToken();
                        const i = this.getToken();
                        a[e1] = i, this.getToken();
                    }
                } else a = getEncoding(n);
                e1.builtInEncoding = a;
                break;
            case "FontBBox":
                const s = this.readNumberArray();
                e1.ascent = Math.max(s[3], s[1]), e1.descent = Math.min(s[1], s[3]), e1.ascentScaled = !0;
        }
    }
}
function findBlock(e1, t, i) {
    const n = e1.length, a = t.length, s = n - a;
    let r = i, o = !1;
    for(; r < s;){
        let i = 0;
        for(; i < a && e1[r + i] === t[i];)i++;
        if (i >= a) {
            for(r += i; r < n && isWhiteSpace(e1[r]);)r++;
            o = !0;
            break;
        }
        r++;
    }
    return {
        found: o,
        length: r
    };
}
class Type1Font {
    constructor(e1, t, i){
        let n = i.length1;
        i.length2;
        let a = t.peekBytes(6);
        const s = 128 === a[0] && 1 === a[1];
        s && (t.skip(6), n = a[5] << 24 | a[4] << 16 | a[3] << 8 | a[2]);
        const r = function(e1, t) {
            const i = [
                101,
                101,
                120,
                101,
                99
            ], n = e1.pos;
            let a, s, r, o;
            try {
                a = e1.getBytes(t), s = a.length;
            } catch  {}
            if (s === t && (r = findBlock(a, i, t - 2 * i.length), r.found && r.length === t)) return {
                stream: new Stream(a),
                length: t
            };
            for(warn$1('Invalid "Length1" property in Type1 font -- trying to recover.'), e1.pos = n; r = findBlock(e1.peekBytes(2048), i, 0), 0 !== r.length;)if (e1.pos += r.length, r.found) {
                o = e1.pos - n;
                break;
            }
            return e1.pos = n, o ? {
                stream: new Stream(e1.getBytes(o)),
                length: o
            } : (warn$1('Unable to recover "Length1" property in Type1 font -- using as is.'), {
                stream: new Stream(e1.getBytes(t)),
                length: t
            });
        }(t, n);
        new Type1Parser(r.stream, !1, Sn).extractFontHeader(i), s && (a = t.getBytes(6), a[5], a[4], a[3], a[2]);
        const o = function(e1) {
            const t = e1.getBytes();
            if (0 === t.length) throw new ti("getEexecBlock - no font program found.");
            return {
                stream: new Stream(t),
                length: t.length
            };
        }(t), l = new Type1Parser(o.stream, !0, Sn).extractFontProgram(i);
        for(const e1 in l.properties)i[e1] = l.properties[e1];
        const c = l.charstrings, h = this.getType2Charstrings(c), d = this.getType2Subrs(l.subrs);
        this.charstrings = c, this.data = this.wrap(e1, h, this.charstrings, d, i), this.seacs = this.getSeacs(l.charstrings);
    }
    get numGlyphs() {
        return this.charstrings.length + 1;
    }
    getCharset() {
        const e1 = [
            ".notdef"
        ];
        for (const { glyphName: t } of this.charstrings)e1.push(t);
        return e1;
    }
    getGlyphMapping(e1) {
        const t = this.charstrings;
        if (e1.composite) {
            const i = Object.create(null);
            for(let n = 0, a = t.length; n < a; n++){
                i[e1.cMap.charCodeOf(n)] = n + 1;
            }
            return i;
        }
        const i = [
            ".notdef"
        ];
        let n, a;
        for(a = 0; a < t.length; a++)i.push(t[a].glyphName);
        const s = e1.builtInEncoding;
        if (s) {
            n = Object.create(null);
            for(const e1 in s)a = i.indexOf(s[e1]), a >= 0 && (n[e1] = a);
        }
        return type1FontGlyphMapping(e1, n, i);
    }
    hasGlyphId(e1) {
        if (e1 < 0 || e1 >= this.numGlyphs) return !1;
        if (0 === e1) return !0;
        return this.charstrings[e1 - 1].charstring.length > 0;
    }
    getSeacs(e1) {
        const t = [];
        for(let i = 0, n = e1.length; i < n; i++){
            const n = e1[i];
            n.seac && (t[i + 1] = n.seac);
        }
        return t;
    }
    getType2Charstrings(e1) {
        const t = [];
        for (const i of e1)t.push(i.charstring);
        return t;
    }
    getType2Subrs(e1) {
        let t = 0;
        const i = e1.length;
        t = i < 1133 ? 107 : i < 33769 ? 1131 : 32768;
        const n = [];
        let a;
        for(a = 0; a < t; a++)n.push([
            11
        ]);
        for(a = 0; a < i; a++)n.push(e1[a]);
        return n;
    }
    wrap(e1, t, i, n, a) {
        const s = new CFF;
        s.header = new CFFHeader(1, 0, 4, 4), s.names = [
            e1
        ];
        const r = new CFFTopDict;
        r.setByName("version", 391), r.setByName("Notice", 392), r.setByName("FullName", 393), r.setByName("FamilyName", 394), r.setByName("Weight", 395), r.setByName("Encoding", null), r.setByName("FontMatrix", a.fontMatrix), r.setByName("FontBBox", a.bbox), r.setByName("charset", null), r.setByName("CharStrings", null), r.setByName("Private", null), s.topDict = r;
        const o = new CFFStrings;
        o.add("Version 0.11"), o.add("See original notice"), o.add(e1), o.add(e1), o.add("Medium"), s.strings = o, s.globalSubrIndex = new CFFIndex;
        const l = t.length, c = [
            ".notdef"
        ];
        let h, d;
        for(h = 0; h < l; h++){
            const e1 = i[h].glyphName;
            -1 === On.indexOf(e1) && o.add(e1), c.push(e1);
        }
        s.charset = new CFFCharset(!1, 0, c);
        const u = new CFFIndex;
        for(u.add([
            139,
            14
        ]), h = 0; h < l; h++)u.add(t[h]);
        s.charStrings = u;
        const g = new CFFPrivateDict;
        g.setByName("Subrs", null);
        const f = [
            "BlueValues",
            "OtherBlues",
            "FamilyBlues",
            "FamilyOtherBlues",
            "StemSnapH",
            "StemSnapV",
            "BlueShift",
            "BlueFuzz",
            "BlueScale",
            "LanguageGroup",
            "ExpansionFactor",
            "ForceBold",
            "StdHW",
            "StdVW"
        ];
        for(h = 0, d = f.length; h < d; h++){
            const e1 = f[h];
            if (!(e1 in a.privateData)) continue;
            const t = a.privateData[e1];
            if (Array.isArray(t)) for(let e1 = t.length - 1; e1 > 0; e1--)t[e1] -= t[e1 - 1];
            g.setByName(e1, t);
        }
        s.topDict.privateDict = g;
        const p = new CFFIndex;
        for(h = 0, d = n.length; h < d; h++)p.add(n[h]);
        g.subrsIndex = p;
        return new CFFCompiler(s).compile();
    }
}
const ra = [
    [
        57344,
        63743
    ],
    [
        1048576,
        1114109
    ]
], oa = 1e3, la = [
    "ascent",
    "bbox",
    "black",
    "bold",
    "charProcOperatorList",
    "cssFontInfo",
    "data",
    "defaultVMetrics",
    "defaultWidth",
    "descent",
    "disableFontFace",
    "fallbackName",
    "fontExtraProperties",
    "fontMatrix",
    "isInvalidPDFjsFont",
    "isType3Font",
    "italic",
    "loadedName",
    "mimetype",
    "missingFile",
    "name",
    "remeasure",
    "systemFontInfo",
    "vertical"
], ca = [
    "cMap",
    "composite",
    "defaultEncoding",
    "differences",
    "isMonospace",
    "isSerifFont",
    "isSymbolicFont",
    "seacMap",
    "subtype",
    "toFontChar",
    "toUnicode",
    "type",
    "vmetrics",
    "widths"
];
function adjustWidths(e1) {
    if (!e1.fontMatrix) return;
    if (e1.fontMatrix[0] === t[0]) return;
    const i = .001 / e1.fontMatrix[0], n = e1.widths;
    for(const e1 in n)n[e1] *= i;
    e1.defaultWidth *= i;
}
function amendFallbackToUnicode(e1) {
    if (!e1.fallbackToUnicode) return;
    if (e1.toUnicode instanceof IdentityToUnicodeMap) return;
    const t = [];
    for(const i in e1.fallbackToUnicode)e1.toUnicode.has(i) || (t[i] = e1.fallbackToUnicode[i]);
    t.length > 0 && e1.toUnicode.amend(t);
}
class fonts_Glyph {
    constructor(e1, t, i, n, a, s, r, o, l){
        this.originalCharCode = e1, this.fontChar = t, this.unicode = i, this.accent = n, this.width = a, this.vmetric = s, this.operatorListId = r, this.isSpace = o, this.isInFont = l;
    }
    get category() {
        return shadow$1(this, "category", function(e1) {
            const t = xn.get(e1);
            if (t) return t;
            const i = e1.match(An), n = {
                isWhitespace: !!i?.[1],
                isZeroWidthDiacritic: !!i?.[2],
                isInvisibleFormatMark: !!i?.[3]
            };
            return xn.set(e1, n), n;
        }(this.unicode), !0);
    }
}
function int16(e1, t) {
    return (e1 << 8) + t;
}
function writeSignedInt16(e1, t, i) {
    e1[t + 1] = i, e1[t] = i >>> 8;
}
function signedInt16(e1, t) {
    const i = (e1 << 8) + t;
    return 32768 & i ? i - 65536 : i;
}
function string16(e1) {
    return String.fromCharCode(e1 >> 8 & 255, 255 & e1);
}
function safeString16(e1) {
    return e1 > 32767 ? e1 = 32767 : e1 < -32768 && (e1 = -32768), String.fromCharCode(e1 >> 8 & 255, 255 & e1);
}
function isTrueTypeCollectionFile(e1) {
    return "ttcf" === bytesToString$1(e1.peekBytes(4));
}
function getFontFileType(e1, { type: t, subtype: i, composite: n }) {
    let a, s;
    return function(e1) {
        const t = e1.peekBytes(4);
        return 65536 === readUint32(t, 0) || "true" === bytesToString$1(t);
    }(e1) || isTrueTypeCollectionFile(e1) ? a = n ? "CIDFontType2" : "TrueType" : !function(e1) {
        return "OTTO" === bytesToString$1(e1.peekBytes(4));
    }(e1) ? !function(e1) {
        const t = e1.peekBytes(2);
        return 37 === t[0] && 33 === t[1] || 128 === t[0] && 1 === t[1];
    }(e1) ? !function(e1) {
        const t = e1.peekBytes(4);
        return t[0] >= 1 && t[3] >= 1 && t[3] <= 4;
    }(e1) ? (warn$1("getFontFileType: Unable to detect correct font file Type/Subtype."), a = t, s = i) : n ? (a = "CIDFontType0", s = "CIDFontType0C") : (a = "MMType1" === t ? "MMType1" : "Type1", s = "Type1C") : a = n ? "CIDFontType0" : "MMType1" === t ? "MMType1" : "Type1" : a = n ? "CIDFontType2" : "OpenType", [
        a,
        s
    ];
}
function applyStandardFontGlyphMap(e1, t) {
    for(const i in t)e1[+i] = t[i];
}
function buildToFontChar(e1, t, i) {
    const n = [];
    let a;
    for(let i = 0, s = e1.length; i < s; i++)a = getUnicodeForGlyph(e1[i], t), -1 !== a && (n[i] = a);
    for(const e1 in i)a = getUnicodeForGlyph(i[e1], t), -1 !== a && (n[+e1] = a);
    return n;
}
function isMacNameRecord(e1) {
    return 1 === e1.platform && 0 === e1.encoding && 0 === e1.language;
}
function isWinNameRecord(e1) {
    return 3 === e1.platform && 1 === e1.encoding && 1033 === e1.language;
}
function convertCidString(e1, t, i = !1) {
    switch(t.length){
        case 1:
            return t.charCodeAt(0);
        case 2:
            return t.charCodeAt(0) << 8 | t.charCodeAt(1);
    }
    const n = `Unsupported CID string (charCode ${e1}): "${t}".`;
    if (i) throw new ti(n);
    return warn$1(n), t;
}
function adjustMapping(e1, t, i, n) {
    const a = Object.create(null), s = new Map, r = [], o = new Set;
    let l = 0;
    let c = ra[l][0], h = ra[l][1];
    const isInPrivateArea = (e1)=>ra[0][0] <= e1 && e1 <= ra[0][1] || ra[1][0] <= e1 && e1 <= ra[1][1];
    let d = null;
    for(const u in e1){
        let g = e1[u];
        if (!t(g)) continue;
        if (c > h) {
            if (l++, l >= ra.length) {
                warn$1("Ran out of space in font private use area.");
                break;
            }
            c = ra[l][0], h = ra[l][1];
        }
        const f = c++;
        0 === g && (g = i);
        let p = n.get(u);
        if ("string" == typeof p) if (1 === p.length) p = p.codePointAt(0);
        else {
            if (!d) {
                d = new Map;
                for(let e1 = 64256; e1 <= 64335; e1++){
                    const t = String.fromCharCode(e1).normalize("NFKD");
                    t.length > 1 && d.set(t, e1);
                }
            }
            p = d.get(p) || p.codePointAt(0);
        }
        !p || isInPrivateArea(p) || o.has(g) || (s.set(p, g), o.add(g)), a[f] = g, r[u] = f;
    }
    return {
        toFontChar: r,
        charCodeToGlyphId: a,
        toUnicodeExtraMap: s,
        nextAvailableFontCharCode: c
    };
}
function createCmapTable(e1, t, i) {
    const n = function(e1, t, i) {
        const n = [];
        for(const t in e1)e1[t] >= i || n.push({
            fontCharCode: 0 | t,
            glyphId: e1[t]
        });
        if (t) for (const [e1, a] of t)a >= i || n.push({
            fontCharCode: e1,
            glyphId: a
        });
        0 === n.length && n.push({
            fontCharCode: 0,
            glyphId: 0
        }), n.sort((e1, t)=>e1.fontCharCode - t.fontCharCode);
        const a = [], s = n.length;
        for(let e1 = 0; e1 < s;){
            const t = n[e1].fontCharCode, i = [
                n[e1].glyphId
            ];
            ++e1;
            let r = t;
            for(; e1 < s && r + 1 === n[e1].fontCharCode && (i.push(n[e1].glyphId), ++r, ++e1, 65535 !== r););
            a.push([
                t,
                r,
                i
            ]);
        }
        return a;
    }(e1, t, i), a = n.at(-1)[1] > 65535 ? 2 : 1;
    let s, r, o, l, c = "\0\0" + string16(a) + "\0\0" + string32$1(4 + 8 * a);
    for(s = n.length - 1; s >= 0 && !(n[s][0] <= 65535); --s);
    const h = s + 1;
    n[s][0] < 65535 && 65535 === n[s][1] && (n[s][1] = 65534);
    const d = n[s][1] < 65535 ? 1 : 0, u = h + d, g = OpenTypeFileBuilder.getSearchParams(u, 2);
    let f, p, m, b, y = "", w = "", x = "", S = "", v = "", C = 0;
    for(s = 0, r = h; s < r; s++){
        f = n[s], p = f[0], m = f[1], y += string16(p), w += string16(m), b = f[2];
        let e1 = !0;
        for(o = 1, l = b.length; o < l; ++o)if (b[o] !== b[o - 1] + 1) {
            e1 = !1;
            break;
        }
        if (e1) {
            x += string16(b[0] - p & 65535), S += string16(0);
        } else {
            const e1 = 2 * (u - s) + 2 * C;
            for(C += m - p + 1, x += string16(0), S += string16(e1), o = 0, l = b.length; o < l; ++o)v += string16(b[o]);
        }
    }
    d > 0 && (w += "Ã¿Ã¿", y += "Ã¿Ã¿", x += "\0", S += "\0\0");
    const k = "\0\0" + string16(2 * u) + string16(g.range) + string16(g.entry) + string16(g.rangeShift) + w + "\0\0" + y + x + S + v;
    let T = "", F = "";
    if (a > 1) {
        for(c += "\0\0\n" + string32$1(4 + 8 * a + 4 + k.length), T = "", s = 0, r = n.length; s < r; s++){
            f = n[s], p = f[0], b = f[2];
            let e1 = b[0];
            for(o = 1, l = b.length; o < l; ++o)b[o] !== b[o - 1] + 1 && (m = f[0] + o - 1, T += string32$1(p) + string32$1(m) + string32$1(e1), p = m + 1, e1 = b[o]);
            T += string32$1(p) + string32$1(f[1]) + string32$1(e1);
        }
        F = "\0\f\0\0" + string32$1(T.length + 16) + "\0\0\0\0" + string32$1(T.length / 12);
    }
    return c + "\0" + string16(k.length + 4) + k + F + T;
}
function createOS2Table(e1, t, i) {
    i ||= {
        unitsPerEm: 0,
        yMax: 0,
        yMin: 0,
        ascent: 0,
        descent: 0
    };
    let n = 0, a = 0, s = 0, r = 0, o = null, l = 0, c = -1;
    if (t) {
        for(let e1 in t)if (e1 |= 0, (o > e1 || !o) && (o = e1), l < e1 && (l = e1), c = getUnicodeRangeFor(e1, c), c < 32) n |= 1 << c;
        else if (c < 64) a |= 1 << c - 32;
        else if (c < 96) s |= 1 << c - 64;
        else {
            if (!(c < 123)) throw new ti("Unicode ranges Bits > 123 are reserved for internal usage");
            r |= 1 << c - 96;
        }
        l > 65535 && (l = 65535);
    } else o = 0, l = 255;
    const h = e1.bbox || [
        0,
        0,
        0,
        0
    ], d = i.unitsPerEm || (e1.fontMatrix ? 1 / Math.max(...e1.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), u = e1.ascentScaled ? 1 : d / oa, g = i.ascent || Math.round(u * (e1.ascent || h[3]));
    let f = i.descent || Math.round(u * (e1.descent || h[1]));
    f > 0 && e1.descent > 0 && h[1] < 0 && (f = -f);
    const p = i.yMax || g, m = -i.yMin || -f;
    return "\0$Ã´\0\0\0ÂÂ»\0\0\0ÂÂÂ»\0\0Ã\x001\0\0\0\0" + String.fromCharCode(e1.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + string32$1(n) + string32$1(a) + string32$1(s) + string32$1(r) + "*21*" + string16(e1.italicAngle ? 1 : 0) + string16(o || e1.firstChar) + string16(l || e1.lastChar) + string16(g) + string16(f) + "\0d" + string16(p) + string16(m) + "\0\0\0\0\0\0\0\0" + string16(e1.xHeight) + string16(e1.capHeight) + string16(0) + string16(o || e1.firstChar) + "\0";
}
function createPostTable(e1) {
    return "\0\0\0" + string32$1(Math.floor(65536 * e1.italicAngle)) + "\0\0\0\0" + string32$1(e1.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function createPostscriptName(e1) {
    return e1.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function createNameTable(e1, t) {
    t || (t = [
        [],
        []
    ]);
    const i = [
        t[0][0] || "Original licence",
        t[0][1] || e1,
        t[0][2] || "Unknown",
        t[0][3] || "uniqueID",
        t[0][4] || e1,
        t[0][5] || "Version 0.11",
        t[0][6] || createPostscriptName(e1),
        t[0][7] || "Unknown",
        t[0][8] || "Unknown",
        t[0][9] || "Unknown"
    ], n = [];
    let a, s, r, o, l;
    for(a = 0, s = i.length; a < s; a++){
        l = t[1][a] || i[a];
        const e1 = [];
        for(r = 0, o = l.length; r < o; r++)e1.push(string16(l.charCodeAt(r)));
        n.push(e1.join(""));
    }
    const c = [
        i,
        n
    ], h = [
        "\0",
        "\0"
    ], d = [
        "\0\0",
        "\0"
    ], u = [
        "\0\0",
        "\t"
    ], g = i.length * h.length;
    let f = "\0\0" + string16(g) + string16(12 * g + 6), p = 0;
    for(a = 0, s = h.length; a < s; a++){
        const e1 = c[a];
        for(r = 0, o = e1.length; r < o; r++){
            l = e1[r];
            f += h[a] + d[a] + u[a] + string16(r) + string16(l.length) + string16(p), p += l.length;
        }
    }
    return f += i.join("") + n.join(""), f;
}
class Font {
    constructor(e1, t, i, n){
        this.name = e1, this.psName = null, this.mimetype = null, this.disableFontFace = n.disableFontFace, this.fontExtraProperties = n.fontExtraProperties, this.loadedName = i.loadedName, this.isType3Font = i.isType3Font, this.missingFile = !1, this.cssFontInfo = i.cssFontInfo, this._charsCache = Object.create(null), this._glyphCache = Object.create(null);
        let a = !!(i.flags & Cn);
        if (!a && !i.isSimulatedFlags) {
            const t = Un(), i = $n(), n = Hn();
            for (const s of e1.split("+")){
                let e1 = s.replaceAll(/[,_]/g, "-");
                if (e1 = t[e1] || i[e1] || e1, e1 = e1.split("-", 1)[0], n[e1]) {
                    a = !0;
                    break;
                }
            }
        }
        this.isSerifFont = a, this.isSymbolicFont = !!(i.flags & kn), this.isMonospace = !!(i.flags & vn);
        let { type: s, subtype: r } = i;
        this.type = s, this.subtype = r, this.systemFontInfo = i.systemFontInfo;
        const o = e1.match(/^InvalidPDFjsFont_(.*)_\d+$/);
        if (this.isInvalidPDFjsFont = !!o, this.isInvalidPDFjsFont ? this.fallbackName = o[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif", this.systemFontInfo?.guessFallback && (this.systemFontInfo.guessFallback = !1, this.systemFontInfo.css += `,${this.fallbackName}`), this.differences = i.differences, this.widths = i.widths, this.defaultWidth = i.defaultWidth, this.composite = i.composite, this.cMap = i.cMap, this.capHeight = i.capHeight / oa, this.ascent = i.ascent / oa, this.descent = i.descent / oa, this.lineHeight = this.ascent - this.descent, this.fontMatrix = i.fontMatrix, this.bbox = i.bbox, this.defaultEncoding = i.defaultEncoding, this.toUnicode = i.toUnicode, this.toFontChar = [], "Type3" === i.type) {
            for(let e1 = 0; e1 < 256; e1++)this.toFontChar[e1] = this.differences[e1] || i.defaultEncoding[e1];
            return;
        }
        if (this.cidEncoding = i.cidEncoding || "", this.vertical = !!i.vertical, this.vertical && (this.vmetrics = i.vmetrics, this.defaultVMetrics = i.defaultVMetrics), !t || t.isEmpty) return t && warn$1('Font file is empty in "' + e1 + '" (' + this.loadedName + ")"), void this.fallbackToSystemFont(i);
        let l;
        [s, r] = getFontFileType(t, i), s === this.type && r === this.subtype || info$1(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${s}/${r}.`);
        try {
            switch(s){
                case "MMType1":
                    info$1("MMType1 font (" + e1 + "), falling back to Type1.");
                case "Type1":
                case "CIDFontType0":
                    this.mimetype = "font/opentype";
                    const n = "Type1C" === r || "CIDFontType0C" === r ? new CFFFont(t, i) : new Type1Font(e1, t, i);
                    adjustWidths(i), l = this.convert(e1, n, i);
                    break;
                case "OpenType":
                case "TrueType":
                case "CIDFontType2":
                    this.mimetype = "font/opentype", l = this.checkAndRepair(e1, t, i), adjustWidths(i), this.isOpenType && (s = "OpenType");
                    break;
                default:
                    throw new ti(`Font ${s} is not supported`);
            }
        } catch (e1) {
            return warn$1(e1), void this.fallbackToSystemFont(i);
        }
        amendFallbackToUnicode(i), this.data = l, this.type = s, this.subtype = r, this.fontMatrix = i.fontMatrix, this.widths = i.widths, this.defaultWidth = i.defaultWidth, this.toUnicode = i.toUnicode, this.seacMap = i.seacMap;
    }
    get renderer() {
        return shadow$1(this, "renderer", FontRendererFactory.create(this, Sn));
    }
    exportData() {
        const e1 = Object.create(null);
        for (const t of la){
            const i = this[t];
            void 0 !== i && (e1[t] = i);
        }
        if (!this.fontExtraProperties) return {
            data: e1
        };
        const t = Object.create(null);
        for (const e1 of ca){
            const i = this[e1];
            void 0 !== i && (t[e1] = i);
        }
        return {
            data: e1,
            extra: t
        };
    }
    fallbackToSystemFont(e1) {
        this.missingFile = !0;
        const { name: t, type: i } = this;
        let n = normalizeFontName(t);
        const a = Un(), s = $n(), r = !!a[n], o = !(!s[n] || !a[s[n]]);
        n = a[n] || s[n] || n;
        const l = Vn()[n];
        l && (isNaN(this.ascent) && (this.ascent = l.ascent / oa), isNaN(this.descent) && (this.descent = l.descent / oa), isNaN(this.capHeight) && (this.capHeight = l.capHeight / oa)), this.bold = /bold/gi.test(n), this.italic = /oblique|italic/gi.test(n), this.black = /Black/g.test(t);
        const c = /Narrow/g.test(t);
        if (this.remeasure = (!r || c) && Object.keys(this.widths).length > 0, (r || o) && "CIDFontType2" === i && this.cidEncoding.startsWith("Identity-")) {
            const i = e1.cidToGidMap, n = [];
            if (applyStandardFontGlyphMap(n, qn()), /Arial-?Black/i.test(t) ? applyStandardFontGlyphMap(n, zn()) : /Calibri/i.test(t) && applyStandardFontGlyphMap(n, Wn()), i) {
                for(const e1 in n){
                    const t = n[e1];
                    void 0 !== i[t] && (n[+e1] = i[t]);
                }
                i.length !== this.toUnicode.length && e1.hasIncludedToUnicodeMap && this.toUnicode instanceof IdentityToUnicodeMap && this.toUnicode.forEach(function(e1, t) {
                    const a = n[e1];
                    void 0 === i[a] && (n[+e1] = t);
                });
            }
            this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(e1, t) {
                n[+e1] = t;
            }), this.toFontChar = n, this.toUnicode = new ToUnicodeMap(n);
        } else if (/Symbol/i.test(n)) this.toFontChar = buildToFontChar(fn, mn(), this.differences);
        else if (/Dingbats/i.test(n)) this.toFontChar = buildToFontChar(pn, bn(), this.differences);
        else if (r || o) {
            const e1 = buildToFontChar(this.defaultEncoding, mn(), this.differences);
            "CIDFontType2" !== i || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(t, i) {
                e1[+t] = i;
            }), this.toFontChar = e1;
        } else {
            const e1 = mn(), i = [];
            this.toUnicode.forEach((t, n)=>{
                if (!this.composite) {
                    const i = getUnicodeForGlyph(this.differences[t] || this.defaultEncoding[t], e1);
                    -1 !== i && (n = i);
                }
                i[+t] = n;
            }), this.composite && this.toUnicode instanceof IdentityToUnicodeMap && /Tahoma|Verdana/i.test(t) && applyStandardFontGlyphMap(i, qn()), this.toFontChar = i;
        }
        amendFallbackToUnicode(e1), this.loadedName = n.split("-", 1)[0];
    }
    checkAndRepair(e1, t, i) {
        const n = [
            "OS/2",
            "cmap",
            "head",
            "hhea",
            "hmtx",
            "maxp",
            "name",
            "post",
            "loca",
            "glyf",
            "fpgm",
            "prep",
            "cvt ",
            "CFF "
        ];
        function readTables(e1, t) {
            const i = Object.create(null);
            i["OS/2"] = null, i.cmap = null, i.head = null, i.hhea = null, i.hmtx = null, i.maxp = null, i.name = null, i.post = null;
            for(let a = 0; a < t; a++){
                const t = readTableEntry(e1);
                n.includes(t.tag) && 0 !== t.length && (i[t.tag] = t);
            }
            return i;
        }
        function readTableEntry(e1) {
            const t = e1.getString(4), i = e1.getInt32() >>> 0, n = e1.getInt32() >>> 0, a = e1.getInt32() >>> 0, s = e1.pos;
            e1.pos = e1.start || 0, e1.skip(n);
            const r = e1.getBytes(a);
            return e1.pos = s, "head" === t && (r[8] = r[9] = r[10] = r[11] = 0, r[17] |= 32), {
                tag: t,
                checksum: i,
                length: a,
                offset: n,
                data: r
            };
        }
        function readOpenTypeHeader(e1) {
            return {
                version: e1.getString(4),
                numTables: e1.getUint16(),
                searchRange: e1.getUint16(),
                entrySelector: e1.getUint16(),
                rangeShift: e1.getUint16()
            };
        }
        function sanitizeGlyph(e1, t, i, n, a, s) {
            const r = {
                length: 0,
                sizeOfInstructions: 0
            };
            if (t < 0 || t >= e1.length || i > e1.length || i - t <= 12) return r;
            const o = e1.subarray(t, i), l = signedInt16(o[2], o[3]), c = signedInt16(o[4], o[5]), h = signedInt16(o[6], o[7]), d = signedInt16(o[8], o[9]);
            l > h && (writeSignedInt16(o, 2, h), writeSignedInt16(o, 6, l)), c > d && (writeSignedInt16(o, 4, d), writeSignedInt16(o, 8, c));
            const u = signedInt16(o[0], o[1]);
            if (u < 0) return u < -1 || (n.set(o, a), r.length = o.length), r;
            let g, f = 10, p = 0;
            for(g = 0; g < u; g++){
                p = (o[f] << 8 | o[f + 1]) + 1, f += 2;
            }
            const m = f, b = o[f] << 8 | o[f + 1];
            r.sizeOfInstructions = b, f += 2 + b;
            const y = f;
            let w = 0;
            for(g = 0; g < p; g++){
                const e1 = o[f++];
                192 & e1 && (o[f - 1] = 63 & e1);
                let t = 2;
                2 & e1 ? t = 1 : 16 & e1 && (t = 0);
                let i = 2;
                4 & e1 ? i = 1 : 32 & e1 && (i = 0);
                const n = t + i;
                if (w += n, 8 & e1) {
                    const e1 = o[f++];
                    0 === e1 && (o[f - 1] ^= 8), g += e1, w += e1 * n;
                }
            }
            if (0 === w) return r;
            let x = f + w;
            return x > o.length ? r : !s && b > 0 ? (n.set(o.subarray(0, m), a), n.set([
                0,
                0
            ], a + m), n.set(o.subarray(y, x), a + m + 2), x -= b, o.length - x > 3 && (x = x + 3 & -4), r.length = x, r) : o.length - x > 3 ? (x = x + 3 & -4, n.set(o.subarray(0, x), a), r.length = x, r) : (n.set(o, a), r.length = o.length, r);
        }
        function readNameTable(e1) {
            const i = (t.start || 0) + e1.offset;
            t.pos = i;
            const n = [
                [],
                []
            ], a = [], s = e1.length, r = i + s;
            if (0 !== t.getUint16() || s < 6) return [
                n,
                a
            ];
            const o = t.getUint16(), l = t.getUint16();
            let c, h;
            for(c = 0; c < o && t.pos + 12 <= r; c++){
                const e1 = {
                    platform: t.getUint16(),
                    encoding: t.getUint16(),
                    language: t.getUint16(),
                    name: t.getUint16(),
                    length: t.getUint16(),
                    offset: t.getUint16()
                };
                (isMacNameRecord(e1) || isWinNameRecord(e1)) && a.push(e1);
            }
            for(c = 0, h = a.length; c < h; c++){
                const e1 = a[c];
                if (e1.length <= 0) continue;
                const s = i + l + e1.offset;
                if (s + e1.length > r) continue;
                t.pos = s;
                const o = e1.name;
                if (e1.encoding) {
                    let i = "";
                    for(let n = 0, a = e1.length; n < a; n += 2)i += String.fromCharCode(t.getUint16());
                    n[1][o] = i;
                } else n[0][o] = t.getString(e1.length);
            }
            return [
                n,
                a
            ];
        }
        const a = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            -2,
            -2,
            -2,
            -2,
            0,
            0,
            -2,
            -5,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            0,
            0,
            -1,
            0,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            -999,
            0,
            1,
            0,
            -1,
            -2,
            0,
            -1,
            -2,
            -1,
            -1,
            0,
            -1,
            -1,
            0,
            0,
            -999,
            -999,
            -1,
            -1,
            -1,
            -1,
            -2,
            -999,
            -2,
            -2,
            -999,
            0,
            -2,
            -2,
            0,
            0,
            -2,
            0,
            -2,
            0,
            0,
            0,
            -2,
            -1,
            -1,
            1,
            1,
            0,
            0,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            0,
            0,
            -1,
            0,
            -1,
            -1,
            0,
            -999,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            -2,
            -999,
            -999,
            -999,
            -999,
            -999,
            -1,
            -1,
            -2,
            -2,
            0,
            0,
            0,
            0,
            -1,
            -1,
            -999,
            -2,
            -2,
            0,
            0,
            -1,
            -2,
            -2,
            0,
            0,
            0,
            -1,
            -1,
            -1,
            -2
        ];
        function sanitizeTTProgram(e1, t) {
            let i, n, s, r, o, l = e1.data, c = 0, h = 0, d = 0;
            const u = [], g = [], f = [];
            let p = t.tooComplexToFollowFunctions, m = !1, b = 0, y = 0;
            for(let e1 = l.length; c < e1;){
                const e1 = l[c++];
                if (64 === e1) if (n = l[c++], m || y) c += n;
                else for(i = 0; i < n; i++)u.push(l[c++]);
                else if (65 === e1) if (n = l[c++], m || y) c += 2 * n;
                else for(i = 0; i < n; i++)s = l[c++], u.push(s << 8 | l[c++]);
                else if (176 == (248 & e1)) if (n = e1 - 176 + 1, m || y) c += n;
                else for(i = 0; i < n; i++)u.push(l[c++]);
                else if (184 == (248 & e1)) if (n = e1 - 184 + 1, m || y) c += 2 * n;
                else for(i = 0; i < n; i++)s = l[c++], u.push(signedInt16(s, l[c++]));
                else if (43 !== e1 || p) if (44 !== e1 || p) {
                    if (45 === e1) if (m) m = !1, h = c;
                    else {
                        if (o = g.pop(), !o) return warn$1("TT: ENDF bad stack"), void (t.hintsValid = !1);
                        r = f.pop(), l = o.data, c = o.i, t.functionsStackDeltas[r] = u.length - o.stackTop;
                    }
                    else if (137 === e1) (m || y) && (warn$1("TT: nested IDEFs not allowed"), p = !0), m = !0, d = c;
                    else if (88 === e1) ++b;
                    else if (27 === e1) y = b;
                    else if (89 === e1) y === b && (y = 0), --b;
                    else if (28 === e1 && !m && !y) {
                        const e1 = u.at(-1);
                        e1 > 0 && (c += e1 - 1);
                    }
                } else (m || y) && (warn$1("TT: nested FDEFs not allowed"), p = !0), m = !0, d = c, r = u.pop(), t.functionsDefined[r] = {
                    data: l,
                    i: c
                };
                else if (!m && !y) {
                    if (r = u.at(-1), isNaN(r)) info$1("TT: CALL empty stack (or invalid entry).");
                    else if (t.functionsUsed[r] = !0, r in t.functionsStackDeltas) {
                        const e1 = u.length + t.functionsStackDeltas[r];
                        if (e1 < 0) return warn$1("TT: CALL invalid functions stack delta."), void (t.hintsValid = !1);
                        u.length = e1;
                    } else if (r in t.functionsDefined && !f.includes(r)) {
                        if (g.push({
                            data: l,
                            i: c,
                            stackTop: u.length - 1
                        }), f.push(r), o = t.functionsDefined[r], !o) return warn$1("TT: CALL non-existent function"), void (t.hintsValid = !1);
                        l = o.data, c = o.i;
                    }
                }
                if (!m && !y) {
                    let t = 0;
                    for(e1 <= 142 ? t = a[e1] : e1 >= 192 && e1 <= 223 ? t = -1 : e1 >= 224 && (t = -2), e1 >= 113 && e1 <= 117 && (n = u.pop(), isNaN(n) || (t = 2 * -n)); t < 0 && u.length > 0;)u.pop(), t++;
                    for(; t > 0;)u.push(NaN), t--;
                }
            }
            t.tooComplexToFollowFunctions = p;
            const w = [
                l
            ];
            c > l.length && w.push(new Uint8Array(c - l.length)), d > h && (warn$1("TT: complementing a missing function tail"), w.push(new Uint8Array([
                34,
                45
            ]))), function(e1, t) {
                if (t.length > 1) {
                    let i, n, a = 0;
                    for(i = 0, n = t.length; i < n; i++)a += t[i].length;
                    a = a + 3 & -4;
                    const s = new Uint8Array(a);
                    let r = 0;
                    for(i = 0, n = t.length; i < n; i++)s.set(t[i], r), r += t[i].length;
                    e1.data = s, e1.length = a;
                }
            }(e1, w);
        }
        let s, r, o, l;
        if (isTrueTypeCollectionFile(t = new Stream(new Uint8Array(t.getBytes())))) {
            const e1 = function(e1, t) {
                const { numFonts: i, offsetTable: n } = function(e1) {
                    const t = e1.getString(4);
                    assert$1("ttcf" === t, "Must be a TrueType Collection font.");
                    const i = e1.getUint16(), n = e1.getUint16(), a = e1.getInt32() >>> 0, s = [];
                    for(let t = 0; t < a; t++)s.push(e1.getInt32() >>> 0);
                    const r = {
                        ttcTag: t,
                        majorVersion: i,
                        minorVersion: n,
                        numFonts: a,
                        offsetTable: s
                    };
                    switch(i){
                        case 1:
                            return r;
                        case 2:
                            return r.dsigTag = e1.getInt32() >>> 0, r.dsigLength = e1.getInt32() >>> 0, r.dsigOffset = e1.getInt32() >>> 0, r;
                    }
                    throw new ti(`Invalid TrueType Collection majorVersion: ${i}.`);
                }(e1), a = t.split("+");
                let s;
                for(let r = 0; r < i; r++){
                    e1.pos = (e1.start || 0) + n[r];
                    const i = readOpenTypeHeader(e1), o = readTables(e1, i.numTables);
                    if (!o.name) throw new ti('TrueType Collection font must contain a "name" table.');
                    const [l] = readNameTable(o.name);
                    for(let e1 = 0, n = l.length; e1 < n; e1++)for(let n = 0, r = l[e1].length; n < r; n++){
                        const r = l[e1][n]?.replaceAll(/\s/g, "");
                        if (r) {
                            if (r === t) return {
                                header: i,
                                tables: o
                            };
                            if (!(a.length < 2)) for (const e1 of a)r === e1 && (s = {
                                name: e1,
                                header: i,
                                tables: o
                            });
                        }
                    }
                }
                if (s) return warn$1(`TrueType Collection does not contain "${t}" font, falling back to "${s.name}" font instead.`), {
                    header: s.header,
                    tables: s.tables
                };
                throw new ti(`TrueType Collection does not contain "${t}" font.`);
            }(t, this.name);
            s = e1.header, r = e1.tables;
        } else s = readOpenTypeHeader(t), r = readTables(t, s.numTables);
        const c = !r["CFF "];
        if (c) {
            if (!r.loca) throw new ti('Required "loca" table is not found');
            r.glyf || (warn$1('Required "glyf" table is not found -- trying to recover.'), r.glyf = {
                tag: "glyf",
                data: new Uint8Array(0)
            }), this.isOpenType = !1;
        } else {
            const t = i.composite && (i.cidToGidMap?.length > 0 || !(i.cMap instanceof IdentityCMap));
            if ("OTTO" === s.version && !t || !r.head || !r.hhea || !r.maxp || !r.post) return l = new Stream(r["CFF "].data), o = new CFFFont(l, i), this.convert(e1, o, i);
            delete r.glyf, delete r.loca, delete r.fpgm, delete r.prep, delete r["cvt "], this.isOpenType = !0;
        }
        if (!r.maxp) throw new ti('Required "maxp" table is not found');
        t.pos = (t.start || 0) + r.maxp.offset;
        let h = t.getInt32();
        const d = t.getUint16();
        if (65536 !== h && 20480 !== h) {
            if (6 === r.maxp.length) h = 20480;
            else {
                if (!(r.maxp.length >= 32)) throw new ti('"maxp" table has a wrong version number');
                h = 65536;
            }
            u = r.maxp.data, f = h, u[(g = 0) + 3] = 255 & f, u[g + 2] = f >>> 8, u[g + 1] = f >>> 16, u[g] = f >>> 24;
        }
        var u, g, f;
        if (i.scaleFactors?.length === d && c) {
            const { scaleFactors: e1 } = i, t = int16(r.head.data[50], r.head.data[51]), n = new GlyfTable({
                glyfTable: r.glyf.data,
                isGlyphLocationsLong: t,
                locaTable: r.loca.data,
                numGlyphs: d
            });
            n.scale(e1);
            const { glyf: a, loca: s, isLocationLong: o } = n.write();
            r.glyf.data = a, r.loca.data = s, o !== !!t && (r.head.data[50] = 0, r.head.data[51] = o ? 1 : 0);
            const l = r.hmtx.data;
            for(let t = 0; t < d; t++){
                const i = 4 * t, n = Math.round(e1[t] * int16(l[i], l[i + 1]));
                l[i] = n >> 8 & 255, l[i + 1] = 255 & n;
                writeSignedInt16(l, i + 2, Math.round(e1[t] * signedInt16(l[i + 2], l[i + 3])));
            }
        }
        let p = d + 1, m = !0;
        p > 65535 && (m = !1, p = d, warn$1("Not enough space in glyfs to duplicate first glyph."));
        let b = 0, y = 0;
        if (h >= 65536 && r.maxp.length >= 32) {
            t.pos += 8;
            t.getUint16() > 2 && (r.maxp.data[14] = 0, r.maxp.data[15] = 2), t.pos += 4, b = t.getUint16(), t.pos += 4, y = t.getUint16();
        }
        r.maxp.data[4] = p >> 8, r.maxp.data[5] = 255 & p;
        const w = function(e1, t, i, n) {
            const a = {
                functionsDefined: [],
                functionsUsed: [],
                functionsStackDeltas: [],
                tooComplexToFollowFunctions: !1,
                hintsValid: !0
            };
            if (e1 && sanitizeTTProgram(e1, a), t && sanitizeTTProgram(t, a), e1 && function(e1, t) {
                if (!e1.tooComplexToFollowFunctions) {
                    if (e1.functionsDefined.length > t) return warn$1("TT: more functions defined than expected"), void (e1.hintsValid = !1);
                    for(let i = 0, n = e1.functionsUsed.length; i < n; i++){
                        if (i > t) return warn$1("TT: invalid function id: " + i), void (e1.hintsValid = !1);
                        if (e1.functionsUsed[i] && !e1.functionsDefined[i]) return warn$1("TT: undefined function: " + i), void (e1.hintsValid = !1);
                    }
                }
            }(a, n), i && 1 & i.length) {
                const e1 = new Uint8Array(i.length + 1);
                e1.set(i.data), i.data = e1;
            }
            return a.hintsValid;
        }(r.fpgm, r.prep, r["cvt "], b);
        if (w || (delete r.fpgm, delete r.prep, delete r["cvt "]), function(e1, t, i, n, a, s) {
            if (!t) return void (i && (i.data = null));
            e1.pos = (e1.start || 0) + t.offset, e1.pos += 4, e1.pos += 2, e1.pos += 2, e1.pos += 2, e1.pos += 2, e1.pos += 2, e1.pos += 2, e1.pos += 2, e1.pos += 2, e1.pos += 2;
            const r = e1.getUint16();
            e1.pos += 8, e1.pos += 2;
            let o = e1.getUint16();
            if (0 !== r) {
                2 & int16(n.data[44], n.data[45]) || (t.data[22] = 0, t.data[23] = 0);
            }
            o > a && (info$1(`The numOfMetrics (${o}) should not be greater than the numGlyphs (${a}).`), o = a, t.data[34] = (65280 & o) >> 8, t.data[35] = 255 & o);
            const l = a - o - (i.length - 4 * o >> 1);
            if (l > 0) {
                const e1 = new Uint8Array(i.length + 2 * l);
                e1.set(i.data), s && (e1[i.length] = i.data[2], e1[i.length + 1] = i.data[3]), i.data = e1;
            }
        }(t, r.hhea, r.hmtx, r.head, p, m), !r.head) throw new ti('Required "head" table is not found');
        !function(e1, t, i) {
            const n = e1.data, a = (s = n[0], r = n[1], o = n[2], l = n[3], (s << 24) + (r << 16) + (o << 8) + l);
            var s, r, o, l;
            a >> 16 != 1 && (info$1("Attempting to fix invalid version in head table: " + a), n[0] = 0, n[1] = 1, n[2] = 0, n[3] = 0);
            const c = int16(n[50], n[51]);
            if (c < 0 || c > 1) {
                info$1("Attempting to fix invalid indexToLocFormat in head table: " + c);
                const e1 = t + 1;
                if (i === e1 << 1) n[50] = 0, n[51] = 0;
                else {
                    if (i !== e1 << 2) throw new ti("Could not fix indexToLocFormat: " + c);
                    n[50] = 0, n[51] = 1;
                }
            }
        }(r.head, d, c ? r.loca.length : 0);
        let x = Object.create(null);
        if (c) {
            const e1 = int16(r.head.data[50], r.head.data[51]), t = function(e1, t, i, n, a, s, r) {
                let o, l, c;
                n ? (o = 4, l = function(e1, t) {
                    return e1[t] << 24 | e1[t + 1] << 16 | e1[t + 2] << 8 | e1[t + 3];
                }, c = function(e1, t, i) {
                    e1[t] = i >>> 24 & 255, e1[t + 1] = i >> 16 & 255, e1[t + 2] = i >> 8 & 255, e1[t + 3] = 255 & i;
                }) : (o = 2, l = function(e1, t) {
                    return e1[t] << 9 | e1[t + 1] << 1;
                }, c = function(e1, t, i) {
                    e1[t] = i >> 9 & 255, e1[t + 1] = i >> 1 & 255;
                });
                const h = s ? i + 1 : i, d = o * (1 + h), u = new Uint8Array(d);
                u.set(e1.data.subarray(0, d)), e1.data = u;
                const g = t.data, f = g.length, p = new Uint8Array(f);
                let m, b;
                const y = [];
                for(m = 0, b = 0; m < i + 1; m++, b += o){
                    let e1 = l(u, b);
                    e1 > f && (e1 = f), y.push({
                        index: m,
                        offset: e1,
                        endOffset: 0
                    });
                }
                for(y.sort((e1, t)=>e1.offset - t.offset), m = 0; m < i; m++)y[m].endOffset = y[m + 1].offset;
                for(y.sort((e1, t)=>e1.index - t.index), m = 0; m < i; m++){
                    const { offset: e1, endOffset: t } = y[m];
                    if (0 !== e1 || 0 !== t) break;
                    const i = y[m + 1].offset;
                    if (0 !== i) {
                        y[m].endOffset = i;
                        break;
                    }
                }
                const w = y.at(-2);
                0 !== w.offset && 0 === w.endOffset && (w.endOffset = f);
                const x = Object.create(null);
                let S = 0;
                for(c(u, 0, S), m = 0, b = o; m < i; m++, b += o){
                    const e1 = sanitizeGlyph(g, y[m].offset, y[m].endOffset, p, S, a), t = e1.length;
                    0 === t && (x[m] = !0), e1.sizeOfInstructions > r && (r = e1.sizeOfInstructions), S += t, c(u, b, S);
                }
                if (0 === S) {
                    const e1 = new Uint8Array([
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        49,
                        0
                    ]);
                    for(m = 0, b = o; m < h; m++, b += o)c(u, b, e1.length);
                    t.data = e1;
                } else if (s) {
                    const i = l(u, o);
                    p.length > i + S ? t.data = p.subarray(0, i + S) : (t.data = new Uint8Array(i + S), t.data.set(p.subarray(0, S))), t.data.set(p.subarray(0, i), S), c(e1.data, u.length - o, S + i);
                } else t.data = p.subarray(0, S);
                return {
                    missingGlyphs: x,
                    maxSizeOfInstructions: r
                };
            }(r.loca, r.glyf, d, e1, w, m, y);
            x = t.missingGlyphs, h >= 65536 && r.maxp.length >= 32 && (r.maxp.data[26] = t.maxSizeOfInstructions >> 8, r.maxp.data[27] = 255 & t.maxSizeOfInstructions);
        }
        if (!r.hhea) throw new ti('Required "hhea" table is not found');
        0 === r.hhea.data[10] && 0 === r.hhea.data[11] && (r.hhea.data[10] = 255, r.hhea.data[11] = 255);
        const S = {
            unitsPerEm: int16(r.head.data[18], r.head.data[19]),
            yMax: signedInt16(r.head.data[42], r.head.data[43]),
            yMin: signedInt16(r.head.data[38], r.head.data[39]),
            ascent: signedInt16(r.hhea.data[4], r.hhea.data[5]),
            descent: signedInt16(r.hhea.data[6], r.hhea.data[7]),
            lineGap: signedInt16(r.hhea.data[8], r.hhea.data[9])
        };
        this.ascent = S.ascent / S.unitsPerEm, this.descent = S.descent / S.unitsPerEm, this.lineGap = S.lineGap / S.unitsPerEm, this.cssFontInfo?.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, r.post && function(e1, i, n) {
            const a = (t.start || 0) + e1.offset;
            t.pos = a;
            const s = a + e1.length, r = t.getInt32();
            let o;
            t.skip(28);
            let l, c = !0;
            switch(r){
                case 65536:
                    o = Fn;
                    break;
                case 131072:
                    const e2 = t.getUint16();
                    if (e2 !== n) {
                        c = !1;
                        break;
                    }
                    const a1 = [];
                    for(l = 0; l < e2; ++l){
                        const e1 = t.getUint16();
                        if (e1 >= 32768) {
                            c = !1;
                            break;
                        }
                        a1.push(e1);
                    }
                    if (!c) break;
                    const h = [], d = [];
                    for(; t.pos < s;){
                        const e1 = t.getByte();
                        for(d.length = e1, l = 0; l < e1; ++l)d[l] = String.fromCharCode(t.getByte());
                        h.push(d.join(""));
                    }
                    for(o = [], l = 0; l < e2; ++l){
                        const e1 = a1[l];
                        e1 < 258 ? o.push(Fn[e1]) : o.push(h[e1 - 258]);
                    }
                    break;
                case 196608:
                    break;
                default:
                    warn$1("Unknown/unsupported post table version " + r), c = !1, i.defaultEncoding && (o = i.defaultEncoding);
            }
            i.glyphNames = o;
        }(r.post, i, d), r.post = {
            tag: "post",
            data: createPostTable(i)
        };
        const v = Object.create(null);
        function hasGlyph(e1) {
            return !x[e1];
        }
        if (i.composite) {
            const e1 = i.cidToGidMap || [], t = 0 === e1.length;
            i.cMap.forEach(function(i, n) {
                if ("string" == typeof n && (n = convertCidString(i, n, !0)), n > 65535) throw new ti("Max size of CID is 65,535");
                let a = -1;
                t ? a = n : void 0 !== e1[n] && (a = e1[n]), a >= 0 && a < d && hasGlyph(a) && (v[i] = a);
            });
        } else {
            const e1 = function(e1, t, i, n) {
                if (!e1) return warn$1("No cmap table available."), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                };
                let a, s = (t.start || 0) + e1.offset;
                t.pos = s, t.skip(2);
                const r = t.getUint16();
                let o, l = !1;
                for(let e1 = 0; e1 < r; e1++){
                    const a = t.getUint16(), s = t.getUint16(), c = t.getInt32() >>> 0;
                    let h = !1;
                    if (o?.platformId !== a || o?.encodingId !== s) {
                        if (0 !== a || 0 !== s && 1 !== s && 3 !== s) if (1 === a && 0 === s) h = !0;
                        else if (3 !== a || 1 !== s || !n && o) {
                            if (i && 3 === a && 0 === s) {
                                h = !0;
                                let i = !0;
                                if (e1 < r - 1) {
                                    const e1 = t.peekBytes(2);
                                    int16(e1[0], e1[1]) < a && (i = !1);
                                }
                                i && (l = !0);
                            }
                        } else h = !0, i || (l = !0);
                        else h = !0;
                        if (h && (o = {
                            platformId: a,
                            encodingId: s,
                            offset: c
                        }), l) break;
                    }
                }
                if (o && (t.pos = s + o.offset), !o || -1 === t.peekByte()) return warn$1("Could not find a preferred cmap table."), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                };
                const c = t.getUint16();
                let h = !1;
                const d = [];
                let u, g;
                if (0 === c) {
                    for(t.skip(4), u = 0; u < 256; u++){
                        const e1 = t.getByte();
                        e1 && d.push({
                            charCode: u,
                            glyphId: e1
                        });
                    }
                    h = !0;
                } else if (2 === c) {
                    t.skip(4);
                    const e1 = [];
                    let i = 0;
                    for(let n = 0; n < 256; n++){
                        const n = t.getUint16() >> 3;
                        e1.push(n), i = Math.max(n, i);
                    }
                    const n = [];
                    for(let e1 = 0; e1 <= i; e1++)n.push({
                        firstCode: t.getUint16(),
                        entryCount: t.getUint16(),
                        idDelta: signedInt16(t.getByte(), t.getByte()),
                        idRangePos: t.pos + t.getUint16()
                    });
                    for(let i = 0; i < 256; i++)if (0 === e1[i]) t.pos = n[0].idRangePos + 2 * i, g = t.getUint16(), d.push({
                        charCode: i,
                        glyphId: g
                    });
                    else {
                        const a = n[e1[i]];
                        for(u = 0; u < a.entryCount; u++){
                            const e1 = (i << 8) + u + a.firstCode;
                            t.pos = a.idRangePos + 2 * u, g = t.getUint16(), 0 !== g && (g = (g + a.idDelta) % 65536), d.push({
                                charCode: e1,
                                glyphId: g
                            });
                        }
                    }
                } else if (4 === c) {
                    t.skip(4);
                    const e1 = t.getUint16() >> 1;
                    t.skip(6);
                    const i = [];
                    let n;
                    for(n = 0; n < e1; n++)i.push({
                        end: t.getUint16()
                    });
                    for(t.skip(2), n = 0; n < e1; n++)i[n].start = t.getUint16();
                    for(n = 0; n < e1; n++)i[n].delta = t.getUint16();
                    let r, o = 0;
                    for(n = 0; n < e1; n++){
                        a = i[n];
                        const s = t.getUint16();
                        s ? (r = (s >> 1) - (e1 - n), a.offsetIndex = r, o = Math.max(o, r + a.end - a.start + 1)) : a.offsetIndex = -1;
                    }
                    const l = [];
                    for(u = 0; u < o; u++)l.push(t.getUint16());
                    for(n = 0; n < e1; n++){
                        a = i[n], s = a.start;
                        const e1 = a.end, t = a.delta;
                        for(r = a.offsetIndex, u = s; u <= e1; u++)65535 !== u && (g = r < 0 ? u : l[r + u - s], g = g + t & 65535, d.push({
                            charCode: u,
                            glyphId: g
                        }));
                    }
                } else if (6 === c) {
                    t.skip(4);
                    const e1 = t.getUint16(), i = t.getUint16();
                    for(u = 0; u < i; u++){
                        g = t.getUint16();
                        const i = e1 + u;
                        d.push({
                            charCode: i,
                            glyphId: g
                        });
                    }
                } else {
                    if (12 !== c) return warn$1("cmap table has unsupported format: " + c), {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: !1
                    };
                    {
                        t.skip(10);
                        const e1 = t.getInt32() >>> 0;
                        for(u = 0; u < e1; u++){
                            const e1 = t.getInt32() >>> 0, i = t.getInt32() >>> 0;
                            let n = t.getInt32() >>> 0;
                            for(let t = e1; t <= i; t++)d.push({
                                charCode: t,
                                glyphId: n++
                            });
                        }
                    }
                }
                d.sort((e1, t)=>e1.charCode - t.charCode);
                const f = [], p = new Set;
                for (const e1 of d){
                    const { charCode: t } = e1;
                    p.has(t) || (p.add(t), f.push(e1));
                }
                return {
                    platformId: o.platformId,
                    encodingId: o.encodingId,
                    mappings: f,
                    hasShortCmap: h
                };
            }(r.cmap, t, this.isSymbolicFont, i.hasEncoding), n = e1.platformId, a = e1.encodingId, s = e1.mappings;
            let o = [], l = !1;
            if (!i.hasEncoding || "MacRomanEncoding" !== i.baseEncodingName && "WinAnsiEncoding" !== i.baseEncodingName || (o = getEncoding(i.baseEncodingName)), i.hasEncoding && !this.isSymbolicFont && (3 === n && 1 === a || 1 === n && 0 === a)) {
                const e1 = mn();
                for(let t = 0; t < 256; t++){
                    let r;
                    if (r = void 0 !== this.differences[t] ? this.differences[t] : o.length && "" !== o[t] ? o[t] : un[t], !r) continue;
                    const l = recoverGlyphName(r, e1);
                    let c;
                    if (3 === n && 1 === a ? c = e1[l] : 1 === n && 0 === a && (c = dn.indexOf(l)), void 0 === c) {
                        if (!i.glyphNames && i.hasIncludedToUnicodeMap && !(this.toUnicode instanceof IdentityToUnicodeMap)) {
                            const e1 = this.toUnicode.get(t);
                            e1 && (c = e1.codePointAt(0));
                        }
                        if (void 0 === c) continue;
                    }
                    for (const e1 of s)if (e1.charCode === c) {
                        v[t] = e1.glyphId;
                        break;
                    }
                }
            } else if (0 === n) {
                for (const e1 of s)v[e1.charCode] = e1.glyphId;
                l = !0;
            } else if (3 === n && 0 === a) for (const e1 of s){
                let t = e1.charCode;
                t >= 61440 && t <= 61695 && (t &= 255), v[t] = e1.glyphId;
            }
            else for (const e1 of s)v[e1.charCode] = e1.glyphId;
            if (i.glyphNames && (o.length || this.differences.length)) for(let e1 = 0; e1 < 256; ++e1){
                if (!l && void 0 !== v[e1]) continue;
                const t = this.differences[e1] || o[e1];
                if (!t) continue;
                const n = i.glyphNames.indexOf(t);
                n > 0 && hasGlyph(n) && (v[e1] = n);
            }
        }
        0 === v.length && (v[0] = 0);
        let C = p - 1;
        if (m || (C = 0), !i.cssFontInfo) {
            const e1 = adjustMapping(v, hasGlyph, C, this.toUnicode);
            this.toFontChar = e1.toFontChar, r.cmap = {
                tag: "cmap",
                data: createCmapTable(e1.charCodeToGlyphId, e1.toUnicodeExtraMap, p)
            }, r["OS/2"] && function(e1, t) {
                t.pos = (t.start || 0) + e1.offset;
                const i = t.getUint16();
                t.skip(60);
                const n = t.getUint16();
                return !(i < 4 && 768 & n) && !(t.getUint16() > t.getUint16()) && (t.skip(6), 0 !== t.getUint16() && (e1.data[8] = e1.data[9] = 0, !0));
            }(r["OS/2"], t) || (r["OS/2"] = {
                tag: "OS/2",
                data: createOS2Table(i, e1.charCodeToGlyphId, S)
            });
        }
        if (!c) try {
            l = new Stream(r["CFF "].data);
            o = new CFFParser(l, i, Sn).parse(), o.duplicateFirstGlyph();
            const e1 = new CFFCompiler(o);
            r["CFF "].data = e1.compile();
        } catch  {
            warn$1("Failed to compile font " + i.loadedName);
        }
        if (r.name) {
            const [t, n] = readNameTable(r.name);
            r.name.data = createNameTable(e1, t), this.psName = t[0][6] || null, i.composite || function(e1, t, i) {
                if (e1.isInternalFont) return;
                if (e1.hasIncludedToUnicodeMap) return;
                if (e1.hasEncoding) return;
                if (e1.toUnicode instanceof IdentityToUnicodeMap) return;
                if (!t) return;
                if (0 === i.length) return;
                if (e1.defaultEncoding === gn) return;
                for (const e1 of i)if (!isWinNameRecord(e1)) return;
                const n = gn, a = [], s = mn();
                for(const e1 in n){
                    const t = n[e1];
                    if ("" === t) continue;
                    const i = s[t];
                    void 0 !== i && (a[e1] = String.fromCharCode(i));
                }
                a.length > 0 && e1.toUnicode.amend(a);
            }(i, this.isSymbolicFont, n);
        } else r.name = {
            tag: "name",
            data: createNameTable(this.name)
        };
        const k = new OpenTypeFileBuilder(s.version);
        for(const e1 in r)k.addTable(e1, r[e1].data);
        return k.toArray();
    }
    convert(e1, i, n) {
        n.fixedPitch = !1, n.builtInEncoding && function(e1, t) {
            if (e1.isInternalFont) return;
            if (e1.hasIncludedToUnicodeMap) return;
            if (t === e1.defaultEncoding) return;
            if (e1.toUnicode instanceof IdentityToUnicodeMap) return;
            const i = [], n = mn();
            for(const a in t){
                if (e1.hasEncoding && (e1.baseEncodingName || void 0 !== e1.differences[a])) continue;
                const s = getUnicodeForGlyph(t[a], n);
                -1 !== s && (i[a] = String.fromCharCode(s));
            }
            i.length > 0 && e1.toUnicode.amend(i);
        }(n, n.builtInEncoding);
        let a = 1;
        i instanceof CFFFont && (a = i.numGlyphs - 1);
        const s = i.getGlyphMapping(n);
        let r = null, o = s, l = null;
        n.cssFontInfo || (r = adjustMapping(s, i.hasGlyphId.bind(i), a, this.toUnicode), this.toFontChar = r.toFontChar, o = r.charCodeToGlyphId, l = r.toUnicodeExtraMap);
        const c = i.numGlyphs;
        function getCharCodes(e1, t) {
            let i = null;
            for(const n in e1)t === e1[n] && (i ||= []).push(0 | n);
            return i;
        }
        function createCharCode(e1, t) {
            for(const i in e1)if (t === e1[i]) return 0 | i;
            return r.charCodeToGlyphId[r.nextAvailableFontCharCode] = t, r.nextAvailableFontCharCode++;
        }
        const h = i.seacs;
        if (r && h?.length) {
            const e1 = n.fontMatrix || t, a = i.getCharset(), o = Object.create(null);
            for(let t in h){
                t |= 0;
                const i = h[t], n = un[i[2]], l = un[i[3]], c = a.indexOf(n), d = a.indexOf(l);
                if (c < 0 || d < 0) continue;
                const u = {
                    x: i[0] * e1[0] + i[1] * e1[2] + e1[4],
                    y: i[0] * e1[1] + i[1] * e1[3] + e1[5]
                }, g = getCharCodes(s, t);
                if (g) for (const e1 of g){
                    const t = r.charCodeToGlyphId, i = createCharCode(t, c), n = createCharCode(t, d);
                    o[e1] = {
                        baseFontCharCode: i,
                        accentFontCharCode: n,
                        accentOffset: u
                    };
                }
            }
            n.seacMap = o;
        }
        const d = n.fontMatrix ? 1 / Math.max(...n.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, u = new OpenTypeFileBuilder("OTTO");
        return u.addTable("CFF ", i.data), u.addTable("OS/2", createOS2Table(n, o)), u.addTable("cmap", createCmapTable(o, l, c)), u.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<Ãµ\0\0" + safeString16(d) + "\0\0\0\0Â\v~'\0\0\0\0Â\v~'\0\0" + safeString16(n.descent) + "Ã¿" + safeString16(n.ascent) + string16(n.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), u.addTable("hhea", "\0\0\0" + safeString16(n.ascent) + safeString16(n.descent) + "\0\0Ã¿Ã¿\0\0\0\0\0\0" + safeString16(n.capHeight) + safeString16(Math.tan(n.italicAngle) * n.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(c)), u.addTable("hmtx", function() {
            const e1 = i.charstrings, t = i.cff ? i.cff.widths : null;
            let n = "\0\0\0\0";
            for(let i = 1, a = c; i < a; i++){
                let a = 0;
                if (e1) {
                    const t = e1[i - 1];
                    a = "width" in t ? t.width : 0;
                } else t && (a = Math.ceil(t[i] || 0));
                n += string16(a) + string16(0);
            }
            return n;
        }()), u.addTable("maxp", "\0\0P\0" + string16(c)), u.addTable("name", createNameTable(e1)), u.addTable("post", createPostTable(n)), u.toArray();
    }
    get _spaceWidth() {
        const e1 = [
            "space",
            "minus",
            "one",
            "i",
            "I"
        ];
        let t;
        for (const i of e1){
            if (i in this.widths) {
                t = this.widths[i];
                break;
            }
            const e1 = mn()[i];
            let n = 0;
            if (this.composite && this.cMap.contains(e1) && (n = this.cMap.lookup(e1), "string" == typeof n && (n = convertCidString(e1, n))), !n && this.toUnicode && (n = this.toUnicode.charCodeOf(e1)), n <= 0 && (n = e1), t = this.widths[n], t) break;
        }
        return shadow$1(this, "_spaceWidth", t || this.defaultWidth);
    }
    _charToGlyph(e1, t = !1) {
        let i, n, a, s = this._glyphCache[e1];
        if (s?.isSpace === t) return s;
        let r = e1;
        this.cMap?.contains(e1) && (r = this.cMap.lookup(e1), "string" == typeof r && (r = convertCidString(e1, r))), n = this.widths[r], "number" != typeof n && (n = this.defaultWidth);
        const o = this.vmetrics?.[r];
        let l = this.toUnicode.get(e1) || e1;
        "number" == typeof l && (l = String.fromCharCode(l));
        let c = void 0 !== this.toFontChar[e1];
        if (i = this.toFontChar[e1] || e1, this.missingFile) {
            const t = this.differences[e1] || this.defaultEncoding[e1];
            ".notdef" !== t && "" !== t || "Type1" !== this.type || (i = 32, "" === t && (n ||= this._spaceWidth, l = String.fromCharCode(i))), i = (h = i) >= 65520 && h <= 65535 ? 0 : h >= 62976 && h <= 63743 ? yn()[h] || h : 173 === h ? 45 : h;
        }
        var h;
        this.isType3Font && (a = i);
        let d = null;
        if (this.seacMap?.[e1]) {
            c = !0;
            const t = this.seacMap[e1];
            i = t.baseFontCharCode, d = {
                fontChar: String.fromCodePoint(t.accentFontCharCode),
                offset: t.accentOffset
            };
        }
        let u = "";
        if ("number" == typeof i && (i <= 1114111 ? u = String.fromCodePoint(i) : warn$1(`charToGlyph - invalid fontCharCode: ${i}`)), this.missingFile && this.vertical && 1 === u.length) {
            const e1 = In()[u.charCodeAt(0)];
            e1 && (u = l = String.fromCharCode(e1));
        }
        return s = new fonts_Glyph(e1, u, l, d, n, o, a, t, c), this._glyphCache[e1] = s;
    }
    charsToGlyphs(e1) {
        let t = this._charsCache[e1];
        if (t) return t;
        if (t = [], this.cMap) {
            const i = Object.create(null), n = e1.length;
            let a = 0;
            for(; a < n;){
                this.cMap.readCharCode(e1, a, i);
                const { charcode: n, length: s } = i;
                a += s;
                const r = this._charToGlyph(n, 1 === s && 32 === e1.charCodeAt(a - 1));
                t.push(r);
            }
        } else for(let i = 0, n = e1.length; i < n; ++i){
            const n = e1.charCodeAt(i), a = this._charToGlyph(n, 32 === n);
            t.push(a);
        }
        return this._charsCache[e1] = t;
    }
    getCharPositions(e1) {
        const t = [];
        if (this.cMap) {
            const i = Object.create(null);
            let n = 0;
            for(; n < e1.length;){
                this.cMap.readCharCode(e1, n, i);
                const a = i.length;
                t.push([
                    n,
                    n + a
                ]), n += a;
            }
        } else for(let i = 0, n = e1.length; i < n; ++i)t.push([
            i,
            i + 1
        ]);
        return t;
    }
    get glyphCacheValues() {
        return Object.values(this._glyphCache);
    }
    encodeString(e1) {
        const t = [], i = [], hasCurrentBufErrors = ()=>t.length % 2 == 1, n = this.toUnicode instanceof IdentityToUnicodeMap ? (e1)=>this.toUnicode.charCodeOf(e1) : (e1)=>this.toUnicode.charCodeOf(String.fromCodePoint(e1));
        for(let a = 0, s = e1.length; a < s; a++){
            const s = e1.codePointAt(a);
            if (s > 55295 && (s < 57344 || s > 65533) && a++, this.toUnicode) {
                const e1 = n(s);
                if (-1 !== e1) {
                    hasCurrentBufErrors() && (t.push(i.join("")), i.length = 0);
                    for(let t = (this.cMap ? this.cMap.getCharCodeLength(e1) : 1) - 1; t >= 0; t--)i.push(String.fromCharCode(e1 >> 8 * t & 255));
                    continue;
                }
            }
            hasCurrentBufErrors() || (t.push(i.join("")), i.length = 0), i.push(String.fromCodePoint(s));
        }
        return t.push(i.join("")), t;
    }
}
class ErrorFont {
    constructor(e1){
        this.error = e1, this.loadedName = "g_font_error", this.missingFile = !0;
    }
    charsToGlyphs() {
        return [];
    }
    encodeString(e1) {
        return [
            e1
        ];
    }
    exportData() {
        return {
            error: this.error
        };
    }
}
const ha = 2, da = 3, ua = 4, ga = 5, fa = 6, pa = 7;
class Pattern {
    constructor(){
        unreachable$1("Cannot initialize Pattern.");
    }
    static parseShading(e1, t, i, n, a, s) {
        const r = e1 instanceof BaseStream ? e1.dict : e1, o = r.get("ShadingType");
        try {
            switch(o){
                case ha:
                case da:
                    return new RadialAxialShading(r, t, i, n, a, s);
                case ua:
                case ga:
                case fa:
                case pa:
                    return new MeshShading(e1, t, i, n, a, s);
                default:
                    throw new ti("Unsupported ShadingType: " + o);
            }
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            return warn$1(e1), new DummyShading;
        }
    }
}
class BaseShading {
    static SMALL_NUMBER = 1e-6;
    getIR() {
        unreachable$1("Abstract method `getIR` called.");
    }
}
class RadialAxialShading extends BaseShading {
    constructor(e1, t, i, n, a, s){
        super(), this.shadingType = e1.get("ShadingType");
        let r = 0;
        if (this.shadingType === ha ? r = 4 : this.shadingType === da && (r = 6), this.coordsArr = e1.getArray("Coords"), !isNumberArray(this.coordsArr, r)) throw new ti("RadialAxialShading: Invalid /Coords array.");
        const o = ColorSpaceUtils.parse({
            cs: e1.getRaw("CS") || e1.getRaw("ColorSpace"),
            xref: t,
            resources: i,
            pdfFunctionFactory: n,
            globalColorSpaceCache: a,
            localColorSpaceCache: s
        });
        this.bbox = lookupNormalRect(e1.getArray("BBox"), null);
        let l = 0, c = 1;
        const h = e1.getArray("Domain");
        isNumberArray(h, 2) && ([l, c] = h);
        let d = !1, u = !1;
        const g = e1.getArray("Extend");
        var f, p;
        if (f = g, p = 2, Array.isArray(f) && f.length === p && f.every((e1)=>"boolean" == typeof e1) && ([d, u] = g), !(this.shadingType !== da || d && u)) {
            const [e1, t, i, n, a, s] = this.coordsArr, r = Math.hypot(e1 - n, t - a);
            i <= s + r && s <= i + r && warn$1("Unsupported radial gradient.");
        }
        this.extendStart = d, this.extendEnd = u;
        const m = e1.getRaw("Function"), b = n.create(m, !0), y = (c - l) / 840, w = this.colorStops = [];
        if (l >= c || y <= 0) return void info$1("Bad shading domain.");
        const x = new Float32Array(o.numComps), S = new Float32Array(1);
        let v = 0;
        S[0] = l, b(S, 0, x, 0);
        const C = new Uint8ClampedArray(3);
        o.getRgb(x, 0, C);
        let [k, T, F] = C;
        w.push([
            0,
            ai.makeHexColor(k, T, F)
        ]);
        let E = 1;
        S[0] = l + y, b(S, 0, x, 0), o.getRgb(x, 0, C);
        let [M, D, O] = C, _ = M - k + 1, R = D - T + 1, N = O - F + 1, L = M - k - 1, U = D - T - 1, j = O - F - 1;
        for(let e1 = 2; e1 < 840; e1++){
            S[0] = l + e1 * y, b(S, 0, x, 0), o.getRgb(x, 0, C);
            const [t, i, n] = C, a = e1 - v;
            _ = Math.min(_, (t - k + 1) / a), R = Math.min(R, (i - T + 1) / a), N = Math.min(N, (n - F + 1) / a), L = Math.max(L, (t - k - 1) / a), U = Math.max(U, (i - T - 1) / a), j = Math.max(j, (n - F - 1) / a);
            if (!(L <= _ && U <= R && j <= N)) {
                const e1 = ai.makeHexColor(M, D, O);
                w.push([
                    E / 840,
                    e1
                ]), _ = t - M + 1, R = i - D + 1, N = n - O + 1, L = t - M - 1, U = i - D - 1, j = n - O - 1, v = E, k = M, T = D, F = O;
            }
            E = e1, M = t, D = i, O = n;
        }
        w.push([
            1,
            ai.makeHexColor(M, D, O)
        ]);
        let $ = "transparent";
        e1.has("Background") && ($ = o.getRgbHex(e1.get("Background"), 0)), d || (w.unshift([
            0,
            $
        ]), w[1][0] += BaseShading.SMALL_NUMBER), u || (w.at(-1)[0] -= BaseShading.SMALL_NUMBER, w.push([
            1,
            $
        ])), this.colorStops = w;
    }
    getIR() {
        const { coordsArr: e1, shadingType: t } = this;
        let i, n, a, s, r;
        return t === ha ? (n = [
            e1[0],
            e1[1]
        ], a = [
            e1[2],
            e1[3]
        ], s = null, r = null, i = "axial") : t === da ? (n = [
            e1[0],
            e1[1]
        ], a = [
            e1[3],
            e1[4]
        ], s = e1[2], r = e1[5], i = "radial") : unreachable$1(`getPattern type unknown: ${t}`), [
            "RadialAxial",
            i,
            this.bbox,
            this.colorStops,
            n,
            a,
            s,
            r
        ];
    }
}
class MeshStreamReader {
    constructor(e1, t){
        this.stream = e1, this.context = t, this.buffer = 0, this.bufferLength = 0;
        const i = t.numComps;
        this.tmpCompsBuf = new Float32Array(i);
        const n = t.colorSpace.numComps;
        this.tmpCsCompsBuf = t.colorFn ? new Float32Array(n) : this.tmpCompsBuf;
    }
    get hasData() {
        if (this.stream.end) return this.stream.pos < this.stream.end;
        if (this.bufferLength > 0) return !0;
        const e1 = this.stream.getByte();
        return !(e1 < 0) && (this.buffer = e1, this.bufferLength = 8, !0);
    }
    readBits(e1) {
        const { stream: t } = this;
        let { buffer: i, bufferLength: n } = this;
        if (32 === e1) {
            if (0 === n) return t.getInt32() >>> 0;
            i = i << 24 | t.getByte() << 16 | t.getByte() << 8 | t.getByte();
            const e1 = t.getByte();
            return this.buffer = e1 & (1 << n) - 1, (i << 8 - n | (255 & e1) >> n) >>> 0;
        }
        if (8 === e1 && 0 === n) return t.getByte();
        for(; n < e1;)i = i << 8 | t.getByte(), n += 8;
        return n -= e1, this.bufferLength = n, this.buffer = i & (1 << n) - 1, i >> n;
    }
    align() {
        this.buffer = 0, this.bufferLength = 0;
    }
    readFlag() {
        return this.readBits(this.context.bitsPerFlag);
    }
    readCoordinate() {
        const { bitsPerCoordinate: e1, decode: t } = this.context, i = this.readBits(e1), n = this.readBits(e1), a = e1 < 32 ? 1 / ((1 << e1) - 1) : 2.3283064365386963e-10;
        return [
            i * a * (t[1] - t[0]) + t[0],
            n * a * (t[3] - t[2]) + t[2]
        ];
    }
    readComponents() {
        const { bitsPerComponent: e1, colorFn: t, colorSpace: i, decode: n, numComps: a } = this.context, s = e1 < 32 ? 1 / ((1 << e1) - 1) : 2.3283064365386963e-10, r = this.tmpCompsBuf;
        for(let t = 0, i = 4; t < a; t++, i += 2){
            const a = this.readBits(e1);
            r[t] = a * s * (n[i + 1] - n[i]) + n[i];
        }
        const o = this.tmpCsCompsBuf;
        return t?.(r, 0, o, 0), i.getRgb(o, 0);
    }
}
let ma = Object.create(null);
function getB(e1) {
    return ma[e1] ||= function(e1) {
        const t = [];
        for(let i = 0; i <= e1; i++){
            const n = i / e1, a = 1 - n;
            t.push(new Float32Array([
                a ** 3,
                3 * n * a ** 2,
                3 * n ** 2 * a,
                n ** 3
            ]));
        }
        return t;
    }(e1);
}
class MeshShading extends BaseShading {
    static MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
    static MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
    static TRIANGLE_DENSITY = 20;
    constructor(e1, t, i, n, a, s){
        if (super(), !(e1 instanceof BaseStream)) throw new ti("Mesh data is not a stream");
        const r = e1.dict;
        this.shadingType = r.get("ShadingType"), this.bbox = lookupNormalRect(r.getArray("BBox"), null);
        const o = ColorSpaceUtils.parse({
            cs: r.getRaw("CS") || r.getRaw("ColorSpace"),
            xref: t,
            resources: i,
            pdfFunctionFactory: n,
            globalColorSpaceCache: a,
            localColorSpaceCache: s
        });
        this.background = r.has("Background") ? o.getRgb(r.get("Background"), 0) : null;
        const l = r.getRaw("Function"), c = l ? n.create(l, !0) : null;
        this.coords = [], this.colors = [], this.figures = [];
        const h = {
            bitsPerCoordinate: r.get("BitsPerCoordinate"),
            bitsPerComponent: r.get("BitsPerComponent"),
            bitsPerFlag: r.get("BitsPerFlag"),
            decode: r.getArray("Decode"),
            colorFn: c,
            colorSpace: o,
            numComps: c ? 1 : o.numComps
        }, d = new MeshStreamReader(e1, h);
        let u = !1;
        switch(this.shadingType){
            case ua:
                this._decodeType4Shading(d);
                break;
            case ga:
                const e2 = 0 | r.get("VerticesPerRow");
                if (e2 < 2) throw new ti("Invalid VerticesPerRow");
                this._decodeType5Shading(d, e2);
                break;
            case fa:
                this._decodeType6Shading(d), u = !0;
                break;
            case pa:
                this._decodeType7Shading(d), u = !0;
                break;
            default:
                unreachable$1("Unsupported mesh type.");
        }
        if (u) {
            this._updateBounds();
            for(let e1 = 0, t = this.figures.length; e1 < t; e1++)this._buildFigureFromPatch(e1);
        }
        this._updateBounds(), this._packData();
    }
    _decodeType4Shading(e1) {
        const t = this.coords, i = this.colors, n = [];
        let a = 0;
        for(; e1.hasData;){
            const s = e1.readFlag(), r = e1.readCoordinate(), o = e1.readComponents();
            if (0 === a) {
                if (!(0 <= s && s <= 2)) throw new ti("Unknown type4 flag");
                switch(s){
                    case 0:
                        a = 3;
                        break;
                    case 1:
                        n.push(n.at(-2), n.at(-1)), a = 1;
                        break;
                    case 2:
                        n.push(n.at(-3), n.at(-1)), a = 1;
                }
            }
            n.push(t.length), t.push(r), i.push(o), a--, e1.align();
        }
        this.figures.push({
            type: "triangles",
            coords: new Int32Array(n),
            colors: new Int32Array(n)
        });
    }
    _decodeType5Shading(e1, t) {
        const i = this.coords, n = this.colors, a = [];
        for(; e1.hasData;){
            const t = e1.readCoordinate(), s = e1.readComponents();
            a.push(i.length), i.push(t), n.push(s);
        }
        this.figures.push({
            type: "lattice",
            coords: new Int32Array(a),
            colors: new Int32Array(a),
            verticesPerRow: t
        });
    }
    _decodeType6Shading(e1) {
        const t = this.coords, i = this.colors, n = new Int32Array(16), a = new Int32Array(4);
        for(; e1.hasData;){
            const s = e1.readFlag();
            if (!(0 <= s && s <= 3)) throw new ti("Unknown type6 flag");
            const r = t.length;
            for(let i = 0, n = 0 !== s ? 8 : 12; i < n; i++)t.push(e1.readCoordinate());
            const o = i.length;
            for(let t = 0, n = 0 !== s ? 2 : 4; t < n; t++)i.push(e1.readComponents());
            let l, c, h, d;
            switch(s){
                case 0:
                    n[12] = r + 3, n[13] = r + 4, n[14] = r + 5, n[15] = r + 6, n[8] = r + 2, n[11] = r + 7, n[4] = r + 1, n[7] = r + 8, n[0] = r, n[1] = r + 11, n[2] = r + 10, n[3] = r + 9, a[2] = o + 1, a[3] = o + 2, a[0] = o, a[1] = o + 3;
                    break;
                case 1:
                    l = n[12], c = n[13], h = n[14], d = n[15], n[12] = d, n[13] = r + 0, n[14] = r + 1, n[15] = r + 2, n[8] = h, n[11] = r + 3, n[4] = c, n[7] = r + 4, n[0] = l, n[1] = r + 7, n[2] = r + 6, n[3] = r + 5, l = a[2], c = a[3], a[2] = c, a[3] = o, a[0] = l, a[1] = o + 1;
                    break;
                case 2:
                    l = n[15], c = n[11], n[12] = n[3], n[13] = r + 0, n[14] = r + 1, n[15] = r + 2, n[8] = n[7], n[11] = r + 3, n[4] = c, n[7] = r + 4, n[0] = l, n[1] = r + 7, n[2] = r + 6, n[3] = r + 5, l = a[3], a[2] = a[1], a[3] = o, a[0] = l, a[1] = o + 1;
                    break;
                case 3:
                    n[12] = n[0], n[13] = r + 0, n[14] = r + 1, n[15] = r + 2, n[8] = n[1], n[11] = r + 3, n[4] = n[2], n[7] = r + 4, n[0] = n[3], n[1] = r + 7, n[2] = r + 6, n[3] = r + 5, a[2] = a[0], a[3] = o, a[0] = a[1], a[1] = o + 1;
            }
            n[5] = t.length, t.push([
                (-4 * t[n[0]][0] - t[n[15]][0] + 6 * (t[n[4]][0] + t[n[1]][0]) - 2 * (t[n[12]][0] + t[n[3]][0]) + 3 * (t[n[13]][0] + t[n[7]][0])) / 9,
                (-4 * t[n[0]][1] - t[n[15]][1] + 6 * (t[n[4]][1] + t[n[1]][1]) - 2 * (t[n[12]][1] + t[n[3]][1]) + 3 * (t[n[13]][1] + t[n[7]][1])) / 9
            ]), n[6] = t.length, t.push([
                (-4 * t[n[3]][0] - t[n[12]][0] + 6 * (t[n[2]][0] + t[n[7]][0]) - 2 * (t[n[0]][0] + t[n[15]][0]) + 3 * (t[n[4]][0] + t[n[14]][0])) / 9,
                (-4 * t[n[3]][1] - t[n[12]][1] + 6 * (t[n[2]][1] + t[n[7]][1]) - 2 * (t[n[0]][1] + t[n[15]][1]) + 3 * (t[n[4]][1] + t[n[14]][1])) / 9
            ]), n[9] = t.length, t.push([
                (-4 * t[n[12]][0] - t[n[3]][0] + 6 * (t[n[8]][0] + t[n[13]][0]) - 2 * (t[n[0]][0] + t[n[15]][0]) + 3 * (t[n[11]][0] + t[n[1]][0])) / 9,
                (-4 * t[n[12]][1] - t[n[3]][1] + 6 * (t[n[8]][1] + t[n[13]][1]) - 2 * (t[n[0]][1] + t[n[15]][1]) + 3 * (t[n[11]][1] + t[n[1]][1])) / 9
            ]), n[10] = t.length, t.push([
                (-4 * t[n[15]][0] - t[n[0]][0] + 6 * (t[n[11]][0] + t[n[14]][0]) - 2 * (t[n[12]][0] + t[n[3]][0]) + 3 * (t[n[2]][0] + t[n[8]][0])) / 9,
                (-4 * t[n[15]][1] - t[n[0]][1] + 6 * (t[n[11]][1] + t[n[14]][1]) - 2 * (t[n[12]][1] + t[n[3]][1]) + 3 * (t[n[2]][1] + t[n[8]][1])) / 9
            ]), this.figures.push({
                type: "patch",
                coords: new Int32Array(n),
                colors: new Int32Array(a)
            });
        }
    }
    _decodeType7Shading(e1) {
        const t = this.coords, i = this.colors, n = new Int32Array(16), a = new Int32Array(4);
        for(; e1.hasData;){
            const s = e1.readFlag();
            if (!(0 <= s && s <= 3)) throw new ti("Unknown type7 flag");
            const r = t.length;
            for(let i = 0, n = 0 !== s ? 12 : 16; i < n; i++)t.push(e1.readCoordinate());
            const o = i.length;
            for(let t = 0, n = 0 !== s ? 2 : 4; t < n; t++)i.push(e1.readComponents());
            let l, c, h, d;
            switch(s){
                case 0:
                    n[12] = r + 3, n[13] = r + 4, n[14] = r + 5, n[15] = r + 6, n[8] = r + 2, n[9] = r + 13, n[10] = r + 14, n[11] = r + 7, n[4] = r + 1, n[5] = r + 12, n[6] = r + 15, n[7] = r + 8, n[0] = r, n[1] = r + 11, n[2] = r + 10, n[3] = r + 9, a[2] = o + 1, a[3] = o + 2, a[0] = o, a[1] = o + 3;
                    break;
                case 1:
                    l = n[12], c = n[13], h = n[14], d = n[15], n[12] = d, n[13] = r + 0, n[14] = r + 1, n[15] = r + 2, n[8] = h, n[9] = r + 9, n[10] = r + 10, n[11] = r + 3, n[4] = c, n[5] = r + 8, n[6] = r + 11, n[7] = r + 4, n[0] = l, n[1] = r + 7, n[2] = r + 6, n[3] = r + 5, l = a[2], c = a[3], a[2] = c, a[3] = o, a[0] = l, a[1] = o + 1;
                    break;
                case 2:
                    l = n[15], c = n[11], n[12] = n[3], n[13] = r + 0, n[14] = r + 1, n[15] = r + 2, n[8] = n[7], n[9] = r + 9, n[10] = r + 10, n[11] = r + 3, n[4] = c, n[5] = r + 8, n[6] = r + 11, n[7] = r + 4, n[0] = l, n[1] = r + 7, n[2] = r + 6, n[3] = r + 5, l = a[3], a[2] = a[1], a[3] = o, a[0] = l, a[1] = o + 1;
                    break;
                case 3:
                    n[12] = n[0], n[13] = r + 0, n[14] = r + 1, n[15] = r + 2, n[8] = n[1], n[9] = r + 9, n[10] = r + 10, n[11] = r + 3, n[4] = n[2], n[5] = r + 8, n[6] = r + 11, n[7] = r + 4, n[0] = n[3], n[1] = r + 7, n[2] = r + 6, n[3] = r + 5, a[2] = a[0], a[3] = o, a[0] = a[1], a[1] = o + 1;
            }
            this.figures.push({
                type: "patch",
                coords: new Int32Array(n),
                colors: new Int32Array(a)
            });
        }
    }
    _buildFigureFromPatch(e1) {
        const t = this.figures[e1];
        assert$1("patch" === t.type, "Unexpected patch mesh figure");
        const i = this.coords, n = this.colors, a = t.coords, s = t.colors, r = Math.min(i[a[0]][0], i[a[3]][0], i[a[12]][0], i[a[15]][0]), o = Math.min(i[a[0]][1], i[a[3]][1], i[a[12]][1], i[a[15]][1]), l = Math.max(i[a[0]][0], i[a[3]][0], i[a[12]][0], i[a[15]][0]), c = Math.max(i[a[0]][1], i[a[3]][1], i[a[12]][1], i[a[15]][1]);
        let h = Math.ceil((l - r) * MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
        h = MathClamp$1(h, MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT);
        let d = Math.ceil((c - o) * MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
        d = MathClamp$1(d, MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT);
        const u = h + 1, g = new Int32Array((d + 1) * u), f = new Int32Array((d + 1) * u);
        let p = 0;
        const m = new Uint8Array(3), b = new Uint8Array(3), y = n[s[0]], w = n[s[1]], x = n[s[2]], S = n[s[3]], v = getB(d), C = getB(h);
        for(let e1 = 0; e1 <= d; e1++){
            m[0] = (y[0] * (d - e1) + x[0] * e1) / d | 0, m[1] = (y[1] * (d - e1) + x[1] * e1) / d | 0, m[2] = (y[2] * (d - e1) + x[2] * e1) / d | 0, b[0] = (w[0] * (d - e1) + S[0] * e1) / d | 0, b[1] = (w[1] * (d - e1) + S[1] * e1) / d | 0, b[2] = (w[2] * (d - e1) + S[2] * e1) / d | 0;
            for(let t = 0; t <= h; t++, p++){
                if (!(0 !== e1 && e1 !== d || 0 !== t && t !== h)) continue;
                let s = 0, r = 0, o = 0;
                for(let n = 0; n <= 3; n++)for(let l = 0; l <= 3; l++, o++){
                    const c = v[e1][n] * C[t][l];
                    s += i[a[o]][0] * c, r += i[a[o]][1] * c;
                }
                g[p] = i.length, i.push([
                    s,
                    r
                ]), f[p] = n.length;
                const l = new Uint8Array(3);
                l[0] = (m[0] * (h - t) + b[0] * t) / h | 0, l[1] = (m[1] * (h - t) + b[1] * t) / h | 0, l[2] = (m[2] * (h - t) + b[2] * t) / h | 0, n.push(l);
            }
        }
        g[0] = a[0], f[0] = s[0], g[h] = a[3], f[h] = s[1], g[u * d] = a[12], f[u * d] = s[2], g[u * d + h] = a[15], f[u * d + h] = s[3], this.figures[e1] = {
            type: "lattice",
            coords: g,
            colors: f,
            verticesPerRow: u
        };
    }
    _updateBounds() {
        let e1 = this.coords[0][0], t = this.coords[0][1], i = e1, n = t;
        for(let a = 1, s = this.coords.length; a < s; a++){
            const s = this.coords[a][0], r = this.coords[a][1];
            e1 = e1 > s ? s : e1, t = t > r ? r : t, i = i < s ? s : i, n = n < r ? r : n;
        }
        this.bounds = [
            e1,
            t,
            i,
            n
        ];
    }
    _packData() {
        let e1, t, i, n;
        const a = this.coords, s = new Float32Array(2 * a.length);
        for(e1 = 0, i = 0, t = a.length; e1 < t; e1++){
            const t = a[e1];
            s[i++] = t[0], s[i++] = t[1];
        }
        this.coords = s;
        const r = this.colors, o = new Uint8Array(3 * r.length);
        for(e1 = 0, i = 0, t = r.length; e1 < t; e1++){
            const t = r[e1];
            o[i++] = t[0], o[i++] = t[1], o[i++] = t[2];
        }
        this.colors = o;
        const l = this.figures;
        for(e1 = 0, t = l.length; e1 < t; e1++){
            const t = l[e1], a = t.coords, s = t.colors;
            for(i = 0, n = a.length; i < n; i++)a[i] *= 2, s[i] *= 3;
        }
    }
    getIR() {
        const { bounds: e1 } = this;
        if (e1[2] - e1[0] === 0 || e1[3] - e1[1] === 0) throw new ti(`Invalid MeshShading bounds: [${e1}].`);
        return [
            "Mesh",
            this.shadingType,
            this.coords,
            this.colors,
            this.figures,
            e1,
            this.bbox,
            this.background
        ];
    }
}
class DummyShading extends BaseShading {
    getIR() {
        return [
            "Dummy"
        ];
    }
}
function getTilingPatternIR(e1, t, i) {
    const n = lookupMatrix(t.getArray("Matrix"), pi), a = lookupNormalRect(t.getArray("BBox"), null);
    if (!a || a[2] - a[0] === 0 || a[3] - a[1] === 0) throw new ti("Invalid getTilingPatternIR /BBox array.");
    const s = t.get("XStep");
    if ("number" != typeof s) throw new ti("Invalid getTilingPatternIR /XStep value.");
    const r = t.get("YStep");
    if ("number" != typeof r) throw new ti("Invalid getTilingPatternIR /YStep value.");
    const o = t.get("PaintType");
    if (!Number.isInteger(o)) throw new ti("Invalid getTilingPatternIR /PaintType value.");
    const l = t.get("TilingType");
    if (!Number.isInteger(l)) throw new ti("Invalid getTilingPatternIR /TilingType value.");
    return [
        "TilingPattern",
        i,
        e1,
        n,
        a,
        s,
        r,
        o,
        l
    ];
}
const ba = [
    1.3877,
    1,
    1,
    1,
    .97801,
    .92482,
    .89552,
    .91133,
    .81988,
    .97566,
    .98152,
    .93548,
    .93548,
    1.2798,
    .85284,
    .92794,
    1,
    .96134,
    1.54657,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .82845,
    .82845,
    .85284,
    .85284,
    .85284,
    .75859,
    .92138,
    .83908,
    .7762,
    .73293,
    .87289,
    .73133,
    .7514,
    .81921,
    .87356,
    .95958,
    .59526,
    .75727,
    .69225,
    1.04924,
    .9121,
    .86943,
    .79795,
    .88198,
    .77958,
    .70864,
    .81055,
    .90399,
    .88653,
    .96017,
    .82577,
    .77892,
    .78257,
    .97507,
    1.54657,
    .97507,
    .85284,
    .89552,
    .90176,
    .88762,
    .8785,
    .75241,
    .8785,
    .90518,
    .95015,
    .77618,
    .8785,
    .88401,
    .91916,
    .86304,
    .88401,
    .91488,
    .8785,
    .8801,
    .8785,
    .8785,
    .91343,
    .7173,
    1.04106,
    .8785,
    .85075,
    .95794,
    .82616,
    .85162,
    .79492,
    .88331,
    1.69808,
    .88331,
    .85284,
    .97801,
    .89552,
    .91133,
    .89552,
    .91133,
    1.7801,
    .89552,
    1.24487,
    1.13254,
    1.12401,
    .96839,
    .85284,
    .68787,
    .70645,
    .85592,
    .90747,
    1.01466,
    1.0088,
    .90323,
    1,
    1.07463,
    1,
    .91056,
    .75806,
    1.19118,
    .96839,
    .78864,
    .82845,
    .84133,
    .75859,
    .83908,
    .83908,
    .83908,
    .83908,
    .83908,
    .83908,
    .77539,
    .73293,
    .73133,
    .73133,
    .73133,
    .73133,
    .95958,
    .95958,
    .95958,
    .95958,
    .88506,
    .9121,
    .86943,
    .86943,
    .86943,
    .86943,
    .86943,
    .85284,
    .87508,
    .90399,
    .90399,
    .90399,
    .90399,
    .77892,
    .79795,
    .90807,
    .88762,
    .88762,
    .88762,
    .88762,
    .88762,
    .88762,
    .8715,
    .75241,
    .90518,
    .90518,
    .90518,
    .90518,
    .88401,
    .88401,
    .88401,
    .88401,
    .8785,
    .8785,
    .8801,
    .8801,
    .8801,
    .8801,
    .8801,
    .90747,
    .89049,
    .8785,
    .8785,
    .8785,
    .8785,
    .85162,
    .8785,
    .85162,
    .83908,
    .88762,
    .83908,
    .88762,
    .83908,
    .88762,
    .73293,
    .75241,
    .73293,
    .75241,
    .73293,
    .75241,
    .73293,
    .75241,
    .87289,
    .83016,
    .88506,
    .93125,
    .73133,
    .90518,
    .73133,
    .90518,
    .73133,
    .90518,
    .73133,
    .90518,
    .73133,
    .90518,
    .81921,
    .77618,
    .81921,
    .77618,
    .81921,
    .77618,
    1,
    1,
    .87356,
    .8785,
    .91075,
    .89608,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .76229,
    .90167,
    .59526,
    .91916,
    1,
    1,
    .86304,
    .69225,
    .88401,
    1,
    1,
    .70424,
    .79468,
    .91926,
    .88175,
    .70823,
    .94903,
    .9121,
    .8785,
    1,
    1,
    .9121,
    .8785,
    .87802,
    .88656,
    .8785,
    .86943,
    .8801,
    .86943,
    .8801,
    .86943,
    .8801,
    .87402,
    .89291,
    .77958,
    .91343,
    1,
    1,
    .77958,
    .91343,
    .70864,
    .7173,
    .70864,
    .7173,
    .70864,
    .7173,
    .70864,
    .7173,
    1,
    1,
    .81055,
    .75841,
    .81055,
    1.06452,
    .90399,
    .8785,
    .90399,
    .8785,
    .90399,
    .8785,
    .90399,
    .8785,
    .90399,
    .8785,
    .90399,
    .8785,
    .96017,
    .95794,
    .77892,
    .85162,
    .77892,
    .78257,
    .79492,
    .78257,
    .79492,
    .78257,
    .79492,
    .9297,
    .56892,
    .83908,
    .88762,
    .77539,
    .8715,
    .87508,
    .89049,
    1,
    1,
    .81055,
    1.04106,
    1.20528,
    1.20528,
    1,
    1.15543,
    .70674,
    .98387,
    .94721,
    1.33431,
    1.45894,
    .95161,
    1.06303,
    .83908,
    .80352,
    .57184,
    .6965,
    .56289,
    .82001,
    .56029,
    .81235,
    1.02988,
    .83908,
    .7762,
    .68156,
    .80367,
    .73133,
    .78257,
    .87356,
    .86943,
    .95958,
    .75727,
    .89019,
    1.04924,
    .9121,
    .7648,
    .86943,
    .87356,
    .79795,
    .78275,
    .81055,
    .77892,
    .9762,
    .82577,
    .99819,
    .84896,
    .95958,
    .77892,
    .96108,
    1.01407,
    .89049,
    1.02988,
    .94211,
    .96108,
    .8936,
    .84021,
    .87842,
    .96399,
    .79109,
    .89049,
    1.00813,
    1.02988,
    .86077,
    .87445,
    .92099,
    .84723,
    .86513,
    .8801,
    .75638,
    .85714,
    .78216,
    .79586,
    .87965,
    .94211,
    .97747,
    .78287,
    .97926,
    .84971,
    1.02988,
    .94211,
    .8801,
    .94211,
    .84971,
    .73133,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90264,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90518,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90548,
    1,
    1,
    1,
    1,
    1,
    1,
    .96017,
    .95794,
    .96017,
    .95794,
    .96017,
    .95794,
    .77892,
    .85162,
    1,
    1,
    .89552,
    .90527,
    1,
    .90363,
    .92794,
    .92794,
    .92794,
    .92794,
    .87012,
    .87012,
    .87012,
    .89552,
    .89552,
    1.42259,
    .71143,
    1.06152,
    1,
    1,
    1.03372,
    1.03372,
    .97171,
    1.4956,
    2.2807,
    .93835,
    .83406,
    .91133,
    .84107,
    .91133,
    1,
    1,
    1,
    .72021,
    1,
    1.23108,
    .83489,
    .88525,
    .88525,
    .81499,
    .90527,
    1.81055,
    .90527,
    1.81055,
    1.31006,
    1.53711,
    .94434,
    1.08696,
    1,
    .95018,
    .77192,
    .85284,
    .90747,
    1.17534,
    .69825,
    .9716,
    1.37077,
    .90747,
    .90747,
    .85356,
    .90747,
    .90747,
    1.44947,
    .85284,
    .8941,
    .8941,
    .70572,
    .8,
    .70572,
    .70572,
    .70572,
    .70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99862,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.08004,
    .91027,
    1,
    1,
    1,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90727,
    .90727,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], ya = {
    lineHeight: 1.2207,
    lineGap: .2207
}, wa = [
    1.3877,
    1,
    1,
    1,
    .97801,
    .92482,
    .89552,
    .91133,
    .81988,
    .97566,
    .98152,
    .93548,
    .93548,
    1.2798,
    .85284,
    .92794,
    1,
    .96134,
    1.56239,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .82845,
    .82845,
    .85284,
    .85284,
    .85284,
    .75859,
    .92138,
    .83908,
    .7762,
    .71805,
    .87289,
    .73133,
    .7514,
    .81921,
    .87356,
    .95958,
    .59526,
    .75727,
    .69225,
    1.04924,
    .90872,
    .85938,
    .79795,
    .87068,
    .77958,
    .69766,
    .81055,
    .90399,
    .88653,
    .96068,
    .82577,
    .77892,
    .78257,
    .97507,
    1.529,
    .97507,
    .85284,
    .89552,
    .90176,
    .94908,
    .86411,
    .74012,
    .86411,
    .88323,
    .95015,
    .86411,
    .86331,
    .88401,
    .91916,
    .86304,
    .88401,
    .9039,
    .86331,
    .86331,
    .86411,
    .86411,
    .90464,
    .70852,
    1.04106,
    .86331,
    .84372,
    .95794,
    .82616,
    .84548,
    .79492,
    .88331,
    1.69808,
    .88331,
    .85284,
    .97801,
    .89552,
    .91133,
    .89552,
    .91133,
    1.7801,
    .89552,
    1.24487,
    1.13254,
    1.19129,
    .96839,
    .85284,
    .68787,
    .70645,
    .85592,
    .90747,
    1.01466,
    1.0088,
    .90323,
    1,
    1.07463,
    1,
    .91056,
    .75806,
    1.19118,
    .96839,
    .78864,
    .82845,
    .84133,
    .75859,
    .83908,
    .83908,
    .83908,
    .83908,
    .83908,
    .83908,
    .77539,
    .71805,
    .73133,
    .73133,
    .73133,
    .73133,
    .95958,
    .95958,
    .95958,
    .95958,
    .88506,
    .90872,
    .85938,
    .85938,
    .85938,
    .85938,
    .85938,
    .85284,
    .87068,
    .90399,
    .90399,
    .90399,
    .90399,
    .77892,
    .79795,
    .90807,
    .94908,
    .94908,
    .94908,
    .94908,
    .94908,
    .94908,
    .85887,
    .74012,
    .88323,
    .88323,
    .88323,
    .88323,
    .88401,
    .88401,
    .88401,
    .88401,
    .8785,
    .86331,
    .86331,
    .86331,
    .86331,
    .86331,
    .86331,
    .90747,
    .89049,
    .86331,
    .86331,
    .86331,
    .86331,
    .84548,
    .86411,
    .84548,
    .83908,
    .94908,
    .83908,
    .94908,
    .83908,
    .94908,
    .71805,
    .74012,
    .71805,
    .74012,
    .71805,
    .74012,
    .71805,
    .74012,
    .87289,
    .79538,
    .88506,
    .92726,
    .73133,
    .88323,
    .73133,
    .88323,
    .73133,
    .88323,
    .73133,
    .88323,
    .73133,
    .88323,
    .81921,
    .86411,
    .81921,
    .86411,
    .81921,
    .86411,
    1,
    1,
    .87356,
    .86331,
    .91075,
    .8777,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .76467,
    .90167,
    .59526,
    .91916,
    1,
    1,
    .86304,
    .69225,
    .88401,
    1,
    1,
    .70424,
    .77312,
    .91926,
    .88175,
    .70823,
    .94903,
    .90872,
    .86331,
    1,
    1,
    .90872,
    .86331,
    .86906,
    .88116,
    .86331,
    .85938,
    .86331,
    .85938,
    .86331,
    .85938,
    .86331,
    .87402,
    .86549,
    .77958,
    .90464,
    1,
    1,
    .77958,
    .90464,
    .69766,
    .70852,
    .69766,
    .70852,
    .69766,
    .70852,
    .69766,
    .70852,
    1,
    1,
    .81055,
    .75841,
    .81055,
    1.06452,
    .90399,
    .86331,
    .90399,
    .86331,
    .90399,
    .86331,
    .90399,
    .86331,
    .90399,
    .86331,
    .90399,
    .86331,
    .96068,
    .95794,
    .77892,
    .84548,
    .77892,
    .78257,
    .79492,
    .78257,
    .79492,
    .78257,
    .79492,
    .9297,
    .56892,
    .83908,
    .94908,
    .77539,
    .85887,
    .87068,
    .89049,
    1,
    1,
    .81055,
    1.04106,
    1.20528,
    1.20528,
    1,
    1.15543,
    .70088,
    .98387,
    .94721,
    1.33431,
    1.45894,
    .95161,
    1.48387,
    .83908,
    .80352,
    .57118,
    .6965,
    .56347,
    .79179,
    .55853,
    .80346,
    1.02988,
    .83908,
    .7762,
    .67174,
    .86036,
    .73133,
    .78257,
    .87356,
    .86441,
    .95958,
    .75727,
    .89019,
    1.04924,
    .90872,
    .74889,
    .85938,
    .87891,
    .79795,
    .7957,
    .81055,
    .77892,
    .97447,
    .82577,
    .97466,
    .87179,
    .95958,
    .77892,
    .94252,
    .95612,
    .8753,
    1.02988,
    .92733,
    .94252,
    .87411,
    .84021,
    .8728,
    .95612,
    .74081,
    .8753,
    1.02189,
    1.02988,
    .84814,
    .87445,
    .91822,
    .84723,
    .85668,
    .86331,
    .81344,
    .87581,
    .76422,
    .82046,
    .96057,
    .92733,
    .99375,
    .78022,
    .95452,
    .86015,
    1.02988,
    .92733,
    .86331,
    .92733,
    .86015,
    .73133,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90631,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .88323,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .85174,
    1,
    1,
    1,
    1,
    1,
    1,
    .96068,
    .95794,
    .96068,
    .95794,
    .96068,
    .95794,
    .77892,
    .84548,
    1,
    1,
    .89552,
    .90527,
    1,
    .90363,
    .92794,
    .92794,
    .92794,
    .89807,
    .87012,
    .87012,
    .87012,
    .89552,
    .89552,
    1.42259,
    .71094,
    1.06152,
    1,
    1,
    1.03372,
    1.03372,
    .97171,
    1.4956,
    2.2807,
    .92972,
    .83406,
    .91133,
    .83326,
    .91133,
    1,
    1,
    1,
    .72021,
    1,
    1.23108,
    .83489,
    .88525,
    .88525,
    .81499,
    .90616,
    1.81055,
    .90527,
    1.81055,
    1.3107,
    1.53711,
    .94434,
    1.08696,
    1,
    .95018,
    .77192,
    .85284,
    .90747,
    1.17534,
    .69825,
    .9716,
    1.37077,
    .90747,
    .90747,
    .85356,
    .90747,
    .90747,
    1.44947,
    .85284,
    .8941,
    .8941,
    .70572,
    .8,
    .70572,
    .70572,
    .70572,
    .70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99862,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.08004,
    .91027,
    1,
    1,
    1,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90727,
    .90727,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Aa = {
    lineHeight: 1.2207,
    lineGap: .2207
}, xa = [
    1.3877,
    1,
    1,
    1,
    1.17223,
    1.1293,
    .89552,
    .91133,
    .80395,
    1.02269,
    1.15601,
    .91056,
    .91056,
    1.2798,
    .85284,
    .89807,
    1,
    .90861,
    1.39543,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .96309,
    .96309,
    .85284,
    .85284,
    .85284,
    .83319,
    .88071,
    .8675,
    .81552,
    .72346,
    .85193,
    .73206,
    .7522,
    .81105,
    .86275,
    .90685,
    .6377,
    .77892,
    .75593,
    1.02638,
    .89249,
    .84118,
    .77452,
    .85374,
    .75186,
    .67789,
    .79776,
    .88844,
    .85066,
    .94309,
    .77818,
    .7306,
    .76659,
    1.10369,
    1.38313,
    1.10369,
    1.06139,
    .89552,
    .8739,
    .9245,
    .9245,
    .83203,
    .9245,
    .85865,
    1.09842,
    .9245,
    .9245,
    1.03297,
    1.07692,
    .90918,
    1.03297,
    .94959,
    .9245,
    .92274,
    .9245,
    .9245,
    1.02933,
    .77832,
    1.20562,
    .9245,
    .8916,
    .98986,
    .86621,
    .89453,
    .79004,
    .94152,
    1.77256,
    .94152,
    .85284,
    .97801,
    .89552,
    .91133,
    .89552,
    .91133,
    1.91729,
    .89552,
    1.17889,
    1.13254,
    1.16359,
    .92098,
    .85284,
    .68787,
    .71353,
    .84737,
    .90747,
    1.0088,
    1.0044,
    .87683,
    1,
    1.09091,
    1,
    .92229,
    .739,
    1.15642,
    .92098,
    .76288,
    .80504,
    .80972,
    .75859,
    .8675,
    .8675,
    .8675,
    .8675,
    .8675,
    .8675,
    .76318,
    .72346,
    .73206,
    .73206,
    .73206,
    .73206,
    .90685,
    .90685,
    .90685,
    .90685,
    .86477,
    .89249,
    .84118,
    .84118,
    .84118,
    .84118,
    .84118,
    .85284,
    .84557,
    .88844,
    .88844,
    .88844,
    .88844,
    .7306,
    .77452,
    .86331,
    .9245,
    .9245,
    .9245,
    .9245,
    .9245,
    .9245,
    .84843,
    .83203,
    .85865,
    .85865,
    .85865,
    .85865,
    .82601,
    .82601,
    .82601,
    .82601,
    .94469,
    .9245,
    .92274,
    .92274,
    .92274,
    .92274,
    .92274,
    .90747,
    .86651,
    .9245,
    .9245,
    .9245,
    .9245,
    .89453,
    .9245,
    .89453,
    .8675,
    .9245,
    .8675,
    .9245,
    .8675,
    .9245,
    .72346,
    .83203,
    .72346,
    .83203,
    .72346,
    .83203,
    .72346,
    .83203,
    .85193,
    .8875,
    .86477,
    .99034,
    .73206,
    .85865,
    .73206,
    .85865,
    .73206,
    .85865,
    .73206,
    .85865,
    .73206,
    .85865,
    .81105,
    .9245,
    .81105,
    .9245,
    .81105,
    .9245,
    1,
    1,
    .86275,
    .9245,
    .90872,
    .93591,
    .90685,
    .82601,
    .90685,
    .82601,
    .90685,
    .82601,
    .90685,
    1.03297,
    .90685,
    .82601,
    .77896,
    1.05611,
    .6377,
    1.07692,
    1,
    1,
    .90918,
    .75593,
    1.03297,
    1,
    1,
    .76032,
    .9375,
    .98156,
    .93407,
    .77261,
    1.11429,
    .89249,
    .9245,
    1,
    1,
    .89249,
    .9245,
    .92534,
    .86698,
    .9245,
    .84118,
    .92274,
    .84118,
    .92274,
    .84118,
    .92274,
    .8667,
    .86291,
    .75186,
    1.02933,
    1,
    1,
    .75186,
    1.02933,
    .67789,
    .77832,
    .67789,
    .77832,
    .67789,
    .77832,
    .67789,
    .77832,
    1,
    1,
    .79776,
    .97655,
    .79776,
    1.23023,
    .88844,
    .9245,
    .88844,
    .9245,
    .88844,
    .9245,
    .88844,
    .9245,
    .88844,
    .9245,
    .88844,
    .9245,
    .94309,
    .98986,
    .7306,
    .89453,
    .7306,
    .76659,
    .79004,
    .76659,
    .79004,
    .76659,
    .79004,
    1.09231,
    .54873,
    .8675,
    .9245,
    .76318,
    .84843,
    .84557,
    .86651,
    1,
    1,
    .79776,
    1.20562,
    1.18622,
    1.18622,
    1,
    1.1437,
    .67009,
    .96334,
    .93695,
    1.35191,
    1.40909,
    .95161,
    1.48387,
    .8675,
    .90861,
    .6192,
    .7363,
    .64824,
    .82411,
    .56321,
    .85696,
    1.23516,
    .8675,
    .81552,
    .7286,
    .84134,
    .73206,
    .76659,
    .86275,
    .84369,
    .90685,
    .77892,
    .85871,
    1.02638,
    .89249,
    .75828,
    .84118,
    .85984,
    .77452,
    .76466,
    .79776,
    .7306,
    .90782,
    .77818,
    .903,
    .87291,
    .90685,
    .7306,
    .99058,
    1.03667,
    .94635,
    1.23516,
    .9849,
    .99058,
    .92393,
    .8916,
    .942,
    1.03667,
    .75026,
    .94635,
    1.0297,
    1.23516,
    .90918,
    .94048,
    .98217,
    .89746,
    .84153,
    .92274,
    .82507,
    .88832,
    .84438,
    .88178,
    1.03525,
    .9849,
    1.00225,
    .78086,
    .97248,
    .89404,
    1.23516,
    .9849,
    .92274,
    .9849,
    .89404,
    .73206,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .89693,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .85865,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90933,
    1,
    1,
    1,
    1,
    1,
    1,
    .94309,
    .98986,
    .94309,
    .98986,
    .94309,
    .98986,
    .7306,
    .89453,
    1,
    1,
    .89552,
    .90527,
    1,
    .90186,
    1.12308,
    1.12308,
    1.12308,
    1.12308,
    1.2566,
    1.2566,
    1.2566,
    .89552,
    .89552,
    1.42259,
    .68994,
    1.03809,
    1,
    1,
    1.0176,
    1.0176,
    1.11523,
    1.4956,
    2.01462,
    .97858,
    .82616,
    .91133,
    .83437,
    .91133,
    1,
    1,
    1,
    .70508,
    1,
    1.23108,
    .79801,
    .84426,
    .84426,
    .774,
    .90572,
    1.81055,
    .90749,
    1.81055,
    1.28809,
    1.55469,
    .94434,
    1.07806,
    1,
    .97094,
    .7589,
    .85284,
    .90747,
    1.19658,
    .69825,
    .97622,
    1.33512,
    .90747,
    .90747,
    .85284,
    .90747,
    .90747,
    1.44947,
    .85284,
    .8941,
    .8941,
    .70572,
    .8,
    .70572,
    .70572,
    .70572,
    .70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99862,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.0336,
    .91027,
    1,
    1,
    1,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05859,
    1.05859,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Sa = {
    lineHeight: 1.2207,
    lineGap: .2207
}, va = [
    1.3877,
    1,
    1,
    1,
    1.17223,
    1.1293,
    .89552,
    .91133,
    .80395,
    1.02269,
    1.15601,
    .91056,
    .91056,
    1.2798,
    .85284,
    .89807,
    1,
    .90861,
    1.39016,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .96309,
    .96309,
    .85284,
    .85284,
    .85284,
    .83319,
    .88071,
    .8675,
    .81552,
    .73834,
    .85193,
    .73206,
    .7522,
    .81105,
    .86275,
    .90685,
    .6377,
    .77892,
    .75593,
    1.02638,
    .89385,
    .85122,
    .77452,
    .86503,
    .75186,
    .68887,
    .79776,
    .88844,
    .85066,
    .94258,
    .77818,
    .7306,
    .76659,
    1.10369,
    1.39016,
    1.10369,
    1.06139,
    .89552,
    .8739,
    .86128,
    .94469,
    .8457,
    .94469,
    .89464,
    1.09842,
    .84636,
    .94469,
    1.03297,
    1.07692,
    .90918,
    1.03297,
    .95897,
    .94469,
    .9482,
    .94469,
    .94469,
    1.04692,
    .78223,
    1.20562,
    .94469,
    .90332,
    .98986,
    .86621,
    .90527,
    .79004,
    .94152,
    1.77256,
    .94152,
    .85284,
    .97801,
    .89552,
    .91133,
    .89552,
    .91133,
    1.91729,
    .89552,
    1.17889,
    1.13254,
    1.08707,
    .92098,
    .85284,
    .68787,
    .71353,
    .84737,
    .90747,
    1.0088,
    1.0044,
    .87683,
    1,
    1.09091,
    1,
    .92229,
    .739,
    1.15642,
    .92098,
    .76288,
    .80504,
    .80972,
    .75859,
    .8675,
    .8675,
    .8675,
    .8675,
    .8675,
    .8675,
    .76318,
    .73834,
    .73206,
    .73206,
    .73206,
    .73206,
    .90685,
    .90685,
    .90685,
    .90685,
    .86477,
    .89385,
    .85122,
    .85122,
    .85122,
    .85122,
    .85122,
    .85284,
    .85311,
    .88844,
    .88844,
    .88844,
    .88844,
    .7306,
    .77452,
    .86331,
    .86128,
    .86128,
    .86128,
    .86128,
    .86128,
    .86128,
    .8693,
    .8457,
    .89464,
    .89464,
    .89464,
    .89464,
    .82601,
    .82601,
    .82601,
    .82601,
    .94469,
    .94469,
    .9482,
    .9482,
    .9482,
    .9482,
    .9482,
    .90747,
    .86651,
    .94469,
    .94469,
    .94469,
    .94469,
    .90527,
    .94469,
    .90527,
    .8675,
    .86128,
    .8675,
    .86128,
    .8675,
    .86128,
    .73834,
    .8457,
    .73834,
    .8457,
    .73834,
    .8457,
    .73834,
    .8457,
    .85193,
    .92454,
    .86477,
    .9921,
    .73206,
    .89464,
    .73206,
    .89464,
    .73206,
    .89464,
    .73206,
    .89464,
    .73206,
    .89464,
    .81105,
    .84636,
    .81105,
    .84636,
    .81105,
    .84636,
    1,
    1,
    .86275,
    .94469,
    .90872,
    .95786,
    .90685,
    .82601,
    .90685,
    .82601,
    .90685,
    .82601,
    .90685,
    1.03297,
    .90685,
    .82601,
    .77741,
    1.05611,
    .6377,
    1.07692,
    1,
    1,
    .90918,
    .75593,
    1.03297,
    1,
    1,
    .76032,
    .90452,
    .98156,
    1.11842,
    .77261,
    1.11429,
    .89385,
    .94469,
    1,
    1,
    .89385,
    .94469,
    .95877,
    .86901,
    .94469,
    .85122,
    .9482,
    .85122,
    .9482,
    .85122,
    .9482,
    .8667,
    .90016,
    .75186,
    1.04692,
    1,
    1,
    .75186,
    1.04692,
    .68887,
    .78223,
    .68887,
    .78223,
    .68887,
    .78223,
    .68887,
    .78223,
    1,
    1,
    .79776,
    .92188,
    .79776,
    1.23023,
    .88844,
    .94469,
    .88844,
    .94469,
    .88844,
    .94469,
    .88844,
    .94469,
    .88844,
    .94469,
    .88844,
    .94469,
    .94258,
    .98986,
    .7306,
    .90527,
    .7306,
    .76659,
    .79004,
    .76659,
    .79004,
    .76659,
    .79004,
    1.09231,
    .54873,
    .8675,
    .86128,
    .76318,
    .8693,
    .85311,
    .86651,
    1,
    1,
    .79776,
    1.20562,
    1.18622,
    1.18622,
    1,
    1.1437,
    .67742,
    .96334,
    .93695,
    1.35191,
    1.40909,
    .95161,
    1.48387,
    .86686,
    .90861,
    .62267,
    .74359,
    .65649,
    .85498,
    .56963,
    .88254,
    1.23516,
    .8675,
    .81552,
    .75443,
    .84503,
    .73206,
    .76659,
    .86275,
    .85122,
    .90685,
    .77892,
    .85746,
    1.02638,
    .89385,
    .75657,
    .85122,
    .86275,
    .77452,
    .74171,
    .79776,
    .7306,
    .95165,
    .77818,
    .89772,
    .88831,
    .90685,
    .7306,
    .98142,
    1.02191,
    .96576,
    1.23516,
    .99018,
    .98142,
    .9236,
    .89258,
    .94035,
    1.02191,
    .78848,
    .96576,
    .9561,
    1.23516,
    .90918,
    .92578,
    .95424,
    .89746,
    .83969,
    .9482,
    .80113,
    .89442,
    .85208,
    .86155,
    .98022,
    .99018,
    1.00452,
    .81209,
    .99247,
    .89181,
    1.23516,
    .99018,
    .9482,
    .99018,
    .89181,
    .73206,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .88844,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .89464,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .96766,
    1,
    1,
    1,
    1,
    1,
    1,
    .94258,
    .98986,
    .94258,
    .98986,
    .94258,
    .98986,
    .7306,
    .90527,
    1,
    1,
    .89552,
    .90527,
    1,
    .90186,
    1.12308,
    1.12308,
    1.12308,
    1.12308,
    1.2566,
    1.2566,
    1.2566,
    .89552,
    .89552,
    1.42259,
    .69043,
    1.03809,
    1,
    1,
    1.0176,
    1.0176,
    1.11523,
    1.4956,
    2.01462,
    .99331,
    .82616,
    .91133,
    .84286,
    .91133,
    1,
    1,
    1,
    .70508,
    1,
    1.23108,
    .79801,
    .84426,
    .84426,
    .774,
    .90527,
    1.81055,
    .90527,
    1.81055,
    1.28809,
    1.55469,
    .94434,
    1.07806,
    1,
    .97094,
    .7589,
    .85284,
    .90747,
    1.19658,
    .69825,
    .97622,
    1.33512,
    .90747,
    .90747,
    .85356,
    .90747,
    .90747,
    1.44947,
    .85284,
    .8941,
    .8941,
    .70572,
    .8,
    .70572,
    .70572,
    .70572,
    .70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99862,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.0336,
    .91027,
    1,
    1,
    1,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05859,
    1.05859,
    1,
    1,
    1,
    1.07185,
    .99413,
    .96334,
    1.08065,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Ca = {
    lineHeight: 1.2207,
    lineGap: .2207
}, ka = [
    .76116,
    1,
    1,
    1.0006,
    .99998,
    .99974,
    .99973,
    .99973,
    .99982,
    .99977,
    1.00087,
    .99998,
    .99998,
    .99959,
    1.00003,
    1.0006,
    .99998,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99998,
    1,
    1.00003,
    1.00003,
    1.00003,
    1.00026,
    .9999,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00026,
    1.00022,
    .99977,
    1.0006,
    .99973,
    .99977,
    1.00026,
    .99999,
    .99977,
    1.00022,
    1.00001,
    1.00022,
    .99977,
    1.00001,
    1.00026,
    .99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    .99998,
    1.0006,
    .99998,
    1.00003,
    .99973,
    .99998,
    .99973,
    1.00026,
    .99973,
    1.00026,
    .99973,
    .99998,
    1.00026,
    1.00026,
    1.0006,
    1.0006,
    .99973,
    1.0006,
    .99982,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99959,
    .99973,
    .99998,
    1.00026,
    .99973,
    1.00022,
    .99973,
    .99973,
    1,
    .99959,
    1.00077,
    .99959,
    1.00003,
    .99998,
    .99973,
    .99973,
    .99973,
    .99973,
    1.00077,
    .99973,
    .99998,
    1.00025,
    .99968,
    .99973,
    1.00003,
    1.00025,
    .60299,
    1.00024,
    1.06409,
    1,
    1,
    .99998,
    1,
    .99973,
    1.0006,
    .99998,
    1,
    .99936,
    .99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    .99977,
    .99977,
    .99977,
    .99977,
    .99977,
    .99977,
    1,
    .99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99977,
    .99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00001,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99982,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.06409,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99973,
    1.00026,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    1.03374,
    .99977,
    1.00026,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.00042,
    .99973,
    .99973,
    1.0006,
    .99977,
    .99973,
    .99973,
    1.00026,
    1.0006,
    1.00026,
    1.0006,
    1.00026,
    1.03828,
    1.00026,
    .99999,
    1.00026,
    1.0006,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .9993,
    .9998,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1,
    1.00016,
    .99977,
    .99959,
    .99977,
    .99959,
    .99977,
    .99959,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00026,
    .99998,
    1.00026,
    .8121,
    1.00026,
    .99998,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    1.00016,
    1.00022,
    1.00001,
    .99973,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    1.0006,
    .99973,
    .99977,
    .99973,
    1,
    .99982,
    1.00022,
    1.00026,
    1.00001,
    .99973,
    1.00026,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    1.00034,
    .99977,
    1,
    .99997,
    1.00026,
    1.00078,
    1.00036,
    .99973,
    1.00013,
    1.0006,
    .99977,
    .99977,
    .99988,
    .85148,
    1.00001,
    1.00026,
    .99977,
    1.00022,
    1.0006,
    .99977,
    1.00001,
    .99999,
    .99977,
    1.00069,
    1.00022,
    .99977,
    1.00001,
    .99984,
    1.00026,
    1.00001,
    1.00024,
    1.00001,
    .9999,
    1,
    1.0006,
    1.00001,
    1.00041,
    .99962,
    1.00026,
    1.0006,
    .99995,
    1.00041,
    .99942,
    .99973,
    .99927,
    1.00082,
    .99902,
    1.00026,
    1.00087,
    1.0006,
    1.00069,
    .99973,
    .99867,
    .99973,
    .9993,
    1.00026,
    1.00049,
    1.00056,
    1,
    .99988,
    .99935,
    .99995,
    .99954,
    1.00055,
    .99945,
    1.00032,
    1.0006,
    .99995,
    1.00026,
    .99995,
    1.00032,
    1.00001,
    1.00008,
    .99971,
    1.00019,
    .9994,
    1.00001,
    1.0006,
    1.00044,
    .99973,
    1.00023,
    1.00047,
    1,
    .99942,
    .99561,
    .99989,
    1.00035,
    .99977,
    1.00035,
    .99977,
    1.00019,
    .99944,
    1.00001,
    1.00021,
    .99926,
    1.00035,
    1.00035,
    .99942,
    1.00048,
    .99999,
    .99977,
    1.00022,
    1.00035,
    1.00001,
    .99977,
    1.00026,
    .99989,
    1.00057,
    1.00001,
    .99936,
    1.00052,
    1.00012,
    .99996,
    1.00043,
    1,
    1.00035,
    .9994,
    .99976,
    1.00035,
    .99973,
    1.00052,
    1.00041,
    1.00119,
    1.00037,
    .99973,
    1.00002,
    .99986,
    1.00041,
    1.00041,
    .99902,
    .9996,
    1.00034,
    .99999,
    1.00026,
    .99999,
    1.00026,
    .99973,
    1.00052,
    .99973,
    1,
    .99973,
    1.00041,
    1.00075,
    .9994,
    1.0003,
    .99999,
    1,
    1.00041,
    .99955,
    1,
    .99915,
    .99973,
    .99973,
    1.00026,
    1.00119,
    .99955,
    .99973,
    1.0006,
    .99911,
    1.0006,
    1.00026,
    .99972,
    1.00026,
    .99902,
    1.00041,
    .99973,
    .99999,
    1,
    1,
    1.00038,
    1.0005,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00001,
    .99973,
    1,
    1,
    .99973,
    1,
    1,
    .99955,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1,
    1,
    1,
    .99973,
    .99973,
    .99972,
    1,
    1,
    1.00106,
    .99999,
    .99998,
    .99998,
    .99999,
    .99998,
    1.66475,
    1,
    .99973,
    .99973,
    1.00023,
    .99973,
    .99971,
    1.00047,
    1.00023,
    1,
    .99991,
    .99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99972,
    1,
    1.20985,
    1.39713,
    1.00003,
    1.00031,
    1.00015,
    1,
    .99561,
    1.00027,
    1.00031,
    1.00031,
    .99915,
    1.00031,
    1.00031,
    .99999,
    1.00003,
    .99999,
    .99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    .99999,
    1,
    .99861,
    .99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99972,
    .99999,
    .99999,
    .99999,
    .99999,
    1.40483,
    1,
    .99977,
    1.00054,
    1,
    1,
    .99953,
    .99962,
    1.00042,
    .9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99998,
    .99998,
    .99998,
    .99998,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Ta = {
    lineHeight: 1.2,
    lineGap: .2
}, Fa = [
    .76116,
    1,
    1,
    1.0006,
    .99998,
    .99974,
    .99973,
    .99973,
    .99982,
    .99977,
    1.00087,
    .99998,
    .99998,
    .99959,
    1.00003,
    1.0006,
    .99998,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99998,
    1,
    1.00003,
    1.00003,
    1.00003,
    1.00026,
    .9999,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00026,
    1.00022,
    .99977,
    1.0006,
    .99973,
    .99977,
    1.00026,
    .99999,
    .99977,
    1.00022,
    1.00001,
    1.00022,
    .99977,
    1.00001,
    1.00026,
    .99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    .99998,
    1.0006,
    .99998,
    1.00003,
    .99973,
    .99998,
    .99973,
    1.00026,
    .99973,
    1.00026,
    .99973,
    .99998,
    1.00026,
    1.00026,
    1.0006,
    1.0006,
    .99973,
    1.0006,
    .99982,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99959,
    .99973,
    .99998,
    1.00026,
    .99973,
    1.00022,
    .99973,
    .99973,
    1,
    .99959,
    1.00077,
    .99959,
    1.00003,
    .99998,
    .99973,
    .99973,
    .99973,
    .99973,
    1.00077,
    .99973,
    .99998,
    1.00025,
    .99968,
    .99973,
    1.00003,
    1.00025,
    .60299,
    1.00024,
    1.06409,
    1,
    1,
    .99998,
    1,
    .99973,
    1.0006,
    .99998,
    1,
    .99936,
    .99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    .99977,
    .99977,
    .99977,
    .99977,
    .99977,
    .99977,
    1,
    .99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99977,
    .99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00001,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99982,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.06409,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99973,
    1.00026,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    1.0044,
    .99977,
    1.00026,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99971,
    .99973,
    .99973,
    1.0006,
    .99977,
    .99973,
    .99973,
    1.00026,
    1.0006,
    1.00026,
    1.0006,
    1.00026,
    1.01011,
    1.00026,
    .99999,
    1.00026,
    1.0006,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .9993,
    .9998,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1,
    1.00016,
    .99977,
    .99959,
    .99977,
    .99959,
    .99977,
    .99959,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00026,
    .99998,
    1.00026,
    .8121,
    1.00026,
    .99998,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    1.00016,
    1.00022,
    1.00001,
    .99973,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    1.0006,
    .99973,
    .99977,
    .99973,
    1,
    .99982,
    1.00022,
    1.00026,
    1.00001,
    .99973,
    1.00026,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99977,
    1,
    1,
    1.00026,
    .99969,
    .99972,
    .99981,
    .9998,
    1.0006,
    .99977,
    .99977,
    1.00022,
    .91155,
    1.00001,
    1.00026,
    .99977,
    1.00022,
    1.0006,
    .99977,
    1.00001,
    .99999,
    .99977,
    .99966,
    1.00022,
    1.00032,
    1.00001,
    .99944,
    1.00026,
    1.00001,
    .99968,
    1.00001,
    1.00047,
    1,
    1.0006,
    1.00001,
    .99981,
    1.00101,
    1.00026,
    1.0006,
    .99948,
    .99981,
    1.00064,
    .99973,
    .99942,
    1.00101,
    1.00061,
    1.00026,
    1.00069,
    1.0006,
    1.00014,
    .99973,
    1.01322,
    .99973,
    1.00065,
    1.00026,
    1.00012,
    .99923,
    1,
    1.00064,
    1.00076,
    .99948,
    1.00055,
    1.00063,
    1.00007,
    .99943,
    1.0006,
    .99948,
    1.00026,
    .99948,
    .99943,
    1.00001,
    1.00001,
    1.00029,
    1.00038,
    1.00035,
    1.00001,
    1.0006,
    1.0006,
    .99973,
    .99978,
    1.00001,
    1.00057,
    .99989,
    .99967,
    .99964,
    .99967,
    .99977,
    .99999,
    .99977,
    1.00038,
    .99977,
    1.00001,
    .99973,
    1.00066,
    .99967,
    .99967,
    1.00041,
    .99998,
    .99999,
    .99977,
    1.00022,
    .99967,
    1.00001,
    .99977,
    1.00026,
    .99964,
    1.00031,
    1.00001,
    .99999,
    .99999,
    1,
    1.00023,
    1,
    1,
    .99999,
    1.00035,
    1.00001,
    .99999,
    .99973,
    .99977,
    .99999,
    1.00058,
    .99973,
    .99973,
    .99955,
    .9995,
    1.00026,
    1.00026,
    1.00032,
    .99989,
    1.00034,
    .99999,
    1.00026,
    1.00026,
    1.00026,
    .99973,
    .45998,
    .99973,
    1.00026,
    .99973,
    1.00001,
    .99999,
    .99982,
    .99994,
    .99996,
    1,
    1.00042,
    1.00044,
    1.00029,
    1.00023,
    .99973,
    .99973,
    1.00026,
    .99949,
    1.00002,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    .99975,
    1.00026,
    1.00026,
    1.00032,
    .98685,
    .99973,
    1.00026,
    1,
    1,
    .99966,
    1.00044,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00001,
    .99973,
    1,
    1,
    .99973,
    1,
    1,
    .99955,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1,
    1,
    1,
    .99973,
    .99973,
    .99972,
    1,
    1,
    1.00106,
    .99999,
    .99998,
    .99998,
    .99999,
    .99998,
    1.66475,
    1,
    .99973,
    .99973,
    1,
    .99973,
    .99971,
    .99978,
    1,
    1,
    .99991,
    .99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1.00098,
    1,
    1,
    1,
    1.00049,
    1,
    1,
    .99972,
    1,
    1.20985,
    1.39713,
    1.00003,
    1.00031,
    1.00015,
    1,
    .99561,
    1.00027,
    1.00031,
    1.00031,
    .99915,
    1.00031,
    1.00031,
    .99999,
    1.00003,
    .99999,
    .99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    .99999,
    1,
    .99861,
    .99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99972,
    .99999,
    .99999,
    .99999,
    .99999,
    1.40483,
    1,
    .99977,
    1.00054,
    1,
    1,
    .99953,
    .99962,
    1.00042,
    .9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99998,
    .99998,
    .99998,
    .99998,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Ia = {
    lineHeight: 1.35,
    lineGap: .2
}, Ea = [
    .76116,
    1,
    1,
    1.0006,
    1.0006,
    1.00006,
    .99973,
    .99973,
    .99982,
    1.00001,
    1.00043,
    .99998,
    .99998,
    .99959,
    1.00003,
    1.0006,
    .99998,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1,
    1.00003,
    1.00003,
    1.00003,
    .99973,
    .99987,
    1.00001,
    1.00001,
    .99977,
    .99977,
    1.00001,
    1.00026,
    1.00022,
    .99977,
    1.0006,
    1,
    1.00001,
    .99973,
    .99999,
    .99977,
    1.00022,
    1.00001,
    1.00022,
    .99977,
    1.00001,
    1.00026,
    .99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    .99949,
    .99973,
    .99998,
    .99973,
    .99973,
    1,
    .99973,
    .99973,
    1.0006,
    .99973,
    .99973,
    .99924,
    .99924,
    1,
    .99924,
    .99999,
    .99973,
    .99973,
    .99973,
    .99973,
    .99998,
    1,
    1.0006,
    .99973,
    1,
    .99977,
    1,
    1,
    1,
    1.00005,
    1.0009,
    1.00005,
    1.00003,
    .99998,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0009,
    .99973,
    .99998,
    1.00025,
    .99968,
    .99973,
    1.00003,
    1.00025,
    .60299,
    1.00024,
    1.06409,
    1,
    1,
    .99998,
    1,
    .9998,
    1.0006,
    .99998,
    1,
    .99936,
    .99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1,
    .99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99977,
    .99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00001,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99982,
    1,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.06409,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    1,
    .99973,
    1,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1.0288,
    .99977,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99924,
    1.0006,
    1.0006,
    .99946,
    1.00034,
    1,
    .99924,
    1.00001,
    1,
    1,
    .99973,
    .99924,
    .99973,
    .99924,
    .99973,
    1.06311,
    .99973,
    1.00024,
    .99973,
    .99924,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.00041,
    .9998,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1,
    1.00016,
    .99977,
    .99998,
    .99977,
    .99998,
    .99977,
    .99998,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00026,
    1.0006,
    1.00026,
    .89547,
    1.00026,
    1.0006,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.00016,
    .99977,
    1.00001,
    1,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    .99924,
    .99973,
    1.00001,
    .99973,
    1,
    .99982,
    1.00022,
    1.00026,
    1.00001,
    1,
    1.00026,
    1.0006,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    1.00001,
    1,
    1.00054,
    .99977,
    1.00084,
    1.00007,
    .99973,
    1.00013,
    .99924,
    1.00001,
    1.00001,
    .99945,
    .91221,
    1.00001,
    1.00026,
    .99977,
    1.00022,
    1.0006,
    1.00001,
    1.00001,
    .99999,
    .99977,
    .99933,
    1.00022,
    1.00054,
    1.00001,
    1.00065,
    1.00026,
    1.00001,
    1.0001,
    1.00001,
    1.00052,
    1,
    1.0006,
    1.00001,
    .99945,
    .99897,
    .99968,
    .99924,
    1.00036,
    .99945,
    .99949,
    1,
    1.0006,
    .99897,
    .99918,
    .99968,
    .99911,
    .99924,
    1,
    .99962,
    1.01487,
    1,
    1.0005,
    .99973,
    1.00012,
    1.00043,
    1,
    .99995,
    .99994,
    1.00036,
    .99947,
    1.00019,
    1.00063,
    1.00025,
    .99924,
    1.00036,
    .99973,
    1.00036,
    1.00025,
    1.00001,
    1.00001,
    1.00027,
    1.0001,
    1.00068,
    1.00001,
    1.0006,
    1.0006,
    1,
    1.00008,
    .99957,
    .99972,
    .9994,
    .99954,
    .99975,
    1.00051,
    1.00001,
    1.00019,
    1.00001,
    1.0001,
    .99986,
    1.00001,
    1.00001,
    1.00038,
    .99954,
    .99954,
    .9994,
    1.00066,
    .99999,
    .99977,
    1.00022,
    1.00054,
    1.00001,
    .99977,
    1.00026,
    .99975,
    1.0001,
    1.00001,
    .99993,
    .9995,
    .99955,
    1.00016,
    .99978,
    .99974,
    1.00019,
    1.00022,
    .99955,
    1.00053,
    .99973,
    1.00089,
    1.00005,
    .99967,
    1.00048,
    .99973,
    1.00002,
    1.00034,
    .99973,
    .99973,
    .99964,
    1.00006,
    1.00066,
    .99947,
    .99973,
    .98894,
    .99973,
    1,
    .44898,
    1,
    .99946,
    1,
    1.00039,
    1.00082,
    .99991,
    .99991,
    .99985,
    1.00022,
    1.00023,
    1.00061,
    1.00006,
    .99966,
    .99973,
    .99973,
    .99973,
    1.00019,
    1.0008,
    1,
    .99924,
    .99924,
    .99924,
    .99983,
    1.00044,
    .99973,
    .99964,
    .98332,
    1,
    .99973,
    1,
    1,
    .99962,
    .99895,
    1.00016,
    .99977,
    1.00016,
    .99977,
    1.00016,
    .99977,
    1.00001,
    1,
    1,
    1,
    .99973,
    1,
    1,
    .99955,
    .99924,
    .99924,
    .99924,
    .99924,
    .99998,
    .99998,
    .99998,
    .99973,
    .99973,
    .99972,
    1,
    1,
    1.00267,
    .99999,
    .99998,
    .99998,
    1,
    .99998,
    1.66475,
    1,
    .99973,
    .99973,
    1.00023,
    .99973,
    1.00423,
    .99925,
    .99999,
    1,
    .99991,
    .99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1.00049,
    1,
    1.00245,
    1,
    1,
    1,
    1,
    .96329,
    1,
    1.20985,
    1.39713,
    1.00003,
    .8254,
    1.00015,
    1,
    1.00035,
    1.00027,
    1.00031,
    1.00031,
    1.00003,
    1.00031,
    1.00031,
    .99999,
    1.00003,
    .99999,
    .99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    .99999,
    1,
    .99861,
    .99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .95317,
    .99999,
    .99999,
    .99999,
    .99999,
    1.40483,
    1,
    .99977,
    1.00054,
    1,
    1,
    .99953,
    .99962,
    1.00042,
    .9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99998,
    .99998,
    .99998,
    .99998,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Ma = {
    lineHeight: 1.35,
    lineGap: .2
}, Da = [
    .76116,
    1,
    1,
    1.0006,
    1.0006,
    1.00006,
    .99973,
    .99973,
    .99982,
    1.00001,
    1.00043,
    .99998,
    .99998,
    .99959,
    1.00003,
    1.0006,
    .99998,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1,
    1.00003,
    1.00003,
    1.00003,
    .99973,
    .99987,
    1.00001,
    1.00001,
    .99977,
    .99977,
    1.00001,
    1.00026,
    1.00022,
    .99977,
    1.0006,
    1,
    1.00001,
    .99973,
    .99999,
    .99977,
    1.00022,
    1.00001,
    1.00022,
    .99977,
    1.00001,
    1.00026,
    .99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    .99949,
    .99973,
    .99998,
    .99973,
    .99973,
    1,
    .99973,
    .99973,
    1.0006,
    .99973,
    .99973,
    .99924,
    .99924,
    1,
    .99924,
    .99999,
    .99973,
    .99973,
    .99973,
    .99973,
    .99998,
    1,
    1.0006,
    .99973,
    1,
    .99977,
    1,
    1,
    1,
    1.00005,
    1.0009,
    1.00005,
    1.00003,
    .99998,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0009,
    .99973,
    .99998,
    1.00025,
    .99968,
    .99973,
    1.00003,
    1.00025,
    .60299,
    1.00024,
    1.06409,
    1,
    1,
    .99998,
    1,
    .9998,
    1.0006,
    .99998,
    1,
    .99936,
    .99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1,
    .99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99977,
    .99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00001,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99982,
    1,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.06409,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    1,
    .99973,
    1,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1.04596,
    .99977,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99924,
    1.0006,
    1.0006,
    1.00019,
    1.00034,
    1,
    .99924,
    1.00001,
    1,
    1,
    .99973,
    .99924,
    .99973,
    .99924,
    .99973,
    1.02572,
    .99973,
    1.00005,
    .99973,
    .99924,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99999,
    .9998,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1,
    1.00016,
    .99977,
    .99998,
    .99977,
    .99998,
    .99977,
    .99998,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00026,
    1.0006,
    1.00026,
    .84533,
    1.00026,
    1.0006,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.00016,
    .99977,
    1.00001,
    1,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    .99924,
    .99973,
    1.00001,
    .99973,
    1,
    .99982,
    1.00022,
    1.00026,
    1.00001,
    1,
    1.00026,
    1.0006,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99928,
    1,
    .99977,
    1.00013,
    1.00055,
    .99947,
    .99945,
    .99941,
    .99924,
    1.00001,
    1.00001,
    1.0004,
    .91621,
    1.00001,
    1.00026,
    .99977,
    1.00022,
    1.0006,
    1.00001,
    1.00005,
    .99999,
    .99977,
    1.00015,
    1.00022,
    .99977,
    1.00001,
    .99973,
    1.00026,
    1.00001,
    1.00019,
    1.00001,
    .99946,
    1,
    1.0006,
    1.00001,
    .99978,
    1.00045,
    .99973,
    .99924,
    1.00023,
    .99978,
    .99966,
    1,
    1.00065,
    1.00045,
    1.00019,
    .99973,
    .99973,
    .99924,
    1,
    1,
    .96499,
    1,
    1.00055,
    .99973,
    1.00008,
    1.00027,
    1,
    .9997,
    .99995,
    1.00023,
    .99933,
    1.00019,
    1.00015,
    1.00031,
    .99924,
    1.00023,
    .99973,
    1.00023,
    1.00031,
    1.00001,
    .99928,
    1.00029,
    1.00092,
    1.00035,
    1.00001,
    1.0006,
    1.0006,
    1,
    .99988,
    .99975,
    1,
    1.00082,
    .99561,
    .9996,
    1.00035,
    1.00001,
    .99962,
    1.00001,
    1.00092,
    .99964,
    1.00001,
    .99963,
    .99999,
    1.00035,
    1.00035,
    1.00082,
    .99962,
    .99999,
    .99977,
    1.00022,
    1.00035,
    1.00001,
    .99977,
    1.00026,
    .9996,
    .99967,
    1.00001,
    1.00034,
    1.00074,
    1.00054,
    1.00053,
    1.00063,
    .99971,
    .99962,
    1.00035,
    .99975,
    .99977,
    .99973,
    1.00043,
    .99953,
    1.0007,
    .99915,
    .99973,
    1.00008,
    .99892,
    1.00073,
    1.00073,
    1.00114,
    .99915,
    1.00073,
    .99955,
    .99973,
    1.00092,
    .99973,
    1,
    .99998,
    1,
    1.0003,
    1,
    1.00043,
    1.00001,
    .99969,
    1.0003,
    1,
    1.00035,
    1.00001,
    .9995,
    1,
    1.00092,
    .99973,
    .99973,
    .99973,
    1.0007,
    .9995,
    1,
    .99924,
    1.0006,
    .99924,
    .99972,
    1.00062,
    .99973,
    1.00114,
    1.00073,
    1,
    .99955,
    1,
    1,
    1.00047,
    .99968,
    1.00016,
    .99977,
    1.00016,
    .99977,
    1.00016,
    .99977,
    1.00001,
    1,
    1,
    1,
    .99973,
    1,
    1,
    .99955,
    .99924,
    .99924,
    .99924,
    .99924,
    .99998,
    .99998,
    .99998,
    .99973,
    .99973,
    .99972,
    1,
    1,
    1.00267,
    .99999,
    .99998,
    .99998,
    1,
    .99998,
    1.66475,
    1,
    .99973,
    .99973,
    1.00023,
    .99973,
    .99971,
    .99925,
    1.00023,
    1,
    .99991,
    .99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .96329,
    1,
    1.20985,
    1.39713,
    1.00003,
    .8254,
    1.00015,
    1,
    1.00035,
    1.00027,
    1.00031,
    1.00031,
    .99915,
    1.00031,
    1.00031,
    .99999,
    1.00003,
    .99999,
    .99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    .99999,
    1,
    .99861,
    .99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .95317,
    .99999,
    .99999,
    .99999,
    .99999,
    1.40483,
    1,
    .99977,
    1.00054,
    1,
    1,
    .99953,
    .99962,
    1.00042,
    .9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Oa = {
    lineHeight: 1.2,
    lineGap: .2
}, _a = [
    365,
    0,
    333,
    278,
    333,
    474,
    556,
    556,
    889,
    722,
    238,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    333,
    333,
    584,
    584,
    584,
    611,
    975,
    722,
    722,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    556,
    722,
    611,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    333,
    278,
    333,
    584,
    556,
    333,
    556,
    611,
    556,
    611,
    556,
    333,
    611,
    611,
    278,
    278,
    556,
    278,
    889,
    611,
    611,
    611,
    611,
    389,
    556,
    333,
    611,
    556,
    778,
    556,
    556,
    500,
    389,
    280,
    389,
    584,
    333,
    556,
    556,
    556,
    556,
    280,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    556,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    722,
    722,
    722,
    722,
    722,
    722,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    611,
    611,
    611,
    611,
    611,
    611,
    611,
    549,
    611,
    611,
    611,
    611,
    611,
    556,
    611,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    719,
    722,
    611,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    722,
    611,
    722,
    611,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    785,
    556,
    556,
    278,
    722,
    556,
    556,
    611,
    278,
    611,
    278,
    611,
    385,
    611,
    479,
    611,
    278,
    722,
    611,
    722,
    611,
    722,
    611,
    708,
    723,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    1e3,
    944,
    722,
    389,
    722,
    389,
    722,
    389,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    611,
    333,
    611,
    479,
    611,
    333,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    944,
    778,
    667,
    556,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    278,
    556,
    722,
    556,
    1e3,
    889,
    778,
    611,
    667,
    556,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    465,
    722,
    333,
    853,
    906,
    474,
    825,
    927,
    838,
    278,
    722,
    722,
    601,
    719,
    667,
    611,
    722,
    778,
    278,
    722,
    667,
    833,
    722,
    644,
    778,
    722,
    667,
    600,
    611,
    667,
    821,
    667,
    809,
    802,
    278,
    667,
    615,
    451,
    611,
    278,
    582,
    615,
    610,
    556,
    606,
    475,
    460,
    611,
    541,
    278,
    558,
    556,
    612,
    556,
    445,
    611,
    766,
    619,
    520,
    684,
    446,
    582,
    715,
    576,
    753,
    845,
    278,
    582,
    611,
    582,
    845,
    667,
    669,
    885,
    567,
    711,
    667,
    278,
    276,
    556,
    1094,
    1062,
    875,
    610,
    722,
    622,
    719,
    722,
    719,
    722,
    567,
    712,
    667,
    904,
    626,
    719,
    719,
    610,
    702,
    833,
    722,
    778,
    719,
    667,
    722,
    611,
    622,
    854,
    667,
    730,
    703,
    1005,
    1019,
    870,
    979,
    719,
    711,
    1031,
    719,
    556,
    618,
    615,
    417,
    635,
    556,
    709,
    497,
    615,
    615,
    500,
    635,
    740,
    604,
    611,
    604,
    611,
    556,
    490,
    556,
    875,
    556,
    615,
    581,
    833,
    844,
    729,
    854,
    615,
    552,
    854,
    583,
    556,
    556,
    611,
    417,
    552,
    556,
    278,
    281,
    278,
    969,
    906,
    611,
    500,
    615,
    556,
    604,
    778,
    611,
    487,
    447,
    944,
    778,
    944,
    778,
    944,
    778,
    667,
    556,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    278,
    278,
    278,
    278,
    500,
    500,
    500,
    556,
    556,
    350,
    1e3,
    1e3,
    240,
    479,
    333,
    333,
    604,
    333,
    167,
    396,
    556,
    556,
    1094,
    556,
    885,
    489,
    1115,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    1e3,
    500,
    1e3,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    722,
    274,
    549,
    549,
    583,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    611,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333
], Pa = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
], Ra = [
    365,
    0,
    333,
    278,
    333,
    474,
    556,
    556,
    889,
    722,
    238,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    333,
    333,
    584,
    584,
    584,
    611,
    975,
    722,
    722,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    556,
    722,
    611,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    333,
    278,
    333,
    584,
    556,
    333,
    556,
    611,
    556,
    611,
    556,
    333,
    611,
    611,
    278,
    278,
    556,
    278,
    889,
    611,
    611,
    611,
    611,
    389,
    556,
    333,
    611,
    556,
    778,
    556,
    556,
    500,
    389,
    280,
    389,
    584,
    333,
    556,
    556,
    556,
    556,
    280,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    556,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    722,
    722,
    722,
    722,
    722,
    722,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    611,
    611,
    611,
    611,
    611,
    611,
    611,
    549,
    611,
    611,
    611,
    611,
    611,
    556,
    611,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    740,
    722,
    611,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    722,
    611,
    722,
    611,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    782,
    556,
    556,
    278,
    722,
    556,
    556,
    611,
    278,
    611,
    278,
    611,
    396,
    611,
    479,
    611,
    278,
    722,
    611,
    722,
    611,
    722,
    611,
    708,
    723,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    1e3,
    944,
    722,
    389,
    722,
    389,
    722,
    389,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    611,
    333,
    611,
    479,
    611,
    333,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    944,
    778,
    667,
    556,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    278,
    556,
    722,
    556,
    1e3,
    889,
    778,
    611,
    667,
    556,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    722,
    333,
    854,
    906,
    473,
    844,
    930,
    847,
    278,
    722,
    722,
    610,
    671,
    667,
    611,
    722,
    778,
    278,
    722,
    667,
    833,
    722,
    657,
    778,
    718,
    667,
    590,
    611,
    667,
    822,
    667,
    829,
    781,
    278,
    667,
    620,
    479,
    611,
    278,
    591,
    620,
    621,
    556,
    610,
    479,
    492,
    611,
    558,
    278,
    566,
    556,
    603,
    556,
    450,
    611,
    712,
    605,
    532,
    664,
    409,
    591,
    704,
    578,
    773,
    834,
    278,
    591,
    611,
    591,
    834,
    667,
    667,
    886,
    614,
    719,
    667,
    278,
    278,
    556,
    1094,
    1042,
    854,
    622,
    719,
    677,
    719,
    722,
    708,
    722,
    614,
    722,
    667,
    927,
    643,
    719,
    719,
    615,
    687,
    833,
    722,
    778,
    719,
    667,
    722,
    611,
    677,
    781,
    667,
    729,
    708,
    979,
    989,
    854,
    1e3,
    708,
    719,
    1042,
    729,
    556,
    619,
    604,
    534,
    618,
    556,
    736,
    510,
    611,
    611,
    507,
    622,
    740,
    604,
    611,
    611,
    611,
    556,
    889,
    556,
    885,
    556,
    646,
    583,
    889,
    935,
    707,
    854,
    594,
    552,
    865,
    589,
    556,
    556,
    611,
    469,
    563,
    556,
    278,
    278,
    278,
    969,
    906,
    611,
    507,
    619,
    556,
    611,
    778,
    611,
    575,
    467,
    944,
    778,
    944,
    778,
    944,
    778,
    667,
    556,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    278,
    278,
    278,
    278,
    500,
    500,
    500,
    556,
    556,
    350,
    1e3,
    1e3,
    240,
    479,
    333,
    333,
    604,
    333,
    167,
    396,
    556,
    556,
    1104,
    556,
    885,
    516,
    1146,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    999,
    500,
    1e3,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    722,
    274,
    549,
    549,
    583,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    611,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333
], Ba = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
], Na = [
    365,
    0,
    333,
    278,
    278,
    355,
    556,
    556,
    889,
    667,
    191,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    584,
    584,
    584,
    556,
    1015,
    667,
    667,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    500,
    667,
    556,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    278,
    278,
    278,
    469,
    556,
    333,
    556,
    556,
    500,
    556,
    556,
    278,
    556,
    556,
    222,
    222,
    500,
    222,
    833,
    556,
    556,
    556,
    556,
    333,
    500,
    278,
    556,
    500,
    722,
    500,
    500,
    500,
    334,
    260,
    334,
    584,
    333,
    556,
    556,
    556,
    556,
    260,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    537,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    667,
    667,
    667,
    667,
    667,
    667,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    500,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    549,
    611,
    556,
    556,
    556,
    556,
    500,
    556,
    500,
    667,
    556,
    667,
    556,
    667,
    556,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    625,
    722,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    722,
    556,
    722,
    556,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    222,
    278,
    278,
    733,
    444,
    500,
    222,
    667,
    500,
    500,
    556,
    222,
    556,
    222,
    556,
    281,
    556,
    400,
    556,
    222,
    722,
    556,
    722,
    556,
    722,
    556,
    615,
    723,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    1e3,
    944,
    722,
    333,
    722,
    333,
    722,
    333,
    667,
    500,
    667,
    500,
    667,
    500,
    667,
    500,
    611,
    278,
    611,
    354,
    611,
    278,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    944,
    722,
    667,
    500,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    222,
    556,
    667,
    556,
    1e3,
    889,
    778,
    611,
    667,
    500,
    611,
    278,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    667,
    278,
    789,
    846,
    389,
    794,
    865,
    775,
    222,
    667,
    667,
    570,
    671,
    667,
    611,
    722,
    778,
    278,
    667,
    667,
    833,
    722,
    648,
    778,
    725,
    667,
    600,
    611,
    667,
    837,
    667,
    831,
    761,
    278,
    667,
    570,
    439,
    555,
    222,
    550,
    570,
    571,
    500,
    556,
    439,
    463,
    555,
    542,
    222,
    500,
    492,
    548,
    500,
    447,
    556,
    670,
    573,
    486,
    603,
    374,
    550,
    652,
    546,
    728,
    779,
    222,
    550,
    556,
    550,
    779,
    667,
    667,
    843,
    544,
    708,
    667,
    278,
    278,
    500,
    1066,
    982,
    844,
    589,
    715,
    639,
    724,
    667,
    651,
    667,
    544,
    704,
    667,
    917,
    614,
    715,
    715,
    589,
    686,
    833,
    722,
    778,
    725,
    667,
    722,
    611,
    639,
    795,
    667,
    727,
    673,
    920,
    923,
    805,
    886,
    651,
    694,
    1022,
    682,
    556,
    562,
    522,
    493,
    553,
    556,
    688,
    465,
    556,
    556,
    472,
    564,
    686,
    550,
    556,
    556,
    556,
    500,
    833,
    500,
    835,
    500,
    572,
    518,
    830,
    851,
    621,
    736,
    526,
    492,
    752,
    534,
    556,
    556,
    556,
    378,
    496,
    500,
    222,
    222,
    222,
    910,
    828,
    556,
    472,
    565,
    500,
    556,
    778,
    556,
    492,
    339,
    944,
    722,
    944,
    722,
    944,
    722,
    667,
    500,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    222,
    222,
    222,
    222,
    333,
    333,
    333,
    556,
    556,
    350,
    1e3,
    1e3,
    188,
    354,
    333,
    333,
    500,
    333,
    167,
    365,
    556,
    556,
    1094,
    556,
    885,
    323,
    1083,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    1e3,
    500,
    998,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    719,
    274,
    549,
    549,
    584,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    500,
    500,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    294,
    294,
    324,
    324,
    316,
    328,
    398,
    285
], La = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
], Ua = [
    365,
    0,
    333,
    278,
    278,
    355,
    556,
    556,
    889,
    667,
    191,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    584,
    584,
    584,
    556,
    1015,
    667,
    667,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    500,
    667,
    556,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    278,
    278,
    278,
    469,
    556,
    333,
    556,
    556,
    500,
    556,
    556,
    278,
    556,
    556,
    222,
    222,
    500,
    222,
    833,
    556,
    556,
    556,
    556,
    333,
    500,
    278,
    556,
    500,
    722,
    500,
    500,
    500,
    334,
    260,
    334,
    584,
    333,
    556,
    556,
    556,
    556,
    260,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    537,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    667,
    667,
    667,
    667,
    667,
    667,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    500,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    549,
    611,
    556,
    556,
    556,
    556,
    500,
    556,
    500,
    667,
    556,
    667,
    556,
    667,
    556,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    615,
    722,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    722,
    556,
    722,
    556,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    222,
    278,
    278,
    735,
    444,
    500,
    222,
    667,
    500,
    500,
    556,
    222,
    556,
    222,
    556,
    292,
    556,
    334,
    556,
    222,
    722,
    556,
    722,
    556,
    722,
    556,
    604,
    723,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    1e3,
    944,
    722,
    333,
    722,
    333,
    722,
    333,
    667,
    500,
    667,
    500,
    667,
    500,
    667,
    500,
    611,
    278,
    611,
    375,
    611,
    278,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    944,
    722,
    667,
    500,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    222,
    556,
    667,
    556,
    1e3,
    889,
    778,
    611,
    667,
    500,
    611,
    278,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    667,
    278,
    784,
    838,
    384,
    774,
    855,
    752,
    222,
    667,
    667,
    551,
    668,
    667,
    611,
    722,
    778,
    278,
    667,
    668,
    833,
    722,
    650,
    778,
    722,
    667,
    618,
    611,
    667,
    798,
    667,
    835,
    748,
    278,
    667,
    578,
    446,
    556,
    222,
    547,
    578,
    575,
    500,
    557,
    446,
    441,
    556,
    556,
    222,
    500,
    500,
    576,
    500,
    448,
    556,
    690,
    569,
    482,
    617,
    395,
    547,
    648,
    525,
    713,
    781,
    222,
    547,
    556,
    547,
    781,
    667,
    667,
    865,
    542,
    719,
    667,
    278,
    278,
    500,
    1057,
    1010,
    854,
    583,
    722,
    635,
    719,
    667,
    656,
    667,
    542,
    677,
    667,
    923,
    604,
    719,
    719,
    583,
    656,
    833,
    722,
    778,
    719,
    667,
    722,
    611,
    635,
    760,
    667,
    740,
    667,
    917,
    938,
    792,
    885,
    656,
    719,
    1010,
    722,
    556,
    573,
    531,
    365,
    583,
    556,
    669,
    458,
    559,
    559,
    438,
    583,
    688,
    552,
    556,
    542,
    556,
    500,
    458,
    500,
    823,
    500,
    573,
    521,
    802,
    823,
    625,
    719,
    521,
    510,
    750,
    542,
    556,
    556,
    556,
    365,
    510,
    500,
    222,
    278,
    222,
    906,
    812,
    556,
    438,
    559,
    500,
    552,
    778,
    556,
    489,
    411,
    944,
    722,
    944,
    722,
    944,
    722,
    667,
    500,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    222,
    222,
    222,
    222,
    333,
    333,
    333,
    556,
    556,
    350,
    1e3,
    1e3,
    188,
    354,
    333,
    333,
    500,
    333,
    167,
    365,
    556,
    556,
    1094,
    556,
    885,
    323,
    1073,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    1e3,
    500,
    1e3,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    719,
    274,
    549,
    549,
    583,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    500,
    500,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    294,
    294,
    324,
    324,
    316,
    328,
    398,
    285
], ja = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
], $a = [
    1.36898,
    1,
    1,
    .72706,
    .80479,
    .83734,
    .98894,
    .99793,
    .9897,
    .93884,
    .86209,
    .94292,
    .94292,
    1.16661,
    1.02058,
    .93582,
    .96694,
    .93582,
    1.19137,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .78076,
    .78076,
    1.02058,
    1.02058,
    1.02058,
    .72851,
    .78966,
    .90838,
    .83637,
    .82391,
    .96376,
    .80061,
    .86275,
    .8768,
    .95407,
    1.0258,
    .73901,
    .85022,
    .83655,
    1.0156,
    .95546,
    .92179,
    .87107,
    .92179,
    .82114,
    .8096,
    .89713,
    .94438,
    .95353,
    .94083,
    .91905,
    .90406,
    .9446,
    .94292,
    1.18777,
    .94292,
    1.02058,
    .89903,
    .90088,
    .94938,
    .97898,
    .81093,
    .97571,
    .94938,
    1.024,
    .9577,
    .95933,
    .98621,
    1.0474,
    .97455,
    .98981,
    .9672,
    .95933,
    .9446,
    .97898,
    .97407,
    .97646,
    .78036,
    1.10208,
    .95442,
    .95298,
    .97579,
    .9332,
    .94039,
    .938,
    .80687,
    1.01149,
    .80687,
    1.02058,
    .80479,
    .99793,
    .99793,
    .99793,
    .99793,
    1.01149,
    1.00872,
    .90088,
    .91882,
    1.0213,
    .8361,
    1.02058,
    .62295,
    .54324,
    .89022,
    1.08595,
    1,
    1,
    .90088,
    1,
    .97455,
    .93582,
    .90088,
    1,
    1.05686,
    .8361,
    .99642,
    .99642,
    .99642,
    .72851,
    .90838,
    .90838,
    .90838,
    .90838,
    .90838,
    .90838,
    .868,
    .82391,
    .80061,
    .80061,
    .80061,
    .80061,
    1.0258,
    1.0258,
    1.0258,
    1.0258,
    .97484,
    .95546,
    .92179,
    .92179,
    .92179,
    .92179,
    .92179,
    1.02058,
    .92179,
    .94438,
    .94438,
    .94438,
    .94438,
    .90406,
    .86958,
    .98225,
    .94938,
    .94938,
    .94938,
    .94938,
    .94938,
    .94938,
    .9031,
    .81093,
    .94938,
    .94938,
    .94938,
    .94938,
    .98621,
    .98621,
    .98621,
    .98621,
    .93969,
    .95933,
    .9446,
    .9446,
    .9446,
    .9446,
    .9446,
    1.08595,
    .9446,
    .95442,
    .95442,
    .95442,
    .95442,
    .94039,
    .97898,
    .94039,
    .90838,
    .94938,
    .90838,
    .94938,
    .90838,
    .94938,
    .82391,
    .81093,
    .82391,
    .81093,
    .82391,
    .81093,
    .82391,
    .81093,
    .96376,
    .84313,
    .97484,
    .97571,
    .80061,
    .94938,
    .80061,
    .94938,
    .80061,
    .94938,
    .80061,
    .94938,
    .80061,
    .94938,
    .8768,
    .9577,
    .8768,
    .9577,
    .8768,
    .9577,
    1,
    1,
    .95407,
    .95933,
    .97069,
    .95933,
    1.0258,
    .98621,
    1.0258,
    .98621,
    1.0258,
    .98621,
    1.0258,
    .98621,
    1.0258,
    .98621,
    .887,
    1.01591,
    .73901,
    1.0474,
    1,
    1,
    .97455,
    .83655,
    .98981,
    1,
    1,
    .83655,
    .73977,
    .83655,
    .73903,
    .84638,
    1.033,
    .95546,
    .95933,
    1,
    1,
    .95546,
    .95933,
    .8271,
    .95417,
    .95933,
    .92179,
    .9446,
    .92179,
    .9446,
    .92179,
    .9446,
    .936,
    .91964,
    .82114,
    .97646,
    1,
    1,
    .82114,
    .97646,
    .8096,
    .78036,
    .8096,
    .78036,
    1,
    1,
    .8096,
    .78036,
    1,
    1,
    .89713,
    .77452,
    .89713,
    1.10208,
    .94438,
    .95442,
    .94438,
    .95442,
    .94438,
    .95442,
    .94438,
    .95442,
    .94438,
    .95442,
    .94438,
    .95442,
    .94083,
    .97579,
    .90406,
    .94039,
    .90406,
    .9446,
    .938,
    .9446,
    .938,
    .9446,
    .938,
    1,
    .99793,
    .90838,
    .94938,
    .868,
    .9031,
    .92179,
    .9446,
    1,
    1,
    .89713,
    1.10208,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90989,
    .9358,
    .91945,
    .83181,
    .75261,
    .87992,
    .82976,
    .96034,
    .83689,
    .97268,
    1.0078,
    .90838,
    .83637,
    .8019,
    .90157,
    .80061,
    .9446,
    .95407,
    .92436,
    1.0258,
    .85022,
    .97153,
    1.0156,
    .95546,
    .89192,
    .92179,
    .92361,
    .87107,
    .96318,
    .89713,
    .93704,
    .95638,
    .91905,
    .91709,
    .92796,
    1.0258,
    .93704,
    .94836,
    1.0373,
    .95933,
    1.0078,
    .95871,
    .94836,
    .96174,
    .92601,
    .9498,
    .98607,
    .95776,
    .95933,
    1.05453,
    1.0078,
    .98275,
    .9314,
    .95617,
    .91701,
    1.05993,
    .9446,
    .78367,
    .9553,
    1,
    .86832,
    1.0128,
    .95871,
    .99394,
    .87548,
    .96361,
    .86774,
    1.0078,
    .95871,
    .9446,
    .95871,
    .86774,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .94083,
    .97579,
    .94083,
    .97579,
    .94083,
    .97579,
    .90406,
    .94039,
    .96694,
    1,
    .89903,
    1,
    1,
    1,
    .93582,
    .93582,
    .93582,
    1,
    .908,
    .908,
    .918,
    .94219,
    .94219,
    .96544,
    1,
    1.285,
    1,
    1,
    .81079,
    .81079,
    1,
    1,
    .74854,
    1,
    1,
    1,
    1,
    .99793,
    1,
    1,
    1,
    .65,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.17173,
    1,
    .80535,
    .76169,
    1.02058,
    1.0732,
    1.05486,
    1,
    1,
    1.30692,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.16161,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Ha = {
    lineHeight: 1.2,
    lineGap: .2
}, Xa = [
    1.36898,
    1,
    1,
    .66227,
    .80779,
    .81625,
    .97276,
    .97276,
    .97733,
    .92222,
    .83266,
    .94292,
    .94292,
    1.16148,
    1.02058,
    .93582,
    .96694,
    .93582,
    1.17337,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .78076,
    .78076,
    1.02058,
    1.02058,
    1.02058,
    .71541,
    .76813,
    .85576,
    .80591,
    .80729,
    .94299,
    .77512,
    .83655,
    .86523,
    .92222,
    .98621,
    .71743,
    .81698,
    .79726,
    .98558,
    .92222,
    .90637,
    .83809,
    .90637,
    .80729,
    .76463,
    .86275,
    .90699,
    .91605,
    .9154,
    .85308,
    .85458,
    .90531,
    .94292,
    1.21296,
    .94292,
    1.02058,
    .89903,
    1.18616,
    .99613,
    .91677,
    .78216,
    .91677,
    .90083,
    .98796,
    .9135,
    .92168,
    .95381,
    .98981,
    .95298,
    .95381,
    .93459,
    .92168,
    .91513,
    .92004,
    .91677,
    .95077,
    .748,
    1.04502,
    .91677,
    .92061,
    .94236,
    .89544,
    .89364,
    .9,
    .80687,
    .8578,
    .80687,
    1.02058,
    .80779,
    .97276,
    .97276,
    .97276,
    .97276,
    .8578,
    .99973,
    1.18616,
    .91339,
    1.08074,
    .82891,
    1.02058,
    .55509,
    .71526,
    .89022,
    1.08595,
    1,
    1,
    1.18616,
    1,
    .96736,
    .93582,
    1.18616,
    1,
    1.04864,
    .82711,
    .99043,
    .99043,
    .99043,
    .71541,
    .85576,
    .85576,
    .85576,
    .85576,
    .85576,
    .85576,
    .845,
    .80729,
    .77512,
    .77512,
    .77512,
    .77512,
    .98621,
    .98621,
    .98621,
    .98621,
    .95961,
    .92222,
    .90637,
    .90637,
    .90637,
    .90637,
    .90637,
    1.02058,
    .90251,
    .90699,
    .90699,
    .90699,
    .90699,
    .85458,
    .83659,
    .94951,
    .99613,
    .99613,
    .99613,
    .99613,
    .99613,
    .99613,
    .85811,
    .78216,
    .90083,
    .90083,
    .90083,
    .90083,
    .95381,
    .95381,
    .95381,
    .95381,
    .9135,
    .92168,
    .91513,
    .91513,
    .91513,
    .91513,
    .91513,
    1.08595,
    .91677,
    .91677,
    .91677,
    .91677,
    .91677,
    .89364,
    .92332,
    .89364,
    .85576,
    .99613,
    .85576,
    .99613,
    .85576,
    .99613,
    .80729,
    .78216,
    .80729,
    .78216,
    .80729,
    .78216,
    .80729,
    .78216,
    .94299,
    .76783,
    .95961,
    .91677,
    .77512,
    .90083,
    .77512,
    .90083,
    .77512,
    .90083,
    .77512,
    .90083,
    .77512,
    .90083,
    .86523,
    .9135,
    .86523,
    .9135,
    .86523,
    .9135,
    1,
    1,
    .92222,
    .92168,
    .92222,
    .92168,
    .98621,
    .95381,
    .98621,
    .95381,
    .98621,
    .95381,
    .98621,
    .95381,
    .98621,
    .95381,
    .86036,
    .97096,
    .71743,
    .98981,
    1,
    1,
    .95298,
    .79726,
    .95381,
    1,
    1,
    .79726,
    .6894,
    .79726,
    .74321,
    .81691,
    1.0006,
    .92222,
    .92168,
    1,
    1,
    .92222,
    .92168,
    .79464,
    .92098,
    .92168,
    .90637,
    .91513,
    .90637,
    .91513,
    .90637,
    .91513,
    .909,
    .87514,
    .80729,
    .95077,
    1,
    1,
    .80729,
    .95077,
    .76463,
    .748,
    .76463,
    .748,
    1,
    1,
    .76463,
    .748,
    1,
    1,
    .86275,
    .72651,
    .86275,
    1.04502,
    .90699,
    .91677,
    .90699,
    .91677,
    .90699,
    .91677,
    .90699,
    .91677,
    .90699,
    .91677,
    .90699,
    .91677,
    .9154,
    .94236,
    .85458,
    .89364,
    .85458,
    .90531,
    .9,
    .90531,
    .9,
    .90531,
    .9,
    1,
    .97276,
    .85576,
    .99613,
    .845,
    .85811,
    .90251,
    .91677,
    1,
    1,
    .86275,
    1.04502,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.00899,
    1.30628,
    .85576,
    .80178,
    .66862,
    .7927,
    .69323,
    .88127,
    .72459,
    .89711,
    .95381,
    .85576,
    .80591,
    .7805,
    .94729,
    .77512,
    .90531,
    .92222,
    .90637,
    .98621,
    .81698,
    .92655,
    .98558,
    .92222,
    .85359,
    .90637,
    .90976,
    .83809,
    .94523,
    .86275,
    .83509,
    .93157,
    .85308,
    .83392,
    .92346,
    .98621,
    .83509,
    .92886,
    .91324,
    .92168,
    .95381,
    .90646,
    .92886,
    .90557,
    .86847,
    .90276,
    .91324,
    .86842,
    .92168,
    .99531,
    .95381,
    .9224,
    .85408,
    .92699,
    .86847,
    1.0051,
    .91513,
    .80487,
    .93481,
    1,
    .88159,
    1.05214,
    .90646,
    .97355,
    .81539,
    .89398,
    .85923,
    .95381,
    .90646,
    .91513,
    .90646,
    .85923,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .9154,
    .94236,
    .9154,
    .94236,
    .9154,
    .94236,
    .85458,
    .89364,
    .96694,
    1,
    .89903,
    1,
    1,
    1,
    .91782,
    .91782,
    .91782,
    1,
    .896,
    .896,
    .896,
    .9332,
    .9332,
    .95973,
    1,
    1.26,
    1,
    1,
    .80479,
    .80178,
    1,
    1,
    .85633,
    1,
    1,
    1,
    1,
    .97276,
    1,
    1,
    1,
    .698,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.14542,
    1,
    .79199,
    .78694,
    1.02058,
    1.03493,
    1.05486,
    1,
    1,
    1.23026,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.20006,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], qa = {
    lineHeight: 1.2,
    lineGap: .2
}, za = [
    1.36898,
    1,
    1,
    .65507,
    .84943,
    .85639,
    .88465,
    .88465,
    .86936,
    .88307,
    .86948,
    .85283,
    .85283,
    1.06383,
    1.02058,
    .75945,
    .9219,
    .75945,
    1.17337,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .75945,
    .75945,
    1.02058,
    1.02058,
    1.02058,
    .69046,
    .70926,
    .85158,
    .77812,
    .76852,
    .89591,
    .70466,
    .76125,
    .80094,
    .86822,
    .83864,
    .728,
    .77212,
    .79475,
    .93637,
    .87514,
    .8588,
    .76013,
    .8588,
    .72421,
    .69866,
    .77598,
    .85991,
    .80811,
    .87832,
    .78112,
    .77512,
    .8562,
    1.0222,
    1.18417,
    1.0222,
    1.27014,
    .89903,
    1.15012,
    .93859,
    .94399,
    .846,
    .94399,
    .81453,
    1.0186,
    .94219,
    .96017,
    1.03075,
    1.02175,
    .912,
    1.03075,
    .96998,
    .96017,
    .93859,
    .94399,
    .94399,
    .95493,
    .746,
    1.12658,
    .94578,
    .91,
    .979,
    .882,
    .882,
    .83,
    .85034,
    .83537,
    .85034,
    1.02058,
    .70869,
    .88465,
    .88465,
    .88465,
    .88465,
    .83537,
    .90083,
    1.15012,
    .9161,
    .94565,
    .73541,
    1.02058,
    .53609,
    .69353,
    .79519,
    1.08595,
    1,
    1,
    1.15012,
    1,
    .91974,
    .75945,
    1.15012,
    1,
    .9446,
    .73361,
    .9005,
    .9005,
    .9005,
    .62864,
    .85158,
    .85158,
    .85158,
    .85158,
    .85158,
    .85158,
    .773,
    .76852,
    .70466,
    .70466,
    .70466,
    .70466,
    .83864,
    .83864,
    .83864,
    .83864,
    .90561,
    .87514,
    .8588,
    .8588,
    .8588,
    .8588,
    .8588,
    1.02058,
    .85751,
    .85991,
    .85991,
    .85991,
    .85991,
    .77512,
    .76013,
    .88075,
    .93859,
    .93859,
    .93859,
    .93859,
    .93859,
    .93859,
    .8075,
    .846,
    .81453,
    .81453,
    .81453,
    .81453,
    .82424,
    .82424,
    .82424,
    .82424,
    .9278,
    .96017,
    .93859,
    .93859,
    .93859,
    .93859,
    .93859,
    1.08595,
    .8562,
    .94578,
    .94578,
    .94578,
    .94578,
    .882,
    .94578,
    .882,
    .85158,
    .93859,
    .85158,
    .93859,
    .85158,
    .93859,
    .76852,
    .846,
    .76852,
    .846,
    .76852,
    .846,
    .76852,
    .846,
    .89591,
    .8544,
    .90561,
    .94399,
    .70466,
    .81453,
    .70466,
    .81453,
    .70466,
    .81453,
    .70466,
    .81453,
    .70466,
    .81453,
    .80094,
    .94219,
    .80094,
    .94219,
    .80094,
    .94219,
    1,
    1,
    .86822,
    .96017,
    .86822,
    .96017,
    .83864,
    .82424,
    .83864,
    .82424,
    .83864,
    .82424,
    .83864,
    1.03075,
    .83864,
    .82424,
    .81402,
    1.02738,
    .728,
    1.02175,
    1,
    1,
    .912,
    .79475,
    1.03075,
    1,
    1,
    .79475,
    .83911,
    .79475,
    .66266,
    .80553,
    1.06676,
    .87514,
    .96017,
    1,
    1,
    .87514,
    .96017,
    .86865,
    .87396,
    .96017,
    .8588,
    .93859,
    .8588,
    .93859,
    .8588,
    .93859,
    .867,
    .84759,
    .72421,
    .95493,
    1,
    1,
    .72421,
    .95493,
    .69866,
    .746,
    .69866,
    .746,
    1,
    1,
    .69866,
    .746,
    1,
    1,
    .77598,
    .88417,
    .77598,
    1.12658,
    .85991,
    .94578,
    .85991,
    .94578,
    .85991,
    .94578,
    .85991,
    .94578,
    .85991,
    .94578,
    .85991,
    .94578,
    .87832,
    .979,
    .77512,
    .882,
    .77512,
    .8562,
    .83,
    .8562,
    .83,
    .8562,
    .83,
    1,
    .88465,
    .85158,
    .93859,
    .773,
    .8075,
    .85751,
    .8562,
    1,
    1,
    .77598,
    1.12658,
    1.15012,
    1.15012,
    1.15012,
    1.15012,
    1.15012,
    1.15313,
    1.15012,
    1.15012,
    1.15012,
    1.08106,
    1.03901,
    .85158,
    .77025,
    .62264,
    .7646,
    .65351,
    .86026,
    .69461,
    .89947,
    1.03075,
    .85158,
    .77812,
    .76449,
    .88836,
    .70466,
    .8562,
    .86822,
    .8588,
    .83864,
    .77212,
    .85308,
    .93637,
    .87514,
    .82352,
    .8588,
    .85701,
    .76013,
    .89058,
    .77598,
    .8156,
    .82565,
    .78112,
    .77899,
    .89386,
    .83864,
    .8156,
    .9486,
    .92388,
    .96186,
    1.03075,
    .91123,
    .9486,
    .93298,
    .878,
    .93942,
    .92388,
    .84596,
    .96186,
    .95119,
    1.03075,
    .922,
    .88787,
    .95829,
    .88,
    .93559,
    .93859,
    .78815,
    .93758,
    1,
    .89217,
    1.03737,
    .91123,
    .93969,
    .77487,
    .85769,
    .86799,
    1.03075,
    .91123,
    .93859,
    .91123,
    .86799,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .87832,
    .979,
    .87832,
    .979,
    .87832,
    .979,
    .77512,
    .882,
    .9219,
    1,
    .89903,
    1,
    1,
    1,
    .87321,
    .87321,
    .87321,
    1,
    1.027,
    1.027,
    1.027,
    .86847,
    .86847,
    .79121,
    1,
    1.124,
    1,
    1,
    .73572,
    .73572,
    1,
    1,
    .85034,
    1,
    1,
    1,
    1,
    .88465,
    1,
    1,
    1,
    .669,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.04828,
    1,
    .74948,
    .75187,
    1.02058,
    .98391,
    1.02119,
    1,
    1,
    1.06233,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05233,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Wa = {
    lineHeight: 1.2,
    lineGap: .2
}, Ga = [
    1.36898,
    1,
    1,
    .76305,
    .82784,
    .94935,
    .89364,
    .92241,
    .89073,
    .90706,
    .98472,
    .85283,
    .85283,
    1.0664,
    1.02058,
    .74505,
    .9219,
    .74505,
    1.23456,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .74505,
    .74505,
    1.02058,
    1.02058,
    1.02058,
    .73002,
    .72601,
    .91755,
    .8126,
    .80314,
    .92222,
    .73764,
    .79726,
    .83051,
    .90284,
    .86023,
    .74,
    .8126,
    .84869,
    .96518,
    .91115,
    .8858,
    .79761,
    .8858,
    .74498,
    .73914,
    .81363,
    .89591,
    .83659,
    .89633,
    .85608,
    .8111,
    .90531,
    1.0222,
    1.22736,
    1.0222,
    1.27014,
    .89903,
    .90088,
    .86667,
    1.0231,
    .896,
    1.01411,
    .90083,
    1.05099,
    1.00512,
    .99793,
    1.05326,
    1.09377,
    .938,
    1.06226,
    1.00119,
    .99793,
    .98714,
    1.0231,
    1.01231,
    .98196,
    .792,
    1.19137,
    .99074,
    .962,
    1.01915,
    .926,
    .942,
    .856,
    .85034,
    .92006,
    .85034,
    1.02058,
    .69067,
    .92241,
    .92241,
    .92241,
    .92241,
    .92006,
    .9332,
    .90088,
    .91882,
    .93484,
    .75339,
    1.02058,
    .56866,
    .54324,
    .79519,
    1.08595,
    1,
    1,
    .90088,
    1,
    .95325,
    .74505,
    .90088,
    1,
    .97198,
    .75339,
    .91009,
    .91009,
    .91009,
    .66466,
    .91755,
    .91755,
    .91755,
    .91755,
    .91755,
    .91755,
    .788,
    .80314,
    .73764,
    .73764,
    .73764,
    .73764,
    .86023,
    .86023,
    .86023,
    .86023,
    .92915,
    .91115,
    .8858,
    .8858,
    .8858,
    .8858,
    .8858,
    1.02058,
    .8858,
    .89591,
    .89591,
    .89591,
    .89591,
    .8111,
    .79611,
    .89713,
    .86667,
    .86667,
    .86667,
    .86667,
    .86667,
    .86667,
    .86936,
    .896,
    .90083,
    .90083,
    .90083,
    .90083,
    .84224,
    .84224,
    .84224,
    .84224,
    .97276,
    .99793,
    .98714,
    .98714,
    .98714,
    .98714,
    .98714,
    1.08595,
    .89876,
    .99074,
    .99074,
    .99074,
    .99074,
    .942,
    1.0231,
    .942,
    .91755,
    .86667,
    .91755,
    .86667,
    .91755,
    .86667,
    .80314,
    .896,
    .80314,
    .896,
    .80314,
    .896,
    .80314,
    .896,
    .92222,
    .93372,
    .92915,
    1.01411,
    .73764,
    .90083,
    .73764,
    .90083,
    .73764,
    .90083,
    .73764,
    .90083,
    .73764,
    .90083,
    .83051,
    1.00512,
    .83051,
    1.00512,
    .83051,
    1.00512,
    1,
    1,
    .90284,
    .99793,
    .90976,
    .99793,
    .86023,
    .84224,
    .86023,
    .84224,
    .86023,
    .84224,
    .86023,
    1.05326,
    .86023,
    .84224,
    .82873,
    1.07469,
    .74,
    1.09377,
    1,
    1,
    .938,
    .84869,
    1.06226,
    1,
    1,
    .84869,
    .83704,
    .84869,
    .81441,
    .85588,
    1.08927,
    .91115,
    .99793,
    1,
    1,
    .91115,
    .99793,
    .91887,
    .90991,
    .99793,
    .8858,
    .98714,
    .8858,
    .98714,
    .8858,
    .98714,
    .894,
    .91434,
    .74498,
    .98196,
    1,
    1,
    .74498,
    .98196,
    .73914,
    .792,
    .73914,
    .792,
    1,
    1,
    .73914,
    .792,
    1,
    1,
    .81363,
    .904,
    .81363,
    1.19137,
    .89591,
    .99074,
    .89591,
    .99074,
    .89591,
    .99074,
    .89591,
    .99074,
    .89591,
    .99074,
    .89591,
    .99074,
    .89633,
    1.01915,
    .8111,
    .942,
    .8111,
    .90531,
    .856,
    .90531,
    .856,
    .90531,
    .856,
    1,
    .92241,
    .91755,
    .86667,
    .788,
    .86936,
    .8858,
    .89876,
    1,
    1,
    .81363,
    1.19137,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90388,
    1.03901,
    .92138,
    .78105,
    .7154,
    .86169,
    .80513,
    .94007,
    .82528,
    .98612,
    1.06226,
    .91755,
    .8126,
    .81884,
    .92819,
    .73764,
    .90531,
    .90284,
    .8858,
    .86023,
    .8126,
    .91172,
    .96518,
    .91115,
    .83089,
    .8858,
    .87791,
    .79761,
    .89297,
    .81363,
    .88157,
    .89992,
    .85608,
    .81992,
    .94307,
    .86023,
    .88157,
    .95308,
    .98699,
    .99793,
    1.06226,
    .95817,
    .95308,
    .97358,
    .928,
    .98088,
    .98699,
    .92761,
    .99793,
    .96017,
    1.06226,
    .986,
    .944,
    .95978,
    .938,
    .96705,
    .98714,
    .80442,
    .98972,
    1,
    .89762,
    1.04552,
    .95817,
    .99007,
    .87064,
    .91879,
    .88888,
    1.06226,
    .95817,
    .98714,
    .95817,
    .88888,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .89633,
    1.01915,
    .89633,
    1.01915,
    .89633,
    1.01915,
    .8111,
    .942,
    .9219,
    1,
    .89903,
    1,
    1,
    1,
    .93173,
    .93173,
    .93173,
    1,
    1.06304,
    1.06304,
    1.06904,
    .89903,
    .89903,
    .80549,
    1,
    1.156,
    1,
    1,
    .76575,
    .76575,
    1,
    1,
    .72458,
    1,
    1,
    1,
    1,
    .92241,
    1,
    1,
    1,
    .619,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.07257,
    1,
    .74705,
    .71119,
    1.02058,
    1.024,
    1.02119,
    1,
    1,
    1.1536,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05638,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Va = {
    lineHeight: 1.2,
    lineGap: .2
}, Ka = [
    1.76738,
    1,
    1,
    .99297,
    .9824,
    1.04016,
    1.06497,
    1.03424,
    .97529,
    1.17647,
    1.23203,
    1.1085,
    1.1085,
    1.16939,
    1.2107,
    .9754,
    1.21408,
    .9754,
    1.59578,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    .81378,
    .81378,
    1.2107,
    1.2107,
    1.2107,
    .71703,
    .97847,
    .97363,
    .88776,
    .8641,
    1.02096,
    .79795,
    .85132,
    .914,
    1.06085,
    1.1406,
    .8007,
    .89858,
    .83693,
    1.14889,
    1.09398,
    .97489,
    .92094,
    .97489,
    .90399,
    .84041,
    .95923,
    1.00135,
    1,
    1.06467,
    .98243,
    .90996,
    .99361,
    1.1085,
    1.56942,
    1.1085,
    1.2107,
    .74627,
    .94282,
    .96752,
    1.01519,
    .86304,
    1.01359,
    .97278,
    1.15103,
    1.01359,
    .98561,
    1.02285,
    1.02285,
    1.00527,
    1.02285,
    1.0302,
    .99041,
    1.0008,
    1.01519,
    1.01359,
    1.02258,
    .79104,
    1.16862,
    .99041,
    .97454,
    1.02511,
    .99298,
    .96752,
    .95801,
    .94856,
    1.16579,
    .94856,
    1.2107,
    .9824,
    1.03424,
    1.03424,
    1,
    1.03424,
    1.16579,
    .8727,
    1.3871,
    1.18622,
    1.10818,
    1.04478,
    1.2107,
    1.18622,
    .75155,
    .94994,
    1.28826,
    1.21408,
    1.21408,
    .91056,
    1,
    .91572,
    .9754,
    .64663,
    1.18328,
    1.24866,
    1.04478,
    1.14169,
    1.15749,
    1.17389,
    .71703,
    .97363,
    .97363,
    .97363,
    .97363,
    .97363,
    .97363,
    .93506,
    .8641,
    .79795,
    .79795,
    .79795,
    .79795,
    1.1406,
    1.1406,
    1.1406,
    1.1406,
    1.02096,
    1.09398,
    .97426,
    .97426,
    .97426,
    .97426,
    .97426,
    1.2107,
    .97489,
    1.00135,
    1.00135,
    1.00135,
    1.00135,
    .90996,
    .92094,
    1.02798,
    .96752,
    .96752,
    .96752,
    .96752,
    .96752,
    .96752,
    .93136,
    .86304,
    .97278,
    .97278,
    .97278,
    .97278,
    1.02285,
    1.02285,
    1.02285,
    1.02285,
    .97122,
    .99041,
    1,
    1,
    1,
    1,
    1,
    1.28826,
    1.0008,
    .99041,
    .99041,
    .99041,
    .99041,
    .96752,
    1.01519,
    .96752,
    .97363,
    .96752,
    .97363,
    .96752,
    .97363,
    .96752,
    .8641,
    .86304,
    .8641,
    .86304,
    .8641,
    .86304,
    .8641,
    .86304,
    1.02096,
    1.03057,
    1.02096,
    1.03517,
    .79795,
    .97278,
    .79795,
    .97278,
    .79795,
    .97278,
    .79795,
    .97278,
    .79795,
    .97278,
    .914,
    1.01359,
    .914,
    1.01359,
    .914,
    1.01359,
    1,
    1,
    1.06085,
    .98561,
    1.06085,
    1.00879,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    .97138,
    1.08692,
    .8007,
    1.02285,
    1,
    1,
    1.00527,
    .83693,
    1.02285,
    1,
    1,
    .83693,
    .9455,
    .83693,
    .90418,
    .83693,
    1.13005,
    1.09398,
    .99041,
    1,
    1,
    1.09398,
    .99041,
    .96692,
    1.09251,
    .99041,
    .97489,
    1.0008,
    .97489,
    1.0008,
    .97489,
    1.0008,
    .93994,
    .97931,
    .90399,
    1.02258,
    1,
    1,
    .90399,
    1.02258,
    .84041,
    .79104,
    .84041,
    .79104,
    .84041,
    .79104,
    .84041,
    .79104,
    1,
    1,
    .95923,
    1.07034,
    .95923,
    1.16862,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.06467,
    1.02511,
    .90996,
    .96752,
    .90996,
    .99361,
    .95801,
    .99361,
    .95801,
    .99361,
    .95801,
    1.07733,
    1.03424,
    .97363,
    .96752,
    .93506,
    .93136,
    .97489,
    1.0008,
    1,
    1,
    .95923,
    1.16862,
    1.15103,
    1.15103,
    1.01173,
    1.03959,
    .75953,
    .81378,
    .79912,
    1.15103,
    1.21994,
    .95161,
    .87815,
    1.01149,
    .81525,
    .7676,
    .98167,
    1.01134,
    1.02546,
    .84097,
    1.03089,
    1.18102,
    .97363,
    .88776,
    .85134,
    .97826,
    .79795,
    .99361,
    1.06085,
    .97489,
    1.1406,
    .89858,
    1.0388,
    1.14889,
    1.09398,
    .86039,
    .97489,
    1.0595,
    .92094,
    .94793,
    .95923,
    .90996,
    .99346,
    .98243,
    1.02112,
    .95493,
    1.1406,
    .90996,
    1.03574,
    1.02597,
    1.0008,
    1.18102,
    1.06628,
    1.03574,
    1.0192,
    1.01932,
    1.00886,
    .97531,
    1.0106,
    1.0008,
    1.13189,
    1.18102,
    1.02277,
    .98683,
    1.0016,
    .99561,
    1.07237,
    1.0008,
    .90434,
    .99921,
    .93803,
    .8965,
    1.23085,
    1.06628,
    1.04983,
    .96268,
    1.0499,
    .98439,
    1.18102,
    1.06628,
    1.0008,
    1.06628,
    .98439,
    .79795,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.09466,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .97278,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.02065,
    1,
    1,
    1,
    1,
    1,
    1,
    1.06467,
    1.02511,
    1.06467,
    1.02511,
    1.06467,
    1.02511,
    .90996,
    .96752,
    1,
    1.21408,
    .89903,
    1,
    1,
    .75155,
    1.04394,
    1.04394,
    1.04394,
    1.04394,
    .98633,
    .98633,
    .98633,
    .73047,
    .73047,
    1.20642,
    .91211,
    1.25635,
    1.222,
    1.02956,
    1.03372,
    1.03372,
    .96039,
    1.24633,
    1,
    1.12454,
    .93503,
    1.03424,
    1.19687,
    1.03424,
    1,
    1,
    1,
    .771,
    1,
    1,
    1.15749,
    1.15749,
    1.15749,
    1.10948,
    .86279,
    .94434,
    .86279,
    .94434,
    .86182,
    1,
    1,
    1.16897,
    1,
    .96085,
    .90137,
    1.2107,
    1.18416,
    1.13973,
    .69825,
    .9716,
    2.10339,
    1.29004,
    1.29004,
    1.21172,
    1.29004,
    1.29004,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    .99862,
    .99862,
    1,
    .87025,
    .87025,
    .87025,
    .87025,
    1.18874,
    1.42603,
    1,
    1.42603,
    1.42603,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.09193,
    1.09193,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Ya = {
    lineHeight: 1.33008,
    lineGap: 0
}, Ja = [
    1.76738,
    1,
    1,
    .98946,
    1.03959,
    1.04016,
    1.02809,
    1.036,
    .97639,
    1.10953,
    1.23203,
    1.11144,
    1.11144,
    1.16939,
    1.21237,
    .9754,
    1.21261,
    .9754,
    1.59754,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    .81378,
    .81378,
    1.21237,
    1.21237,
    1.21237,
    .73541,
    .97847,
    .97363,
    .89723,
    .87897,
    1.0426,
    .79429,
    .85292,
    .91149,
    1.05815,
    1.1406,
    .79631,
    .90128,
    .83853,
    1.04396,
    1.10615,
    .97552,
    .94436,
    .97552,
    .88641,
    .80527,
    .96083,
    1.00135,
    1,
    1.06777,
    .9817,
    .91142,
    .99361,
    1.11144,
    1.57293,
    1.11144,
    1.21237,
    .74627,
    1.31818,
    1.06585,
    .97042,
    .83055,
    .97042,
    .93503,
    1.1261,
    .97042,
    .97922,
    1.14236,
    .94552,
    1.01054,
    1.14236,
    1.02471,
    .97922,
    .94165,
    .97042,
    .97042,
    1.0276,
    .78929,
    1.1261,
    .97922,
    .95874,
    1.02197,
    .98507,
    .96752,
    .97168,
    .95107,
    1.16579,
    .95107,
    1.21237,
    1.03959,
    1.036,
    1.036,
    1,
    1.036,
    1.16579,
    .87357,
    1.31818,
    1.18754,
    1.26781,
    1.05356,
    1.21237,
    1.18622,
    .79487,
    .94994,
    1.29004,
    1.24047,
    1.24047,
    1.31818,
    1,
    .91484,
    .9754,
    1.31818,
    1.1349,
    1.24866,
    1.05356,
    1.13934,
    1.15574,
    1.17389,
    .73541,
    .97363,
    .97363,
    .97363,
    .97363,
    .97363,
    .97363,
    .94385,
    .87897,
    .79429,
    .79429,
    .79429,
    .79429,
    1.1406,
    1.1406,
    1.1406,
    1.1406,
    1.0426,
    1.10615,
    .97552,
    .97552,
    .97552,
    .97552,
    .97552,
    1.21237,
    .97552,
    1.00135,
    1.00135,
    1.00135,
    1.00135,
    .91142,
    .94436,
    .98721,
    1.06585,
    1.06585,
    1.06585,
    1.06585,
    1.06585,
    1.06585,
    .96705,
    .83055,
    .93503,
    .93503,
    .93503,
    .93503,
    1.14236,
    1.14236,
    1.14236,
    1.14236,
    .93125,
    .97922,
    .94165,
    .94165,
    .94165,
    .94165,
    .94165,
    1.29004,
    .94165,
    .97922,
    .97922,
    .97922,
    .97922,
    .96752,
    .97042,
    .96752,
    .97363,
    1.06585,
    .97363,
    1.06585,
    .97363,
    1.06585,
    .87897,
    .83055,
    .87897,
    .83055,
    .87897,
    .83055,
    .87897,
    .83055,
    1.0426,
    1.0033,
    1.0426,
    .97042,
    .79429,
    .93503,
    .79429,
    .93503,
    .79429,
    .93503,
    .79429,
    .93503,
    .79429,
    .93503,
    .91149,
    .97042,
    .91149,
    .97042,
    .91149,
    .97042,
    1,
    1,
    1.05815,
    .97922,
    1.05815,
    .97922,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    .97441,
    1.04302,
    .79631,
    1.01582,
    1,
    1,
    1.01054,
    .83853,
    1.14236,
    1,
    1,
    .83853,
    1.09125,
    .83853,
    .90418,
    .83853,
    1.19508,
    1.10615,
    .97922,
    1,
    1,
    1.10615,
    .97922,
    1.01034,
    1.10466,
    .97922,
    .97552,
    .94165,
    .97552,
    .94165,
    .97552,
    .94165,
    .91602,
    .91981,
    .88641,
    1.0276,
    1,
    1,
    .88641,
    1.0276,
    .80527,
    .78929,
    .80527,
    .78929,
    .80527,
    .78929,
    .80527,
    .78929,
    1,
    1,
    .96083,
    1.05403,
    .95923,
    1.16862,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.06777,
    1.02197,
    .91142,
    .96752,
    .91142,
    .99361,
    .97168,
    .99361,
    .97168,
    .99361,
    .97168,
    1.23199,
    1.036,
    .97363,
    1.06585,
    .94385,
    .96705,
    .97552,
    .94165,
    1,
    1,
    .96083,
    1.1261,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    .95161,
    1.27126,
    1.00811,
    .83284,
    .77702,
    .99137,
    .95253,
    1.0347,
    .86142,
    1.07205,
    1.14236,
    .97363,
    .89723,
    .86869,
    1.09818,
    .79429,
    .99361,
    1.05815,
    .97552,
    1.1406,
    .90128,
    1.06662,
    1.04396,
    1.10615,
    .84918,
    .97552,
    1.04694,
    .94436,
    .98015,
    .96083,
    .91142,
    1.00356,
    .9817,
    1.01945,
    .98999,
    1.1406,
    .91142,
    1.04961,
    .9898,
    1.00639,
    1.14236,
    1.07514,
    1.04961,
    .99607,
    1.02897,
    1.008,
    .9898,
    .95134,
    1.00639,
    1.11121,
    1.14236,
    1.00518,
    .97981,
    1.02186,
    1,
    1.08578,
    .94165,
    .99314,
    .98387,
    .93028,
    .93377,
    1.35125,
    1.07514,
    1.10687,
    .93491,
    1.04232,
    1.00351,
    1.14236,
    1.07514,
    .94165,
    1.07514,
    1.00351,
    .79429,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.09097,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .93503,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .96609,
    1,
    1,
    1,
    1,
    1,
    1,
    1.06777,
    1.02197,
    1.06777,
    1.02197,
    1.06777,
    1.02197,
    .91142,
    .96752,
    1,
    1.21261,
    .89903,
    1,
    1,
    .75155,
    1.04745,
    1.04745,
    1.04745,
    1.04394,
    .98633,
    .98633,
    .98633,
    .72959,
    .72959,
    1.20502,
    .91406,
    1.26514,
    1.222,
    1.02956,
    1.03372,
    1.03372,
    .96039,
    1.24633,
    1,
    1.09125,
    .93327,
    1.03336,
    1.16541,
    1.036,
    1,
    1,
    1,
    .771,
    1,
    1,
    1.15574,
    1.15574,
    1.15574,
    1.15574,
    .86364,
    .94434,
    .86279,
    .94434,
    .86224,
    1,
    1,
    1.16798,
    1,
    .96085,
    .90068,
    1.21237,
    1.18416,
    1.13904,
    .69825,
    .9716,
    2.10339,
    1.29004,
    1.29004,
    1.21339,
    1.29004,
    1.29004,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    .99862,
    .99862,
    1,
    .87025,
    .87025,
    .87025,
    .87025,
    1.18775,
    1.42603,
    1,
    1.42603,
    1.42603,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.13269,
    1.13269,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Za = {
    lineHeight: 1.33008,
    lineGap: 0
}, Qa = [
    1.76738,
    1,
    1,
    .98946,
    1.14763,
    1.05365,
    1.06234,
    .96927,
    .92586,
    1.15373,
    1.18414,
    .91349,
    .91349,
    1.07403,
    1.17308,
    .78383,
    1.20088,
    .78383,
    1.42531,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .78383,
    .78383,
    1.17308,
    1.17308,
    1.17308,
    .77349,
    .94565,
    .94729,
    .85944,
    .88506,
    .9858,
    .74817,
    .80016,
    .88449,
    .98039,
    .95782,
    .69238,
    .89898,
    .83231,
    .98183,
    1.03989,
    .96924,
    .86237,
    .96924,
    .80595,
    .74524,
    .86091,
    .95402,
    .94143,
    .98448,
    .8858,
    .83089,
    .93285,
    1.0949,
    1.39016,
    1.0949,
    1.45994,
    .74627,
    1.04839,
    .97454,
    .97454,
    .87207,
    .97454,
    .87533,
    1.06151,
    .97454,
    1.00176,
    1.16484,
    1.08132,
    .98047,
    1.16484,
    1.02989,
    1.01054,
    .96225,
    .97454,
    .97454,
    1.06598,
    .79004,
    1.16344,
    1.00351,
    .94629,
    .9973,
    .91016,
    .96777,
    .9043,
    .91082,
    .92481,
    .91082,
    1.17308,
    .95748,
    .96927,
    .96927,
    1,
    .96927,
    .92481,
    .80597,
    1.04839,
    1.23393,
    1.1781,
    .9245,
    1.17308,
    1.20808,
    .63218,
    .94261,
    1.24822,
    1.09971,
    1.09971,
    1.04839,
    1,
    .85273,
    .78032,
    1.04839,
    1.09971,
    1.22326,
    .9245,
    1.09836,
    1.13525,
    1.15222,
    .70424,
    .94729,
    .94729,
    .94729,
    .94729,
    .94729,
    .94729,
    .85498,
    .88506,
    .74817,
    .74817,
    .74817,
    .74817,
    .95782,
    .95782,
    .95782,
    .95782,
    .9858,
    1.03989,
    .96924,
    .96924,
    .96924,
    .96924,
    .96924,
    1.17308,
    .96924,
    .95402,
    .95402,
    .95402,
    .95402,
    .83089,
    .86237,
    .88409,
    .97454,
    .97454,
    .97454,
    .97454,
    .97454,
    .97454,
    .92916,
    .87207,
    .87533,
    .87533,
    .87533,
    .87533,
    .93146,
    .93146,
    .93146,
    .93146,
    .93854,
    1.01054,
    .96225,
    .96225,
    .96225,
    .96225,
    .96225,
    1.24822,
    .8761,
    1.00351,
    1.00351,
    1.00351,
    1.00351,
    .96777,
    .97454,
    .96777,
    .94729,
    .97454,
    .94729,
    .97454,
    .94729,
    .97454,
    .88506,
    .87207,
    .88506,
    .87207,
    .88506,
    .87207,
    .88506,
    .87207,
    .9858,
    .95391,
    .9858,
    .97454,
    .74817,
    .87533,
    .74817,
    .87533,
    .74817,
    .87533,
    .74817,
    .87533,
    .74817,
    .87533,
    .88449,
    .97454,
    .88449,
    .97454,
    .88449,
    .97454,
    1,
    1,
    .98039,
    1.00176,
    .98039,
    1.00176,
    .95782,
    .93146,
    .95782,
    .93146,
    .95782,
    .93146,
    .95782,
    1.16484,
    .95782,
    .93146,
    .84421,
    1.12761,
    .69238,
    1.08132,
    1,
    1,
    .98047,
    .83231,
    1.16484,
    1,
    1,
    .84723,
    1.04861,
    .84723,
    .78755,
    .83231,
    1.23736,
    1.03989,
    1.01054,
    1,
    1,
    1.03989,
    1.01054,
    .9857,
    1.03849,
    1.01054,
    .96924,
    .96225,
    .96924,
    .96225,
    .96924,
    .96225,
    .92383,
    .90171,
    .80595,
    1.06598,
    1,
    1,
    .80595,
    1.06598,
    .74524,
    .79004,
    .74524,
    .79004,
    .74524,
    .79004,
    .74524,
    .79004,
    1,
    1,
    .86091,
    1.02759,
    .85771,
    1.16344,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .98448,
    .9973,
    .83089,
    .96777,
    .83089,
    .93285,
    .9043,
    .93285,
    .9043,
    .93285,
    .9043,
    1.31868,
    .96927,
    .94729,
    .97454,
    .85498,
    .92916,
    .96924,
    .8761,
    1,
    1,
    .86091,
    1.16344,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    .81965,
    .81965,
    .94729,
    .78032,
    .71022,
    .90883,
    .84171,
    .99877,
    .77596,
    1.05734,
    1.2,
    .94729,
    .85944,
    .82791,
    .9607,
    .74817,
    .93285,
    .98039,
    .96924,
    .95782,
    .89898,
    .98316,
    .98183,
    1.03989,
    .78614,
    .96924,
    .97642,
    .86237,
    .86075,
    .86091,
    .83089,
    .90082,
    .8858,
    .97296,
    1.01284,
    .95782,
    .83089,
    1.0976,
    1.04,
    1.03342,
    1.2,
    1.0675,
    1.0976,
    .98205,
    1.03809,
    1.05097,
    1.04,
    .95364,
    1.03342,
    1.05401,
    1.2,
    1.02148,
    1.0119,
    1.04724,
    1.0127,
    1.02732,
    .96225,
    .8965,
    .97783,
    .93574,
    .94818,
    1.30679,
    1.0675,
    1.11826,
    .99821,
    1.0557,
    1.0326,
    1.2,
    1.0675,
    .96225,
    1.0675,
    1.0326,
    .74817,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.03754,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .87533,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .98705,
    1,
    1,
    1,
    1,
    1,
    1,
    .98448,
    .9973,
    .98448,
    .9973,
    .98448,
    .9973,
    .83089,
    .96777,
    1,
    1.20088,
    .89903,
    1,
    1,
    .75155,
    .94945,
    .94945,
    .94945,
    .94945,
    1.12317,
    1.12317,
    1.12317,
    .67603,
    .67603,
    1.15621,
    .73584,
    1.21191,
    1.22135,
    1.06483,
    .94868,
    .94868,
    .95996,
    1.24633,
    1,
    1.07497,
    .87709,
    .96927,
    1.01473,
    .96927,
    1,
    1,
    1,
    .77295,
    1,
    1,
    1.09836,
    1.09836,
    1.09836,
    1.01522,
    .86321,
    .94434,
    .8649,
    .94434,
    .86182,
    1,
    1,
    1.083,
    1,
    .91578,
    .86438,
    1.17308,
    1.18416,
    1.14589,
    .69825,
    .97622,
    1.96791,
    1.24822,
    1.24822,
    1.17308,
    1.24822,
    1.24822,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    .99862,
    .99862,
    1,
    .87025,
    .87025,
    .87025,
    .87025,
    1.17984,
    1.42603,
    1,
    1.42603,
    1.42603,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.10742,
    1.10742,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], es = {
    lineHeight: 1.33008,
    lineGap: 0
}, ts = [
    1.76738,
    1,
    1,
    .98594,
    1.02285,
    1.10454,
    1.06234,
    .96927,
    .92037,
    1.19985,
    1.2046,
    .90616,
    .90616,
    1.07152,
    1.1714,
    .78032,
    1.20088,
    .78032,
    1.40246,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .78032,
    .78032,
    1.1714,
    1.1714,
    1.1714,
    .80597,
    .94084,
    .96706,
    .85944,
    .85734,
    .97093,
    .75842,
    .79936,
    .88198,
    .9831,
    .95782,
    .71387,
    .86969,
    .84636,
    1.07796,
    1.03584,
    .96924,
    .83968,
    .96924,
    .82826,
    .79649,
    .85771,
    .95132,
    .93119,
    .98965,
    .88433,
    .8287,
    .93365,
    1.08612,
    1.3638,
    1.08612,
    1.45786,
    .74627,
    .80499,
    .91484,
    1.05707,
    .92383,
    1.05882,
    .9403,
    1.12654,
    1.05882,
    1.01756,
    1.09011,
    1.09011,
    .99414,
    1.09011,
    1.034,
    1.01756,
    1.05356,
    1.05707,
    1.05882,
    1.04399,
    .84863,
    1.21968,
    1.01756,
    .95801,
    1.00068,
    .91797,
    .96777,
    .9043,
    .90351,
    .92105,
    .90351,
    1.1714,
    .85337,
    .96927,
    .96927,
    .99912,
    .96927,
    .92105,
    .80597,
    1.2434,
    1.20808,
    1.05937,
    .90957,
    1.1714,
    1.20808,
    .75155,
    .94261,
    1.24644,
    1.09971,
    1.09971,
    .84751,
    1,
    .85273,
    .78032,
    .61584,
    1.05425,
    1.17914,
    .90957,
    1.08665,
    1.11593,
    1.14169,
    .73381,
    .96706,
    .96706,
    .96706,
    .96706,
    .96706,
    .96706,
    .86035,
    .85734,
    .75842,
    .75842,
    .75842,
    .75842,
    .95782,
    .95782,
    .95782,
    .95782,
    .97093,
    1.03584,
    .96924,
    .96924,
    .96924,
    .96924,
    .96924,
    1.1714,
    .96924,
    .95132,
    .95132,
    .95132,
    .95132,
    .8287,
    .83968,
    .89049,
    .91484,
    .91484,
    .91484,
    .91484,
    .91484,
    .91484,
    .93575,
    .92383,
    .9403,
    .9403,
    .9403,
    .9403,
    .8717,
    .8717,
    .8717,
    .8717,
    1.00527,
    1.01756,
    1.05356,
    1.05356,
    1.05356,
    1.05356,
    1.05356,
    1.24644,
    .95923,
    1.01756,
    1.01756,
    1.01756,
    1.01756,
    .96777,
    1.05707,
    .96777,
    .96706,
    .91484,
    .96706,
    .91484,
    .96706,
    .91484,
    .85734,
    .92383,
    .85734,
    .92383,
    .85734,
    .92383,
    .85734,
    .92383,
    .97093,
    1.0969,
    .97093,
    1.05882,
    .75842,
    .9403,
    .75842,
    .9403,
    .75842,
    .9403,
    .75842,
    .9403,
    .75842,
    .9403,
    .88198,
    1.05882,
    .88198,
    1.05882,
    .88198,
    1.05882,
    1,
    1,
    .9831,
    1.01756,
    .9831,
    1.01756,
    .95782,
    .8717,
    .95782,
    .8717,
    .95782,
    .8717,
    .95782,
    1.09011,
    .95782,
    .8717,
    .84784,
    1.11551,
    .71387,
    1.09011,
    1,
    1,
    .99414,
    .84636,
    1.09011,
    1,
    1,
    .84636,
    1.0536,
    .84636,
    .94298,
    .84636,
    1.23297,
    1.03584,
    1.01756,
    1,
    1,
    1.03584,
    1.01756,
    1.00323,
    1.03444,
    1.01756,
    .96924,
    1.05356,
    .96924,
    1.05356,
    .96924,
    1.05356,
    .93066,
    .98293,
    .82826,
    1.04399,
    1,
    1,
    .82826,
    1.04399,
    .79649,
    .84863,
    .79649,
    .84863,
    .79649,
    .84863,
    .79649,
    .84863,
    1,
    1,
    .85771,
    1.17318,
    .85771,
    1.21968,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .98965,
    1.00068,
    .8287,
    .96777,
    .8287,
    .93365,
    .9043,
    .93365,
    .9043,
    .93365,
    .9043,
    1.08571,
    .96927,
    .96706,
    .91484,
    .86035,
    .93575,
    .96924,
    .95923,
    1,
    1,
    .85771,
    1.21968,
    1.11437,
    1.11437,
    .93109,
    .91202,
    .60411,
    .84164,
    .55572,
    1.01173,
    .97361,
    .81818,
    .81818,
    .96635,
    .78032,
    .72727,
    .92366,
    .98601,
    1.03405,
    .77968,
    1.09799,
    1.2,
    .96706,
    .85944,
    .85638,
    .96491,
    .75842,
    .93365,
    .9831,
    .96924,
    .95782,
    .86969,
    .94152,
    1.07796,
    1.03584,
    .78437,
    .96924,
    .98715,
    .83968,
    .83491,
    .85771,
    .8287,
    .94492,
    .88433,
    .9287,
    1.0098,
    .95782,
    .8287,
    1.0625,
    .98248,
    1.03424,
    1.2,
    1.01071,
    1.0625,
    .95246,
    1.03809,
    1.04912,
    .98248,
    1.00221,
    1.03424,
    1.05443,
    1.2,
    1.04785,
    .99609,
    1.00169,
    1.05176,
    .99346,
    1.05356,
    .9087,
    1.03004,
    .95542,
    .93117,
    1.23362,
    1.01071,
    1.07831,
    1.02512,
    1.05205,
    1.03502,
    1.2,
    1.01071,
    1.05356,
    1.01071,
    1.03502,
    .75842,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.03719,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .9403,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.04021,
    1,
    1,
    1,
    1,
    1,
    1,
    .98965,
    1.00068,
    .98965,
    1.00068,
    .98965,
    1.00068,
    .8287,
    .96777,
    1,
    1.20088,
    .89903,
    1,
    1,
    .75155,
    1.03077,
    1.03077,
    1.03077,
    1.03077,
    1.13196,
    1.13196,
    1.13196,
    .67428,
    .67428,
    1.16039,
    .73291,
    1.20996,
    1.22135,
    1.06483,
    .94868,
    .94868,
    .95996,
    1.24633,
    1,
    1.07497,
    .87796,
    .96927,
    1.01518,
    .96927,
    1,
    1,
    1,
    .77295,
    1,
    1,
    1.10539,
    1.10539,
    1.11358,
    1.06967,
    .86279,
    .94434,
    .86279,
    .94434,
    .86182,
    1,
    1,
    1.083,
    1,
    .91578,
    .86507,
    1.1714,
    1.18416,
    1.14589,
    .69825,
    .97622,
    1.9697,
    1.24822,
    1.24822,
    1.17238,
    1.24822,
    1.24822,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    .99862,
    .99862,
    1,
    .87025,
    .87025,
    .87025,
    .87025,
    1.18083,
    1.42603,
    1,
    1.42603,
    1.42603,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.10938,
    1.10938,
    1,
    1,
    1,
    1.05425,
    1.09971,
    1.09971,
    1.09971,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], is = {
    lineHeight: 1.33008,
    lineGap: 0
}, ns = getLookupTableFactory(function(e1) {
    e1["MyriadPro-Regular"] = e1["PdfJS-Fallback-Regular"] = {
        name: "LiberationSans-Regular",
        factors: Ga,
        baseWidths: Ua,
        baseMapping: ja,
        metrics: Va
    }, e1["MyriadPro-Bold"] = e1["PdfJS-Fallback-Bold"] = {
        name: "LiberationSans-Bold",
        factors: $a,
        baseWidths: _a,
        baseMapping: Pa,
        metrics: Ha
    }, e1["MyriadPro-It"] = e1["MyriadPro-Italic"] = e1["PdfJS-Fallback-Italic"] = {
        name: "LiberationSans-Italic",
        factors: za,
        baseWidths: Na,
        baseMapping: La,
        metrics: Wa
    }, e1["MyriadPro-BoldIt"] = e1["MyriadPro-BoldItalic"] = e1["PdfJS-Fallback-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        factors: Xa,
        baseWidths: Ra,
        baseMapping: Ba,
        metrics: qa
    }, e1.ArialMT = e1.Arial = e1["Arial-Regular"] = {
        name: "LiberationSans-Regular",
        baseWidths: Ua,
        baseMapping: ja
    }, e1["Arial-BoldMT"] = e1["Arial-Bold"] = {
        name: "LiberationSans-Bold",
        baseWidths: _a,
        baseMapping: Pa
    }, e1["Arial-ItalicMT"] = e1["Arial-Italic"] = {
        name: "LiberationSans-Italic",
        baseWidths: Na,
        baseMapping: La
    }, e1["Arial-BoldItalicMT"] = e1["Arial-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        baseWidths: Ra,
        baseMapping: Ba
    }, e1["Calibri-Regular"] = {
        name: "LiberationSans-Regular",
        factors: va,
        baseWidths: Ua,
        baseMapping: ja,
        metrics: Ca
    }, e1["Calibri-Bold"] = {
        name: "LiberationSans-Bold",
        factors: ba,
        baseWidths: _a,
        baseMapping: Pa,
        metrics: ya
    }, e1["Calibri-Italic"] = {
        name: "LiberationSans-Italic",
        factors: xa,
        baseWidths: Na,
        baseMapping: La,
        metrics: Sa
    }, e1["Calibri-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        factors: wa,
        baseWidths: Ra,
        baseMapping: Ba,
        metrics: Aa
    }, e1["Segoeui-Regular"] = {
        name: "LiberationSans-Regular",
        factors: ts,
        baseWidths: Ua,
        baseMapping: ja,
        metrics: is
    }, e1["Segoeui-Bold"] = {
        name: "LiberationSans-Bold",
        factors: Ka,
        baseWidths: _a,
        baseMapping: Pa,
        metrics: Ya
    }, e1["Segoeui-Italic"] = {
        name: "LiberationSans-Italic",
        factors: Qa,
        baseWidths: Na,
        baseMapping: La,
        metrics: es
    }, e1["Segoeui-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        factors: Ja,
        baseWidths: Ra,
        baseMapping: Ba,
        metrics: Za
    }, e1["Helvetica-Regular"] = e1.Helvetica = {
        name: "LiberationSans-Regular",
        factors: Da,
        baseWidths: Ua,
        baseMapping: ja,
        metrics: Oa
    }, e1["Helvetica-Bold"] = {
        name: "LiberationSans-Bold",
        factors: ka,
        baseWidths: _a,
        baseMapping: Pa,
        metrics: Ta
    }, e1["Helvetica-Italic"] = {
        name: "LiberationSans-Italic",
        factors: Ea,
        baseWidths: Na,
        baseMapping: La,
        metrics: Ma
    }, e1["Helvetica-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        factors: Fa,
        baseWidths: Ra,
        baseMapping: Ba,
        metrics: Ia
    };
});
function getXfaFontName(e1) {
    const t = normalizeFontName(e1);
    return ns()[t];
}
function getXfaFontDict(e1) {
    const t = function(e1) {
        const t = getXfaFontName(e1);
        if (!t) return null;
        const { baseWidths: i, baseMapping: n, factors: a } = t, s = a ? i.map((e1, t)=>e1 * a[t]) : i;
        let r, o = -2;
        const l = [];
        for (const [e1, t] of n.map((e1, t)=>[
                e1,
                t
            ]).sort(([e1], [t])=>e1 - t))-1 !== e1 && (e1 === o + 1 ? (r.push(s[t]), o += 1) : (o = e1, r = [
            s[t]
        ], l.push(e1, r)));
        return l;
    }(e1), i = new Dict(null);
    i.set("BaseFont", Name.get(e1)), i.set("Type", Name.get("Font")), i.set("Subtype", Name.get("CIDFontType2")), i.set("Encoding", Name.get("Identity-H")), i.set("CIDToGIDMap", Name.get("Identity")), i.set("W", t), i.set("FirstChar", t[0]), i.set("LastChar", t.at(-2) + t.at(-1).length - 1);
    const n = new Dict(null);
    i.set("FontDescriptor", n);
    const a = new Dict(null);
    return a.set("Ordering", "Identity"), a.set("Registry", "Adobe"), a.set("Supplement", 0), i.set("CIDSystemInfo", a), i;
}
class PostScriptParser {
    constructor(e1){
        this.lexer = e1, this.operators = [], this.token = null, this.prev = null;
    }
    nextToken() {
        this.prev = this.token, this.token = this.lexer.getToken();
    }
    accept(e1) {
        return this.token.type === e1 && (this.nextToken(), !0);
    }
    expect(e1) {
        if (this.accept(e1)) return !0;
        throw new ti(`Unexpected symbol: found ${this.token.type} expected ${e1}.`);
    }
    parse() {
        return this.nextToken(), this.expect(as.LBRACE), this.parseBlock(), this.expect(as.RBRACE), this.operators;
    }
    parseBlock() {
        for(;;)if (this.accept(as.NUMBER)) this.operators.push(this.prev.value);
        else if (this.accept(as.OPERATOR)) this.operators.push(this.prev.value);
        else {
            if (!this.accept(as.LBRACE)) return;
            this.parseCondition();
        }
    }
    parseCondition() {
        const e1 = this.operators.length;
        if (this.operators.push(null, null), this.parseBlock(), this.expect(as.RBRACE), this.accept(as.IF)) this.operators[e1] = this.operators.length, this.operators[e1 + 1] = "jz";
        else {
            if (!this.accept(as.LBRACE)) throw new ti("PS Function: error parsing conditional.");
            {
                const t = this.operators.length;
                this.operators.push(null, null);
                const i = this.operators.length;
                this.parseBlock(), this.expect(as.RBRACE), this.expect(as.IFELSE), this.operators[t] = this.operators.length, this.operators[t + 1] = "j", this.operators[e1] = i, this.operators[e1 + 1] = "jz";
            }
        }
    }
}
const as = {
    LBRACE: 0,
    RBRACE: 1,
    NUMBER: 2,
    OPERATOR: 3,
    IF: 4,
    IFELSE: 5
};
class PostScriptToken {
    static get opCache() {
        return shadow$1(this, "opCache", Object.create(null));
    }
    constructor(e1, t){
        this.type = e1, this.value = t;
    }
    static getOperator(e1) {
        return PostScriptToken.opCache[e1] ||= new PostScriptToken(as.OPERATOR, e1);
    }
    static get LBRACE() {
        return shadow$1(this, "LBRACE", new PostScriptToken(as.LBRACE, "{"));
    }
    static get RBRACE() {
        return shadow$1(this, "RBRACE", new PostScriptToken(as.RBRACE, "}"));
    }
    static get IF() {
        return shadow$1(this, "IF", new PostScriptToken(as.IF, "IF"));
    }
    static get IFELSE() {
        return shadow$1(this, "IFELSE", new PostScriptToken(as.IFELSE, "IFELSE"));
    }
}
class PostScriptLexer {
    constructor(e1){
        this.stream = e1, this.nextChar(), this.strBuf = [];
    }
    nextChar() {
        return this.currentChar = this.stream.getByte();
    }
    getToken() {
        let e1 = !1, t = this.currentChar;
        for(;;){
            if (t < 0) return ci;
            if (e1) 10 !== t && 13 !== t || (e1 = !1);
            else if (37 === t) e1 = !0;
            else if (!isWhiteSpace(t)) break;
            t = this.nextChar();
        }
        switch(0 | t){
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 43:
            case 45:
            case 46:
                return new PostScriptToken(as.NUMBER, this.getNumber());
            case 123:
                return this.nextChar(), PostScriptToken.LBRACE;
            case 125:
                return this.nextChar(), PostScriptToken.RBRACE;
        }
        const i = this.strBuf;
        for(i.length = 0, i[0] = String.fromCharCode(t); (t = this.nextChar()) >= 0 && (t >= 65 && t <= 90 || t >= 97 && t <= 122);)i.push(String.fromCharCode(t));
        const n = i.join("");
        switch(n.toLowerCase()){
            case "if":
                return PostScriptToken.IF;
            case "ifelse":
                return PostScriptToken.IFELSE;
            default:
                return PostScriptToken.getOperator(n);
        }
    }
    getNumber() {
        let e1 = this.currentChar;
        const t = this.strBuf;
        for(t.length = 0, t[0] = String.fromCharCode(e1); (e1 = this.nextChar()) >= 0 && (e1 >= 48 && e1 <= 57 || 45 === e1 || 46 === e1);)t.push(String.fromCharCode(e1));
        const i = parseFloat(t.join(""));
        if (isNaN(i)) throw new ti(`Invalid floating point number: ${i}`);
        return i;
    }
}
class BaseLocalCache {
    constructor(e1){
        this._onlyRefs = !0 === e1?.onlyRefs, this._onlyRefs || (this._nameRefMap = new Map, this._imageMap = new Map), this._imageCache = new RefSetCache;
    }
    getByName(e1) {
        this._onlyRefs && unreachable$1("Should not call `getByName` method.");
        const t = this._nameRefMap.get(e1);
        return t ? this.getByRef(t) : this._imageMap.get(e1) || null;
    }
    getByRef(e1) {
        return this._imageCache.get(e1) || null;
    }
    set(e1, t, i) {
        unreachable$1("Abstract method `set` called.");
    }
}
class LocalImageCache extends BaseLocalCache {
    set(e1, t = null, i) {
        if ("string" != typeof e1) throw new Error('LocalImageCache.set - expected "name" argument.');
        if (t) {
            if (this._imageCache.has(t)) return;
            return this._nameRefMap.set(e1, t), void this._imageCache.put(t, i);
        }
        this._imageMap.has(e1) || this._imageMap.set(e1, i);
    }
}
class LocalColorSpaceCache extends BaseLocalCache {
    set(e1 = null, t = null, i) {
        if ("string" != typeof e1 && !t) throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
        if (t) {
            if (this._imageCache.has(t)) return;
            return null !== e1 && this._nameRefMap.set(e1, t), void this._imageCache.put(t, i);
        }
        this._imageMap.has(e1) || this._imageMap.set(e1, i);
    }
}
class LocalFunctionCache extends BaseLocalCache {
    constructor(e1){
        super({
            onlyRefs: !0
        });
    }
    set(e1 = null, t, i) {
        if (!t) throw new Error('LocalFunctionCache.set - expected "ref" argument.');
        this._imageCache.has(t) || this._imageCache.put(t, i);
    }
}
class LocalGStateCache extends BaseLocalCache {
    set(e1, t = null, i) {
        if ("string" != typeof e1) throw new Error('LocalGStateCache.set - expected "name" argument.');
        if (t) {
            if (this._imageCache.has(t)) return;
            return this._nameRefMap.set(e1, t), void this._imageCache.put(t, i);
        }
        this._imageMap.has(e1) || this._imageMap.set(e1, i);
    }
}
class LocalTilingPatternCache extends BaseLocalCache {
    constructor(e1){
        super({
            onlyRefs: !0
        });
    }
    set(e1 = null, t, i) {
        if (!t) throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
        this._imageCache.has(t) || this._imageCache.put(t, i);
    }
}
class RegionalImageCache extends BaseLocalCache {
    constructor(e1){
        super({
            onlyRefs: !0
        });
    }
    set(e1 = null, t, i) {
        if (!t) throw new Error('RegionalImageCache.set - expected "ref" argument.');
        this._imageCache.has(t) || this._imageCache.put(t, i);
    }
}
class GlobalColorSpaceCache extends BaseLocalCache {
    constructor(e1){
        super({
            onlyRefs: !0
        });
    }
    set(e1 = null, t, i) {
        if (!t) throw new Error('GlobalColorSpaceCache.set - expected "ref" argument.');
        this._imageCache.has(t) || this._imageCache.put(t, i);
    }
    clear() {
        this._imageCache.clear();
    }
}
class GlobalImageCache {
    static NUM_PAGES_THRESHOLD = 2;
    static MIN_IMAGES_TO_CACHE = 10;
    static MAX_BYTE_SIZE = 5e7;
    #X = new RefSet;
    constructor(){
        this._refCache = new RefSetCache, this._imageCache = new RefSetCache;
    }
    get #q() {
        let e1 = 0;
        for (const t of this._imageCache)e1 += t.byteSize;
        return e1;
    }
    get #z() {
        return !(this._imageCache.size < GlobalImageCache.MIN_IMAGES_TO_CACHE) && !(this.#q < GlobalImageCache.MAX_BYTE_SIZE);
    }
    shouldCache(e1, t) {
        let i = this._refCache.get(e1);
        return i || (i = new Set, this._refCache.put(e1, i)), i.add(t), !(i.size < GlobalImageCache.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(e1) && this.#z);
    }
    addDecodeFailed(e1) {
        this.#X.put(e1);
    }
    hasDecodeFailed(e1) {
        return this.#X.has(e1);
    }
    addByteSize(e1, t) {
        const i = this._imageCache.get(e1);
        i && (i.byteSize || (i.byteSize = t));
    }
    getData(e1, t) {
        const i = this._refCache.get(e1);
        if (!i) return null;
        if (i.size < GlobalImageCache.NUM_PAGES_THRESHOLD) return null;
        const n = this._imageCache.get(e1);
        return n ? (i.add(t), n) : null;
    }
    setData(e1, t) {
        if (!this._refCache.has(e1)) throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
        this._imageCache.has(e1) || (this.#z ? warn$1("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(e1, t));
    }
    clear(e1 = !1) {
        e1 || (this.#X.clear(), this._refCache.clear()), this._imageCache.clear();
    }
}
class PDFFunctionFactory {
    constructor({ xref: e1, isEvalSupported: t = !0 }){
        this.xref = e1, this.isEvalSupported = !1 !== t;
    }
    create(e1, t = !1) {
        let i, n;
        if (e1 instanceof Ref ? i = e1 : e1 instanceof Dict ? i = e1.objId : e1 instanceof BaseStream && (i = e1.dict?.objId), i) {
            const e1 = this._localFunctionCache.getByRef(i);
            if (e1) return e1;
        }
        const a = this.xref.fetchIfRef(e1);
        if (Array.isArray(a)) {
            if (!t) throw new Error('PDFFunctionFactory.create - expected "parseArray" argument.');
            n = PDFFunction.parseArray(this, a);
        } else n = PDFFunction.parse(this, a);
        return i && this._localFunctionCache.set(null, i, n), n;
    }
    get _localFunctionCache() {
        return shadow$1(this, "_localFunctionCache", new LocalFunctionCache);
    }
}
function toNumberArray(e1) {
    return Array.isArray(e1) ? isNumberArray(e1, null) ? e1 : e1.map((e1)=>+e1) : null;
}
class PDFFunction {
    static getSampleArray(e1, t, i, n) {
        let a, s, r = 1;
        for(a = 0, s = e1.length; a < s; a++)r *= e1[a];
        r *= t;
        const o = new Array(r);
        let l = 0, c = 0;
        const h = 1 / (2 ** i - 1), d = n.getBytes((r * i + 7) / 8);
        let u = 0;
        for(a = 0; a < r; a++){
            for(; l < i;)c <<= 8, c |= d[u++], l += 8;
            l -= i, o[a] = (c >> l) * h, c &= (1 << l) - 1;
        }
        return o;
    }
    static parse(e1, t) {
        const i = t.dict || t;
        switch(i.get("FunctionType")){
            case 0:
                return this.constructSampled(e1, t, i);
            case 1:
                break;
            case 2:
                return this.constructInterpolated(e1, i);
            case 3:
                return this.constructStiched(e1, i);
            case 4:
                return this.constructPostScript(e1, t, i);
        }
        throw new ti("Unknown type of function");
    }
    static parseArray(e1, t) {
        const { xref: i } = e1, n = [];
        for (const a of t)n.push(this.parse(e1, i.fetchIfRef(a)));
        return function(e1, t, i, a) {
            for(let s = 0, r = n.length; s < r; s++)n[s](e1, t, i, a + s);
        };
    }
    static constructSampled(e1, t, i) {
        function toMultiArray(e1) {
            const t = e1.length, i = [];
            let n = 0;
            for(let a = 0; a < t; a += 2)i[n++] = [
                e1[a],
                e1[a + 1]
            ];
            return i;
        }
        function interpolate(e1, t, i, n, a) {
            return n + (a - n) / (i - t) * (e1 - t);
        }
        let n = toNumberArray(i.getArray("Domain")), a = toNumberArray(i.getArray("Range"));
        if (!n || !a) throw new ti("No domain or range");
        const s = n.length / 2, r = a.length / 2;
        n = toMultiArray(n), a = toMultiArray(a);
        const o = toNumberArray(i.getArray("Size")), l = i.get("BitsPerSample"), c = i.get("Order") || 1;
        1 !== c && info$1("No support for cubic spline interpolation: " + c);
        let h = toNumberArray(i.getArray("Encode"));
        if (h) h = toMultiArray(h);
        else {
            h = [];
            for(let e1 = 0; e1 < s; ++e1)h.push([
                0,
                o[e1] - 1
            ]);
        }
        let d = toNumberArray(i.getArray("Decode"));
        d = d ? toMultiArray(d) : a;
        const u = this.getSampleArray(o, r, l, t);
        return function(e1, t, i, l) {
            const c = 1 << s, g = new Float64Array(c).fill(1), f = new Uint32Array(c);
            let p, m, b = r, y = 1;
            for(p = 0; p < s; ++p){
                const i = n[p][0], a = n[p][1];
                let s = interpolate(MathClamp$1(e1[t + p], i, a), i, a, h[p][0], h[p][1]);
                const r = o[p];
                s = MathClamp$1(s, 0, r - 1);
                const l = s < r - 1 ? Math.floor(s) : s - 1, d = l + 1 - s, u = s - l, w = l * b, x = w + b;
                for(m = 0; m < c; m++)m & y ? (g[m] *= u, f[m] += x) : (g[m] *= d, f[m] += w);
                b *= r, y <<= 1;
            }
            for(m = 0; m < r; ++m){
                let e1 = 0;
                for(p = 0; p < c; p++)e1 += u[f[p] + m] * g[p];
                e1 = interpolate(e1, 0, 1, d[m][0], d[m][1]), i[l + m] = MathClamp$1(e1, a[m][0], a[m][1]);
            }
        };
    }
    static constructInterpolated(e1, t) {
        const i = toNumberArray(t.getArray("C0")) || [
            0
        ], n = toNumberArray(t.getArray("C1")) || [
            1
        ], a = t.get("N"), s = [];
        for(let e1 = 0, t = i.length; e1 < t; ++e1)s.push(n[e1] - i[e1]);
        const r = s.length;
        return function(e1, t, n, o) {
            const l = 1 === a ? e1[t] : e1[t] ** a;
            for(let e1 = 0; e1 < r; ++e1)n[o + e1] = i[e1] + l * s[e1];
        };
    }
    static constructStiched(e1, t) {
        const i = toNumberArray(t.getArray("Domain"));
        if (!i) throw new ti("No domain");
        if (1 !== i.length / 2) throw new ti("Bad domain for stiched function");
        const { xref: n } = e1, a = [];
        for (const i of t.get("Functions"))a.push(this.parse(e1, n.fetchIfRef(i)));
        const s = toNumberArray(t.getArray("Bounds")), r = toNumberArray(t.getArray("Encode")), o = new Float32Array(1);
        return function(e1, t, n, l) {
            const c = MathClamp$1(e1[t], i[0], i[1]), h = s.length;
            let d;
            for(d = 0; d < h && !(c < s[d]); ++d);
            let u = i[0];
            d > 0 && (u = s[d - 1]);
            let g = i[1];
            d < s.length && (g = s[d]);
            const f = r[2 * d], p = r[2 * d + 1];
            o[0] = u === g ? f : f + (c - u) * (p - f) / (g - u), a[d](o, 0, n, l);
        };
    }
    static constructPostScript(e1, t, i) {
        const n = toNumberArray(i.getArray("Domain")), a = toNumberArray(i.getArray("Range"));
        if (!n) throw new ti("No domain.");
        if (!a) throw new ti("No range.");
        const s = new PostScriptLexer(t), r = new PostScriptParser(s).parse();
        if (e1.isEvalSupported && FeatureTest.isEvalSupported) {
            const e1 = (new PostScriptCompiler).compile(r, n, a);
            if (e1) return new Function("src", "srcOffset", "dest", "destOffset", e1);
        }
        info$1("Unable to compile PS function");
        const o = a.length >> 1, l = n.length >> 1, c = new PostScriptEvaluator(r), h = Object.create(null);
        let d = 8192;
        const u = new Float32Array(l);
        return function(e1, t, i, n) {
            let s, r, g = "";
            const f = u;
            for(s = 0; s < l; s++)r = e1[t + s], f[s] = r, g += r + "_";
            const p = h[g];
            if (void 0 !== p) return void i.set(p, n);
            const m = new Float32Array(o), b = c.execute(f), y = b.length - o;
            for(s = 0; s < o; s++){
                r = b[y + s];
                let e1 = a[2 * s];
                r < e1 ? r = e1 : (e1 = a[2 * s + 1], r > e1 && (r = e1)), m[s] = r;
            }
            d > 0 && (d--, h[g] = m), i.set(m, n);
        };
    }
}
function isPDFFunction(e1) {
    let t;
    if (e1 instanceof Dict) t = e1;
    else {
        if (!(e1 instanceof BaseStream)) return !1;
        t = e1.dict;
    }
    return t.has("FunctionType");
}
class PostScriptStack {
    static MAX_STACK_SIZE = 100;
    constructor(e1){
        this.stack = e1 ? Array.from(e1) : [];
    }
    push(e1) {
        if (this.stack.length >= PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
        this.stack.push(e1);
    }
    pop() {
        if (this.stack.length <= 0) throw new Error("PostScript function stack underflow.");
        return this.stack.pop();
    }
    copy(e1) {
        if (this.stack.length + e1 >= PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
        const t = this.stack;
        for(let i = t.length - e1, n = e1 - 1; n >= 0; n--, i++)t.push(t[i]);
    }
    index(e1) {
        this.push(this.stack[this.stack.length - e1 - 1]);
    }
    roll(e1, t) {
        const i = this.stack, n = i.length - e1, a = i.length - 1, s = n + (t - Math.floor(t / e1) * e1);
        for(let e1 = n, t = a; e1 < t; e1++, t--){
            const n = i[e1];
            i[e1] = i[t], i[t] = n;
        }
        for(let e1 = n, t = s - 1; e1 < t; e1++, t--){
            const n = i[e1];
            i[e1] = i[t], i[t] = n;
        }
        for(let e1 = s, t = a; e1 < t; e1++, t--){
            const n = i[e1];
            i[e1] = i[t], i[t] = n;
        }
    }
}
class PostScriptEvaluator {
    constructor(e1){
        this.operators = e1;
    }
    execute(e1) {
        const t = new PostScriptStack(e1);
        let i = 0;
        const n = this.operators, a = n.length;
        let s, r, o;
        for(; i < a;)if (s = n[i++], "number" != typeof s) switch(s){
            case "jz":
                o = t.pop(), r = t.pop(), r || (i = o);
                break;
            case "j":
                r = t.pop(), i = r;
                break;
            case "abs":
                r = t.pop(), t.push(Math.abs(r));
                break;
            case "add":
                o = t.pop(), r = t.pop(), t.push(r + o);
                break;
            case "and":
                o = t.pop(), r = t.pop(), "boolean" == typeof r && "boolean" == typeof o ? t.push(r && o) : t.push(r & o);
                break;
            case "atan":
                o = t.pop(), r = t.pop(), r = Math.atan2(r, o) / Math.PI * 180, r < 0 && (r += 360), t.push(r);
                break;
            case "bitshift":
                o = t.pop(), r = t.pop(), r > 0 ? t.push(r << o) : t.push(r >> o);
                break;
            case "ceiling":
                r = t.pop(), t.push(Math.ceil(r));
                break;
            case "copy":
                r = t.pop(), t.copy(r);
                break;
            case "cos":
                r = t.pop(), t.push(Math.cos(r % 360 / 180 * Math.PI));
                break;
            case "cvi":
                r = 0 | t.pop(), t.push(r);
                break;
            case "cvr":
                break;
            case "div":
                o = t.pop(), r = t.pop(), t.push(r / o);
                break;
            case "dup":
                t.copy(1);
                break;
            case "eq":
                o = t.pop(), r = t.pop(), t.push(r === o);
                break;
            case "exch":
                t.roll(2, 1);
                break;
            case "exp":
                o = t.pop(), r = t.pop(), t.push(r ** o);
                break;
            case "false":
                t.push(!1);
                break;
            case "floor":
                r = t.pop(), t.push(Math.floor(r));
                break;
            case "ge":
                o = t.pop(), r = t.pop(), t.push(r >= o);
                break;
            case "gt":
                o = t.pop(), r = t.pop(), t.push(r > o);
                break;
            case "idiv":
                o = t.pop(), r = t.pop(), t.push(r / o | 0);
                break;
            case "index":
                r = t.pop(), t.index(r);
                break;
            case "le":
                o = t.pop(), r = t.pop(), t.push(r <= o);
                break;
            case "ln":
                r = t.pop(), t.push(Math.log(r));
                break;
            case "log":
                r = t.pop(), t.push(Math.log10(r));
                break;
            case "lt":
                o = t.pop(), r = t.pop(), t.push(r < o);
                break;
            case "mod":
                o = t.pop(), r = t.pop(), t.push(r % o);
                break;
            case "mul":
                o = t.pop(), r = t.pop(), t.push(r * o);
                break;
            case "ne":
                o = t.pop(), r = t.pop(), t.push(r !== o);
                break;
            case "neg":
                r = t.pop(), t.push(-r);
                break;
            case "not":
                r = t.pop(), "boolean" == typeof r ? t.push(!r) : t.push(~r);
                break;
            case "or":
                o = t.pop(), r = t.pop(), "boolean" == typeof r && "boolean" == typeof o ? t.push(r || o) : t.push(r | o);
                break;
            case "pop":
                t.pop();
                break;
            case "roll":
                o = t.pop(), r = t.pop(), t.roll(r, o);
                break;
            case "round":
                r = t.pop(), t.push(Math.round(r));
                break;
            case "sin":
                r = t.pop(), t.push(Math.sin(r % 360 / 180 * Math.PI));
                break;
            case "sqrt":
                r = t.pop(), t.push(Math.sqrt(r));
                break;
            case "sub":
                o = t.pop(), r = t.pop(), t.push(r - o);
                break;
            case "true":
                t.push(!0);
                break;
            case "truncate":
                r = t.pop(), r = r < 0 ? Math.ceil(r) : Math.floor(r), t.push(r);
                break;
            case "xor":
                o = t.pop(), r = t.pop(), "boolean" == typeof r && "boolean" == typeof o ? t.push(r !== o) : t.push(r ^ o);
                break;
            default:
                throw new ti(`Unknown operator ${s}`);
        }
        else t.push(s);
        return t.stack;
    }
}
class AstNode {
    constructor(e1){
        this.type = e1;
    }
    visit(e1) {
        unreachable$1("abstract method");
    }
}
class AstArgument extends AstNode {
    constructor(e1, t, i){
        super("args"), this.index = e1, this.min = t, this.max = i;
    }
    visit(e1) {
        e1.visitArgument(this);
    }
}
class AstLiteral extends AstNode {
    constructor(e1){
        super("literal"), this.number = e1, this.min = e1, this.max = e1;
    }
    visit(e1) {
        e1.visitLiteral(this);
    }
}
class AstBinaryOperation extends AstNode {
    constructor(e1, t, i, n, a){
        super("binary"), this.op = e1, this.arg1 = t, this.arg2 = i, this.min = n, this.max = a;
    }
    visit(e1) {
        e1.visitBinaryOperation(this);
    }
}
class AstMin extends AstNode {
    constructor(e1, t){
        super("max"), this.arg = e1, this.min = e1.min, this.max = t;
    }
    visit(e1) {
        e1.visitMin(this);
    }
}
class AstVariable extends AstNode {
    constructor(e1, t, i){
        super("var"), this.index = e1, this.min = t, this.max = i;
    }
    visit(e1) {
        e1.visitVariable(this);
    }
}
class AstVariableDefinition extends AstNode {
    constructor(e1, t){
        super("definition"), this.variable = e1, this.arg = t;
    }
    visit(e1) {
        e1.visitVariableDefinition(this);
    }
}
class ExpressionBuilderVisitor {
    constructor(){
        this.parts = [];
    }
    visitArgument(e1) {
        this.parts.push("Math.max(", e1.min, ", Math.min(", e1.max, ", src[srcOffset + ", e1.index, "]))");
    }
    visitVariable(e1) {
        this.parts.push("v", e1.index);
    }
    visitLiteral(e1) {
        this.parts.push(e1.number);
    }
    visitBinaryOperation(e1) {
        this.parts.push("("), e1.arg1.visit(this), this.parts.push(" ", e1.op, " "), e1.arg2.visit(this), this.parts.push(")");
    }
    visitVariableDefinition(e1) {
        this.parts.push("var "), e1.variable.visit(this), this.parts.push(" = "), e1.arg.visit(this), this.parts.push(";");
    }
    visitMin(e1) {
        this.parts.push("Math.min("), e1.arg.visit(this), this.parts.push(", ", e1.max, ")");
    }
    toString() {
        return this.parts.join("");
    }
}
function buildAddOperation(e1, t) {
    return "literal" === t.type && 0 === t.number ? e1 : "literal" === e1.type && 0 === e1.number ? t : "literal" === t.type && "literal" === e1.type ? new AstLiteral(e1.number + t.number) : new AstBinaryOperation("+", e1, t, e1.min + t.min, e1.max + t.max);
}
function buildMulOperation(e1, t) {
    if ("literal" === t.type) {
        if (0 === t.number) return new AstLiteral(0);
        if (1 === t.number) return e1;
        if ("literal" === e1.type) return new AstLiteral(e1.number * t.number);
    }
    if ("literal" === e1.type) {
        if (0 === e1.number) return new AstLiteral(0);
        if (1 === e1.number) return t;
    }
    const i = Math.min(e1.min * t.min, e1.min * t.max, e1.max * t.min, e1.max * t.max), n = Math.max(e1.min * t.min, e1.min * t.max, e1.max * t.min, e1.max * t.max);
    return new AstBinaryOperation("*", e1, t, i, n);
}
function buildSubOperation(e1, t) {
    if ("literal" === t.type) {
        if (0 === t.number) return e1;
        if ("literal" === e1.type) return new AstLiteral(e1.number - t.number);
    }
    return "binary" === t.type && "-" === t.op && "literal" === e1.type && 1 === e1.number && "literal" === t.arg1.type && 1 === t.arg1.number ? t.arg2 : new AstBinaryOperation("-", e1, t, e1.min - t.max, e1.max - t.min);
}
function buildMinOperation(e1, t) {
    return e1.min >= t ? new AstLiteral(t) : e1.max <= t ? e1 : new AstMin(e1, t);
}
class PostScriptCompiler {
    compile(e1, t, i) {
        const n = [], a = [], s = t.length >> 1, r = i.length >> 1;
        let o, l, c, h, d, u, g, f, p = 0;
        for(let e1 = 0; e1 < s; e1++)n.push(new AstArgument(e1, t[2 * e1], t[2 * e1 + 1]));
        for(let t = 0, i = e1.length; t < i; t++)if (f = e1[t], "number" != typeof f) switch(f){
            case "add":
                if (n.length < 2) return null;
                h = n.pop(), c = n.pop(), n.push(buildAddOperation(c, h));
                break;
            case "cvr":
                if (n.length < 1) return null;
                break;
            case "mul":
                if (n.length < 2) return null;
                h = n.pop(), c = n.pop(), n.push(buildMulOperation(c, h));
                break;
            case "sub":
                if (n.length < 2) return null;
                h = n.pop(), c = n.pop(), n.push(buildSubOperation(c, h));
                break;
            case "exch":
                if (n.length < 2) return null;
                d = n.pop(), u = n.pop(), n.push(d, u);
                break;
            case "pop":
                if (n.length < 1) return null;
                n.pop();
                break;
            case "index":
                if (n.length < 1) return null;
                if (c = n.pop(), "literal" !== c.type) return null;
                if (o = c.number, o < 0 || !Number.isInteger(o) || n.length < o) return null;
                if (d = n[n.length - o - 1], "literal" === d.type || "var" === d.type) {
                    n.push(d);
                    break;
                }
                g = new AstVariable(p++, d.min, d.max), n[n.length - o - 1] = g, n.push(g), a.push(new AstVariableDefinition(g, d));
                break;
            case "dup":
                if (n.length < 1) return null;
                if ("number" == typeof e1[t + 1] && "gt" === e1[t + 2] && e1[t + 3] === t + 7 && "jz" === e1[t + 4] && "pop" === e1[t + 5] && e1[t + 6] === e1[t + 1]) {
                    c = n.pop(), n.push(buildMinOperation(c, e1[t + 1])), t += 6;
                    break;
                }
                if (d = n.at(-1), "literal" === d.type || "var" === d.type) {
                    n.push(d);
                    break;
                }
                g = new AstVariable(p++, d.min, d.max), n[n.length - 1] = g, n.push(g), a.push(new AstVariableDefinition(g, d));
                break;
            case "roll":
                if (n.length < 2) return null;
                if (h = n.pop(), c = n.pop(), "literal" !== h.type || "literal" !== c.type) return null;
                if (l = h.number, o = c.number, o <= 0 || !Number.isInteger(o) || !Number.isInteger(l) || n.length < o) return null;
                if (l = (l % o + o) % o, 0 === l) break;
                n.push(...n.splice(n.length - o, o - l));
                break;
            default:
                return null;
        }
        else n.push(new AstLiteral(f));
        if (n.length !== r) return null;
        const m = [];
        for (const e1 of a){
            const t = new ExpressionBuilderVisitor;
            e1.visit(t), m.push(t.toString());
        }
        for(let e1 = 0, t = n.length; e1 < t; e1++){
            const t = n[e1], a = new ExpressionBuilderVisitor;
            t.visit(a);
            const s = i[2 * e1], r = i[2 * e1 + 1], o = [
                a.toString()
            ];
            s > t.min && (o.unshift("Math.max(", s, ", "), o.push(")")), r < t.max && (o.unshift("Math.min(", r, ", "), o.push(")")), o.unshift("dest[destOffset + ", e1, "] = "), o.push(";"), m.push(o.join(""));
        }
        return m.join("\n");
    }
}
const ss = [
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "S",
    "B",
    "S",
    "WS",
    "B",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "B",
    "B",
    "B",
    "S",
    "WS",
    "ON",
    "ON",
    "ET",
    "ET",
    "ET",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "ES",
    "CS",
    "ES",
    "CS",
    "CS",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "CS",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "ON",
    "ON",
    "ON",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "B",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "CS",
    "ON",
    "ET",
    "ET",
    "ET",
    "ET",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "ON",
    "ON",
    "BN",
    "ON",
    "ON",
    "ET",
    "ET",
    "EN",
    "EN",
    "ON",
    "L",
    "ON",
    "ON",
    "ON",
    "EN",
    "L",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L"
], rs = [
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "ON",
    "ON",
    "AL",
    "ET",
    "ET",
    "AL",
    "CS",
    "AL",
    "ON",
    "ON",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AL",
    "AL",
    "",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "ET",
    "AN",
    "AN",
    "AL",
    "AL",
    "AL",
    "NSM",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AN",
    "ON",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AL",
    "AL",
    "NSM",
    "NSM",
    "ON",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AL",
    "AL",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL"
];
function isOdd(e1) {
    return !!(1 & e1);
}
function isEven(e1) {
    return !(1 & e1);
}
function findUnequal(e1, t, i) {
    let n, a;
    for(n = t, a = e1.length; n < a; ++n)if (e1[n] !== i) return n;
    return n;
}
function reverseValues(e1, t, i) {
    for(let n = t, a = i - 1; n < a; ++n, --a){
        const t = e1[n];
        e1[n] = e1[a], e1[a] = t;
    }
}
function createBidiText(e1, t, i = !1) {
    let n = "ltr";
    return i ? n = "ttb" : t || (n = "rtl"), {
        str: e1,
        dir: n
    };
}
const os = [], ls = [];
function bidi(e1, t = -1, i = !1) {
    let n = !0;
    const a = e1.length;
    if (0 === a || i) return createBidiText(e1, n, i);
    os.length = a, ls.length = a;
    let s, r, o = 0;
    for(s = 0; s < a; ++s){
        os[s] = e1.charAt(s);
        const t = e1.charCodeAt(s);
        let i = "L";
        t <= 255 ? i = ss[t] : 1424 <= t && t <= 1524 ? i = "R" : 1536 <= t && t <= 1791 ? (i = rs[255 & t], i || warn$1("Bidi: invalid Unicode character " + t.toString(16))) : (1792 <= t && t <= 2220 || 64336 <= t && t <= 65023 || 65136 <= t && t <= 65279) && (i = "AL"), "R" !== i && "AL" !== i && "AN" !== i || o++, ls[s] = i;
    }
    if (0 === o) return n = !0, createBidiText(e1, n);
    -1 === t && (o / a < .3 && a > 4 ? (n = !0, t = 0) : (n = !1, t = 1));
    const l = [];
    for(s = 0; s < a; ++s)l[s] = t;
    const c = isOdd(t) ? "R" : "L", h = c, d = h;
    let u, g = h;
    for(s = 0; s < a; ++s)"NSM" === ls[s] ? ls[s] = g : g = ls[s];
    for(g = h, s = 0; s < a; ++s)u = ls[s], "EN" === u ? ls[s] = "AL" === g ? "AN" : "EN" : "R" !== u && "L" !== u && "AL" !== u || (g = u);
    for(s = 0; s < a; ++s)u = ls[s], "AL" === u && (ls[s] = "R");
    for(s = 1; s < a - 1; ++s)"ES" === ls[s] && "EN" === ls[s - 1] && "EN" === ls[s + 1] && (ls[s] = "EN"), "CS" !== ls[s] || "EN" !== ls[s - 1] && "AN" !== ls[s - 1] || ls[s + 1] !== ls[s - 1] || (ls[s] = ls[s - 1]);
    for(s = 0; s < a; ++s)if ("EN" === ls[s]) {
        for(let e1 = s - 1; e1 >= 0 && "ET" === ls[e1]; --e1)ls[e1] = "EN";
        for(let e1 = s + 1; e1 < a && "ET" === ls[e1]; ++e1)ls[e1] = "EN";
    }
    for(s = 0; s < a; ++s)u = ls[s], "WS" !== u && "ES" !== u && "ET" !== u && "CS" !== u || (ls[s] = "ON");
    for(g = h, s = 0; s < a; ++s)u = ls[s], "EN" === u ? ls[s] = "L" === g ? "L" : "EN" : "R" !== u && "L" !== u || (g = u);
    for(s = 0; s < a; ++s)if ("ON" === ls[s]) {
        const e1 = findUnequal(ls, s + 1, "ON");
        let t = h;
        s > 0 && (t = ls[s - 1]);
        let i = d;
        e1 + 1 < a && (i = ls[e1 + 1]), "L" !== t && (t = "R"), "L" !== i && (i = "R"), t === i && ls.fill(t, s, e1), s = e1 - 1;
    }
    for(s = 0; s < a; ++s)"ON" === ls[s] && (ls[s] = c);
    for(s = 0; s < a; ++s)u = ls[s], isEven(l[s]) ? "R" === u ? l[s] += 1 : "AN" !== u && "EN" !== u || (l[s] += 2) : "L" !== u && "AN" !== u && "EN" !== u || (l[s] += 1);
    let f, p = -1, m = 99;
    for(s = 0, r = l.length; s < r; ++s)f = l[s], p < f && (p = f), m > f && isOdd(f) && (m = f);
    for(f = p; f >= m; --f){
        let e1 = -1;
        for(s = 0, r = l.length; s < r; ++s)l[s] < f ? e1 >= 0 && (reverseValues(os, e1, s), e1 = -1) : e1 < 0 && (e1 = s);
        e1 >= 0 && reverseValues(os, e1, l.length);
    }
    for(s = 0, r = os.length; s < r; ++s){
        const e1 = os[s];
        "<" !== e1 && ">" !== e1 || (os[s] = "");
    }
    return createBidiText(os.join(""), n);
}
let cs = class CssFontInfo {
    #R;
    #W;
    #G;
    static strings = [
        "fontFamily",
        "fontWeight",
        "italicAngle"
    ];
    static write(e1) {
        const t = new TextEncoder, i = {};
        let n = 0;
        for (const a of CssFontInfo.strings){
            const s = t.encode(e1[a]);
            i[a] = s, n += 4 + s.length;
        }
        const a = new ArrayBuffer(n), s = new Uint8Array(a), r = new DataView(a);
        let o = 0;
        for (const e1 of CssFontInfo.strings){
            const t = i[e1], n = t.length;
            r.setUint32(o, n), s.set(t, o + 4), o += 4 + n;
        }
        return assert$1(o === a.byteLength, "CssFontInfo.write: Buffer overflow"), a;
    }
    constructor(e1){
        this.#R = e1, this.#W = new DataView(this.#R), this.#G = new TextDecoder;
    }
    #V(e1) {
        assert$1(e1 < CssFontInfo.strings.length, "Invalid string index");
        let t = 0;
        for(let i = 0; i < e1; i++)t += this.#W.getUint32(t) + 4;
        const i = this.#W.getUint32(t);
        return this.#G.decode(new Uint8Array(this.#R, t + 4, i));
    }
    get fontFamily() {
        return this.#V(0);
    }
    get fontWeight() {
        return this.#V(1);
    }
    get italicAngle() {
        return this.#V(2);
    }
}, hs = class SystemFontInfo {
    #R;
    #W;
    #G;
    static strings = [
        "css",
        "loadedName",
        "baseFontName",
        "src"
    ];
    static write(e1) {
        const t = new TextEncoder, i = {};
        let n = 0;
        for (const a of SystemFontInfo.strings){
            const s = t.encode(e1[a]);
            i[a] = s, n += 4 + s.length;
        }
        n += 4;
        let a, s, r = 1 + n;
        e1.style && (a = t.encode(e1.style.style), s = t.encode(e1.style.weight), r += 4 + a.length + 4 + s.length);
        const o = new ArrayBuffer(r), l = new Uint8Array(o), c = new DataView(o);
        let h = 0;
        c.setUint8(h++, e1.guessFallback ? 1 : 0), c.setUint32(h, 0), h += 4, n = 0;
        for (const e1 of SystemFontInfo.strings){
            const t = i[e1], a = t.length;
            n += 4 + a, c.setUint32(h, a), l.set(t, h + 4), h += 4 + a;
        }
        return c.setUint32(h - n - 4, n), e1.style && (c.setUint32(h, a.length), l.set(a, h + 4), h += 4 + a.length, c.setUint32(h, s.length), l.set(s, h + 4), h += 4 + s.length), assert$1(h <= o.byteLength, "SubstitionInfo.write: Buffer overflow"), o.transferToFixedLength(h);
    }
    constructor(e1){
        this.#R = e1, this.#W = new DataView(this.#R), this.#G = new TextDecoder;
    }
    get guessFallback() {
        return 0 !== this.#W.getUint8(0);
    }
    #V(e1) {
        assert$1(e1 < SystemFontInfo.strings.length, "Invalid string index");
        let t = 5;
        for(let i = 0; i < e1; i++)t += this.#W.getUint32(t) + 4;
        const i = this.#W.getUint32(t);
        return this.#G.decode(new Uint8Array(this.#R, t + 4, i));
    }
    get css() {
        return this.#V(0);
    }
    get loadedName() {
        return this.#V(1);
    }
    get baseFontName() {
        return this.#V(2);
    }
    get src() {
        return this.#V(3);
    }
    get style() {
        let e1 = 1;
        e1 += 4 + this.#W.getUint32(e1);
        const t = this.#W.getUint32(e1), i = this.#G.decode(new Uint8Array(this.#R, e1 + 4, t));
        e1 += 4 + t;
        const n = this.#W.getUint32(e1);
        return {
            style: i,
            weight: this.#G.decode(new Uint8Array(this.#R, e1 + 4, n))
        };
    }
}, ds = class FontInfo {
    static bools = [
        "black",
        "bold",
        "disableFontFace",
        "fontExtraProperties",
        "isInvalidPDFjsFont",
        "isType3Font",
        "italic",
        "missingFile",
        "remeasure",
        "vertical"
    ];
    static numbers = [
        "ascent",
        "defaultWidth",
        "descent"
    ];
    static strings = [
        "fallbackName",
        "loadedName",
        "mimetype",
        "name"
    ];
    static #K = Math.ceil(2 * this.bools.length / 8);
    static #Y = this.#K + 8 * this.numbers.length;
    static #J = this.#Y + 1 + 8;
    static #Z = this.#J + 1 + 48;
    static #Q = this.#Z + 1 + 6;
    #R;
    #G;
    #W;
    constructor({ data: e1, extra: t }){
        this.#R = e1, this.#G = new TextDecoder, this.#W = new DataView(this.#R), t && Object.assign(this, t);
    }
    #ee(e1) {
        assert$1(e1 < FontInfo.bools.length, "Invalid boolean index");
        const t = Math.floor(e1 / 4), i = 2 * e1 % 8, n = this.#W.getUint8(t) >> i & 3;
        return 0 === n ? void 0 : 2 === n;
    }
    get black() {
        return this.#ee(0);
    }
    get bold() {
        return this.#ee(1);
    }
    get disableFontFace() {
        return this.#ee(2);
    }
    get fontExtraProperties() {
        return this.#ee(3);
    }
    get isInvalidPDFjsFont() {
        return this.#ee(4);
    }
    get isType3Font() {
        return this.#ee(5);
    }
    get italic() {
        return this.#ee(6);
    }
    get missingFile() {
        return this.#ee(7);
    }
    get remeasure() {
        return this.#ee(8);
    }
    get vertical() {
        return this.#ee(9);
    }
    #te(e1) {
        return assert$1(e1 < FontInfo.numbers.length, "Invalid number index"), this.#W.getFloat64(FontInfo.#K + 8 * e1);
    }
    get ascent() {
        return this.#te(0);
    }
    get defaultWidth() {
        return this.#te(1);
    }
    get descent() {
        return this.#te(2);
    }
    get bbox() {
        let e1 = FontInfo.#Y;
        if (0 === this.#W.getUint8(e1)) return;
        e1 += 1;
        const t = [];
        for(let i = 0; i < 4; i++)t.push(this.#W.getInt16(e1, !0)), e1 += 2;
        return t;
    }
    get fontMatrix() {
        let e1 = FontInfo.#J;
        if (0 === this.#W.getUint8(e1)) return;
        e1 += 1;
        const t = [];
        for(let i = 0; i < 6; i++)t.push(this.#W.getFloat64(e1, !0)), e1 += 8;
        return t;
    }
    get defaultVMetrics() {
        let e1 = FontInfo.#Z;
        if (0 === this.#W.getUint8(e1)) return;
        e1 += 1;
        const t = [];
        for(let i = 0; i < 3; i++)t.push(this.#W.getInt16(e1, !0)), e1 += 2;
        return t;
    }
    #V(e1) {
        assert$1(e1 < FontInfo.strings.length, "Invalid string index");
        let t = FontInfo.#Q + 4;
        for(let i = 0; i < e1; i++)t += this.#W.getUint32(t) + 4;
        const i = this.#W.getUint32(t), n = new Uint8Array(i);
        return n.set(new Uint8Array(this.#R, t + 4, i)), this.#G.decode(n);
    }
    get fallbackName() {
        return this.#V(0);
    }
    get loadedName() {
        return this.#V(1);
    }
    get mimetype() {
        return this.#V(2);
    }
    get name() {
        return this.#V(3);
    }
    get data() {
        let e1 = FontInfo.#Q;
        e1 += 4 + this.#W.getUint32(e1);
        e1 += 4 + this.#W.getUint32(e1);
        e1 += 4 + this.#W.getUint32(e1);
        const t = this.#W.getUint32(e1);
        if (0 !== t) return new Uint8Array(this.#R, e1 + 4, t);
    }
    clearData() {
        let e1 = FontInfo.#Q;
        e1 += 4 + this.#W.getUint32(e1);
        e1 += 4 + this.#W.getUint32(e1);
        e1 += 4 + this.#W.getUint32(e1);
        const t = this.#W.getUint32(e1);
        new Uint8Array(this.#R, e1 + 4, t).fill(0), this.#W.setUint32(e1, 0);
    }
    get cssFontInfo() {
        let e1 = FontInfo.#Q;
        e1 += 4 + this.#W.getUint32(e1);
        e1 += 4 + this.#W.getUint32(e1);
        const t = this.#W.getUint32(e1);
        if (0 === t) return null;
        const i = new Uint8Array(t);
        return i.set(new Uint8Array(this.#R, e1 + 4, t)), new cs(i.buffer);
    }
    get systemFontInfo() {
        let e1 = FontInfo.#Q;
        e1 += 4 + this.#W.getUint32(e1);
        const t = this.#W.getUint32(e1);
        if (0 === t) return null;
        const i = new Uint8Array(t);
        return i.set(new Uint8Array(this.#R, e1 + 4, t)), new hs(i.buffer);
    }
    static write(e1) {
        const t = e1.systemFontInfo ? hs.write(e1.systemFontInfo) : null, i = e1.cssFontInfo ? cs.write(e1.cssFontInfo) : null, n = new TextEncoder, a = {};
        let s = 0;
        for (const t of FontInfo.strings)a[t] = n.encode(e1[t]), s += 4 + a[t].length;
        const r = FontInfo.#Q + 4 + s + 4 + (t ? t.byteLength : 0) + 4 + (i ? i.byteLength : 0) + 4 + (e1.data ? e1.data.length : 0), o = new ArrayBuffer(r), l = new Uint8Array(o), c = new DataView(o);
        let h = 0;
        const d = FontInfo.bools.length;
        let u = 0, g = 0;
        for(let t = 0; t < d; t++){
            const i = e1[FontInfo.bools[t]];
            u |= (void 0 === i ? 0 : i ? 2 : 1) << g, g += 2, 8 !== g && t !== d - 1 || (c.setUint8(h++, u), u = 0, g = 0);
        }
        assert$1(h === FontInfo.#K, "FontInfo.write: Boolean properties offset mismatch");
        for (const t of FontInfo.numbers)c.setFloat64(h, e1[t]), h += 8;
        if (assert$1(h === FontInfo.#Y, "FontInfo.write: Number properties offset mismatch"), e1.bbox) {
            c.setUint8(h++, 4);
            for (const t of e1.bbox)c.setInt16(h, t, !0), h += 2;
        } else c.setUint8(h++, 0), h += 8;
        if (assert$1(h === FontInfo.#J, "FontInfo.write: BBox properties offset mismatch"), e1.fontMatrix) {
            c.setUint8(h++, 6);
            for (const t of e1.fontMatrix)c.setFloat64(h, t, !0), h += 8;
        } else c.setUint8(h++, 0), h += 48;
        if (assert$1(h === FontInfo.#Z, "FontInfo.write: FontMatrix properties offset mismatch"), e1.defaultVMetrics) {
            c.setUint8(h++, 1);
            for (const t of e1.defaultVMetrics)c.setInt16(h, t, !0), h += 2;
        } else c.setUint8(h++, 0), h += 6;
        assert$1(h === FontInfo.#Q, "FontInfo.write: DefaultVMetrics properties offset mismatch"), c.setUint32(FontInfo.#Q, 0), h += 4;
        for (const e1 of FontInfo.strings){
            const t = a[e1], i = t.length;
            c.setUint32(h, i), l.set(t, h + 4), h += 4 + i;
        }
        if (c.setUint32(FontInfo.#Q, h - FontInfo.#Q - 4), t) {
            const e1 = t.byteLength;
            c.setUint32(h, e1), assert$1(h + 4 + e1 <= o.byteLength, "FontInfo.write: Buffer overflow at systemFontInfo"), l.set(new Uint8Array(t), h + 4), h += 4 + e1;
        } else c.setUint32(h, 0), h += 4;
        if (i) {
            const e1 = i.byteLength;
            c.setUint32(h, e1), assert$1(h + 4 + e1 <= o.byteLength, "FontInfo.write: Buffer overflow at cssFontInfo"), l.set(new Uint8Array(i), h + 4), h += 4 + e1;
        } else c.setUint32(h, 0), h += 4;
        return void 0 === e1.data ? (c.setUint32(h, 0), h += 4) : (c.setUint32(h, e1.data.length), l.set(e1.data, h + 4), h += 4 + e1.data.length), assert$1(h <= o.byteLength, "FontInfo.write: Buffer overflow"), o.transferToFixedLength(h);
    }
};
const us = {
    style: "normal",
    weight: "normal"
}, gs = {
    style: "normal",
    weight: "bold"
}, fs = {
    style: "italic",
    weight: "normal"
}, ps = {
    style: "italic",
    weight: "bold"
}, ms = new Map([
    [
        "Times-Roman",
        {
            local: [
                "Times New Roman",
                "Times-Roman",
                "Times",
                "Liberation Serif",
                "Nimbus Roman",
                "Nimbus Roman L",
                "Tinos",
                "Thorndale",
                "TeX Gyre Termes",
                "FreeSerif",
                "Linux Libertine O",
                "Libertinus Serif",
                "DejaVu Serif",
                "Bitstream Vera Serif",
                "Ubuntu"
            ],
            style: us,
            ultimate: "serif"
        }
    ],
    [
        "Times-Bold",
        {
            alias: "Times-Roman",
            style: gs,
            ultimate: "serif"
        }
    ],
    [
        "Times-Italic",
        {
            alias: "Times-Roman",
            style: fs,
            ultimate: "serif"
        }
    ],
    [
        "Times-BoldItalic",
        {
            alias: "Times-Roman",
            style: ps,
            ultimate: "serif"
        }
    ],
    [
        "Helvetica",
        {
            local: [
                "Helvetica",
                "Helvetica Neue",
                "Arial",
                "Arial Nova",
                "Liberation Sans",
                "Arimo",
                "Nimbus Sans",
                "Nimbus Sans L",
                "A030",
                "TeX Gyre Heros",
                "FreeSans",
                "DejaVu Sans",
                "Albany",
                "Bitstream Vera Sans",
                "Arial Unicode MS",
                "Microsoft Sans Serif",
                "Apple Symbols",
                "Cantarell"
            ],
            path: "LiberationSans-Regular.ttf",
            style: us,
            ultimate: "sans-serif"
        }
    ],
    [
        "Helvetica-Bold",
        {
            alias: "Helvetica",
            path: "LiberationSans-Bold.ttf",
            style: gs,
            ultimate: "sans-serif"
        }
    ],
    [
        "Helvetica-Oblique",
        {
            alias: "Helvetica",
            path: "LiberationSans-Italic.ttf",
            style: fs,
            ultimate: "sans-serif"
        }
    ],
    [
        "Helvetica-BoldOblique",
        {
            alias: "Helvetica",
            path: "LiberationSans-BoldItalic.ttf",
            style: ps,
            ultimate: "sans-serif"
        }
    ],
    [
        "Courier",
        {
            local: [
                "Courier",
                "Courier New",
                "Liberation Mono",
                "Nimbus Mono",
                "Nimbus Mono L",
                "Cousine",
                "Cumberland",
                "TeX Gyre Cursor",
                "FreeMono",
                "Linux Libertine Mono O",
                "Libertinus Mono"
            ],
            style: us,
            ultimate: "monospace"
        }
    ],
    [
        "Courier-Bold",
        {
            alias: "Courier",
            style: gs,
            ultimate: "monospace"
        }
    ],
    [
        "Courier-Oblique",
        {
            alias: "Courier",
            style: fs,
            ultimate: "monospace"
        }
    ],
    [
        "Courier-BoldOblique",
        {
            alias: "Courier",
            style: ps,
            ultimate: "monospace"
        }
    ],
    [
        "ArialBlack",
        {
            local: [
                "Arial Black"
            ],
            style: {
                style: "normal",
                weight: "900"
            },
            fallback: "Helvetica-Bold"
        }
    ],
    [
        "ArialBlack-Bold",
        {
            alias: "ArialBlack"
        }
    ],
    [
        "ArialBlack-Italic",
        {
            alias: "ArialBlack",
            style: {
                style: "italic",
                weight: "900"
            },
            fallback: "Helvetica-BoldOblique"
        }
    ],
    [
        "ArialBlack-BoldItalic",
        {
            alias: "ArialBlack-Italic"
        }
    ],
    [
        "ArialNarrow",
        {
            local: [
                "Arial Narrow",
                "Liberation Sans Narrow",
                "Helvetica Condensed",
                "Nimbus Sans Narrow",
                "TeX Gyre Heros Cn"
            ],
            style: us,
            fallback: "Helvetica"
        }
    ],
    [
        "ArialNarrow-Bold",
        {
            alias: "ArialNarrow",
            style: gs,
            fallback: "Helvetica-Bold"
        }
    ],
    [
        "ArialNarrow-Italic",
        {
            alias: "ArialNarrow",
            style: fs,
            fallback: "Helvetica-Oblique"
        }
    ],
    [
        "ArialNarrow-BoldItalic",
        {
            alias: "ArialNarrow",
            style: ps,
            fallback: "Helvetica-BoldOblique"
        }
    ],
    [
        "Calibri",
        {
            local: [
                "Calibri",
                "Carlito"
            ],
            style: us,
            fallback: "Helvetica"
        }
    ],
    [
        "Calibri-Bold",
        {
            alias: "Calibri",
            style: gs,
            fallback: "Helvetica-Bold"
        }
    ],
    [
        "Calibri-Italic",
        {
            alias: "Calibri",
            style: fs,
            fallback: "Helvetica-Oblique"
        }
    ],
    [
        "Calibri-BoldItalic",
        {
            alias: "Calibri",
            style: ps,
            fallback: "Helvetica-BoldOblique"
        }
    ],
    [
        "Wingdings",
        {
            local: [
                "Wingdings",
                "URW Dingbats"
            ],
            style: us
        }
    ],
    [
        "Wingdings-Regular",
        {
            alias: "Wingdings"
        }
    ],
    [
        "Wingdings-Bold",
        {
            alias: "Wingdings"
        }
    ]
]), bs = new Map([
    [
        "Arial-Black",
        "ArialBlack"
    ]
]);
function getFamilyName(e1) {
    const t = new Set([
        "thin",
        "extralight",
        "ultralight",
        "demilight",
        "semilight",
        "light",
        "book",
        "regular",
        "normal",
        "medium",
        "demibold",
        "semibold",
        "bold",
        "extrabold",
        "ultrabold",
        "black",
        "heavy",
        "extrablack",
        "ultrablack",
        "roman",
        "italic",
        "oblique",
        "ultracondensed",
        "extracondensed",
        "condensed",
        "semicondensed",
        "normal",
        "semiexpanded",
        "expanded",
        "extraexpanded",
        "ultraexpanded",
        "bolditalic"
    ]);
    return e1.split(/[- ,+]+/g).filter((e1)=>!t.has(e1.toLowerCase())).join(" ");
}
function generateFont({ alias: e1, local: t, path: i, fallback: n, style: a, ultimate: s }, r, o, l = !0, c = !0, h = "") {
    const d = {
        style: null,
        ultimate: null
    };
    if (t) {
        const e1 = h ? ` ${h}` : "";
        for (const i of t)r.push(`local(${i}${e1})`);
    }
    if (e1) {
        const t = ms.get(e1), s = h || function(e1) {
            switch(e1){
                case gs:
                    return "Bold";
                case fs:
                    return "Italic";
                case ps:
                    return "Bold Italic";
                default:
                    if ("bold" === e1?.weight) return "Bold";
                    if ("italic" === e1?.style) return "Italic";
            }
            return "";
        }(a);
        Object.assign(d, generateFont(t, r, o, l && !n, c && !i, s));
    }
    if (a && (d.style = a), s && (d.ultimate = s), l && n) {
        const e1 = ms.get(n), { ultimate: t } = generateFont(e1, r, o, l, c && !i, h);
        d.ultimate ||= t;
    }
    return c && i && o && r.push(`url(${o}${i})`), d;
}
function getFontSubstitution(e1, t, i, n, a, s) {
    if (n.startsWith("InvalidPDFjsFont_")) return null;
    "TrueType" !== s && "Type1" !== s || !/^[A-Z]{6}\+/.test(n) || (n = n.slice(7));
    const r = n = normalizeFontName(n);
    let o = e1.get(r);
    if (o) return o;
    let l = ms.get(n);
    if (!l) {
        for (const [e1, t] of bs)if (n.startsWith(e1)) {
            n = `${t}${n.substring(e1.length)}`, l = ms.get(n);
            break;
        }
    }
    let c = !1;
    l || (l = ms.get(a), c = !0);
    const h = `${t.getDocId()}_s${t.createFontId()}`;
    if (!l) {
        if (!validateFontName(n)) return warn$1(`Cannot substitute the font because of its name: ${n}`), e1.set(r, null), null;
        const t = /bold/gi.test(n), i = /oblique|italic/gi.test(n), a = t && i && ps || t && gs || i && fs || us;
        return o = {
            css: `"${getFamilyName(n)}",${h}`,
            guessFallback: !0,
            loadedName: h,
            baseFontName: n,
            src: `local(${n})`,
            style: a
        }, e1.set(r, o), o;
    }
    const d = [];
    c && validateFontName(n) && d.push(`local(${n})`);
    const { style: u, ultimate: g } = generateFont(l, d, i), f = null === g, p = f ? "" : `,${g}`;
    return o = {
        css: `"${getFamilyName(n)}",${h}${p}`,
        guessFallback: f,
        loadedName: h,
        baseFontName: n,
        src: d.join(","),
        style: u
    }, e1.set(r, o), o;
}
const ys = 3285377520, ws = 4294901760, As = 65535;
let xs = class {
    constructor(e1){
        this.h1 = e1 ? 4294967295 & e1 : ys, this.h2 = e1 ? 4294967295 & e1 : ys;
    }
    update(e1) {
        let t, i;
        if ("string" == typeof e1) {
            t = new Uint8Array(2 * e1.length), i = 0;
            for(let n = 0, a = e1.length; n < a; n++){
                const a = e1.charCodeAt(n);
                a <= 255 ? t[i++] = a : (t[i++] = a >>> 8, t[i++] = 255 & a);
            }
        } else {
            if (!ArrayBuffer.isView(e1)) throw new Error("Invalid data format, must be a string or TypedArray.");
            t = e1.slice(), i = t.byteLength;
        }
        const n = i >> 2, a = i - 4 * n, s = new Uint32Array(t.buffer, 0, n);
        let r = 0, o = 0, l = this.h1, c = this.h2;
        const h = 3432918353, d = 461845907, u = 11601, g = 13715;
        for(let e1 = 0; e1 < n; e1++)1 & e1 ? (r = s[e1], r = r * h & ws | r * u & As, r = r << 15 | r >>> 17, r = r * d & ws | r * g & As, l ^= r, l = l << 13 | l >>> 19, l = 5 * l + 3864292196) : (o = s[e1], o = o * h & ws | o * u & As, o = o << 15 | o >>> 17, o = o * d & ws | o * g & As, c ^= o, c = c << 13 | c >>> 19, c = 5 * c + 3864292196);
        switch(r = 0, a){
            case 3:
                r ^= t[4 * n + 2] << 16;
            case 2:
                r ^= t[4 * n + 1] << 8;
            case 1:
                r ^= t[4 * n], r = r * h & ws | r * u & As, r = r << 15 | r >>> 17, r = r * d & ws | r * g & As, 1 & n ? l ^= r : c ^= r;
        }
        this.h1 = l, this.h2 = c;
    }
    hexdigest() {
        let e1 = this.h1, t = this.h2;
        return e1 ^= t >>> 1, e1 = 3981806797 * e1 & ws | 36045 * e1 & As, t = 4283543511 * t & ws | (2950163797 * (t << 16 | e1 >>> 16) & ws) >>> 16, e1 ^= t >>> 1, e1 = 444984403 * e1 & ws | 60499 * e1 & As, t = 3301882366 * t & ws | (3120437893 * (t << 16 | e1 >>> 16) & ws) >>> 16, e1 ^= t >>> 1, (e1 >>> 0).toString(16).padStart(8, "0") + (t >>> 0).toString(16).padStart(8, "0");
    }
};
function resizeImageMask(e1, t, i, n, a, s) {
    const r = a * s;
    let o;
    o = t <= 8 ? new Uint8Array(r) : t <= 16 ? new Uint16Array(r) : new Uint32Array(r);
    const l = i / a, c = n / s;
    let h, d, u, g, f = 0;
    const p = new Uint16Array(a), m = i;
    for(h = 0; h < a; h++)p[h] = Math.floor(h * l);
    for(h = 0; h < s; h++)for(u = Math.floor(h * c) * m, d = 0; d < a; d++)g = u + p[d], o[f++] = e1[g];
    return o;
}
class PDFImage {
    constructor({ xref: e1, res: t, image: i, isInline: n = !1, smask: a = null, mask: s = null, isMask: r = !1, pdfFunctionFactory: o, globalColorSpaceCache: l, localColorSpaceCache: c }){
        this.image = i;
        const h = i.dict, d = h.get("F", "Filter");
        let u;
        if (d instanceof Name) u = d.name;
        else if (Array.isArray(d)) {
            const t = e1.fetchIfRef(d[0]);
            t instanceof Name && (u = t.name);
        }
        switch(u){
            case "JPXDecode":
                ({ width: i.width, height: i.height, componentsCount: i.numComps, bitsPerComponent: i.bitsPerComponent } = JpxImage.parseImageProperties(i.stream)), i.stream.reset();
                const e2 = ImageResizer.getReducePowerForJPX(i.width, i.height, i.numComps);
                if (this.jpxDecoderOptions = {
                    numComponents: 0,
                    isIndexedColormap: !1,
                    smaskInData: h.has("SMaskInData"),
                    reducePower: e2
                }, e2) {
                    const t = 2 ** e2;
                    i.width = Math.ceil(i.width / t), i.height = Math.ceil(i.height / t);
                }
                break;
            case "JBIG2Decode":
                i.bitsPerComponent = 1, i.numComps = 1;
        }
        let g = h.get("W", "Width"), f = h.get("H", "Height");
        if (Number.isInteger(i.width) && i.width > 0 && Number.isInteger(i.height) && i.height > 0 && (i.width !== g || i.height !== f)) warn$1("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), g = i.width, f = i.height;
        else {
            const e1 = "number" == typeof g && g > 0, t = "number" == typeof f && f > 0;
            if (!e1 || !t) {
                if (!i.fallbackDims) throw new ti(`Invalid image width: ${g} or height: ${f}`);
                warn$1("PDFImage - using the Width/Height of the parent image, for SMask/Mask data."), e1 || (g = i.fallbackDims.width), t || (f = i.fallbackDims.height);
            }
        }
        this.width = g, this.height = f, this.interpolate = h.get("I", "Interpolate"), this.imageMask = h.get("IM", "ImageMask") || !1, this.matte = h.get("Matte") || !1;
        let p = i.bitsPerComponent;
        if (!p && (p = h.get("BPC", "BitsPerComponent"), !p)) {
            if (!this.imageMask) throw new ti(`Bits per component missing in image: ${this.imageMask}`);
            p = 1;
        }
        if (this.bpc = p, !this.imageMask) {
            let a = h.getRaw("CS") || h.getRaw("ColorSpace");
            const s = !!a;
            if (s) this.jpxDecoderOptions?.smaskInData && (a = Name.get("DeviceRGBA"));
            else if (this.jpxDecoderOptions) a = Name.get("DeviceRGBA");
            else switch(i.numComps){
                case 1:
                    a = Name.get("DeviceGray");
                    break;
                case 3:
                    a = Name.get("DeviceRGB");
                    break;
                case 4:
                    a = Name.get("DeviceCMYK");
                    break;
                default:
                    throw new Error(`Images with ${i.numComps} color components not supported.`);
            }
            this.colorSpace = ColorSpaceUtils.parse({
                cs: a,
                xref: e1,
                resources: n ? t : null,
                pdfFunctionFactory: o,
                globalColorSpaceCache: l,
                localColorSpaceCache: c
            }), this.numComps = this.colorSpace.numComps, this.jpxDecoderOptions && (this.jpxDecoderOptions.numComponents = s ? this.numComps : 0, this.jpxDecoderOptions.isIndexedColormap = "Indexed" === this.colorSpace.name);
        }
        if (this.decode = h.getArray("D", "Decode"), this.needsDecode = !1, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, p) || r && !ColorSpace.isDefaultDecode(this.decode, 1))) {
            this.needsDecode = !0;
            const e1 = (1 << p) - 1;
            this.decodeCoefficients = [], this.decodeAddends = [];
            const t = "Indexed" === this.colorSpace?.name;
            for(let i = 0, n = 0; i < this.decode.length; i += 2, ++n){
                const a = this.decode[i], s = this.decode[i + 1];
                this.decodeCoefficients[n] = t ? (s - a) / e1 : s - a, this.decodeAddends[n] = t ? a : e1 * a;
            }
        }
        if (a) a.fallbackDims ??= {
            width: g,
            height: f
        }, this.smask = new PDFImage({
            xref: e1,
            res: t,
            image: a,
            isInline: n,
            pdfFunctionFactory: o,
            globalColorSpaceCache: l,
            localColorSpaceCache: c
        });
        else if (s) if (s instanceof BaseStream) {
            s.dict.get("IM", "ImageMask") ? (s.fallbackDims ??= {
                width: g,
                height: f
            }, this.mask = new PDFImage({
                xref: e1,
                res: t,
                image: s,
                isInline: n,
                isMask: !0,
                pdfFunctionFactory: o,
                globalColorSpaceCache: l,
                localColorSpaceCache: c
            })) : warn$1("Ignoring /Mask in image without /ImageMask.");
        } else this.mask = s;
    }
    static async buildImage({ xref: e1, res: t, image: i, isInline: n = !1, pdfFunctionFactory: a, globalColorSpaceCache: s, localColorSpaceCache: r }) {
        const o = i;
        let l = null, c = null;
        const h = i.dict.get("SMask"), d = i.dict.get("Mask");
        return h ? h instanceof BaseStream ? l = h : warn$1("Unsupported /SMask format.") : d && (d instanceof BaseStream || Array.isArray(d) ? c = d : warn$1("Unsupported /Mask format.")), new PDFImage({
            xref: e1,
            res: t,
            image: o,
            isInline: n,
            smask: l,
            mask: c,
            pdfFunctionFactory: a,
            globalColorSpaceCache: s,
            localColorSpaceCache: r
        });
    }
    static async createMask({ image: e1, isOffscreenCanvasSupported: t = !1 }) {
        const { dict: i } = e1, n = i.get("W", "Width"), a = i.get("H", "Height"), s = i.get("I", "Interpolate"), r = i.getArray("D", "Decode"), o = r?.[0] > 0, l = (n + 7 >> 3) * a, c = e1.getBytes(l), h = 1 === n && 1 === a && o === (0 === c.length || !!(128 & c[0]));
        if (h) return {
            isSingleOpaquePixel: h
        };
        if (t) {
            if (ImageResizer.needsToBeResized(n, a)) {
                const e1 = new Uint8ClampedArray(n * a * 4);
                return convertBlackAndWhiteToRGBA$1({
                    src: c,
                    dest: e1,
                    width: n,
                    height: a,
                    nonBlackColor: 0,
                    inverseDecode: o
                }), ImageResizer.createImage({
                    kind: k,
                    data: e1,
                    width: n,
                    height: a,
                    interpolate: s
                });
            }
            const e1 = new OffscreenCanvas(n, a), t = e1.getContext("2d"), i = t.createImageData(n, a);
            convertBlackAndWhiteToRGBA$1({
                src: c,
                dest: i.data,
                width: n,
                height: a,
                nonBlackColor: 0,
                inverseDecode: o
            }), t.putImageData(i, 0, 0);
            return {
                data: null,
                width: n,
                height: a,
                interpolate: s,
                bitmap: e1.transferToImageBitmap()
            };
        }
        const d = c.byteLength;
        let u;
        if (e1 instanceof DecodeStream && (!o || l === d) ? u = c : o ? (u = new Uint8Array(l), u.set(c), u.fill(255, d)) : u = new Uint8Array(c), o) for(let e1 = 0; e1 < d; e1++)u[e1] ^= 255;
        return {
            data: u,
            width: n,
            height: a,
            interpolate: s
        };
    }
    get drawWidth() {
        return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
    }
    get drawHeight() {
        return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);
    }
    decodeBuffer(e1) {
        const t = this.bpc, i = this.numComps, n = this.decodeAddends, a = this.decodeCoefficients, s = (1 << t) - 1;
        let r, o;
        if (1 === t) {
            for(r = 0, o = e1.length; r < o; r++)e1[r] = +!e1[r];
            return;
        }
        let l = 0;
        for(r = 0, o = this.width * this.height; r < o; r++)for(let t = 0; t < i; t++)e1[l] = MathClamp$1(n[t] + e1[l] * a[t], 0, s), l++;
    }
    getComponents(e1) {
        const t = this.bpc;
        if (8 === t) return e1;
        const i = this.width, n = this.height, a = this.numComps, s = i * n * a;
        let r, o = 0;
        r = t <= 8 ? new Uint8Array(s) : t <= 16 ? new Uint16Array(s) : new Uint32Array(s);
        const l = i * a, c = (1 << t) - 1;
        let h, d, u = 0;
        if (1 === t) {
            let t, i, a;
            for(let s = 0; s < n; s++){
                for(i = u + (-8 & l), a = u + l; u < i;)d = e1[o++], r[u] = d >> 7 & 1, r[u + 1] = d >> 6 & 1, r[u + 2] = d >> 5 & 1, r[u + 3] = d >> 4 & 1, r[u + 4] = d >> 3 & 1, r[u + 5] = d >> 2 & 1, r[u + 6] = d >> 1 & 1, r[u + 7] = 1 & d, u += 8;
                if (u < a) for(d = e1[o++], t = 128; u < a;)r[u++] = +!!(d & t), t >>= 1;
            }
        } else {
            let i = 0;
            for(d = 0, u = 0, h = s; u < h; ++u){
                for(u % l === 0 && (d = 0, i = 0); i < t;)d = d << 8 | e1[o++], i += 8;
                const n = i - t;
                let a = d >> n;
                a < 0 ? a = 0 : a > c && (a = c), r[u] = a, d &= (1 << n) - 1, i = n;
            }
        }
        return r;
    }
    async fillOpacity(e1, t, i, n, a) {
        const s = this.smask, r = this.mask;
        let o, l, c, h, d, u;
        if (s) l = s.width, c = s.height, o = new Uint8ClampedArray(l * c), await s.fillGrayBuffer(o), l === t && c === i || (o = resizeImageMask(o, s.bpc, l, c, t, i));
        else if (r) if (r instanceof PDFImage) {
            for(l = r.width, c = r.height, o = new Uint8ClampedArray(l * c), r.numComps = 1, await r.fillGrayBuffer(o), h = 0, d = l * c; h < d; ++h)o[h] = 255 - o[h];
            l === t && c === i || (o = resizeImageMask(o, r.bpc, l, c, t, i));
        } else {
            if (!Array.isArray(r)) throw new ti("Unknown mask format.");
            {
                o = new Uint8ClampedArray(t * i);
                const e1 = this.numComps;
                for(h = 0, d = t * i; h < d; ++h){
                    let t = 0;
                    const i = h * e1;
                    for(u = 0; u < e1; ++u){
                        const e1 = a[i + u], n = 2 * u;
                        if (e1 < r[n] || e1 > r[n + 1]) {
                            t = 255;
                            break;
                        }
                    }
                    o[h] = t;
                }
            }
        }
        if (o) for(h = 0, u = 3, d = t * n; h < d; ++h, u += 4)e1[u] = o[h];
        else for(h = 0, u = 3, d = t * n; h < d; ++h, u += 4)e1[u] = 255;
    }
    undoPreblend(e1, t, i) {
        const n = this.smask?.matte;
        if (!n) return;
        const a = this.colorSpace.getRgb(n, 0), s = a[0], r = a[1], o = a[2], l = t * i * 4;
        for(let t = 0; t < l; t += 4){
            const i = e1[t + 3];
            if (0 === i) {
                e1[t] = 255, e1[t + 1] = 255, e1[t + 2] = 255;
                continue;
            }
            const n = 255 / i;
            e1[t] = (e1[t] - s) * n + s, e1[t + 1] = (e1[t + 1] - r) * n + r, e1[t + 2] = (e1[t + 2] - o) * n + o;
        }
    }
    async createImageData(e1 = !1, t = !1) {
        const i = this.drawWidth, n = this.drawHeight, a = {
            width: i,
            height: n,
            interpolate: this.interpolate,
            kind: 0,
            data: null
        }, s = this.numComps, r = this.width, o = this.height, l = this.bpc, c = r * s * l + 7 >> 3, h = t && ImageResizer.needsToBeResized(i, n);
        if (!this.smask && !this.mask && "DeviceRGBA" === this.colorSpace.name) {
            a.kind = k;
            const e1 = a.data = await this.getImageBytes(o * r * 4, {});
            return t ? h ? ImageResizer.createImage(a, !1) : this.createBitmap(k, i, n, e1) : a;
        }
        if (!e1) {
            let e1;
            if ("DeviceGray" === this.colorSpace.name && 1 === l ? e1 = v : "DeviceRGB" !== this.colorSpace.name || 8 !== l || this.needsDecode || (e1 = C), e1 && !this.smask && !this.mask && i === r && n === o) {
                const s = await this.#ie(r, o);
                if (s) return s;
                const l = await this.getImageBytes(o * c, {});
                if (t) return h ? ImageResizer.createImage({
                    data: l,
                    kind: e1,
                    width: i,
                    height: n,
                    interpolate: this.interpolate
                }, this.needsDecode) : this.createBitmap(e1, r, o, l);
                if (a.kind = e1, a.data = l, this.needsDecode) {
                    assert$1(e1 === v, "PDFImage.createImageData: The image must be grayscale.");
                    const t = a.data;
                    for(let e1 = 0, i = t.length; e1 < i; e1++)t[e1] ^= 255;
                }
                return a;
            }
            if (this.image instanceof JpegStream && !this.smask && !this.mask && !this.needsDecode) {
                let e1 = o * c;
                if (t && !h) {
                    let t = !1;
                    switch(this.colorSpace.name){
                        case "DeviceGray":
                            e1 *= 4, t = !0;
                            break;
                        case "DeviceRGB":
                            e1 = e1 / 3 * 4, t = !0;
                            break;
                        case "DeviceCMYK":
                            t = !0;
                    }
                    if (t) {
                        const t = await this.#ie(i, n);
                        if (t) return t;
                        const a = await this.getImageBytes(e1, {
                            drawWidth: i,
                            drawHeight: n,
                            forceRGBA: !0
                        });
                        return this.createBitmap(k, i, n, a);
                    }
                } else switch(this.colorSpace.name){
                    case "DeviceGray":
                        e1 *= 3;
                    case "DeviceRGB":
                    case "DeviceCMYK":
                        return a.kind = C, a.data = await this.getImageBytes(e1, {
                            drawWidth: i,
                            drawHeight: n,
                            forceRGB: !0
                        }), h ? ImageResizer.createImage(a) : a;
                }
            }
        }
        const d = await this.getImageBytes(o * c, {
            internal: !0
        }), u = 0 | d.length / c * n / o, g = this.getComponents(d);
        let f, p, m, b, y, w;
        if (t && !h && (m = new OffscreenCanvas(i, n), b = m.getContext("2d"), y = b.createImageData(i, n), w = y.data), a.kind = k, e1 || this.smask || this.mask) t && !h || (w = new Uint8ClampedArray(i * n * 4)), f = 1, p = !0, await this.fillOpacity(w, i, n, u, g);
        else {
            if (!t || h) a.kind = C, w = new Uint8ClampedArray(i * n * 3), f = 0;
            else {
                new Uint32Array(w.buffer).fill(FeatureTest.isLittleEndian ? 4278190080 : 255), f = 1;
            }
            p = !1;
        }
        if (this.needsDecode && this.decodeBuffer(g), this.colorSpace.fillRgb(w, r, o, i, n, u, l, g, f), p && this.undoPreblend(w, i, u), t && !h) {
            b.putImageData(y, 0, 0);
            return {
                data: null,
                width: i,
                height: n,
                bitmap: m.transferToImageBitmap(),
                interpolate: this.interpolate
            };
        }
        return a.data = w, h ? ImageResizer.createImage(a) : a;
    }
    async fillGrayBuffer(e1) {
        const t = this.numComps;
        if (1 !== t) throw new ti(`Reading gray scale from a color image: ${t}`);
        const i = this.width, n = this.height, a = this.bpc, s = i * t * a + 7 >> 3, r = await this.getImageBytes(n * s, {
            internal: !0
        }), o = this.getComponents(r);
        let l, c;
        if (1 === a) {
            if (c = i * n, this.needsDecode) for(l = 0; l < c; ++l)e1[l] = o[l] - 1 & 255;
            else for(l = 0; l < c; ++l)e1[l] = 255 & -o[l];
            return;
        }
        this.needsDecode && this.decodeBuffer(o), c = i * n;
        const h = 255 / ((1 << a) - 1);
        for(l = 0; l < c; ++l)e1[l] = h * o[l];
    }
    createBitmap(e1, t, i, n) {
        const a = new OffscreenCanvas(t, i), s = a.getContext("2d");
        let r;
        e1 === k ? r = new ImageData(n, t, i) : (r = s.createImageData(t, i), convertToRGBA({
            kind: e1,
            src: n,
            dest: new Uint32Array(r.data.buffer),
            width: t,
            height: i,
            inverseDecode: this.needsDecode
        })), s.putImageData(r, 0, 0);
        return {
            data: null,
            width: t,
            height: i,
            bitmap: a.transferToImageBitmap(),
            interpolate: this.interpolate
        };
    }
    async #ie(e1, t) {
        const i = await this.image.getTransferableImage();
        return i ? {
            data: null,
            width: e1,
            height: t,
            bitmap: i,
            interpolate: this.interpolate
        } : null;
    }
    async getImageBytes(e1, { drawWidth: t, drawHeight: i, forceRGBA: n = !1, forceRGB: a = !1, internal: s = !1 }) {
        this.image.reset(), this.image.drawWidth = t || this.width, this.image.drawHeight = i || this.height, this.image.forceRGBA = !!n, this.image.forceRGB = !!a;
        const r = await this.image.getImageData(e1, this.jpxDecoderOptions);
        return s || this.image instanceof DecodeStream ? r : (assert$1(r instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(r));
    }
}
const Ss = Object.freeze({
    maxImageSize: -1,
    disableFontFace: !1,
    ignoreErrors: !1,
    isEvalSupported: !0,
    isOffscreenCanvasSupported: !1,
    isImageDecoderSupported: !1,
    canvasMaxAreaInBytes: -1,
    fontExtraProperties: !1,
    useSystemFonts: !0,
    useWasm: !0,
    useWorkerFetch: !0,
    cMapUrl: null,
    iccUrl: null,
    standardFontDataUrl: null,
    wasmUrl: null
}), vs = 1, Cs = 2, ks = Promise.resolve();
function normalizeBlendMode(e1, t = !1) {
    if (Array.isArray(e1)) {
        for (const t of e1){
            const e1 = normalizeBlendMode(t, !0);
            if (e1) return e1;
        }
        return warn$1(`Unsupported blend mode Array: ${e1}`), "source-over";
    }
    if (!(e1 instanceof Name)) return t ? null : "source-over";
    switch(e1.name){
        case "Normal":
        case "Compatible":
            return "source-over";
        case "Multiply":
            return "multiply";
        case "Screen":
            return "screen";
        case "Overlay":
            return "overlay";
        case "Darken":
            return "darken";
        case "Lighten":
            return "lighten";
        case "ColorDodge":
            return "color-dodge";
        case "ColorBurn":
            return "color-burn";
        case "HardLight":
            return "hard-light";
        case "SoftLight":
            return "soft-light";
        case "Difference":
            return "difference";
        case "Exclusion":
            return "exclusion";
        case "Hue":
            return "hue";
        case "Saturation":
            return "saturation";
        case "Color":
            return "color";
        case "Luminosity":
            return "luminosity";
    }
    return t ? null : (warn$1(`Unsupported blend mode: ${e1.name}`), "source-over");
}
function addCachedImageOps(e1, { objId: t, fn: i, args: n, optionalContent: a, hasMask: s }) {
    t && e1.addDependency(t), e1.addImageOps(i, n, a, s), i === Dt && n[0]?.count > 0 && n[0].count++;
}
class TimeSlotManager {
    static TIME_SLOT_DURATION_MS = 20;
    static CHECK_TIME_EVERY = 100;
    constructor(){
        this.reset();
    }
    check() {
        return !(++this.checked < TimeSlotManager.CHECK_TIME_EVERY) && (this.checked = 0, this.endTime <= Date.now());
    }
    reset() {
        this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS, this.checked = 0;
    }
}
class PartialEvaluator {
    constructor({ xref: e1, handler: t, pageIndex: i, idFactory: n, fontCache: a, builtInCMapCache: s, standardFontDataCache: r, globalColorSpaceCache: o, globalImageCache: l, systemFontCache: c, options: h = null }){
        this.xref = e1, this.handler = t, this.pageIndex = i, this.idFactory = n, this.fontCache = a, this.builtInCMapCache = s, this.standardFontDataCache = r, this.globalColorSpaceCache = o, this.globalImageCache = l, this.systemFontCache = c, this.options = h || Ss, this.type3FontRefs = null, this._regionalImageCache = new RegionalImageCache, this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
    }
    get _pdfFunctionFactory() {
        return shadow$1(this, "_pdfFunctionFactory", new PDFFunctionFactory({
            xref: this.xref,
            isEvalSupported: this.options.isEvalSupported
        }));
    }
    get parsingType3Font() {
        return !!this.type3FontRefs;
    }
    clone(e1 = null) {
        const t = Object.create(this);
        return t.options = Object.assign(Object.create(null), this.options, e1), t;
    }
    hasBlendModes(e1, t) {
        if (!(e1 instanceof Dict)) return !1;
        if (e1.objId && t.has(e1.objId)) return !1;
        const i = new RefSet(t);
        e1.objId && i.put(e1.objId);
        const n = [
            e1
        ], a = this.xref;
        for(; n.length;){
            const e1 = n.shift(), t = e1.get("ExtGState");
            if (t instanceof Dict) for (let e1 of t.getRawValues()){
                if (e1 instanceof Ref) {
                    if (i.has(e1)) continue;
                    try {
                        e1 = a.fetch(e1);
                    } catch (t) {
                        i.put(e1), info$1(`hasBlendModes - ignoring ExtGState: "${t}".`);
                        continue;
                    }
                }
                if (!(e1 instanceof Dict)) continue;
                e1.objId && i.put(e1.objId);
                const t = e1.get("BM");
                if (t instanceof Name) {
                    if ("Normal" !== t.name) return !0;
                } else if (void 0 !== t && Array.isArray(t)) {
                    for (const e1 of t)if (e1 instanceof Name && "Normal" !== e1.name) return !0;
                }
            }
            const s = e1.get("XObject");
            if (s instanceof Dict) for (let e1 of s.getRawValues()){
                if (e1 instanceof Ref) {
                    if (i.has(e1)) continue;
                    try {
                        e1 = a.fetch(e1);
                    } catch (t) {
                        i.put(e1), info$1(`hasBlendModes - ignoring XObject: "${t}".`);
                        continue;
                    }
                }
                if (!(e1 instanceof BaseStream)) continue;
                e1.dict.objId && i.put(e1.dict.objId);
                const t = e1.dict.get("Resources");
                t instanceof Dict && (t.objId && i.has(t.objId) || (n.push(t), t.objId && i.put(t.objId)));
            }
        }
        for (const e1 of i)t.put(e1);
        return !1;
    }
    async fetchBuiltInCMap(e1) {
        const t = this.builtInCMapCache.get(e1);
        if (t) return t;
        let i;
        return i = this.options.useWorkerFetch ? {
            cMapData: await fetchBinaryData(`${this.options.cMapUrl}${e1}.bcmap`),
            isCompressed: !0
        } : await this.handler.sendWithPromise("FetchBinaryData", {
            type: "cMapReaderFactory",
            name: e1
        }), this.builtInCMapCache.set(e1, i), i;
    }
    async fetchStandardFontData(e1) {
        const t = this.standardFontDataCache.get(e1);
        if (t) return new Stream(t);
        if (this.options.useSystemFonts && "Symbol" !== e1 && "ZapfDingbats" !== e1) return null;
        const i = jn()[e1];
        let n;
        try {
            n = this.options.useWorkerFetch ? await fetchBinaryData(`${this.options.standardFontDataUrl}${i}`) : await this.handler.sendWithPromise("FetchBinaryData", {
                type: "standardFontDataFactory",
                filename: i
            });
        } catch (e1) {
            return warn$1(e1), null;
        }
        return this.standardFontDataCache.set(e1, n), new Stream(n);
    }
    async buildFormXObject(e1, t, i, n, a, s, r, o) {
        const { dict: l } = t, c = lookupMatrix(l.getArray("Matrix"), null), h = lookupNormalRect(l.getArray("BBox"), null);
        let d, u;
        l.has("OC") && (d = await this.parseMarkedContentProps(l.get("OC"), e1)), void 0 !== d && n.addOp(xt, [
            "OC",
            d
        ]);
        const g = l.get("Group");
        if (g) {
            u = {
                matrix: c,
                bbox: h,
                smask: i,
                isolated: !1,
                knockout: !1
            };
            let t = null;
            if (isName(g.get("S"), "Transparency") && (u.isolated = g.get("I") || !1, u.knockout = g.get("K") || !1, g.has("CS"))) {
                const i = this._getColorSpace(g.getRaw("CS"), e1, r);
                t = i instanceof ColorSpace ? i : await this._handleColorSpace(i);
            }
            i?.backdrop && (t ||= ColorSpaceUtils.rgb, i.backdrop = t.getRgbHex(i.backdrop, 0)), n.addOp(Ft, [
                u
            ]);
        }
        const f = [
            c && new Float32Array(c),
            !g && h && new Float32Array(h) || null
        ];
        n.addOp(kt, f);
        const p = l.get("Resources");
        await this.getOperatorList({
            stream: t,
            task: a,
            resources: p instanceof Dict ? p : e1,
            operatorList: n,
            initialState: s,
            prevRefs: o
        }), n.addOp(Tt, []), g && n.addOp(It, [
            u
        ]), void 0 !== d && n.addOp(St, []);
    }
    _sendImgData(e1, t, i = !1) {
        const n = t ? [
            t.bitmap || t.data.buffer
        ] : null;
        return this.parsingType3Font || i ? this.handler.send("commonobj", [
            e1,
            "Image",
            t
        ], n) : this.handler.send("obj", [
            e1,
            this.pageIndex,
            "Image",
            t
        ], n);
    }
    async buildPaintImageXObject({ resources: e1, image: t, isInline: i = !1, operatorList: n, cacheKey: a, localImageCache: s, localColorSpaceCache: r }) {
        const { maxImageSize: o, ignoreErrors: l, isOffscreenCanvasSupported: c } = this.options, { dict: h } = t, d = h.objId, u = h.get("W", "Width"), g = h.get("H", "Height");
        if (!u || "number" != typeof u || !g || "number" != typeof g) return void warn$1("Image dimensions are missing, or not numbers.");
        if (-1 !== o && u * g > o) {
            const e1 = "Image exceeded maximum allowed size and was removed.";
            if (!l) throw new Error(e1);
            return void warn$1(e1);
        }
        let f;
        h.has("OC") && (f = await this.parseMarkedContentProps(h.get("OC"), e1));
        let p, m, b;
        if (h.get("IM", "ImageMask") || !1) {
            if (p = await PDFImage.createMask({
                image: t,
                isOffscreenCanvasSupported: c && !this.parsingType3Font
            }), p.isSingleOpaquePixel) {
                if (m = Lt, b = [], n.addImageOps(m, b, f), a) {
                    const e1 = {
                        fn: m,
                        args: b,
                        optionalContent: f
                    };
                    s.set(a, d, e1), d && this._regionalImageCache.set(null, d, e1);
                }
                return;
            }
            if (this.parsingType3Font) return b = function({ data: e1, width: t, height: i }) {
                if (t > 1e3 || i > 1e3) return null;
                const n = new Uint8Array([
                    0,
                    2,
                    4,
                    0,
                    1,
                    0,
                    5,
                    4,
                    8,
                    10,
                    0,
                    8,
                    0,
                    2,
                    1,
                    0
                ]), a = t + 1, s = new Uint8Array(a * (i + 1));
                let r, o, l;
                const c = t + 7 & -8, h = new Uint8Array(c * i);
                let d = 0;
                for (const t of e1){
                    let e1 = 128;
                    for(; e1 > 0;)h[d++] = t & e1 ? 0 : 255, e1 >>= 1;
                }
                let u = 0;
                for(d = 0, 0 !== h[d] && (s[0] = 1, ++u), o = 1; o < t; o++)h[d] !== h[d + 1] && (s[o] = h[d] ? 2 : 1, ++u), d++;
                for(0 !== h[d] && (s[o] = 2, ++u), r = 1; r < i; r++){
                    d = r * c, l = r * a, h[d - c] !== h[d] && (s[l] = h[d] ? 1 : 8, ++u);
                    let e1 = (h[d] ? 4 : 0) + (h[d - c] ? 8 : 0);
                    for(o = 1; o < t; o++)e1 = (e1 >> 2) + (h[d + 1] ? 4 : 0) + (h[d - c + 1] ? 8 : 0), n[e1] && (s[l + o] = n[e1], ++u), d++;
                    if (h[d - c] !== h[d] && (s[l + o] = h[d] ? 2 : 4, ++u), u > 1e3) return null;
                }
                for(d = c * (i - 1), l = r * a, 0 !== h[d] && (s[l] = 8, ++u), o = 1; o < t; o++)h[d] !== h[d + 1] && (s[l + o] = h[d] ? 4 : 8, ++u), d++;
                if (0 !== h[d] && (s[l + o] = 4, ++u), u > 1e3) return null;
                const g = new Int32Array([
                    0,
                    a,
                    -1,
                    0,
                    -a,
                    0,
                    0,
                    0,
                    1
                ]), f = [], { a: p, b: m, c: b, d: y, e: w, f: x } = (new DOMMatrix).scaleSelf(1 / t, -1 / i).translateSelf(0, -i);
                for(r = 0; u && r <= i; r++){
                    let e1 = r * a;
                    const i = e1 + t;
                    for(; e1 < i && !s[e1];)e1++;
                    if (e1 === i) continue;
                    let n = e1 % a, o = r;
                    f.push(Xt, p * n + b * o + w, m * n + y * o + x);
                    const l = e1;
                    let c = s[e1];
                    do {
                        const t = g[c];
                        do {
                            e1 += t;
                        }while (!s[e1])
                        const i = s[e1];
                        5 !== i && 10 !== i ? (c = i, s[e1] = 0) : (c = i & 51 * c >> 4, s[e1] &= c >> 2 | c << 2), n = e1 % a, o = e1 / a | 0, f.push(qt, p * n + b * o + w, m * n + y * o + x), s[e1] || --u;
                    }while (l !== e1)
                    --r;
                }
                return [
                    Ht,
                    [
                        new Float32Array(f)
                    ],
                    new Float32Array([
                        0,
                        0,
                        t,
                        i
                    ])
                ];
            }(p), b ? void n.addImageOps(Ut, b, f) : (warn$1("Cannot compile Type3 glyph."), void n.addImageOps(Dt, [
                p
            ], f));
            const e1 = `mask_${this.idFactory.createObjId()}`;
            if (n.addDependency(e1), p.dataLen = p.bitmap ? p.width * p.height * 4 : p.data.length, this._sendImgData(e1, p), m = Dt, b = [
                {
                    data: e1,
                    width: p.width,
                    height: p.height,
                    interpolate: p.interpolate,
                    count: 1
                }
            ], n.addImageOps(m, b, f), a) {
                const t = {
                    objId: e1,
                    fn: m,
                    args: b,
                    optionalContent: f
                };
                s.set(a, d, t), d && this._regionalImageCache.set(null, d, t);
            }
            return;
        }
        const y = h.has("SMask") || h.has("Mask");
        if (i && u + g < 200 && !y) {
            try {
                const a = new PDFImage({
                    xref: this.xref,
                    res: e1,
                    image: t,
                    isInline: i,
                    pdfFunctionFactory: this._pdfFunctionFactory,
                    globalColorSpaceCache: this.globalColorSpaceCache,
                    localColorSpaceCache: r
                });
                p = await a.createImageData(!0, !1), n.addImageOps(Pt, [
                    p
                ], f);
            } catch (e1) {
                const t = `Unable to decode inline image: "${e1}".`;
                if (!l) throw new Error(t);
                warn$1(t);
            }
            return;
        }
        let w = `img_${this.idFactory.createObjId()}`, x = !1, S = null;
        if (this.parsingType3Font ? w = `${this.idFactory.getDocId()}_type3_${w}` : a && d && (x = this.globalImageCache.shouldCache(d, this.pageIndex), x && (assert$1(!i, "Cannot cache an inline image globally."), w = `${this.idFactory.getDocId()}_${w}`)), n.addDependency(w), m = _t, b = [
            w,
            u,
            g
        ], n.addImageOps(m, b, f, y), x) {
            if (S = {
                objId: w,
                fn: m,
                args: b,
                optionalContent: f,
                hasMask: y,
                byteSize: 0
            }, this.globalImageCache.hasDecodeFailed(d)) return this.globalImageCache.setData(d, S), void this._sendImgData(w, null, x);
            if (u * g > 25e4 || y) {
                const e1 = await this.handler.sendWithPromise("commonobj", [
                    w,
                    "CopyLocalImage",
                    {
                        imageRef: d
                    }
                ]);
                if (e1) return this.globalImageCache.setData(d, S), void this.globalImageCache.addByteSize(d, e1);
            }
        }
        if (PDFImage.buildImage({
            xref: this.xref,
            res: e1,
            image: t,
            isInline: i,
            pdfFunctionFactory: this._pdfFunctionFactory,
            globalColorSpaceCache: this.globalColorSpaceCache,
            localColorSpaceCache: r
        }).then(async (e1)=>(p = await e1.createImageData(!1, c), p.dataLen = p.bitmap ? p.width * p.height * 4 : p.data.length, p.ref = d, x && this.globalImageCache.addByteSize(d, p.dataLen), this._sendImgData(w, p, x))).catch((e1)=>(warn$1(`Unable to decode image "${w}": "${e1}".`), d && this.globalImageCache.addDecodeFailed(d), this._sendImgData(w, null, x))), a) {
            const e1 = {
                objId: w,
                fn: m,
                args: b,
                optionalContent: f,
                hasMask: y
            };
            s.set(a, d, e1), d && (this._regionalImageCache.set(null, d, e1), x && (assert$1(S, "The global cache-data must be available."), this.globalImageCache.setData(d, S)));
        }
    }
    handleSMask(e1, t, i, n, a, s, r) {
        const o = e1.get("G"), l = {
            subtype: e1.get("S").name,
            backdrop: e1.get("BC")
        }, c = e1.get("TR");
        if (isPDFFunction(c)) {
            const e1 = this._pdfFunctionFactory.create(c), t = new Uint8Array(256), i = new Float32Array(1);
            for(let n = 0; n < 256; n++)i[0] = n / 255, e1(i, 0, i, 0), t[n] = 255 * i[0] | 0;
            l.transferMap = t;
        }
        return this.buildFormXObject(t, o, l, i, n, a.state.clone({
            newPath: !0
        }), s, r);
    }
    handleTransferFunction(e1) {
        let t;
        if (Array.isArray(e1)) t = e1;
        else {
            if (!isPDFFunction(e1)) return null;
            t = [
                e1
            ];
        }
        const i = [];
        let n = 0, a = 0;
        for (const e1 of t){
            const t = this.xref.fetchIfRef(e1);
            if (n++, isName(t, "Identity")) {
                i.push(null);
                continue;
            }
            if (!isPDFFunction(t)) return null;
            const s = this._pdfFunctionFactory.create(t), r = new Uint8Array(256), o = new Float32Array(1);
            for(let e1 = 0; e1 < 256; e1++)o[0] = e1 / 255, s(o, 0, o, 0), r[e1] = 255 * o[0] | 0;
            i.push(r), a++;
        }
        return 1 !== n && 4 !== n || 0 === a ? null : i;
    }
    handleTilingType(e1, t, i, n, a, s, r, o) {
        const l = new OperatorList, c = Dict.merge({
            xref: this.xref,
            dictArray: [
                a.get("Resources"),
                i
            ]
        });
        return this.getOperatorList({
            stream: n,
            task: r,
            resources: c,
            operatorList: l
        }).then(function() {
            const i = l.getIR(), n = getTilingPatternIR(i, a, t);
            s.addDependencies(l.dependencies), s.addOp(e1, n), a.objId && o.set(null, a.objId, {
                operatorListIR: i,
                dict: a
            });
        }).catch((e1)=>{
            if (!(e1 instanceof ii)) {
                if (!this.options.ignoreErrors) throw e1;
                warn$1(`handleTilingType - ignoring pattern: "${e1}".`);
            }
        });
    }
    async handleSetFont(e1, t, i, n, a, s, r = null, o = null) {
        const l = t?.[0] instanceof Name ? t[0].name : null, c = await this.loadFont(l, i, e1, a, r, o);
        return c.font.isType3Font && n.addDependencies(c.type3Dependencies), s.font = c.font, c.send(this.handler), c.loadedName;
    }
    handleText(e1, t) {
        const i = t.font, n = i.charsToGlyphs(e1);
        if (i.data) {
            (!!(t.textRenderingMode & S) || "Pattern" === t.fillColorSpace.name || i.disableFontFace) && PartialEvaluator.buildFontPaths(i, n, this.handler, this.options);
        }
        return n;
    }
    ensureStateFont(e1) {
        if (e1.font) return;
        const t = new ti("Missing setFont (Tf) operator before text rendering operator.");
        if (!this.options.ignoreErrors) throw t;
        warn$1(`ensureStateFont: "${t}".`);
    }
    async setGState({ resources: e1, gState: t, operatorList: i, cacheKey: n, task: a, stateManager: s, localGStateCache: r, localColorSpaceCache: o, seenRefs: l }) {
        const c = t.objId;
        let h = !0;
        const d = [];
        let u = Promise.resolve();
        for (const [n, r] of t)switch(n){
            case "Type":
                break;
            case "LW":
                if ("number" != typeof r) {
                    warn$1(`Invalid LW (line width): ${r}`);
                    break;
                }
                d.push([
                    n,
                    Math.abs(r)
                ]);
                break;
            case "LC":
            case "LJ":
            case "ML":
            case "D":
            case "RI":
            case "FL":
            case "CA":
            case "ca":
                d.push([
                    n,
                    r
                ]);
                break;
            case "Font":
                h = !1, u = u.then(()=>this.handleSetFont(e1, null, r[0], i, a, s.state).then(function(e1) {
                        i.addDependency(e1), d.push([
                            n,
                            [
                                e1,
                                r[1]
                            ]
                        ]);
                    }));
                break;
            case "BM":
                d.push([
                    n,
                    normalizeBlendMode(r)
                ]);
                break;
            case "SMask":
                if (isName(r, "None")) {
                    d.push([
                        n,
                        !1
                    ]);
                    break;
                }
                r instanceof Dict ? (h = !1, u = u.then(()=>this.handleSMask(r, e1, i, a, s, o, l)), d.push([
                    n,
                    !0
                ])) : warn$1("Unsupported SMask type");
                break;
            case "TR":
                const t = this.handleTransferFunction(r);
                d.push([
                    n,
                    t
                ]);
                break;
            case "OP":
            case "op":
            case "OPM":
            case "BG":
            case "BG2":
            case "UCR":
            case "UCR2":
            case "TR2":
            case "HT":
            case "SM":
            case "SA":
            case "AIS":
            case "TK":
                info$1("graphic state operator " + n);
                break;
            default:
                info$1("Unknown graphic state operator " + n);
        }
        await u, d.length > 0 && i.addOp(fe, [
            d
        ]), h && r.set(n, c, d);
    }
    loadFont(e1, t, i, n, a = null, s = null) {
        const errorFont = async ()=>new TranslatedFont({
                loadedName: "g_font_error",
                font: new ErrorFont(`Font "${e1}" is not available.`),
                dict: t
            });
        let r;
        if (t) t instanceof Ref && (r = t);
        else {
            const t = i.get("Font");
            t && (r = t.getRaw(e1));
        }
        if (r) {
            if (this.type3FontRefs?.has(r)) return errorFont();
            if (this.fontCache.has(r)) return this.fontCache.get(r);
            try {
                t = this.xref.fetchIfRef(r);
            } catch (e1) {
                warn$1(`loadFont - lookup failed: "${e1}".`);
            }
        }
        if (!(t instanceof Dict)) {
            if (!this.options.ignoreErrors && !this.parsingType3Font) return warn$1(`Font "${e1}" is not available.`), errorFont();
            warn$1(`Font "${e1}" is not available -- attempting to fallback to a default font.`), t = a || PartialEvaluator.fallbackFontDict;
        }
        if (t.cacheKey && this.fontCache.has(t.cacheKey)) return this.fontCache.get(t.cacheKey);
        const { promise: o, resolve: l } = Promise.withResolvers();
        let c;
        try {
            c = this.preEvaluateFont(t), c.cssFontInfo = s;
        } catch (e1) {
            return warn$1(`loadFont - preEvaluateFont failed: "${e1}".`), errorFont();
        }
        const { descriptor: h, hash: d } = c, u = r instanceof Ref;
        let g;
        if (d && h instanceof Dict) {
            const e1 = h.fontAliases ||= Object.create(null);
            if (e1[d]) {
                const t = e1[d].aliasRef;
                if (u && t && this.fontCache.has(t)) return this.fontCache.putAlias(r, t), this.fontCache.get(r);
            } else e1[d] = {
                fontID: this.idFactory.createFontId()
            };
            u && (e1[d].aliasRef = r), g = e1[d].fontID;
        } else g = this.idFactory.createFontId();
        return assert$1(g?.startsWith("f"), 'The "fontID" must be (correctly) defined.'), u ? this.fontCache.put(r, o) : (t.cacheKey = `cacheKey_${g}`, this.fontCache.put(t.cacheKey, o)), t.loadedName = `${this.idFactory.getDocId()}_${g}`, this.translateFont(c).then(async (e1)=>{
            const a = new TranslatedFont({
                loadedName: t.loadedName,
                font: e1,
                dict: t
            });
            if (e1.isType3Font) try {
                await a.loadType3Data(this, i, n);
            } catch (e1) {
                throw new Error(`Type3 font load error: ${e1}`);
            }
            l(a);
        }).catch((e1)=>{
            warn$1(`loadFont - translateFont failed: "${e1}".`), l(new TranslatedFont({
                loadedName: t.loadedName,
                font: new ErrorFont(e1?.message),
                dict: t
            }));
        }), o;
    }
    buildPath(e1, t, i) {
        const { pathMinMax: n, pathBuffer: a } = i;
        switch(0 | e1){
            case Ce:
                {
                    const e1 = i.currentPointX = t[0], s = i.currentPointY = t[1], r = t[2], o = t[3], l = e1 + r, c = s + o;
                    0 === r || 0 === o ? a.push(Xt, e1, s, qt, l, c, Wt) : a.push(Xt, e1, s, qt, l, s, qt, l, c, qt, e1, c, Wt), ai.rectBoundingBox(e1, s, l, c, n);
                    break;
                }
            case ye:
                {
                    const e1 = i.currentPointX = t[0], s = i.currentPointY = t[1];
                    a.push(Xt, e1, s), ai.pointBoundingBox(e1, s, n);
                    break;
                }
            case we:
                {
                    const e1 = i.currentPointX = t[0], s = i.currentPointY = t[1];
                    a.push(qt, e1, s), ai.pointBoundingBox(e1, s, n);
                    break;
                }
            case Ae:
                {
                    const e1 = i.currentPointX, s = i.currentPointY, [r, o, l, c, h, d] = t;
                    i.currentPointX = h, i.currentPointY = d, a.push(zt, r, o, l, c, h, d), ai.bezierBoundingBox(e1, s, r, o, l, c, h, d, n);
                    break;
                }
            case xe:
                {
                    const e1 = i.currentPointX, s = i.currentPointY, [r, o, l, c] = t;
                    i.currentPointX = l, i.currentPointY = c, a.push(zt, e1, s, r, o, l, c), ai.bezierBoundingBox(e1, s, e1, s, r, o, l, c, n);
                    break;
                }
            case Se:
                {
                    const e1 = i.currentPointX, s = i.currentPointY, [r, o, l, c] = t;
                    i.currentPointX = l, i.currentPointY = c, a.push(zt, r, o, l, c, l, c), ai.bezierBoundingBox(e1, s, r, o, l, c, l, c, n);
                    break;
                }
            case ve:
                a.push(Wt);
        }
    }
    _getColorSpace(e1, t, i) {
        return ColorSpaceUtils.parse({
            cs: e1,
            xref: this.xref,
            resources: t,
            pdfFunctionFactory: this._pdfFunctionFactory,
            globalColorSpaceCache: this.globalColorSpaceCache,
            localColorSpaceCache: i,
            asyncIfNotCached: !0
        });
    }
    async _handleColorSpace(e1) {
        try {
            return await e1;
        } catch (e1) {
            if (e1 instanceof ii) return null;
            if (this.options.ignoreErrors) return warn$1(`_handleColorSpace - ignoring ColorSpace: "${e1}".`), null;
            throw e1;
        }
    }
    parseShading({ shading: e1, resources: t, localColorSpaceCache: i, localShadingPatternCache: n }) {
        let a, s = n.get(e1);
        if (s) return s;
        try {
            a = Pattern.parseShading(e1, this.xref, t, this._pdfFunctionFactory, this.globalColorSpaceCache, i).getIR();
        } catch (t) {
            if (t instanceof ii) return null;
            if (this.options.ignoreErrors) return warn$1(`parseShading - ignoring shading: "${t}".`), n.set(e1, null), null;
            throw t;
        }
        return s = `pattern_${this.idFactory.createObjId()}`, this.parsingType3Font && (s = `${this.idFactory.getDocId()}_type3_${s}`), n.set(e1, s), this.parsingType3Font ? this.handler.send("commonobj", [
            s,
            "Pattern",
            a
        ]) : this.handler.send("obj", [
            s,
            this.pageIndex,
            "Pattern",
            a
        ]), s;
    }
    handleColorN(e1, t, i, n, a, s, r, o, l, c) {
        const h = i.pop();
        if (h instanceof Name) {
            const d = a.getRaw(h.name), u = d instanceof Ref && l.getByRef(d);
            if (u) try {
                const a = n.base ? n.base.getRgbHex(i, 0) : null, s = getTilingPatternIR(u.operatorListIR, u.dict, a);
                return void e1.addOp(t, s);
            } catch  {}
            const g = this.xref.fetchIfRef(d);
            if (g) {
                const a = g instanceof BaseStream ? g.dict : g, h = a.get("PatternType");
                if (h === vs) {
                    const o = n.base ? n.base.getRgbHex(i, 0) : null;
                    return this.handleTilingType(t, o, s, g, a, e1, r, l);
                }
                if (h === Cs) {
                    const i = a.get("Shading"), n = this.parseShading({
                        shading: i,
                        resources: s,
                        localColorSpaceCache: o,
                        localShadingPatternCache: c
                    });
                    if (n) {
                        const i = lookupMatrix(a.getArray("Matrix"), null);
                        e1.addOp(t, [
                            "Shading",
                            n,
                            i
                        ]);
                    }
                    return;
                }
                throw new ti(`Unknown PatternType: ${h}`);
            }
        }
        throw new ti(`Unknown PatternName: ${h}`);
    }
    _parseVisibilityExpression(e1, t, i) {
        if (++t > 10) return void warn$1("Visibility expression is too deeply nested");
        const n = e1.length, a = this.xref.fetchIfRef(e1[0]);
        if (!(n < 2) && a instanceof Name) {
            switch(a.name){
                case "And":
                case "Or":
                case "Not":
                    i.push(a.name);
                    break;
                default:
                    return void warn$1(`Invalid operator ${a.name} in visibility expression`);
            }
            for(let a = 1; a < n; a++){
                const n = e1[a], s = this.xref.fetchIfRef(n);
                if (Array.isArray(s)) {
                    const e1 = [];
                    i.push(e1), this._parseVisibilityExpression(s, t, e1);
                } else n instanceof Ref && i.push(n.toString());
            }
        } else warn$1("Invalid visibility expression");
    }
    async parseMarkedContentProps(e1, t) {
        let i;
        if (e1 instanceof Name) {
            i = t.get("Properties").get(e1.name);
        } else {
            if (!(e1 instanceof Dict)) throw new ti("Optional content properties malformed.");
            i = e1;
        }
        const n = i.get("Type")?.name;
        if ("OCG" === n) return {
            type: n,
            id: i.objId
        };
        if ("OCMD" === n) {
            const e1 = i.get("VE");
            if (Array.isArray(e1)) {
                const t = [];
                if (this._parseVisibilityExpression(e1, 0, t), t.length > 0) return {
                    type: "OCMD",
                    expression: t
                };
            }
            const t = i.get("OCGs");
            if (Array.isArray(t) || t instanceof Dict) {
                const e1 = [];
                if (Array.isArray(t)) for (const i of t)e1.push(i.toString());
                else e1.push(t.objId);
                return {
                    type: n,
                    ids: e1,
                    policy: i.get("P") instanceof Name ? i.get("P").name : null,
                    expression: null
                };
            }
            if (t instanceof Ref) return {
                type: n,
                id: t.toString()
            };
        }
        return null;
    }
    getOperatorList({ stream: e1, task: t, resources: i, operatorList: n, initialState: a = null, fallbackFontDict: s = null, prevRefs: r = null }) {
        const o = e1.dict?.objId, l = new RefSet(r);
        if (o) {
            if (r?.has(o)) throw new Error(`getOperatorList - ignoring circular reference: ${o}`);
            l.put(o);
        }
        if (i ||= Dict.empty, a ||= new EvalState, !n) throw new Error('getOperatorList: missing "operatorList" parameter');
        const c = this, h = this.xref, d = new LocalImageCache, u = new LocalColorSpaceCache, g = new LocalGStateCache, f = new LocalTilingPatternCache, p = new Map, m = i.get("XObject") || Dict.empty, b = i.get("Pattern") || Dict.empty, y = new StateManager(a), w = new EvaluatorPreprocessor(e1, h, y), x = new TimeSlotManager;
        function closePendingRestoreOPS(e1) {
            for(let e1 = 0, t = w.savedStatesDepth; e1 < t; e1++)n.addOp(me, []);
        }
        return new Promise(function promiseBody(e1, a) {
            const next = function(t) {
                Promise.all([
                    t,
                    n.ready
                ]).then(function() {
                    try {
                        promiseBody(e1, a);
                    } catch (e1) {
                        a(e1);
                    }
                }, a);
            };
            t.ensureNotTerminated(), x.reset();
            const r = {};
            let o, S, v, C, k, T;
            for(; !(o = x.check()) && (r.args = null, w.read(r));){
                let e1 = r.args, a = r.fn;
                switch(0 | a){
                    case bt:
                        if (T = e1[0] instanceof Name, k = e1[0].name, T) {
                            const t = d.getByName(k);
                            if (t) {
                                addCachedImageOps(n, t), e1 = null;
                                continue;
                            }
                        }
                        return void next(new Promise(function(e1, a) {
                            if (!T) throw new ti("XObject must be referred to by name.");
                            let s = m.getRaw(k);
                            if (s instanceof Ref) {
                                const t = d.getByRef(s) || c._regionalImageCache.getByRef(s) || c.globalImageCache.getData(s, c.pageIndex);
                                if (t) return addCachedImageOps(n, t), void e1();
                                s = h.fetch(s);
                            }
                            if (!(s instanceof BaseStream)) throw new ti("XObject should be a stream");
                            const r = s.dict.get("Subtype");
                            if (!(r instanceof Name)) throw new ti("XObject should have a Name subtype");
                            if ("Form" === r.name) return y.save(), void c.buildFormXObject(i, s, null, n, t, y.state.clone({
                                newPath: !0
                            }), u, l).then(function() {
                                y.restore(), e1();
                            }, a);
                            if ("Image" !== r.name) {
                                if ("PS" !== r.name) throw new ti(`Unhandled XObject subtype ${r.name}`);
                                info$1("Ignored XObject subtype PS"), e1();
                            } else c.buildPaintImageXObject({
                                resources: i,
                                image: s,
                                operatorList: n,
                                cacheKey: k,
                                localImageCache: d,
                                localColorSpaceCache: u
                            }).then(e1, a);
                        }).catch(function(e1) {
                            if (!(e1 instanceof ii)) {
                                if (!c.options.ignoreErrors) throw e1;
                                warn$1(`getOperatorList - ignoring XObject: "${e1}".`);
                            }
                        }));
                    case He:
                        const r1 = e1[1];
                        return void next(c.handleSetFont(i, e1, null, n, t, y.state, s).then(function(e1) {
                            n.addDependency(e1), n.addOp(He, [
                                e1,
                                r1
                            ]);
                        }));
                    case mt:
                        const o = e1[0].cacheKey;
                        if (o) {
                            const t = d.getByName(o);
                            if (t) {
                                addCachedImageOps(n, t), e1 = null;
                                continue;
                            }
                        }
                        return void next(c.buildPaintImageXObject({
                            resources: i,
                            image: e1[0],
                            isInline: !0,
                            operatorList: n,
                            cacheKey: o,
                            localImageCache: d,
                            localColorSpaceCache: u
                        }));
                    case Ke:
                        if (!y.state.font) {
                            c.ensureStateFont(y.state);
                            continue;
                        }
                        e1[0] = c.handleText(e1[0], y.state);
                        break;
                    case Ye:
                        if (!y.state.font) {
                            c.ensureStateFont(y.state);
                            continue;
                        }
                        const w = [], x = y.state;
                        for (const t of e1[0])"string" == typeof t ? w.push(...c.handleText(t, x)) : "number" == typeof t && w.push(t);
                        e1[0] = w, a = Ke;
                        break;
                    case Je:
                        if (!y.state.font) {
                            c.ensureStateFont(y.state);
                            continue;
                        }
                        n.addOp(Ve), e1[0] = c.handleText(e1[0], y.state), a = Ke;
                        break;
                    case Ze:
                        if (!y.state.font) {
                            c.ensureStateFont(y.state);
                            continue;
                        }
                        n.addOp(Ve), n.addOp(Ue, [
                            e1.shift()
                        ]), n.addOp(Le, [
                            e1.shift()
                        ]), e1[0] = c.handleText(e1[0], y.state), a = Ke;
                        break;
                    case Xe:
                        y.state.textRenderingMode = e1[0];
                        break;
                    case it:
                        {
                            const t = c._getColorSpace(e1[0], i, u);
                            if (t instanceof ColorSpace) {
                                y.state.fillColorSpace = t;
                                continue;
                            }
                            return void next(c._handleColorSpace(t).then((e1)=>{
                                y.state.fillColorSpace = e1 || ColorSpaceUtils.gray;
                            }));
                        }
                    case tt:
                        {
                            const t = c._getColorSpace(e1[0], i, u);
                            if (t instanceof ColorSpace) {
                                y.state.strokeColorSpace = t;
                                continue;
                            }
                            return void next(c._handleColorSpace(t).then((e1)=>{
                                y.state.strokeColorSpace = e1 || ColorSpaceUtils.gray;
                            }));
                        }
                    case st:
                        C = y.state.fillColorSpace, e1 = [
                            C.getRgbHex(e1, 0)
                        ], a = ht;
                        break;
                    case nt:
                        C = y.state.strokeColorSpace, e1 = [
                            C.getRgbHex(e1, 0)
                        ], a = ct;
                        break;
                    case lt:
                        y.state.fillColorSpace = ColorSpaceUtils.gray, e1 = [
                            ColorSpaceUtils.gray.getRgbHex(e1, 0)
                        ], a = ht;
                        break;
                    case ot:
                        y.state.strokeColorSpace = ColorSpaceUtils.gray, e1 = [
                            ColorSpaceUtils.gray.getRgbHex(e1, 0)
                        ], a = ct;
                        break;
                    case ut:
                        y.state.fillColorSpace = ColorSpaceUtils.cmyk, e1 = [
                            ColorSpaceUtils.cmyk.getRgbHex(e1, 0)
                        ], a = ht;
                        break;
                    case dt:
                        y.state.strokeColorSpace = ColorSpaceUtils.cmyk, e1 = [
                            ColorSpaceUtils.cmyk.getRgbHex(e1, 0)
                        ], a = ct;
                        break;
                    case ht:
                        y.state.fillColorSpace = ColorSpaceUtils.rgb, e1 = [
                            ColorSpaceUtils.rgb.getRgbHex(e1, 0)
                        ];
                        break;
                    case ct:
                        y.state.strokeColorSpace = ColorSpaceUtils.rgb, e1 = [
                            ColorSpaceUtils.rgb.getRgbHex(e1, 0)
                        ];
                        break;
                    case rt:
                        if (C = y.state.patternFillColorSpace, !C) {
                            if (isNumberArray(e1, null)) {
                                e1 = [
                                    ColorSpaceUtils.gray.getRgbHex(e1, 0)
                                ], a = ht;
                                break;
                            }
                            e1 = [], a = $t;
                            break;
                        }
                        if ("Pattern" === C.name) return void next(c.handleColorN(n, rt, e1, C, b, i, t, u, f, p));
                        e1 = [
                            C.getRgbHex(e1, 0)
                        ], a = ht;
                        break;
                    case at:
                        if (C = y.state.patternStrokeColorSpace, !C) {
                            if (isNumberArray(e1, null)) {
                                e1 = [
                                    ColorSpaceUtils.gray.getRgbHex(e1, 0)
                                ], a = ct;
                                break;
                            }
                            e1 = [], a = jt;
                            break;
                        }
                        if ("Pattern" === C.name) return void next(c.handleColorN(n, at, e1, C, b, i, t, u, f, p));
                        e1 = [
                            C.getRgbHex(e1, 0)
                        ], a = ct;
                        break;
                    case gt:
                        let F;
                        try {
                            const t = i.get("Shading");
                            if (!t) throw new ti("No shading resource found");
                            if (F = t.get(e1[0].name), !F) throw new ti("No shading object found");
                        } catch (e1) {
                            if (e1 instanceof ii) continue;
                            if (c.options.ignoreErrors) {
                                warn$1(`getOperatorList - ignoring Shading: "${e1}".`);
                                continue;
                            }
                            throw e1;
                        }
                        const E = c.parseShading({
                            shading: F,
                            resources: i,
                            localColorSpaceCache: u,
                            localShadingPatternCache: p
                        });
                        if (!E) continue;
                        e1 = [
                            E
                        ], a = gt;
                        break;
                    case fe:
                        if (T = e1[0] instanceof Name, k = e1[0].name, T) {
                            const t = g.getByName(k);
                            if (t) {
                                t.length > 0 && n.addOp(fe, [
                                    t
                                ]), e1 = null;
                                continue;
                            }
                        }
                        return void next(new Promise(function(e1, a) {
                            if (!T) throw new ti("GState must be referred to by name.");
                            const s = i.get("ExtGState");
                            if (!(s instanceof Dict)) throw new ti("ExtGState should be a dictionary.");
                            const r = s.get(k);
                            if (!(r instanceof Dict)) throw new ti("GState should be a dictionary.");
                            c.setGState({
                                resources: i,
                                gState: r,
                                operatorList: n,
                                cacheKey: k,
                                task: t,
                                stateManager: y,
                                localGStateCache: g,
                                localColorSpaceCache: u,
                                seenRefs: l
                            }).then(e1, a);
                        }).catch(function(e1) {
                            if (!(e1 instanceof ii)) {
                                if (!c.options.ignoreErrors) throw e1;
                                warn$1(`getOperatorList - ignoring ExtGState: "${e1}".`);
                            }
                        }));
                    case oe:
                        {
                            const [t] = e1;
                            if ("number" != typeof t) {
                                warn$1(`Invalid setLineWidth: ${t}`);
                                continue;
                            }
                            e1[0] = Math.abs(t);
                            break;
                        }
                    case de:
                        {
                            const t = e1[1];
                            if ("number" != typeof t) {
                                warn$1(`Invalid setDash: ${t}`);
                                continue;
                            }
                            const i = e1[0];
                            if (!Array.isArray(i)) {
                                warn$1(`Invalid setDash: ${i}`);
                                continue;
                            }
                            i.some((e1)=>"number" != typeof e1) && (e1[0] = i.filter((e1)=>"number" == typeof e1));
                            break;
                        }
                    case ye:
                    case we:
                    case Ae:
                    case xe:
                    case Se:
                    case ve:
                    case Ce:
                        c.buildPath(a, e1, y.state);
                        continue;
                    case ke:
                    case Te:
                    case Fe:
                    case Ie:
                    case Ee:
                    case Me:
                    case De:
                    case Oe:
                    case _e:
                        {
                            const { state: { pathBuffer: e1, pathMinMax: t } } = y;
                            a !== Te && a !== De && a !== Oe || e1.push(Wt), 0 === e1.length ? n.addOp(Ut, [
                                a,
                                [
                                    null
                                ],
                                null
                            ]) : (n.addOp(Ut, [
                                a,
                                [
                                    new Float32Array(e1)
                                ],
                                t.slice()
                            ]), e1.length = 0, t.set([
                                1 / 0,
                                1 / 0,
                                -1 / 0,
                                -1 / 0
                            ], 0));
                            continue;
                        }
                    case Ge:
                        n.addOp(a, [
                            new Float32Array(e1)
                        ]);
                        continue;
                    case yt:
                    case wt:
                    case vt:
                    case Ct:
                        continue;
                    case xt:
                        if (!(e1[0] instanceof Name)) {
                            warn$1(`Expected name for beginMarkedContentProps arg0=${e1[0]}`), n.addOp(xt, [
                                "OC",
                                null
                            ]);
                            continue;
                        }
                        if ("OC" === e1[0].name) return void next(c.parseMarkedContentProps(e1[1], i).then((e1)=>{
                            n.addOp(xt, [
                                "OC",
                                e1
                            ]);
                        }).catch((e1)=>{
                            if (!(e1 instanceof ii)) {
                                if (c.options.ignoreErrors) return warn$1(`getOperatorList - ignoring beginMarkedContentProps: "${e1}".`), void n.addOp(xt, [
                                    "OC",
                                    null
                                ]);
                                throw e1;
                            }
                        }));
                        e1 = [
                            e1[0].name,
                            e1[1] instanceof Dict ? e1[1].get("MCID") : null
                        ];
                        break;
                    default:
                        if (null !== e1) {
                            for(S = 0, v = e1.length; S < v && !(e1[S] instanceof Dict); S++);
                            if (S < v) {
                                warn$1("getOperatorList - ignoring operator: " + a);
                                continue;
                            }
                        }
                }
                n.addOp(a, e1);
            }
            o ? next(ks) : (closePendingRestoreOPS(), e1());
        }).catch((e1)=>{
            if (!(e1 instanceof ii)) {
                if (this.options.ignoreErrors) return warn$1(`getOperatorList - ignoring errors during "${t.name}" task: "${e1}".`), void closePendingRestoreOPS();
                throw e1;
            }
        });
    }
    getTextContent({ stream: e1, task: i, resources: n, stateManager: a = null, includeMarkedContent: s = !1, sink: r, seenStyles: o = new Set, viewBox: l, lang: c = null, markedContentData: h = null, disableNormalization: d = !1, keepWhiteSpace: u = !1, prevRefs: g = null, intersector: f = null }) {
        const p = e1.dict?.objId, m = new RefSet(g);
        if (p) {
            if (g?.has(p)) throw new Error(`getTextContent - ignoring circular reference: ${p}`);
            m.put(p);
        }
        n ||= Dict.empty, a ||= new StateManager(new TextState), s && (h ||= {
            level: 0
        });
        const b = {
            items: [],
            styles: Object.create(null),
            lang: c
        }, y = {
            initialized: !1,
            str: [],
            totalWidth: 0,
            totalHeight: 0,
            width: 0,
            height: 0,
            vertical: !1,
            prevTransform: null,
            textAdvanceScale: 0,
            spaceInFlowMin: 0,
            spaceInFlowMax: 0,
            trackingSpaceMin: 1 / 0,
            negativeSpaceMax: -1 / 0,
            notASpace: -1 / 0,
            transform: null,
            fontName: null,
            hasEOL: !1
        }, w = [
            " ",
            " "
        ];
        let x = 0;
        function saveLastChar(e1) {
            const t = (x + 1) % 2, i = " " !== w[x] && " " === w[t];
            return w[x] = e1, x = t, !u && i;
        }
        function shouldAddWhitepsace() {
            return !u && " " !== w[x] && " " === w[(x + 1) % 2];
        }
        function resetLastChars() {
            w[0] = w[1] = " ", x = 0;
        }
        const S = this, v = this.xref, C = [];
        let k = null;
        const T = new LocalImageCache, F = new LocalGStateCache, E = new EvaluatorPreprocessor(e1, v, a);
        let M;
        function pushWhitespace({ width: e1 = 0, height: t = 0, transform: i = y.prevTransform, fontName: n = y.fontName }) {
            f?.addExtraChar(" "), b.items.push({
                str: " ",
                dir: "ltr",
                width: e1,
                height: t,
                transform: i,
                fontName: n,
                hasEOL: !1
            });
        }
        function getCurrentTextTransform() {
            const e1 = M.font, i = [
                M.fontSize * M.textHScale,
                0,
                0,
                M.fontSize,
                0,
                M.textRise
            ];
            if (e1.isType3Font && (M.fontSize <= 1 || e1.isCharBBox) && !isArrayEqual(M.fontMatrix, t)) {
                const t = e1.bbox[3] - e1.bbox[1];
                t > 0 && (i[3] *= t * M.fontMatrix[3]);
            }
            return ai.transform(M.ctm, ai.transform(M.textMatrix, i));
        }
        function ensureTextContentItem() {
            if (y.initialized) return y;
            const { font: e1, loadedName: t } = M;
            if (!o.has(t) && (o.add(t), b.styles[t] = {
                fontFamily: e1.fallbackName,
                ascent: e1.ascent,
                descent: e1.descent,
                vertical: e1.vertical
            }, S.options.fontExtraProperties && e1.systemFontInfo)) {
                const i = b.styles[t];
                i.fontSubstitution = e1.systemFontInfo.css, i.fontSubstitutionLoadedName = e1.systemFontInfo.loadedName;
            }
            y.fontName = t;
            const i = y.transform = getCurrentTextTransform();
            e1.vertical ? (y.width = y.totalWidth = Math.hypot(i[0], i[1]), y.height = y.totalHeight = 0, y.vertical = !0) : (y.width = y.totalWidth = 0, y.height = y.totalHeight = Math.hypot(i[2], i[3]), y.vertical = !1);
            const n = Math.hypot(M.textLineMatrix[0], M.textLineMatrix[1]), a = Math.hypot(M.ctm[0], M.ctm[1]);
            y.textAdvanceScale = a * n;
            const { fontSize: s } = M;
            return y.trackingSpaceMin = .102 * s, y.notASpace = .03 * s, y.negativeSpaceMax = -.2 * s, y.spaceInFlowMin = .102 * s, y.spaceInFlowMax = .6 * s, y.hasEOL = !1, y.initialized = !0, y;
        }
        function updateAdvanceScale() {
            if (!y.initialized) return;
            const e1 = Math.hypot(M.textLineMatrix[0], M.textLineMatrix[1]), t = Math.hypot(M.ctm[0], M.ctm[1]) * e1;
            t !== y.textAdvanceScale && (y.vertical ? (y.totalHeight += y.height * y.textAdvanceScale, y.height = 0) : (y.totalWidth += y.width * y.textAdvanceScale, y.width = 0), y.textAdvanceScale = t);
        }
        function runBidiTransform(e1) {
            let t = e1.str.join("");
            var i;
            d || (i = t, ri || (ri = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, oi = new Map([
                [
                    "ï¬",
                    "Å¿t"
                ]
            ])), t = i.replaceAll(ri, (e1, t, i)=>t ? t.normalize("NFKC") : oi.get(i)));
            const n = bidi(t, -1, e1.vertical);
            return {
                str: n.str,
                dir: n.dir,
                width: Math.abs(e1.totalWidth),
                height: Math.abs(e1.totalHeight),
                transform: e1.transform,
                fontName: e1.fontName,
                hasEOL: e1.hasEOL
            };
        }
        async function handleSetFont(e1, a) {
            const s = await S.loadFont(e1, a, n, i);
            M.loadedName = s.loadedName, M.font = s.font, M.fontMatrix = s.font.fontMatrix || t;
        }
        function applyInverseRotation(e1, t, i) {
            const n = Math.hypot(i[0], i[1]);
            return [
                (i[0] * e1 + i[1] * t) / n,
                (i[2] * e1 + i[3] * t) / n
            ];
        }
        function compareWithLastPosition(e1) {
            const t = getCurrentTextTransform();
            let i = t[4], n = t[5];
            if (M.font?.vertical) {
                if (i < l[0] || i > l[2] || n + e1 < l[1] || n > l[3]) return !1;
            } else if (i + e1 < l[0] || i > l[2] || n < l[1] || n > l[3]) return !1;
            if (!M.font || !y.prevTransform) return !0;
            let a = y.prevTransform[4], s = y.prevTransform[5];
            if (a === i && s === n) return !0;
            let r = -1;
            switch(t[0] && 0 === t[1] && 0 === t[2] ? r = t[0] > 0 ? 0 : 180 : t[1] && 0 === t[0] && 0 === t[3] && (r = t[1] > 0 ? 90 : 270), r){
                case 0:
                    break;
                case 90:
                    [i, n] = [
                        n,
                        i
                    ], [a, s] = [
                        s,
                        a
                    ];
                    break;
                case 180:
                    [i, n, a, s] = [
                        -i,
                        -n,
                        -a,
                        -s
                    ];
                    break;
                case 270:
                    [i, n] = [
                        -n,
                        -i
                    ], [a, s] = [
                        -s,
                        -a
                    ];
                    break;
                default:
                    [i, n] = applyInverseRotation(i, n, t), [a, s] = applyInverseRotation(a, s, y.prevTransform);
            }
            if (M.font.vertical) {
                const e1 = (s - n) / y.textAdvanceScale, t = i - a, r = Math.sign(y.height);
                return e1 < r * y.negativeSpaceMax ? Math.abs(t) > .5 * y.width ? (appendEOL(), !0) : (resetLastChars(), flushTextContentItem(), !0) : Math.abs(t) > y.width ? (appendEOL(), !0) : (e1 <= r * y.notASpace && resetLastChars(), e1 <= r * y.trackingSpaceMin ? shouldAddWhitepsace() ? (resetLastChars(), flushTextContentItem(), pushWhitespace({
                    height: Math.abs(e1)
                })) : y.height += e1 : addFakeSpaces(e1, y.prevTransform, r) || (0 === y.str.length ? (resetLastChars(), pushWhitespace({
                    height: Math.abs(e1)
                })) : y.height += e1), Math.abs(t) > .25 * y.width && flushTextContentItem(), !0);
            }
            const o = (i - a) / y.textAdvanceScale, c = n - s, h = Math.sign(y.width);
            return o < h * y.negativeSpaceMax ? Math.abs(c) > .5 * y.height ? (appendEOL(), !0) : (resetLastChars(), flushTextContentItem(), !0) : Math.abs(c) > y.height ? (appendEOL(), !0) : (o <= h * y.notASpace && resetLastChars(), o <= h * y.trackingSpaceMin ? shouldAddWhitepsace() ? (resetLastChars(), flushTextContentItem(), pushWhitespace({
                width: Math.abs(o)
            })) : y.width += o : addFakeSpaces(o, y.prevTransform, h) || (0 === y.str.length ? (resetLastChars(), pushWhitespace({
                width: Math.abs(o)
            })) : y.width += o), Math.abs(c) > .25 * y.height && flushTextContentItem(), !0);
        }
        function buildTextContentItem({ chars: e1, extraSpacing: t }) {
            const i = M.font;
            if (!e1) {
                const e1 = M.charSpacing + t;
                return e1 && (i.vertical ? M.translateTextMatrix(0, -e1) : M.translateTextMatrix(e1 * M.textHScale, 0)), void (u && compareWithLastPosition(0));
            }
            const n = i.charsToGlyphs(e1), a = M.fontMatrix[0] * M.fontSize;
            for(let e1 = 0, s = n.length; e1 < s; e1++){
                const r = n[e1], { category: o, originalCharCode: l } = r;
                if (o.isInvisibleFormatMark) continue;
                let c = M.charSpacing + (e1 + 1 === s ? t : 0), h = r.width;
                i.vertical && (h = r.vmetric ? r.vmetric[0] : -h);
                let d = h * a;
                if (32 === l && (c += M.wordSpacing), !u && o.isWhitespace) {
                    i.vertical ? (c += -d, M.translateTextMatrix(0, -c)) : (c += d, M.translateTextMatrix(c * M.textHScale, 0)), saveLastChar(" ");
                    continue;
                }
                if (!o.isZeroWidthDiacritic && !compareWithLastPosition(d)) {
                    i.vertical ? M.translateTextMatrix(0, d) : M.translateTextMatrix(d * M.textHScale, 0);
                    continue;
                }
                const g = ensureTextContentItem();
                o.isZeroWidthDiacritic && (d = 0), i.vertical ? (f?.addGlyph(getCurrentTextTransform(), 0, d, r.unicode), M.translateTextMatrix(0, d), d = Math.abs(d), g.height += d) : (d *= M.textHScale, f?.addGlyph(getCurrentTextTransform(), d, 0, r.unicode), M.translateTextMatrix(d, 0), g.width += d), d && (g.prevTransform = getCurrentTextTransform());
                const p = r.unicode;
                saveLastChar(p) && (g.str.push(" "), f?.addExtraChar(" ")), f || g.str.push(p), c && (i.vertical ? M.translateTextMatrix(0, -c) : M.translateTextMatrix(c * M.textHScale, 0));
            }
        }
        function appendEOL() {
            f?.addExtraChar("\n"), resetLastChars(), y.initialized ? (y.hasEOL = !0, flushTextContentItem()) : b.items.push({
                str: "",
                dir: "ltr",
                width: 0,
                height: 0,
                transform: getCurrentTextTransform(),
                fontName: M.loadedName,
                hasEOL: !0
            });
        }
        function addFakeSpaces(e1, t, i) {
            if (i * y.spaceInFlowMin <= e1 && e1 <= i * y.spaceInFlowMax) return y.initialized && (resetLastChars(), y.str.push(" "), f?.addExtraChar(" ")), !1;
            const n = y.fontName;
            let a = 0;
            return y.vertical && (a = e1, e1 = 0), flushTextContentItem(), resetLastChars(), pushWhitespace({
                width: Math.abs(e1),
                height: Math.abs(a),
                transform: t || getCurrentTextTransform(),
                fontName: n
            }), !0;
        }
        function flushTextContentItem() {
            y.initialized && y.str && (y.vertical ? y.totalHeight += y.height * y.textAdvanceScale : y.totalWidth += y.width * y.textAdvanceScale, b.items.push(runBidiTransform(y)), y.initialized = !1, y.str.length = 0);
        }
        function enqueueChunk(e1 = !1) {
            const t = b.items.length;
            0 !== t && (e1 && t < 10 || (r?.enqueue(b, t), b.items = [], b.styles = Object.create(null)));
        }
        const D = new TimeSlotManager;
        return new Promise(function promiseBody(e1, t) {
            const next = function(i) {
                enqueueChunk(!0), Promise.all([
                    i,
                    r?.ready
                ]).then(function() {
                    try {
                        promiseBody(e1, t);
                    } catch (e1) {
                        t(e1);
                    }
                }, t);
            };
            i.ensureNotTerminated(), D.reset();
            const g = {};
            let f, p, y, w = [];
            for(; !(f = D.check()) && (w.length = 0, g.args = w, E.read(g));){
                const e1 = M;
                M = a.state;
                const t = g.fn;
                switch(w = g.args, 0 | t){
                    case He:
                        const t1 = w[0].name, g1 = w[1];
                        if (M.font && t1 === M.fontName && g1 === M.fontSize) break;
                        return flushTextContentItem(), M.fontName = t1, M.fontSize = g1, void next(handleSetFont(t1, null));
                    case qe:
                        M.textRise = w[0];
                        break;
                    case je:
                        M.textHScale = w[0] / 100;
                        break;
                    case $e:
                        M.leading = w[0];
                        break;
                    case ze:
                        M.translateTextLineMatrix(w[0], w[1]), M.textMatrix = M.textLineMatrix.slice();
                        break;
                    case We:
                        M.leading = -w[1], M.translateTextLineMatrix(w[0], w[1]), M.textMatrix = M.textLineMatrix.slice();
                        break;
                    case Ve:
                        M.carriageReturn();
                        break;
                    case Ge:
                        M.setTextMatrix(w[0], w[1], w[2], w[3], w[4], w[5]), M.setTextLineMatrix(w[0], w[1], w[2], w[3], w[4], w[5]), updateAdvanceScale();
                        break;
                    case Le:
                        M.charSpacing = w[0];
                        break;
                    case Ue:
                        M.wordSpacing = w[0];
                        break;
                    case Be:
                        M.textMatrix = pi.slice(), M.textLineMatrix = pi.slice();
                        break;
                    case Ye:
                        if (!a.state.font) {
                            S.ensureStateFont(a.state);
                            continue;
                        }
                        const f1 = (M.font.vertical ? 1 : -1) * M.fontSize / 1e3, x = w[0];
                        for(let e1 = 0, t = x.length; e1 < t; e1++){
                            const t = x[e1];
                            if ("string" == typeof t) C.push(t);
                            else if ("number" == typeof t && 0 !== t) {
                                const e1 = C.join("");
                                C.length = 0, buildTextContentItem({
                                    chars: e1,
                                    extraSpacing: t * f1
                                });
                            }
                        }
                        if (C.length > 0) {
                            const e1 = C.join("");
                            C.length = 0, buildTextContentItem({
                                chars: e1,
                                extraSpacing: 0
                            });
                        }
                        break;
                    case Ke:
                        if (!a.state.font) {
                            S.ensureStateFont(a.state);
                            continue;
                        }
                        buildTextContentItem({
                            chars: w[0],
                            extraSpacing: 0
                        });
                        break;
                    case Je:
                        if (!a.state.font) {
                            S.ensureStateFont(a.state);
                            continue;
                        }
                        M.carriageReturn(), buildTextContentItem({
                            chars: w[0],
                            extraSpacing: 0
                        });
                        break;
                    case Ze:
                        if (!a.state.font) {
                            S.ensureStateFont(a.state);
                            continue;
                        }
                        M.wordSpacing = w[0], M.charSpacing = w[1], M.carriageReturn(), buildTextContentItem({
                            chars: w[2],
                            extraSpacing: 0
                        });
                        break;
                    case bt:
                        if (flushTextContentItem(), k ??= n.get("XObject") || Dict.empty, y = w[0] instanceof Name, p = w[0].name, y && T.getByName(p)) break;
                        return void next(new Promise(function(e1, t) {
                            if (!y) throw new ti("XObject must be referred to by name.");
                            let g = k.getRaw(p);
                            if (g instanceof Ref) {
                                if (T.getByRef(g)) return void e1();
                                if (S.globalImageCache.getData(g, S.pageIndex)) return void e1();
                                g = v.fetch(g);
                            }
                            if (!(g instanceof BaseStream)) throw new ti("XObject should be a stream");
                            const { dict: f } = g, b = f.get("Subtype");
                            if (!(b instanceof Name)) throw new ti("XObject should have a Name subtype");
                            if ("Form" !== b.name) return T.set(p, f.objId, !0), void e1();
                            const w = a.state.clone(), x = new StateManager(w), C = lookupMatrix(f.getArray("Matrix"), null);
                            C && x.transform(C);
                            const F = f.get("Resources");
                            enqueueChunk();
                            const E = {
                                enqueueInvoked: !1,
                                enqueue (e1, t) {
                                    this.enqueueInvoked = !0, r.enqueue(e1, t);
                                },
                                get desiredSize () {
                                    return r.desiredSize ?? 0;
                                },
                                get ready () {
                                    return r.ready;
                                }
                            };
                            S.getTextContent({
                                stream: g,
                                task: i,
                                resources: F instanceof Dict ? F : n,
                                stateManager: x,
                                includeMarkedContent: s,
                                sink: r && E,
                                seenStyles: o,
                                viewBox: l,
                                lang: c,
                                markedContentData: h,
                                disableNormalization: d,
                                keepWhiteSpace: u,
                                prevRefs: m
                            }).then(function() {
                                E.enqueueInvoked || T.set(p, f.objId, !0), e1();
                            }, t);
                        }).catch(function(e1) {
                            if (!(e1 instanceof ii)) {
                                if (!S.options.ignoreErrors) throw e1;
                                warn$1(`getTextContent - ignoring XObject: "${e1}".`);
                            }
                        }));
                    case fe:
                        if (y = w[0] instanceof Name, p = w[0].name, y && F.getByName(p)) break;
                        return void next(new Promise(function(e1, t) {
                            if (!y) throw new ti("GState must be referred to by name.");
                            const i = n.get("ExtGState");
                            if (!(i instanceof Dict)) throw new ti("ExtGState should be a dictionary.");
                            const a = i.get(p);
                            if (!(a instanceof Dict)) throw new ti("GState should be a dictionary.");
                            const s = a.get("Font");
                            if (!s) return F.set(p, a.objId, !0), void e1();
                            flushTextContentItem(), M.fontName = null, M.fontSize = s[1], handleSetFont(null, s[0]).then(e1, t);
                        }).catch(function(e1) {
                            if (!(e1 instanceof ii)) {
                                if (!S.options.ignoreErrors) throw e1;
                                warn$1(`getTextContent - ignoring ExtGState: "${e1}".`);
                            }
                        }));
                    case At:
                        flushTextContentItem(), s && (h.level++, b.items.push({
                            type: "beginMarkedContent",
                            tag: w[0] instanceof Name ? w[0].name : null
                        }));
                        break;
                    case xt:
                        if (flushTextContentItem(), s) {
                            h.level++;
                            let e1 = null;
                            w[1] instanceof Dict && (e1 = w[1].get("MCID")), b.items.push({
                                type: "beginMarkedContentProps",
                                id: Number.isInteger(e1) ? `${S.idFactory.getPageObjId()}_mc${e1}` : null,
                                tag: w[0] instanceof Name ? w[0].name : null
                            });
                        }
                        break;
                    case St:
                        if (flushTextContentItem(), s) {
                            if (0 === h.level) break;
                            h.level--, b.items.push({
                                type: "endMarkedContent"
                            });
                        }
                        break;
                    case me:
                        !e1 || e1.font === M.font && e1.fontSize === M.fontSize && e1.fontName === M.fontName || flushTextContentItem();
                }
                if (b.items.length >= (r?.desiredSize ?? 1)) {
                    f = !0;
                    break;
                }
            }
            f ? next(ks) : (flushTextContentItem(), enqueueChunk(), e1());
        }).catch((e1)=>{
            if (!(e1 instanceof ii)) {
                if (this.options.ignoreErrors) return warn$1(`getTextContent - ignoring errors during "${i.name}" task: "${e1}".`), flushTextContentItem(), void enqueueChunk();
                throw e1;
            }
        });
    }
    async extractDataStructures(e1, t) {
        const i = this.xref;
        let n;
        const a = this.readToUnicode(t.toUnicode);
        if (t.composite) {
            const i = e1.get("CIDSystemInfo");
            i instanceof Dict && (t.cidSystemInfo = {
                registry: stringToPDFString(i.get("Registry")),
                ordering: stringToPDFString(i.get("Ordering")),
                supplement: i.get("Supplement")
            });
            try {
                const t = e1.get("CIDToGIDMap");
                t instanceof BaseStream && (n = t.getBytes());
            } catch (e1) {
                if (!this.options.ignoreErrors) throw e1;
                warn$1(`extractDataStructures - ignoring CIDToGIDMap data: "${e1}".`);
            }
        }
        const s = [];
        let r, o = null;
        if (e1.has("Encoding")) {
            if (r = e1.get("Encoding"), r instanceof Dict) {
                if (o = r.get("BaseEncoding"), o = o instanceof Name ? o.name : null, r.has("Differences")) {
                    const e1 = r.get("Differences");
                    let t = 0;
                    for (const n of e1){
                        const e1 = i.fetchIfRef(n);
                        if ("number" == typeof e1) t = e1;
                        else {
                            if (!(e1 instanceof Name)) throw new ti(`Invalid entry in 'Differences' array: ${e1}`);
                            s[t++] = e1.name;
                        }
                    }
                }
            } else if (r instanceof Name) o = r.name;
            else {
                const e1 = "Encoding is not a Name nor a Dict";
                if (!this.options.ignoreErrors) throw new ti(e1);
                warn$1(e1);
            }
            "MacRomanEncoding" !== o && "MacExpertEncoding" !== o && "WinAnsiEncoding" !== o && (o = null);
        }
        const l = !t.file || t.isInternalFont, c = Xn()[t.name];
        if (o && l && c && (o = null), o) t.defaultEncoding = getEncoding(o);
        else {
            let e1 = !!(t.flags & kn);
            const i = !!(t.flags & Tn);
            "TrueType" === t.type && e1 && i && 0 !== s.length && (t.flags &= -5, e1 = !1), r = un, "TrueType" !== t.type || i || (r = gn), (e1 || c) && (r = dn, l && (/Symbol/i.test(t.name) ? r = fn : /Dingbats/i.test(t.name) ? r = pn : /Wingdings/i.test(t.name) && (r = gn))), t.defaultEncoding = r;
        }
        t.differences = s, t.baseEncodingName = o, t.hasEncoding = !!o || s.length > 0, t.dict = e1, t.toUnicode = await a;
        const h = await this.buildToUnicode(t);
        return t.toUnicode = h, n && (t.cidToGidMap = this.readCidToGidMap(n, h)), t;
    }
    _simpleFontToUnicode(e1, t = !1) {
        assert$1(!e1.composite, "Must be a simple font.");
        const i = [], n = e1.defaultEncoding.slice(), a = e1.baseEncodingName, s = e1.differences;
        for(const e1 in s){
            const t = s[e1];
            ".notdef" !== t && (n[e1] = t);
        }
        const r = mn();
        for(const s in n){
            let o = n[s];
            if ("" === o) continue;
            let l = r[o];
            if (void 0 !== l) {
                i[s] = String.fromCharCode(l);
                continue;
            }
            let c = 0;
            switch(o[0]){
                case "G":
                    3 === o.length && (c = parseInt(o.substring(1), 16));
                    break;
                case "g":
                    5 === o.length && (c = parseInt(o.substring(1), 16));
                    break;
                case "C":
                case "c":
                    if (o.length >= 3 && o.length <= 4) {
                        const i = o.substring(1);
                        if (t) {
                            c = parseInt(i, 16);
                            break;
                        }
                        if (c = +i, Number.isNaN(c) && Number.isInteger(parseInt(i, 16))) return this._simpleFontToUnicode(e1, !0);
                    }
                    break;
                case "u":
                    l = getUnicodeForGlyph(o, r), -1 !== l && (c = l);
                    break;
                default:
                    switch(o){
                        case "f_h":
                        case "f_t":
                        case "T_h":
                            i[s] = o.replaceAll("_", "");
                            continue;
                    }
            }
            if (c > 0 && c <= 1114111 && Number.isInteger(c)) {
                if (a && c === +s) {
                    const e1 = getEncoding(a);
                    if (e1 && (o = e1[s])) {
                        i[s] = String.fromCharCode(r[o]);
                        continue;
                    }
                }
                i[s] = String.fromCodePoint(c);
            }
        }
        return i;
    }
    async buildToUnicode(e1) {
        if (e1.hasIncludedToUnicodeMap = e1.toUnicode?.length > 0, e1.hasIncludedToUnicodeMap) return !e1.composite && e1.hasEncoding && (e1.fallbackToUnicode = this._simpleFontToUnicode(e1)), e1.toUnicode;
        if (!e1.composite) return new ToUnicodeMap(this._simpleFontToUnicode(e1));
        if (e1.composite && (e1.cMap.builtInCMap && !(e1.cMap instanceof IdentityCMap) || "Adobe" === e1.cidSystemInfo?.registry && ("GB1" === e1.cidSystemInfo.ordering || "CNS1" === e1.cidSystemInfo.ordering || "Japan1" === e1.cidSystemInfo.ordering || "Korea1" === e1.cidSystemInfo.ordering))) {
            const { registry: t, ordering: i } = e1.cidSystemInfo, n = Name.get(`${t}-${i}-UCS2`), a = await CMapFactory.create({
                encoding: n,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
            }), s = [], r = [];
            return e1.cMap.forEach(function(e1, t) {
                if (t > 65535) throw new ti("Max size of CID is 65,535");
                const i = a.lookup(t);
                if (i) {
                    r.length = 0;
                    for(let e1 = 0, t = i.length; e1 < t; e1 += 2)r.push((i.charCodeAt(e1) << 8) + i.charCodeAt(e1 + 1));
                    s[e1] = String.fromCharCode(...r);
                }
            }), new ToUnicodeMap(s);
        }
        return new IdentityToUnicodeMap(e1.firstChar, e1.lastChar);
    }
    async readToUnicode(e1) {
        if (!e1) return null;
        if (e1 instanceof Name) {
            const t = await CMapFactory.create({
                encoding: e1,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
            });
            return t instanceof IdentityCMap ? new IdentityToUnicodeMap(0, 65535) : new ToUnicodeMap(t.getMap());
        }
        if (e1 instanceof BaseStream) try {
            const t = await CMapFactory.create({
                encoding: e1,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
            });
            if (t instanceof IdentityCMap) return new IdentityToUnicodeMap(0, 65535);
            const i = new Array(t.length);
            return t.forEach(function(e1, t) {
                if ("number" == typeof t) return void (i[e1] = String.fromCodePoint(t));
                t.length % 2 != 0 && (t = "\0" + t);
                const n = [];
                for(let e1 = 0; e1 < t.length; e1 += 2){
                    const i = t.charCodeAt(e1) << 8 | t.charCodeAt(e1 + 1);
                    if (55296 != (63488 & i)) {
                        n.push(i);
                        continue;
                    }
                    e1 += 2;
                    const a = t.charCodeAt(e1) << 8 | t.charCodeAt(e1 + 1);
                    n.push(((1023 & i) << 10) + (1023 & a) + 65536);
                }
                i[e1] = String.fromCodePoint(...n);
            }), new ToUnicodeMap(i);
        } catch (e1) {
            if (e1 instanceof ii) return null;
            if (this.options.ignoreErrors) return warn$1(`readToUnicode - ignoring ToUnicode data: "${e1}".`), null;
            throw e1;
        }
        return null;
    }
    readCidToGidMap(e1, t) {
        const i = [];
        for(let n = 0, a = e1.length; n < a; n++){
            const a = e1[n++] << 8 | e1[n], s = n >> 1;
            (0 !== a || t.has(s)) && (i[s] = a);
        }
        return i;
    }
    extractWidths(e1, t, i) {
        const n = this.xref;
        let a = [], s = 0;
        const r = [];
        let o;
        if (i.composite) {
            const t = e1.get("DW");
            s = "number" == typeof t ? Math.ceil(t) : 1e3;
            const l = e1.get("W");
            if (Array.isArray(l)) for(let e1 = 0, t = l.length; e1 < t; e1++){
                let t = n.fetchIfRef(l[e1++]);
                if (!Number.isInteger(t)) break;
                const i = n.fetchIfRef(l[e1]);
                if (Array.isArray(i)) for (const e1 of i){
                    const i = n.fetchIfRef(e1);
                    "number" == typeof i && (a[t] = i), t++;
                }
                else {
                    if (!Number.isInteger(i)) break;
                    {
                        const s = n.fetchIfRef(l[++e1]);
                        if ("number" != typeof s) continue;
                        for(let e1 = t; e1 <= i; e1++)a[e1] = s;
                    }
                }
            }
            if (i.vertical) {
                const t = e1.getArray("DW2");
                let i = isNumberArray(t, 2) ? t : [
                    880,
                    -1e3
                ];
                if (o = [
                    i[1],
                    .5 * s,
                    i[0]
                ], i = e1.get("W2"), Array.isArray(i)) for(let e1 = 0, t = i.length; e1 < t; e1++){
                    let t = n.fetchIfRef(i[e1++]);
                    if (!Number.isInteger(t)) break;
                    const a = n.fetchIfRef(i[e1]);
                    if (Array.isArray(a)) for(let e1 = 0, i = a.length; e1 < i; e1++){
                        const i = [
                            n.fetchIfRef(a[e1++]),
                            n.fetchIfRef(a[e1++]),
                            n.fetchIfRef(a[e1])
                        ];
                        isNumberArray(i, null) && (r[t] = i), t++;
                    }
                    else {
                        if (!Number.isInteger(a)) break;
                        {
                            const s = [
                                n.fetchIfRef(i[++e1]),
                                n.fetchIfRef(i[++e1]),
                                n.fetchIfRef(i[++e1])
                            ];
                            if (!isNumberArray(s, null)) continue;
                            for(let e1 = t; e1 <= a; e1++)r[e1] = s;
                        }
                    }
                }
            }
        } else {
            const r = e1.get("Widths");
            if (Array.isArray(r)) {
                let e1 = i.firstChar;
                for (const t of r){
                    const i = n.fetchIfRef(t);
                    "number" == typeof i && (a[e1] = i), e1++;
                }
                const o = t.get("MissingWidth");
                s = "number" == typeof o ? o : 0;
            } else {
                const t = e1.get("BaseFont");
                if (t instanceof Name) {
                    const e1 = this.getBaseFontMetrics(t.name);
                    a = this.buildCharCodeToWidth(e1.widths, i), s = e1.defaultWidth;
                }
            }
        }
        let l = !0, c = s;
        for(const e1 in a){
            const t = a[e1];
            if (t) if (c) {
                if (c !== t) {
                    l = !1;
                    break;
                }
            } else c = t;
        }
        l ? i.flags |= vn : i.flags &= -2, i.defaultWidth = s, i.widths = a, i.defaultVMetrics = o, i.vmetrics = r;
    }
    isSerifFont(e1) {
        const t = e1.split("-", 1)[0];
        return t in Hn() || /serif/gi.test(t);
    }
    getBaseFontMetrics(e1) {
        let t = 0, i = Object.create(null), n = !1;
        let a = Un()[e1] || e1;
        const s = Gn();
        a in s || (a = this.isSerifFont(e1) ? "Times-Roman" : "Helvetica");
        const r = s[a];
        return "number" == typeof r ? (t = r, n = !0) : i = r(), {
            defaultWidth: t,
            monospace: n,
            widths: i
        };
    }
    buildCharCodeToWidth(e1, t) {
        const i = Object.create(null), n = t.differences, a = t.defaultEncoding;
        for(let t = 0; t < 256; t++)t in n && e1[n[t]] ? i[t] = e1[n[t]] : t in a && e1[a[t]] && (i[t] = e1[a[t]]);
        return i;
    }
    preEvaluateFont(e1) {
        const t = e1;
        let i = e1.get("Subtype");
        if (!(i instanceof Name)) throw new ti("invalid font Subtype");
        let n, a = !1;
        if ("Type0" === i.name) {
            const t = e1.get("DescendantFonts");
            if (!t) throw new ti("Descendant fonts are not specified");
            if (!((e1 = Array.isArray(t) ? this.xref.fetchIfRef(t[0]) : t) instanceof Dict)) throw new ti("Descendant font is not a dictionary.");
            if (i = e1.get("Subtype"), !(i instanceof Name)) throw new ti("invalid font Subtype");
            a = !0;
        }
        let s = e1.get("FirstChar");
        Number.isInteger(s) || (s = 0);
        let r = e1.get("LastChar");
        Number.isInteger(r) || (r = a ? 65535 : 255);
        const o = e1.get("FontDescriptor"), l = e1.get("ToUnicode") || t.get("ToUnicode");
        if (o) {
            n = new xs;
            const i = t.getRaw("Encoding");
            if (i instanceof Name) n.update(i.name);
            else if (i instanceof Ref) n.update(i.toString());
            else if (i instanceof Dict) {
                for (const e1 of i.getRawValues())if (e1 instanceof Name) n.update(e1.name);
                else if (e1 instanceof Ref) n.update(e1.toString());
                else if (Array.isArray(e1)) {
                    const t = e1.length, i = new Array(t);
                    for(let n = 0; n < t; n++){
                        const t = e1[n];
                        t instanceof Name ? i[n] = t.name : ("number" == typeof t || t instanceof Ref) && (i[n] = t.toString());
                    }
                    n.update(i.join());
                }
            }
            if (n.update(`${s}-${r}`), l instanceof BaseStream) {
                const e1 = l.str || l, t = e1.buffer ? new Uint8Array(e1.buffer.buffer, 0, e1.bufferLength) : new Uint8Array(e1.bytes.buffer, e1.start, e1.end - e1.start);
                n.update(t);
            } else l instanceof Name && n.update(l.name);
            const o = e1.get("Widths") || t.get("Widths");
            if (Array.isArray(o)) {
                const e1 = [];
                for (const t of o)("number" == typeof t || t instanceof Ref) && e1.push(t.toString());
                n.update(e1.join());
            }
            if (a) {
                n.update("compositeFont");
                const i = e1.get("W") || t.get("W");
                if (Array.isArray(i)) {
                    const e1 = [];
                    for (const t of i)if ("number" == typeof t || t instanceof Ref) e1.push(t.toString());
                    else if (Array.isArray(t)) {
                        const i = [];
                        for (const e1 of t)("number" == typeof e1 || e1 instanceof Ref) && i.push(e1.toString());
                        e1.push(`[${i.join()}]`);
                    }
                    n.update(e1.join());
                }
                const a = e1.getRaw("CIDToGIDMap") || t.getRaw("CIDToGIDMap");
                a instanceof Name ? n.update(a.name) : a instanceof Ref ? n.update(a.toString()) : a instanceof BaseStream && n.update(a.peekBytes());
            }
        }
        return {
            descriptor: o,
            dict: e1,
            baseDict: t,
            composite: a,
            type: i.name,
            firstChar: s,
            lastChar: r,
            toUnicode: l,
            hash: n ? n.hexdigest() : ""
        };
    }
    async translateFont({ descriptor: e1, dict: i, baseDict: n, composite: a, type: s, firstChar: r, lastChar: o, toUnicode: l, cssFontInfo: c }) {
        const h = "Type3" === s;
        if (!e1) {
            if (!h) {
                let e1 = i.get("BaseFont");
                if (!(e1 instanceof Name)) throw new ti("Base font is not specified");
                e1 = e1.name.replaceAll(/[,_]/g, "-");
                const t = this.getBaseFontMetrics(e1), a = e1.split("-", 1)[0], c = (this.isSerifFont(a) ? Cn : 0) | (t.monospace ? vn : 0) | (Xn()[a] ? kn : Tn), d = {
                    type: s,
                    name: e1,
                    loadedName: n.loadedName,
                    systemFontInfo: null,
                    widths: t.widths,
                    defaultWidth: t.defaultWidth,
                    isSimulatedFlags: !0,
                    flags: c,
                    firstChar: r,
                    lastChar: o,
                    toUnicode: l,
                    xHeight: 0,
                    capHeight: 0,
                    italicAngle: 0,
                    isType3Font: h
                }, u = i.get("Widths"), g = getStandardFontName(e1);
                let f = null;
                g && (f = await this.fetchStandardFontData(g), d.isInternalFont = !!f), !d.isInternalFont && this.options.useSystemFonts && (d.systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, e1, g, s));
                const p = await this.extractDataStructures(i, d);
                if (Array.isArray(u)) {
                    const e1 = [];
                    let t = r;
                    for (const i of u){
                        const n = this.xref.fetchIfRef(i);
                        "number" == typeof n && (e1[t] = n), t++;
                    }
                    p.widths = e1;
                } else p.widths = this.buildCharCodeToWidth(t.widths, p);
                return new Font(e1, f, p, this.options);
            }
            e1 = Dict.empty;
        }
        let d = e1.get("FontName"), u = i.get("BaseFont");
        "string" == typeof d && (d = Name.get(d)), "string" == typeof u && (u = Name.get(u));
        const g = d?.name, f = u?.name;
        if (h ? g || (d = Name.get(s)) : g !== f && (info$1(`The FontDescriptor's FontName is "${g}" but should be the same as the Font's BaseFont "${f}".`), g && f && (f.startsWith(g) || !isKnownFontName(g) && isKnownFontName(f)) && (d = null), d ||= u), !(d instanceof Name)) throw new ti("invalid font name");
        let p, m, b, y, w;
        try {
            if (p = e1.get("FontFile", "FontFile2", "FontFile3"), p) {
                if (!(p instanceof BaseStream)) throw new ti("FontFile should be a stream");
                if (p.isEmpty) throw new ti("FontFile is empty");
            }
        } catch (e1) {
            if (!this.options.ignoreErrors) throw e1;
            warn$1(`translateFont - fetching "${d.name}" font file: "${e1}".`), p = null;
        }
        let x = !1, S = null, v = null;
        if (p) {
            if (p.dict) {
                const e1 = p.dict.get("Subtype");
                e1 instanceof Name && (m = e1.name), b = p.dict.get("Length1"), y = p.dict.get("Length2"), w = p.dict.get("Length3");
            }
        } else if (c) {
            const e1 = getXfaFontName(d.name);
            e1 && (c.fontFamily = `${c.fontFamily}-PdfJS-XFA`, c.metrics = e1.metrics || null, S = e1.factors || null, p = await this.fetchStandardFontData(e1.name), x = !!p, n = i = getXfaFontDict(d.name), a = !0);
        } else if (!h) {
            const e1 = getStandardFontName(d.name);
            e1 && (p = await this.fetchStandardFontData(e1), x = !!p), !x && this.options.useSystemFonts && (v = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, d.name, e1, s));
        }
        const C = lookupMatrix(i.getArray("FontMatrix"), t), k = lookupNormalRect(e1.getArray("FontBBox") || i.getArray("FontBBox"), h ? [
            0,
            0,
            0,
            0
        ] : void 0);
        let T = e1.get("Ascent");
        "number" != typeof T && (T = void 0);
        let F = e1.get("Descent");
        "number" != typeof F && (F = void 0);
        let E = e1.get("XHeight");
        "number" != typeof E && (E = 0);
        let M = e1.get("CapHeight");
        "number" != typeof M && (M = 0);
        let D = e1.get("Flags");
        Number.isInteger(D) || (D = 0);
        let O = e1.get("ItalicAngle");
        "number" != typeof O && (O = 0);
        const _ = {
            type: s,
            name: d.name,
            subtype: m,
            file: p,
            length1: b,
            length2: y,
            length3: w,
            isInternalFont: x,
            loadedName: n.loadedName,
            composite: a,
            fixedPitch: !1,
            fontMatrix: C,
            firstChar: r,
            lastChar: o,
            toUnicode: l,
            bbox: k,
            ascent: T,
            descent: F,
            xHeight: E,
            capHeight: M,
            flags: D,
            italicAngle: O,
            isType3Font: h,
            cssFontInfo: c,
            scaleFactors: S,
            systemFontInfo: v
        };
        if (a) {
            const e1 = n.get("Encoding");
            e1 instanceof Name && (_.cidEncoding = e1.name);
            const t = await CMapFactory.create({
                encoding: e1,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
            });
            _.cMap = t, _.vertical = _.cMap.vertical;
        }
        const R = await this.extractDataStructures(i, _);
        return this.extractWidths(i, e1, R), new Font(d.name, p, R, this.options);
    }
    static buildFontPaths(e1, t, i, n) {
        function buildPath(t) {
            const a = `${e1.loadedName}_path_${t}`;
            try {
                if (e1.renderer.hasBuiltPath(t)) return;
                i.send("commonobj", [
                    a,
                    "FontPath",
                    e1.renderer.getPathJs(t)
                ]);
            } catch (e1) {
                if (n.ignoreErrors) return void warn$1(`buildFontPaths - ignoring ${a} glyph: "${e1}".`);
                throw e1;
            }
        }
        for (const e1 of t){
            buildPath(e1.fontChar);
            const t = e1.accent;
            t?.fontChar && buildPath(t.fontChar);
        }
    }
    static get fallbackFontDict() {
        const e1 = new Dict;
        return e1.set("BaseFont", Name.get("Helvetica")), e1.set("Type", Name.get("FallbackType")), e1.set("Subtype", Name.get("FallbackType")), e1.set("Encoding", Name.get("WinAnsiEncoding")), shadow$1(this, "fallbackFontDict", e1);
    }
}
class TranslatedFont {
    #ne = !1;
    #ae = null;
    constructor({ loadedName: e1, font: t, dict: i }){
        this.loadedName = e1, this.font = t, this.dict = i, this.type3Dependencies = t.isType3Font ? new Set : null;
    }
    send(e1) {
        if (this.#ne) return;
        this.#ne = !0;
        const t = this.font.exportData(), i = [];
        t.data && (t.data.charProcOperatorList && (t.charProcOperatorList = t.data.charProcOperatorList), t.data = ds.write(t.data), i.push(t.data)), e1.send("commonobj", [
            this.loadedName,
            "Font",
            t
        ], i);
    }
    fallback(e1, t) {
        this.font.data && (this.font.disableFontFace = !0, PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, e1, t));
    }
    loadType3Data(e1, t, i) {
        if (this.#ae) return this.#ae;
        const { font: n, type3Dependencies: a } = this;
        assert$1(n.isType3Font, "Must be a Type3 font.");
        const s = e1.clone({
            ignoreErrors: !1
        }), r = new RefSet(e1.type3FontRefs);
        this.dict.objId && !r.has(this.dict.objId) && r.put(this.dict.objId), s.type3FontRefs = r;
        let o = Promise.resolve();
        const l = this.dict.get("CharProcs"), c = this.dict.get("Resources") || t, h = Object.create(null), [d, u, g, f] = n.bbox, p = g - d, m = f - u, b = Math.hypot(p, m);
        for (const e1 of l.getKeys())o = o.then(()=>{
            const t = l.get(e1), n = new OperatorList;
            return s.getOperatorList({
                stream: t,
                task: i,
                resources: c,
                operatorList: n
            }).then(()=>{
                switch(n.fnArray[0]){
                    case et:
                        this.#se(n, b);
                        break;
                    case Qe:
                        b || this.#re(n);
                }
                h[e1] = n.getIR();
                for (const e1 of n.dependencies)a.add(e1);
            }).catch(function(t) {
                warn$1(`Type3 font resource "${e1}" is not available.`);
                const i = new OperatorList;
                h[e1] = i.getIR();
            });
        });
        return this.#ae = o.then(()=>{
            n.charProcOperatorList = h, this._bbox && (n.isCharBBox = !0, n.bbox = this._bbox);
        }), this.#ae;
    }
    #se(e1, t = NaN) {
        const i = ai.normalizeRect(e1.argsArray[0].slice(2)), n = i[2] - i[0], a = i[3] - i[1], s = Math.hypot(n, a);
        0 === n || 0 === a ? (e1.fnArray.splice(0, 1), e1.argsArray.splice(0, 1)) : (0 === t || Math.round(s / t) >= 10) && (this._bbox ??= [
            1 / 0,
            1 / 0,
            -1 / 0,
            -1 / 0
        ], ai.rectBoundingBox(...i, this._bbox));
        let r = 0, o = e1.length;
        for(; r < o;){
            switch(e1.fnArray[r]){
                case et:
                    break;
                case tt:
                case it:
                case nt:
                case at:
                case st:
                case rt:
                case ot:
                case lt:
                case ct:
                case ht:
                case dt:
                case ut:
                case gt:
                case ue:
                    e1.fnArray.splice(r, 1), e1.argsArray.splice(r, 1), o--;
                    continue;
                case fe:
                    const [t] = e1.argsArray[r];
                    let i = 0, n = t.length;
                    for(; i < n;){
                        const [e1] = t[i];
                        switch(e1){
                            case "TR":
                            case "TR2":
                            case "HT":
                            case "BG":
                            case "BG2":
                            case "UCR":
                            case "UCR2":
                                t.splice(i, 1), n--;
                                continue;
                        }
                        i++;
                    }
            }
            r++;
        }
    }
    #re(e1) {
        let t = 1;
        const i = e1.length;
        for(; t < i;){
            if (e1.fnArray[t] === Ut) {
                const i = e1.argsArray[t][2];
                this._bbox ??= [
                    1 / 0,
                    1 / 0,
                    -1 / 0,
                    -1 / 0
                ], ai.rectBoundingBox(...i, this._bbox);
            }
            t++;
        }
    }
}
class StateManager {
    constructor(e1 = new EvalState){
        this.state = e1, this.stateStack = [];
    }
    save() {
        const e1 = this.state;
        this.stateStack.push(this.state), this.state = e1.clone();
    }
    restore() {
        const e1 = this.stateStack.pop();
        e1 && (this.state = e1);
    }
    transform(e1) {
        this.state.ctm = ai.transform(this.state.ctm, e1);
    }
}
class TextState {
    constructor(){
        this.ctm = new Float32Array(pi), this.fontName = null, this.fontSize = 0, this.loadedName = null, this.font = null, this.fontMatrix = t, this.textMatrix = pi.slice(), this.textLineMatrix = pi.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
    }
    setTextMatrix(e1, t, i, n, a, s) {
        const r = this.textMatrix;
        r[0] = e1, r[1] = t, r[2] = i, r[3] = n, r[4] = a, r[5] = s;
    }
    setTextLineMatrix(e1, t, i, n, a, s) {
        const r = this.textLineMatrix;
        r[0] = e1, r[1] = t, r[2] = i, r[3] = n, r[4] = a, r[5] = s;
    }
    translateTextMatrix(e1, t) {
        const i = this.textMatrix;
        i[4] = i[0] * e1 + i[2] * t + i[4], i[5] = i[1] * e1 + i[3] * t + i[5];
    }
    translateTextLineMatrix(e1, t) {
        const i = this.textLineMatrix;
        i[4] = i[0] * e1 + i[2] * t + i[4], i[5] = i[1] * e1 + i[3] * t + i[5];
    }
    carriageReturn() {
        this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
    }
    clone() {
        const e1 = Object.create(this);
        return e1.textMatrix = this.textMatrix.slice(), e1.textLineMatrix = this.textLineMatrix.slice(), e1.fontMatrix = this.fontMatrix.slice(), e1;
    }
}
class EvalState {
    constructor(){
        this.ctm = new Float32Array(pi), this.font = null, this.textRenderingMode = x, this._fillColorSpace = this._strokeColorSpace = ColorSpaceUtils.gray, this.patternFillColorSpace = null, this.patternStrokeColorSpace = null, this.currentPointX = this.currentPointY = 0, this.pathMinMax = new Float32Array([
            1 / 0,
            1 / 0,
            -1 / 0,
            -1 / 0
        ]), this.pathBuffer = [];
    }
    get fillColorSpace() {
        return this._fillColorSpace;
    }
    set fillColorSpace(e1) {
        this._fillColorSpace = this.patternFillColorSpace = e1;
    }
    get strokeColorSpace() {
        return this._strokeColorSpace;
    }
    set strokeColorSpace(e1) {
        this._strokeColorSpace = this.patternStrokeColorSpace = e1;
    }
    clone({ newPath: e1 = !1 } = {}) {
        const t = Object.create(this);
        return e1 && (t.pathBuffer = [], t.pathMinMax = new Float32Array([
            1 / 0,
            1 / 0,
            -1 / 0,
            -1 / 0
        ])), t;
    }
}
class EvaluatorPreprocessor {
    static get opMap() {
        return shadow$1(this, "opMap", Object.assign(Object.create(null), {
            w: {
                id: oe,
                numArgs: 1,
                variableArgs: !1
            },
            J: {
                id: le,
                numArgs: 1,
                variableArgs: !1
            },
            j: {
                id: ce,
                numArgs: 1,
                variableArgs: !1
            },
            M: {
                id: he,
                numArgs: 1,
                variableArgs: !1
            },
            d: {
                id: de,
                numArgs: 2,
                variableArgs: !1
            },
            ri: {
                id: ue,
                numArgs: 1,
                variableArgs: !1
            },
            i: {
                id: ge,
                numArgs: 1,
                variableArgs: !1
            },
            gs: {
                id: fe,
                numArgs: 1,
                variableArgs: !1
            },
            q: {
                id: pe,
                numArgs: 0,
                variableArgs: !1
            },
            Q: {
                id: me,
                numArgs: 0,
                variableArgs: !1
            },
            cm: {
                id: be,
                numArgs: 6,
                variableArgs: !1
            },
            m: {
                id: ye,
                numArgs: 2,
                variableArgs: !1
            },
            l: {
                id: we,
                numArgs: 2,
                variableArgs: !1
            },
            c: {
                id: Ae,
                numArgs: 6,
                variableArgs: !1
            },
            v: {
                id: xe,
                numArgs: 4,
                variableArgs: !1
            },
            y: {
                id: Se,
                numArgs: 4,
                variableArgs: !1
            },
            h: {
                id: ve,
                numArgs: 0,
                variableArgs: !1
            },
            re: {
                id: Ce,
                numArgs: 4,
                variableArgs: !1
            },
            S: {
                id: ke,
                numArgs: 0,
                variableArgs: !1
            },
            s: {
                id: Te,
                numArgs: 0,
                variableArgs: !1
            },
            f: {
                id: Fe,
                numArgs: 0,
                variableArgs: !1
            },
            F: {
                id: Fe,
                numArgs: 0,
                variableArgs: !1
            },
            "f*": {
                id: Ie,
                numArgs: 0,
                variableArgs: !1
            },
            B: {
                id: Ee,
                numArgs: 0,
                variableArgs: !1
            },
            "B*": {
                id: Me,
                numArgs: 0,
                variableArgs: !1
            },
            b: {
                id: De,
                numArgs: 0,
                variableArgs: !1
            },
            "b*": {
                id: Oe,
                numArgs: 0,
                variableArgs: !1
            },
            n: {
                id: _e,
                numArgs: 0,
                variableArgs: !1
            },
            W: {
                id: Pe,
                numArgs: 0,
                variableArgs: !1
            },
            "W*": {
                id: Re,
                numArgs: 0,
                variableArgs: !1
            },
            BT: {
                id: Be,
                numArgs: 0,
                variableArgs: !1
            },
            ET: {
                id: Ne,
                numArgs: 0,
                variableArgs: !1
            },
            Tc: {
                id: Le,
                numArgs: 1,
                variableArgs: !1
            },
            Tw: {
                id: Ue,
                numArgs: 1,
                variableArgs: !1
            },
            Tz: {
                id: je,
                numArgs: 1,
                variableArgs: !1
            },
            TL: {
                id: $e,
                numArgs: 1,
                variableArgs: !1
            },
            Tf: {
                id: He,
                numArgs: 2,
                variableArgs: !1
            },
            Tr: {
                id: Xe,
                numArgs: 1,
                variableArgs: !1
            },
            Ts: {
                id: qe,
                numArgs: 1,
                variableArgs: !1
            },
            Td: {
                id: ze,
                numArgs: 2,
                variableArgs: !1
            },
            TD: {
                id: We,
                numArgs: 2,
                variableArgs: !1
            },
            Tm: {
                id: Ge,
                numArgs: 6,
                variableArgs: !1
            },
            "T*": {
                id: Ve,
                numArgs: 0,
                variableArgs: !1
            },
            Tj: {
                id: Ke,
                numArgs: 1,
                variableArgs: !1
            },
            TJ: {
                id: Ye,
                numArgs: 1,
                variableArgs: !1
            },
            "'": {
                id: Je,
                numArgs: 1,
                variableArgs: !1
            },
            '"': {
                id: Ze,
                numArgs: 3,
                variableArgs: !1
            },
            d0: {
                id: Qe,
                numArgs: 2,
                variableArgs: !1
            },
            d1: {
                id: et,
                numArgs: 6,
                variableArgs: !1
            },
            CS: {
                id: tt,
                numArgs: 1,
                variableArgs: !1
            },
            cs: {
                id: it,
                numArgs: 1,
                variableArgs: !1
            },
            SC: {
                id: nt,
                numArgs: 4,
                variableArgs: !0
            },
            SCN: {
                id: at,
                numArgs: 33,
                variableArgs: !0
            },
            sc: {
                id: st,
                numArgs: 4,
                variableArgs: !0
            },
            scn: {
                id: rt,
                numArgs: 33,
                variableArgs: !0
            },
            G: {
                id: ot,
                numArgs: 1,
                variableArgs: !1
            },
            g: {
                id: lt,
                numArgs: 1,
                variableArgs: !1
            },
            RG: {
                id: ct,
                numArgs: 3,
                variableArgs: !1
            },
            rg: {
                id: ht,
                numArgs: 3,
                variableArgs: !1
            },
            K: {
                id: dt,
                numArgs: 4,
                variableArgs: !1
            },
            k: {
                id: ut,
                numArgs: 4,
                variableArgs: !1
            },
            sh: {
                id: gt,
                numArgs: 1,
                variableArgs: !1
            },
            BI: {
                id: ft,
                numArgs: 0,
                variableArgs: !1
            },
            ID: {
                id: pt,
                numArgs: 0,
                variableArgs: !1
            },
            EI: {
                id: mt,
                numArgs: 1,
                variableArgs: !1
            },
            Do: {
                id: bt,
                numArgs: 1,
                variableArgs: !1
            },
            MP: {
                id: yt,
                numArgs: 1,
                variableArgs: !1
            },
            DP: {
                id: wt,
                numArgs: 2,
                variableArgs: !1
            },
            BMC: {
                id: At,
                numArgs: 1,
                variableArgs: !1
            },
            BDC: {
                id: xt,
                numArgs: 2,
                variableArgs: !1
            },
            EMC: {
                id: St,
                numArgs: 0,
                variableArgs: !1
            },
            BX: {
                id: vt,
                numArgs: 0,
                variableArgs: !1
            },
            EX: {
                id: Ct,
                numArgs: 0,
                variableArgs: !1
            },
            BM: null,
            BD: null,
            true: null,
            fa: null,
            fal: null,
            fals: null,
            false: null,
            nu: null,
            nul: null,
            null: null
        }));
    }
    static MAX_INVALID_PATH_OPS = 10;
    constructor(e1, t, i = new StateManager){
        this.parser = new Parser({
            lexer: new Lexer(e1, EvaluatorPreprocessor.opMap),
            xref: t
        }), this.stateManager = i, this.nonProcessedArgs = [], this._isPathOp = !1, this._numInvalidPathOPS = 0;
    }
    get savedStatesDepth() {
        return this.stateManager.stateStack.length;
    }
    read(e1) {
        let t = e1.args;
        for(;;){
            const i = this.parser.getObj();
            if (i instanceof Cmd) {
                const n = i.cmd, a = EvaluatorPreprocessor.opMap[n];
                if (!a) {
                    warn$1(`Unknown command "${n}".`);
                    continue;
                }
                const s = a.id, r = a.numArgs;
                let o = null !== t ? t.length : 0;
                if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = s >= ye && s <= _e, a.variableArgs) o > r && info$1(`Command ${n}: expected [0, ${r}] args, but received ${o} args.`);
                else {
                    if (o !== r) {
                        const e1 = this.nonProcessedArgs;
                        for(; o > r;)e1.push(t.shift()), o--;
                        for(; o < r && 0 !== e1.length;)null === t && (t = []), t.unshift(e1.pop()), o++;
                    }
                    if (o < r) {
                        const e1 = `command ${n}: expected ${r} args, but received ${o} args.`;
                        if (this._isPathOp && ++this._numInvalidPathOPS > EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) throw new ti(`Invalid ${e1}`);
                        warn$1(`Skipping ${e1}`), null !== t && (t.length = 0);
                        continue;
                    }
                }
                return this.preprocessCommand(s, t), e1.fn = s, e1.args = t, !0;
            }
            if (i === ci) return !1;
            if (null !== i && (null === t && (t = []), t.push(i), t.length > 33)) throw new ti("Too many arguments");
        }
    }
    preprocessCommand(e1, t) {
        switch(0 | e1){
            case pe:
                this.stateManager.save();
                break;
            case me:
                this.stateManager.restore();
                break;
            case be:
                this.stateManager.transform(t);
        }
    }
}
class DefaultAppearanceEvaluator extends EvaluatorPreprocessor {
    constructor(e1){
        super(new StringStream(e1));
    }
    parse() {
        const e1 = {
            fn: 0,
            args: []
        }, t = {
            fontSize: 0,
            fontName: "",
            fontColor: new Uint8ClampedArray(3)
        };
        try {
            for(; e1.args.length = 0, this.read(e1);){
                if (0 !== this.savedStatesDepth) continue;
                const { fn: i, args: n } = e1;
                switch(0 | i){
                    case He:
                        const [e2, i1] = n;
                        e2 instanceof Name && (t.fontName = e2.name), "number" == typeof i1 && i1 > 0 && (t.fontSize = i1);
                        break;
                    case ht:
                        ColorSpaceUtils.rgb.getRgbItem(n, 0, t.fontColor, 0);
                        break;
                    case lt:
                        ColorSpaceUtils.gray.getRgbItem(n, 0, t.fontColor, 0);
                        break;
                    case ut:
                        ColorSpaceUtils.cmyk.getRgbItem(n, 0, t.fontColor, 0);
                }
            }
        } catch (e1) {
            warn$1(`parseDefaultAppearance - ignoring errors: "${e1}".`);
        }
        return t;
    }
}
function parseDefaultAppearance(e1) {
    return new DefaultAppearanceEvaluator(e1).parse();
}
class AppearanceStreamEvaluator extends EvaluatorPreprocessor {
    constructor(e1, t, i, n){
        super(e1), this.stream = e1, this.evaluatorOptions = t, this.xref = i, this.globalColorSpaceCache = n, this.resources = e1.dict?.get("Resources");
    }
    parse() {
        const e1 = {
            fn: 0,
            args: []
        };
        let t = {
            scaleFactor: 1,
            fontSize: 0,
            fontName: "",
            fontColor: new Uint8ClampedArray(3),
            fillColorSpace: ColorSpaceUtils.gray
        }, i = !1;
        const n = [];
        try {
            for(; e1.args.length = 0, !i && this.read(e1);){
                const { fn: a, args: s } = e1;
                switch(0 | a){
                    case pe:
                        n.push({
                            scaleFactor: t.scaleFactor,
                            fontSize: t.fontSize,
                            fontName: t.fontName,
                            fontColor: t.fontColor.slice(),
                            fillColorSpace: t.fillColorSpace
                        });
                        break;
                    case me:
                        t = n.pop() || t;
                        break;
                    case Ge:
                        t.scaleFactor *= Math.hypot(s[0], s[1]);
                        break;
                    case He:
                        const [e2, a1] = s;
                        e2 instanceof Name && (t.fontName = e2.name), "number" == typeof a1 && a1 > 0 && (t.fontSize = a1 * t.scaleFactor);
                        break;
                    case it:
                        t.fillColorSpace = ColorSpaceUtils.parse({
                            cs: s[0],
                            xref: this.xref,
                            resources: this.resources,
                            pdfFunctionFactory: this._pdfFunctionFactory,
                            globalColorSpaceCache: this.globalColorSpaceCache,
                            localColorSpaceCache: this._localColorSpaceCache
                        });
                        break;
                    case st:
                        t.fillColorSpace.getRgbItem(s, 0, t.fontColor, 0);
                        break;
                    case ht:
                        ColorSpaceUtils.rgb.getRgbItem(s, 0, t.fontColor, 0);
                        break;
                    case lt:
                        ColorSpaceUtils.gray.getRgbItem(s, 0, t.fontColor, 0);
                        break;
                    case ut:
                        ColorSpaceUtils.cmyk.getRgbItem(s, 0, t.fontColor, 0);
                        break;
                    case Ke:
                    case Ye:
                    case Je:
                    case Ze:
                        i = !0;
                }
            }
        } catch (e1) {
            warn$1(`parseAppearanceStream - ignoring errors: "${e1}".`);
        }
        return this.stream.reset(), delete t.scaleFactor, delete t.fillColorSpace, t;
    }
    get _localColorSpaceCache() {
        return shadow$1(this, "_localColorSpaceCache", new LocalColorSpaceCache);
    }
    get _pdfFunctionFactory() {
        return shadow$1(this, "_pdfFunctionFactory", new PDFFunctionFactory({
            xref: this.xref,
            isEvalSupported: this.evaluatorOptions.isEvalSupported
        }));
    }
}
function getPdfColor(e1, t) {
    if (e1[0] === e1[1] && e1[1] === e1[2]) {
        return `${numberToString(e1[0] / 255)} ${t ? "g" : "G"}`;
    }
    return Array.from(e1, (e1)=>numberToString(e1 / 255)).join(" ") + " " + (t ? "rg" : "RG");
}
class FakeUnicodeFont {
    constructor(e1, t){
        this.xref = e1, this.widths = null, this.firstChar = 1 / 0, this.lastChar = -1 / 0, this.fontFamily = t;
        const i = new OffscreenCanvas(1, 1);
        this.ctxMeasure = i.getContext("2d", {
            willReadFrequently: !0
        }), FakeUnicodeFont._fontNameId || (FakeUnicodeFont._fontNameId = 1), this.fontName = Name.get(`InvalidPDFjsFont_${t}_${FakeUnicodeFont._fontNameId++}`);
    }
    get fontDescriptorRef() {
        if (!FakeUnicodeFont._fontDescriptorRef) {
            const e1 = new Dict(this.xref);
            e1.setIfName("Type", "FontDescriptor"), e1.set("FontName", this.fontName), e1.set("FontFamily", "MyriadPro Regular"), e1.set("FontBBox", [
                0,
                0,
                0,
                0
            ]), e1.setIfName("FontStretch", "Normal"), e1.set("FontWeight", 400), e1.set("ItalicAngle", 0), FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(e1);
        }
        return FakeUnicodeFont._fontDescriptorRef;
    }
    get descendantFontRef() {
        const e1 = new Dict(this.xref);
        e1.set("BaseFont", this.fontName), e1.setIfName("Type", "Font"), e1.setIfName("Subtype", "CIDFontType0"), e1.setIfName("CIDToGIDMap", "Identity"), e1.set("FirstChar", this.firstChar), e1.set("LastChar", this.lastChar), e1.set("FontDescriptor", this.fontDescriptorRef), e1.set("DW", 1e3);
        const t = [], i = [
            ...this.widths.entries()
        ].sort();
        let n = null, a = null;
        for (const [e1, s] of i)n ? e1 === n + a.length ? a.push(s) : (t.push(n, a), n = e1, a = [
            s
        ]) : (n = e1, a = [
            s
        ]);
        n && t.push(n, a), e1.set("W", t);
        const s = new Dict(this.xref);
        return s.set("Ordering", "Identity"), s.set("Registry", "Adobe"), s.set("Supplement", 0), e1.set("CIDSystemInfo", s), this.xref.getNewPersistentRef(e1);
    }
    get baseFontRef() {
        const e1 = new Dict(this.xref);
        return e1.set("BaseFont", this.fontName), e1.setIfName("Type", "Font"), e1.setIfName("Subtype", "Type0"), e1.setIfName("Encoding", "Identity-H"), e1.set("DescendantFonts", [
            this.descendantFontRef
        ]), e1.setIfName("ToUnicode", "Identity-H"), this.xref.getNewPersistentRef(e1);
    }
    get resources() {
        const e1 = new Dict(this.xref), t = new Dict(this.xref);
        return t.set(this.fontName.name, this.baseFontRef), e1.set("Font", t), e1;
    }
    _createContext() {
        return this.widths = new Map, this.ctxMeasure.font = `1000px ${this.fontFamily}`, this.ctxMeasure;
    }
    createFontResources(e1) {
        const t = this._createContext();
        for (const i of e1.split(/\r\n?|\n/))for (const e1 of i.split("")){
            const i = e1.charCodeAt(0);
            if (this.widths.has(i)) continue;
            const n = t.measureText(e1), a = Math.ceil(n.width);
            this.widths.set(i, a), this.firstChar = Math.min(i, this.firstChar), this.lastChar = Math.max(i, this.lastChar);
        }
        return this.resources;
    }
    static getFirstPositionInfo(e1, t, a) {
        const [s, r, o, l] = e1;
        let c = o - s, h = l - r;
        t % 180 != 0 && ([c, h] = [
            h,
            c
        ]);
        const d = i * a;
        return {
            coords: [
                0,
                h + n * a - d
            ],
            bbox: [
                0,
                0,
                c,
                h
            ],
            matrix: 0 !== t ? getRotationMatrix(t, h, d) : void 0
        };
    }
    createAppearance(e1, t, a, s, r, o) {
        const l = this._createContext(), c = [];
        let h = -1 / 0;
        for (const t of e1.split(/\r\n?|\n/)){
            c.push(t);
            const e1 = l.measureText(t).width;
            h = Math.max(h, e1);
            for (const e1 of codePointIter(t)){
                const t = String.fromCodePoint(e1);
                let i = this.widths.get(e1);
                if (void 0 === i) {
                    const n = l.measureText(t);
                    i = Math.ceil(n.width), this.widths.set(e1, i), this.firstChar = Math.min(e1, this.firstChar), this.lastChar = Math.max(e1, this.lastChar);
                }
            }
        }
        h *= s / 1e3;
        const [d, u, g, f] = t;
        let p = g - d, m = f - u;
        a % 180 != 0 && ([p, m] = [
            m,
            p
        ]);
        let b = 1;
        h > p && (b = p / h);
        let y = 1;
        const w = i * s, x = n * s, S = w * c.length;
        S > m && (y = m / S);
        const v = s * Math.min(b, y), C = [
            "q",
            `0 0 ${numberToString(p)} ${numberToString(m)} re W n`,
            "BT",
            `1 0 0 1 0 ${numberToString(m + x)} Tm 0 Tc ${getPdfColor(r, !0)}`,
            `/${this.fontName.name} ${numberToString(v)} Tf`
        ], { resources: k } = this;
        if (1 !== (o = "number" == typeof o && o >= 0 && o <= 1 ? o : 1)) {
            C.push("/R0 gs");
            const e1 = new Dict(this.xref), t = new Dict(this.xref);
            t.set("ca", o), t.set("CA", o), t.setIfName("Type", "ExtGState"), e1.set("R0", t), k.set("ExtGState", e1);
        }
        const T = numberToString(w);
        for (const e1 of c)C.push(`0 -${T} Td <${stringToUTF16HexString(e1)}> Tj`);
        C.push("ET", "Q");
        const F = C.join("\n"), E = new Dict(this.xref);
        if (E.setIfName("Subtype", "Form"), E.setIfName("Type", "XObject"), E.set("BBox", [
            0,
            0,
            p,
            m
        ]), E.set("Length", F.length), E.set("Resources", k), a) {
            const e1 = getRotationMatrix(a, p, m);
            E.set("Matrix", e1);
        }
        const M = new StringStream(F);
        return M.dict = E, M;
    }
}
const Ts = [
    "m/d",
    "m/d/yy",
    "mm/dd/yy",
    "mm/yy",
    "d-mmm",
    "d-mmm-yy",
    "dd-mmm-yy",
    "yy-mm-dd",
    "mmm-yy",
    "mmmm-yy",
    "mmm d, yyyy",
    "mmmm d, yyyy",
    "m/d/yy h:MM tt",
    "m/d/yy HH:MM"
], Fs = [
    "HH:MM",
    "h:MM tt",
    "HH:MM:ss",
    "h:MM:ss tt"
];
class NameOrNumberTree {
    constructor(e1, t, i){
        this.root = e1, this.xref = t, this._type = i;
    }
    getAll() {
        const e1 = new Map;
        if (!this.root) return e1;
        const t = this.xref, i = new RefSet;
        i.put(this.root);
        const n = [
            this.root
        ];
        for(; n.length > 0;){
            const a = t.fetchIfRef(n.shift());
            if (!(a instanceof Dict)) continue;
            if (a.has("Kids")) {
                const e1 = a.get("Kids");
                if (!Array.isArray(e1)) continue;
                for (const t of e1){
                    if (i.has(t)) throw new ti(`Duplicate entry in "${this._type}" tree.`);
                    n.push(t), i.put(t);
                }
                continue;
            }
            const s = a.get(this._type);
            if (Array.isArray(s)) for(let i = 0, n = s.length; i < n; i += 2)e1.set(t.fetchIfRef(s[i]), t.fetchIfRef(s[i + 1]));
        }
        return e1;
    }
    getRaw(e1) {
        if (!this.root) return null;
        const t = this.xref;
        let i = t.fetchIfRef(this.root), n = 0;
        for(; i.has("Kids");){
            if (++n > 10) return warn$1(`Search depth limit reached for "${this._type}" tree.`), null;
            const a = i.get("Kids");
            if (!Array.isArray(a)) return null;
            let s = 0, r = a.length - 1;
            for(; s <= r;){
                const n = s + r >> 1, o = t.fetchIfRef(a[n]), l = o.get("Limits");
                if (e1 < t.fetchIfRef(l[0])) r = n - 1;
                else {
                    if (!(e1 > t.fetchIfRef(l[1]))) {
                        i = o;
                        break;
                    }
                    s = n + 1;
                }
            }
            if (s > r) return null;
        }
        const a = i.get(this._type);
        if (Array.isArray(a)) {
            let i = 0, n = a.length - 2;
            for(; i <= n;){
                const s = i + n >> 1, r = s + (1 & s), o = t.fetchIfRef(a[r]);
                if (e1 < o) n = r - 2;
                else {
                    if (!(e1 > o)) return a[r + 1];
                    i = r + 2;
                }
            }
        }
        return null;
    }
    get(e1) {
        return this.xref.fetchIfRef(this.getRaw(e1));
    }
}
class NameTree extends NameOrNumberTree {
    constructor(e1, t){
        super(e1, t, "Names");
    }
}
class NumberTree extends NameOrNumberTree {
    constructor(e1, t){
        super(e1, t, "Nums");
    }
}
function clearGlobalCaches() {
    ma = Object.create(null), hi = Object.create(null), di = Object.create(null), ui = Object.create(null), xn.clear(), JpxImage.cleanup();
}
function pickPlatformItem(e1) {
    return e1 instanceof Dict ? e1.has("UF") ? e1.get("UF") : e1.has("F") ? e1.get("F") : e1.has("Unix") ? e1.get("Unix") : e1.has("Mac") ? e1.get("Mac") : e1.has("DOS") ? e1.get("DOS") : null : null;
}
class FileSpec {
    #oe = !1;
    constructor(e1, t, i = !1){
        e1 instanceof Dict && (this.xref = t, this.root = e1, e1.has("FS") && (this.fs = e1.get("FS")), e1.has("RF") && warn$1("Related file specifications are not supported"), i || (e1.has("EF") ? this.#oe = !0 : warn$1("Non-embedded file specifications are not supported")));
    }
    get filename() {
        let e1 = "";
        const t = pickPlatformItem(this.root);
        return t && "string" == typeof t && (e1 = stringToPDFString(t, !0).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/")), shadow$1(this, "filename", e1 || "unnamed");
    }
    get content() {
        if (!this.#oe) return null;
        this._contentRef ||= pickPlatformItem(this.root?.get("EF"));
        let e1 = null;
        if (this._contentRef) {
            const t = this.xref.fetchIfRef(this._contentRef);
            t instanceof BaseStream ? e1 = t.getBytes() : warn$1("Embedded file specification points to non-existing/invalid content");
        } else warn$1("Embedded file specification does not have any content");
        return e1;
    }
    get description() {
        let e1 = "";
        const t = this.root?.get("Desc");
        return t && "string" == typeof t && (e1 = stringToPDFString(t)), shadow$1(this, "description", e1);
    }
    get serializable() {
        return {
            rawFilename: this.filename,
            filename: (e1 = this.filename, e1.substring(e1.lastIndexOf("/") + 1)),
            content: this.content,
            description: this.description
        };
        //TURBOPACK unreachable
        ;
        var e1;
    }
}
const Is = 0, Es = -2, Ms = -3, Ds = -4, Os = -5, _s = -6, Rs = -9;
function isWhitespace(e1, t) {
    const i = e1[t];
    return " " === i || "\n" === i || "\r" === i || "\t" === i;
}
class XMLParserBase {
    _resolveEntities(e1) {
        return e1.replaceAll(/&([^;]+);/g, (e1, t)=>{
            if ("#x" === t.substring(0, 2)) return String.fromCodePoint(parseInt(t.substring(2), 16));
            if ("#" === t.substring(0, 1)) return String.fromCodePoint(parseInt(t.substring(1), 10));
            switch(t){
                case "lt":
                    return "<";
                case "gt":
                    return ">";
                case "amp":
                    return "&";
                case "quot":
                    return '"';
                case "apos":
                    return "'";
            }
            return this.onResolveEntity(t);
        });
    }
    _parseContent(e1, t) {
        const i = [];
        let n = t;
        function skipWs() {
            for(; n < e1.length && isWhitespace(e1, n);)++n;
        }
        for(; n < e1.length && !isWhitespace(e1, n) && ">" !== e1[n] && "/" !== e1[n];)++n;
        const a = e1.substring(t, n);
        for(skipWs(); n < e1.length && ">" !== e1[n] && "/" !== e1[n] && "?" !== e1[n];){
            skipWs();
            let t = "", a = "";
            for(; n < e1.length && !isWhitespace(e1, n) && "=" !== e1[n];)t += e1[n], ++n;
            if (skipWs(), "=" !== e1[n]) return null;
            ++n, skipWs();
            const s = e1[n];
            if ('"' !== s && "'" !== s) return null;
            const r = e1.indexOf(s, ++n);
            if (r < 0) return null;
            a = e1.substring(n, r), i.push({
                name: t,
                value: this._resolveEntities(a)
            }), n = r + 1, skipWs();
        }
        return {
            name: a,
            attributes: i,
            parsed: n - t
        };
    }
    _parseProcessingInstruction(e1, t) {
        let i = t;
        for(; i < e1.length && !isWhitespace(e1, i) && ">" !== e1[i] && "?" !== e1[i] && "/" !== e1[i];)++i;
        const n = e1.substring(t, i);
        !function() {
            for(; i < e1.length && isWhitespace(e1, i);)++i;
        }();
        const a = i;
        for(; i < e1.length && ("?" !== e1[i] || ">" !== e1[i + 1]);)++i;
        return {
            name: n,
            value: e1.substring(a, i),
            parsed: i - t
        };
    }
    parseXml(e1) {
        let t = 0;
        for(; t < e1.length;){
            let i = t;
            if ("<" === e1[t]) {
                ++i;
                let t;
                switch(e1[i]){
                    case "/":
                        if (++i, t = e1.indexOf(">", i), t < 0) return void this.onError(Rs);
                        this.onEndElement(e1.substring(i, t)), i = t + 1;
                        break;
                    case "?":
                        ++i;
                        const n = this._parseProcessingInstruction(e1, i);
                        if ("?>" !== e1.substring(i + n.parsed, i + n.parsed + 2)) return void this.onError(Ms);
                        this.onPi(n.name, n.value), i += n.parsed + 2;
                        break;
                    case "!":
                        if ("--" === e1.substring(i + 1, i + 3)) {
                            if (t = e1.indexOf("--\x3e", i + 3), t < 0) return void this.onError(Os);
                            this.onComment(e1.substring(i + 3, t)), i = t + 3;
                        } else if ("[CDATA[" === e1.substring(i + 1, i + 8)) {
                            if (t = e1.indexOf("]]>", i + 8), t < 0) return void this.onError(Es);
                            this.onCdata(e1.substring(i + 8, t)), i = t + 3;
                        } else {
                            if ("DOCTYPE" !== e1.substring(i + 1, i + 8)) return void this.onError(_s);
                            {
                                const n = e1.indexOf("[", i + 8);
                                let a = !1;
                                if (t = e1.indexOf(">", i + 8), t < 0) return void this.onError(Ds);
                                if (n > 0 && t > n) {
                                    if (t = e1.indexOf("]>", i + 8), t < 0) return void this.onError(Ds);
                                    a = !0;
                                }
                                const s = e1.substring(i + 8, t + (a ? 1 : 0));
                                this.onDoctype(s), i = t + (a ? 2 : 1);
                            }
                        }
                        break;
                    default:
                        const a = this._parseContent(e1, i);
                        if (null === a) return void this.onError(_s);
                        let s = !1;
                        if ("/>" === e1.substring(i + a.parsed, i + a.parsed + 2)) s = !0;
                        else if (">" !== e1.substring(i + a.parsed, i + a.parsed + 1)) return void this.onError(Rs);
                        this.onBeginElement(a.name, a.attributes, s), i += a.parsed + (s ? 2 : 1);
                }
            } else {
                for(; i < e1.length && "<" !== e1[i];)i++;
                const n = e1.substring(t, i);
                this.onText(this._resolveEntities(n));
            }
            t = i;
        }
    }
    onResolveEntity(e1) {
        return `&${e1};`;
    }
    onPi(e1, t) {}
    onComment(e1) {}
    onCdata(e1) {}
    onDoctype(e1) {}
    onText(e1) {}
    onBeginElement(e1, t, i) {}
    onEndElement(e1) {}
    onError(e1) {}
}
class SimpleDOMNode {
    constructor(e1, t){
        this.nodeName = e1, this.nodeValue = t, Object.defineProperty(this, "parentNode", {
            value: null,
            writable: !0
        });
    }
    get firstChild() {
        return this.childNodes?.[0];
    }
    get nextSibling() {
        const e1 = this.parentNode.childNodes;
        if (!e1) return;
        const t = e1.indexOf(this);
        return -1 !== t ? e1[t + 1] : void 0;
    }
    get textContent() {
        return this.childNodes ? this.childNodes.map((e1)=>e1.textContent).join("") : this.nodeValue || "";
    }
    get children() {
        return this.childNodes || [];
    }
    hasChildNodes() {
        return this.childNodes?.length > 0;
    }
    searchNode(e1, t) {
        if (t >= e1.length) return this;
        const i = e1[t];
        if (i.name.startsWith("#") && t < e1.length - 1) return this.searchNode(e1, t + 1);
        const n = [];
        let a = this;
        for(;;){
            if (i.name === a.nodeName) {
                if (0 !== i.pos) {
                    if (0 === n.length) return null;
                    {
                        const [s] = n.pop();
                        let r = 0;
                        for (const n of s.childNodes)if (i.name === n.nodeName) {
                            if (r === i.pos) return n.searchNode(e1, t + 1);
                            r++;
                        }
                        return a.searchNode(e1, t + 1);
                    }
                }
                {
                    const i = a.searchNode(e1, t + 1);
                    if (null !== i) return i;
                }
            }
            if (a.childNodes?.length > 0) n.push([
                a,
                0
            ]), a = a.childNodes[0];
            else {
                if (0 === n.length) return null;
                for(; 0 !== n.length;){
                    const [e1, t] = n.pop(), i = t + 1;
                    if (i < e1.childNodes.length) {
                        n.push([
                            e1,
                            i
                        ]), a = e1.childNodes[i];
                        break;
                    }
                }
                if (0 === n.length) return null;
            }
        }
    }
    dump(e1) {
        if ("#text" !== this.nodeName) {
            if (e1.push(`<${this.nodeName}`), this.attributes) for (const t of this.attributes)e1.push(` ${t.name}="${encodeToXmlString(t.value)}"`);
            if (this.hasChildNodes()) {
                e1.push(">");
                for (const t of this.childNodes)t.dump(e1);
                e1.push(`</${this.nodeName}>`);
            } else this.nodeValue ? e1.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`) : e1.push("/>");
        } else e1.push(encodeToXmlString(this.nodeValue));
    }
}
class SimpleXMLParser extends XMLParserBase {
    constructor({ hasAttributes: e1 = !1, lowerCaseName: t = !1 }){
        super(), this._currentFragment = null, this._stack = null, this._errorCode = Is, this._hasAttributes = e1, this._lowerCaseName = t;
    }
    parseFromString(e1) {
        if (this._currentFragment = [], this._stack = [], this._errorCode = Is, this.parseXml(e1), this._errorCode !== Is) return;
        const [t] = this._currentFragment;
        return t ? {
            documentElement: t
        } : void 0;
    }
    onText(e1) {
        if (function(e1) {
            for(let t = 0, i = e1.length; t < i; t++)if (!isWhitespace(e1, t)) return !1;
            return !0;
        }(e1)) return;
        const t = new SimpleDOMNode("#text", e1);
        this._currentFragment.push(t);
    }
    onCdata(e1) {
        const t = new SimpleDOMNode("#text", e1);
        this._currentFragment.push(t);
    }
    onBeginElement(e1, t, i) {
        this._lowerCaseName && (e1 = e1.toLowerCase());
        const n = new SimpleDOMNode(e1);
        n.childNodes = [], this._hasAttributes && (n.attributes = t), this._currentFragment.push(n), i || (this._stack.push(this._currentFragment), this._currentFragment = n.childNodes);
    }
    onEndElement(e1) {
        this._currentFragment = this._stack.pop() || [];
        const t = this._currentFragment.at(-1);
        if (!t) return null;
        for (const e1 of t.childNodes)e1.parentNode = t;
        return t;
    }
    onError(e1) {
        this._errorCode = e1;
    }
}
class MetadataParser {
    constructor(e1){
        e1 = this._repair(e1);
        const t = new SimpleXMLParser({
            lowerCaseName: !0
        }).parseFromString(e1);
        this._metadataMap = new Map, this._data = e1, t && this._parse(t);
    }
    _repair(e1) {
        return e1.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(e1, t) {
            const i = t.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(e1, t, i, n) {
                return String.fromCharCode(64 * t + 8 * i + 1 * n);
            }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(e1, t) {
                switch(t){
                    case "amp":
                        return "&";
                    case "apos":
                        return "'";
                    case "gt":
                        return ">";
                    case "lt":
                        return "<";
                    case "quot":
                        return '"';
                }
                throw new Error(`_repair: ${t} isn't defined.`);
            }), n = [
                ">"
            ];
            for(let e1 = 0, t = i.length; e1 < t; e1 += 2){
                const t = 256 * i.charCodeAt(e1) + i.charCodeAt(e1 + 1);
                t >= 32 && t < 127 && 60 !== t && 62 !== t && 38 !== t ? n.push(String.fromCharCode(t)) : n.push("&#x" + (65536 + t).toString(16).substring(1) + ";");
            }
            return n.join("");
        });
    }
    _getSequence(e1) {
        const t = e1.nodeName;
        return "rdf:bag" !== t && "rdf:seq" !== t && "rdf:alt" !== t ? null : e1.childNodes.filter((e1)=>"rdf:li" === e1.nodeName);
    }
    _parseArray(e1) {
        if (!e1.hasChildNodes()) return;
        const [t] = e1.childNodes, i = this._getSequence(t) || [];
        this._metadataMap.set(e1.nodeName, i.map((e1)=>e1.textContent.trim()));
    }
    _parse(e1) {
        let t = e1.documentElement;
        if ("rdf:rdf" !== t.nodeName) for(t = t.firstChild; t && "rdf:rdf" !== t.nodeName;)t = t.nextSibling;
        if (t && "rdf:rdf" === t.nodeName && t.hasChildNodes()) {
            for (const e1 of t.childNodes)if ("rdf:description" === e1.nodeName) for (const t of e1.childNodes){
                const e1 = t.nodeName;
                switch(e1){
                    case "#text":
                        continue;
                    case "dc:creator":
                    case "dc:subject":
                        this._parseArray(t);
                        continue;
                }
                this._metadataMap.set(e1, t.textContent.trim());
            }
        }
    }
    get serializable() {
        return {
            parsedData: this._metadataMap,
            rawData: this._data
        };
    }
}
const Bs = 1, Ns = 2, Ls = 3, Us = 4, js = 5;
class StructTreeRoot {
    constructor(e1, t, i){
        this.xref = e1, this.dict = t, this.ref = i instanceof Ref ? i : null, this.roleMap = new Map, this.structParentIds = null;
    }
    init() {
        this.readRoleMap();
    }
    #le(e1, t, i) {
        if (!(e1 instanceof Ref) || t < 0) return;
        this.structParentIds ||= new RefSetCache;
        let n = this.structParentIds.get(e1);
        n || (n = [], this.structParentIds.put(e1, n)), n.push([
            t,
            i
        ]);
    }
    addAnnotationIdToPage(e1, t) {
        this.#le(e1, t, Us);
    }
    readRoleMap() {
        const e1 = this.dict.get("RoleMap");
        if (e1 instanceof Dict) for (const [t, i] of e1)i instanceof Name && this.roleMap.set(t, i.name);
    }
    static async canCreateStructureTree({ catalogRef: e1, pdfManager: t, newAnnotationsByPage: i }) {
        if (!(e1 instanceof Ref)) return warn$1("Cannot save the struct tree: no catalog reference."), !1;
        let n = 0, a = !0;
        for (const [e1, s] of i){
            const { ref: i } = await t.getPage(e1);
            if (!(i instanceof Ref)) {
                warn$1(`Cannot save the struct tree: page ${e1} has no ref.`), a = !0;
                break;
            }
            for (const e1 of s)e1.accessibilityData?.type && (e1.parentTreeId = n++, a = !1);
        }
        if (a) {
            for (const e1 of i.values())for (const t of e1)delete t.parentTreeId;
            return !1;
        }
        return !0;
    }
    static async createStructureTree({ newAnnotationsByPage: e1, xref: t, catalogRef: i, pdfManager: n, changes: a }) {
        const s = await n.ensureCatalog("cloneDict"), r = new RefSetCache;
        r.put(i, s);
        const o = t.getNewTemporaryRef();
        s.set("StructTreeRoot", o);
        const l = new Dict(t);
        l.set("Type", Name.get("StructTreeRoot"));
        const c = t.getNewTemporaryRef();
        l.set("ParentTree", c);
        const h = [];
        l.set("K", h), r.put(o, l);
        const d = new Dict(t), u = [];
        d.set("Nums", u);
        const g = await this.#ce({
            newAnnotationsByPage: e1,
            structTreeRootRef: o,
            structTreeRoot: null,
            kids: h,
            nums: u,
            xref: t,
            pdfManager: n,
            changes: a,
            cache: r
        });
        l.set("ParentTreeNextKey", g), r.put(c, d);
        for (const [e1, t] of r.items())a.put(e1, {
            data: t
        });
    }
    async canUpdateStructTree({ pdfManager: e1, newAnnotationsByPage: t }) {
        if (!this.ref) return warn$1("Cannot update the struct tree: no root reference."), !1;
        let i = this.dict.get("ParentTreeNextKey");
        if (!Number.isInteger(i) || i < 0) return warn$1("Cannot update the struct tree: invalid next key."), !1;
        const n = this.dict.get("ParentTree");
        if (!(n instanceof Dict)) return warn$1("Cannot update the struct tree: ParentTree isn't a dict."), !1;
        const a = n.get("Nums");
        if (!Array.isArray(a)) return warn$1("Cannot update the struct tree: nums isn't an array."), !1;
        const s = new NumberTree(n, this.xref);
        for (const i of t.keys()){
            const { pageDict: t } = await e1.getPage(i);
            if (!t.has("StructParents")) continue;
            const n = t.get("StructParents");
            if (!Number.isInteger(n) || !Array.isArray(s.get(n))) return warn$1(`Cannot save the struct tree: page ${i} has a wrong id.`), !1;
        }
        let r = !0;
        for (const [n, a] of t){
            const { pageDict: t } = await e1.getPage(n);
            StructTreeRoot.#he({
                elements: a,
                xref: this.xref,
                pageDict: t,
                numberTree: s
            });
            for (const e1 of a)e1.accessibilityData?.type && (e1.accessibilityData.structParent >= 0 || (e1.parentTreeId = i++), r = !1);
        }
        if (r) {
            for (const e1 of t.values())for (const t of e1)delete t.parentTreeId, delete t.structTreeParent;
            return !1;
        }
        return !0;
    }
    async updateStructureTree({ newAnnotationsByPage: e1, pdfManager: t, changes: i }) {
        const { ref: n, xref: a } = this, s = this.dict.clone(), r = new RefSetCache;
        r.put(n, s);
        let o, l = s.getRaw("ParentTree");
        l instanceof Ref ? o = a.fetch(l) : (o = l, l = a.getNewTemporaryRef(), s.set("ParentTree", l)), o = o.clone(), r.put(l, o);
        let c = o.getRaw("Nums"), h = null;
        c instanceof Ref && (h = c, c = a.fetch(h)), c = c.slice(), h || o.set("Nums", c);
        const d = await StructTreeRoot.#ce({
            newAnnotationsByPage: e1,
            structTreeRootRef: n,
            structTreeRoot: this,
            kids: null,
            nums: c,
            xref: a,
            pdfManager: t,
            changes: i,
            cache: r
        });
        if (-1 !== d) {
            s.set("ParentTreeNextKey", d), h && r.put(h, c);
            for (const [e1, t] of r.items())i.put(e1, {
                data: t
            });
        }
    }
    static async #ce({ newAnnotationsByPage: e1, structTreeRootRef: t, structTreeRoot: i, kids: n, nums: a, xref: s, pdfManager: r, changes: o, cache: l }) {
        const c = Name.get("OBJR");
        let h, d = -1;
        for (const [u, g] of e1){
            const e1 = await r.getPage(u), { ref: f } = e1, p = f instanceof Ref;
            for (const { accessibilityData: r, ref: m, parentTreeId: b, structTreeParent: y } of g){
                if (!r?.type) continue;
                const { structParent: g } = r;
                if (i && Number.isInteger(g) && g >= 0) {
                    let t = (h ||= new Map).get(u);
                    if (void 0 === t) {
                        t = new StructTreePage(i, e1.pageDict).collectObjects(f), h.set(u, t);
                    }
                    const n = t?.get(g);
                    if (n) {
                        const e1 = s.fetch(n).clone();
                        StructTreeRoot.#de(e1, r), o.put(n, {
                            data: e1
                        });
                        continue;
                    }
                }
                d = Math.max(d, b);
                const w = s.getNewTemporaryRef(), x = new Dict(s);
                StructTreeRoot.#de(x, r), await this.#ue({
                    structTreeParent: y,
                    tagDict: x,
                    newTagRef: w,
                    structTreeRootRef: t,
                    fallbackKids: n,
                    xref: s,
                    cache: l
                });
                const S = new Dict(s);
                x.set("K", S), S.set("Type", c), p && S.set("Pg", f), S.set("Obj", m), l.put(w, x), a.push(b, w);
            }
        }
        return d + 1;
    }
    static #de(e1, { type: t, title: i, lang: n, alt: a, expanded: s, actualText: r }) {
        e1.set("S", Name.get(t)), i && e1.set("T", stringToAsciiOrUTF16BE(i)), n && e1.set("Lang", stringToAsciiOrUTF16BE(n)), a && e1.set("Alt", stringToAsciiOrUTF16BE(a)), s && e1.set("E", stringToAsciiOrUTF16BE(s)), r && e1.set("ActualText", stringToAsciiOrUTF16BE(r));
    }
    static #he({ elements: e1, xref: t, pageDict: i, numberTree: n }) {
        const a = new Map;
        for (const t of e1)if (t.structTreeParentId) {
            const e1 = parseInt(t.structTreeParentId.split("_mc")[1], 10);
            let i = a.get(e1);
            i || (i = [], a.set(e1, i)), i.push(t);
        }
        const s = i.get("StructParents");
        if (!Number.isInteger(s)) return;
        const r = n.get(s), updateElement = (e1, i, n)=>{
            const s = a.get(e1);
            if (s) {
                const e1 = i.getRaw("P"), a = t.fetchIfRef(e1);
                if (e1 instanceof Ref && a instanceof Dict) {
                    const e1 = {
                        ref: n,
                        dict: i
                    };
                    for (const t of s)t.structTreeParent = e1;
                }
                return !0;
            }
            return !1;
        };
        for (const e1 of r){
            if (!(e1 instanceof Ref)) continue;
            const i = t.fetch(e1), n = i.get("K");
            if (Number.isInteger(n)) updateElement(n, i, e1);
            else if (Array.isArray(n)) for (let a of n){
                if (a = t.fetchIfRef(a), Number.isInteger(a) && updateElement(a, i, e1)) break;
                if (!(a instanceof Dict)) continue;
                if (!isName(a.get("Type"), "MCR")) break;
                const n = a.get("MCID");
                if (Number.isInteger(n) && updateElement(n, i, e1)) break;
            }
        }
    }
    static async #ue({ structTreeParent: e1, tagDict: t, newTagRef: i, structTreeRootRef: n, fallbackKids: a, xref: s, cache: r }) {
        let o, l = null;
        e1 ? ({ ref: l } = e1, o = e1.dict.getRaw("P") || n) : o = n, t.set("P", o);
        const c = s.fetchIfRef(o);
        if (!c) return void a.push(i);
        let h = r.get(o);
        h || (h = c.clone(), r.put(o, h));
        const d = h.getRaw("K");
        let u = d instanceof Ref ? r.get(d) : null;
        if (!u) {
            u = s.fetchIfRef(d), u = Array.isArray(u) ? u.slice() : [
                d
            ];
            const e1 = s.getNewTemporaryRef();
            h.set("K", e1), r.put(e1, u);
        }
        const g = u.indexOf(l);
        u.splice(g >= 0 ? g + 1 : u.length, 0, i);
    }
}
class StructElementNode {
    constructor(e1, t){
        this.tree = e1, this.xref = e1.xref, this.dict = t, this.kids = [], this.parseKids();
    }
    get role() {
        const e1 = this.dict.get("S"), t = e1 instanceof Name ? e1.name : "", { root: i } = this.tree;
        return i.roleMap.get(t) ?? t;
    }
    parseKids() {
        let e1 = null;
        const t = this.dict.getRaw("Pg");
        t instanceof Ref && (e1 = t.toString());
        const i = this.dict.get("K");
        if (Array.isArray(i)) for (const t of i){
            const i = this.parseKid(e1, this.xref.fetchIfRef(t));
            i && this.kids.push(i);
        }
        else {
            const t = this.parseKid(e1, i);
            t && this.kids.push(t);
        }
    }
    parseKid(e1, t) {
        if (Number.isInteger(t)) return this.tree.pageDict.objId !== e1 ? null : new StructElement({
            type: Bs,
            mcid: t,
            pageObjId: e1
        });
        if (!(t instanceof Dict)) return null;
        const i = t.getRaw("Pg");
        i instanceof Ref && (e1 = i.toString());
        const n = t.get("Type") instanceof Name ? t.get("Type").name : null;
        if ("MCR" === n) {
            if (this.tree.pageDict.objId !== e1) return null;
            const i = t.getRaw("Stm");
            return new StructElement({
                type: Ns,
                refObjId: i instanceof Ref ? i.toString() : null,
                pageObjId: e1,
                mcid: t.get("MCID")
            });
        }
        if ("OBJR" === n) {
            if (this.tree.pageDict.objId !== e1) return null;
            const i = t.getRaw("Obj");
            return new StructElement({
                type: Ls,
                refObjId: i instanceof Ref ? i.toString() : null,
                pageObjId: e1
            });
        }
        return new StructElement({
            type: js,
            dict: t
        });
    }
}
class StructElement {
    constructor({ type: e1, dict: t = null, mcid: i = null, pageObjId: n = null, refObjId: a = null }){
        this.type = e1, this.dict = t, this.mcid = i, this.pageObjId = n, this.refObjId = a, this.parentNode = null;
    }
}
class StructTreePage {
    constructor(e1, t){
        this.root = e1, this.xref = e1?.xref ?? null, this.rootDict = e1?.dict ?? null, this.pageDict = t, this.nodes = [];
    }
    collectObjects(e1) {
        if (!(this.root && this.rootDict && e1 instanceof Ref)) return null;
        const t = this.rootDict.get("ParentTree");
        if (!t) return null;
        const i = this.root.structParentIds?.get(e1);
        if (!i) return null;
        const n = new Map, a = new NumberTree(t, this.xref);
        for (const [e1] of i){
            const t = a.getRaw(e1);
            t instanceof Ref && n.set(e1, t);
        }
        return n;
    }
    parse(e1) {
        if (!(this.root && this.rootDict && e1 instanceof Ref)) return;
        const t = this.rootDict.get("ParentTree");
        if (!t) return;
        const i = this.pageDict.get("StructParents"), n = this.root.structParentIds?.get(e1);
        if (!Number.isInteger(i) && !n) return;
        const a = new Map, s = new NumberTree(t, this.xref);
        if (Number.isInteger(i)) {
            const e1 = s.get(i);
            if (Array.isArray(e1)) for (const t of e1)t instanceof Ref && this.addNode(this.xref.fetch(t), a);
        }
        if (n) for (const [e1, t] of n){
            const i = s.get(e1);
            if (i) {
                const e1 = this.addNode(this.xref.fetchIfRef(i), a);
                1 === e1?.kids?.length && e1.kids[0].type === Ls && (e1.kids[0].type = t);
            }
        }
    }
    addNode(e1, t, i = 0) {
        if (i > 40) return warn$1("StructTree MAX_DEPTH reached."), null;
        if (!(e1 instanceof Dict)) return null;
        if (t.has(e1)) return t.get(e1);
        const n = new StructElementNode(this, e1);
        t.set(e1, n);
        const a = e1.get("P");
        if (!(a instanceof Dict) || isName(a.get("Type"), "StructTreeRoot")) return this.addTopLevelNode(e1, n) || t.delete(e1), n;
        const s = this.addNode(a, t, i + 1);
        if (!s) return n;
        let r = !1;
        for (const t of s.kids)t.type === js && t.dict === e1 && (t.parentNode = n, r = !0);
        return r || t.delete(e1), n;
    }
    addTopLevelNode(e1, t) {
        const i = this.rootDict.get("K");
        if (!i) return !1;
        if (i instanceof Dict) return i.objId === e1.objId && (this.nodes[0] = t, !0);
        if (!Array.isArray(i)) return !0;
        let n = !1;
        for(let a = 0; a < i.length; a++){
            const s = i[a];
            s?.toString() === e1.objId && (this.nodes[a] = t, n = !0);
        }
        return n;
    }
    get serializable() {
        function nodeToSerializable(e1, t, i = 0) {
            if (i > 40) return void warn$1("StructTree too deep to be fully serialized.");
            const n = Object.create(null);
            n.role = e1.role, n.children = [], t.children.push(n);
            let a = e1.dict.get("Alt");
            "string" != typeof a && (a = e1.dict.get("ActualText")), "string" == typeof a && (n.alt = stringToPDFString(a));
            const s = e1.dict.get("A");
            if (s instanceof Dict) {
                const e1 = lookupNormalRect(s.getArray("BBox"), null);
                if (e1) n.bbox = e1;
                else {
                    const e1 = s.get("Width"), t = s.get("Height");
                    "number" == typeof e1 && e1 > 0 && "number" == typeof t && t > 0 && (n.bbox = [
                        0,
                        0,
                        e1,
                        t
                    ]);
                }
            }
            const r = e1.dict.get("Lang");
            "string" == typeof r && (n.lang = stringToPDFString(r));
            for (const t of e1.kids){
                const e1 = t.type === js ? t.parentNode : null;
                e1 ? nodeToSerializable(e1, n, i + 1) : t.type === Bs || t.type === Ns ? n.children.push({
                    type: "content",
                    id: `p${t.pageObjId}_mc${t.mcid}`
                }) : t.type === Ls ? n.children.push({
                    type: "object",
                    id: t.refObjId
                }) : t.type === Us && n.children.push({
                    type: "annotation",
                    id: `pdfjs_internal_id_${t.refObjId}`
                });
            }
        }
        const e1 = Object.create(null);
        e1.children = [], e1.role = "Root";
        for (const t of this.nodes)t && nodeToSerializable(t, e1);
        return e1;
    }
}
const $s = (function(e1, t, i) {
    if (!Array.isArray(i) || i.length < 2) return !1;
    const [n, a, ...s] = i;
    if (!e1(n) && !Number.isInteger(n)) return !1;
    if (!t(a)) return !1;
    const r = s.length;
    let o = !0;
    switch(a.name){
        case "XYZ":
            if (r < 2 || r > 3) return !1;
            break;
        case "Fit":
        case "FitB":
            return 0 === r;
        case "FitH":
        case "FitBH":
        case "FitV":
        case "FitBV":
            if (r > 1) return !1;
            break;
        case "FitR":
            if (4 !== r) return !1;
            o = !1;
            break;
        default:
            return !1;
    }
    for (const e1 of s)if (!("number" == typeof e1 || o && null === e1)) return !1;
    return !0;
}).bind(null, (e1)=>e1 instanceof Ref, isName);
function fetchDest(e1) {
    return e1 instanceof Dict && (e1 = e1.get("D")), $s(e1) ? e1 : null;
}
function fetchRemoteDest(e1) {
    let t = e1.get("D");
    if (t) {
        if (t instanceof Name && (t = t.name), "string" == typeof t) return stringToPDFString(t, !0);
        if ($s(t)) return JSON.stringify(t);
    }
    return null;
}
class Catalog {
    #ge = null;
    #fe = null;
    builtInCMapCache = new Map;
    fontCache = new RefSetCache;
    globalColorSpaceCache = new GlobalColorSpaceCache;
    globalImageCache = new GlobalImageCache;
    nonBlendModesSet = new RefSet;
    pageDictCache = new RefSetCache;
    pageIndexCache = new RefSetCache;
    pageKidsCountCache = new RefSetCache;
    standardFontDataCache = new Map;
    systemFontCache = new Map;
    constructor(e1, t){
        if (this.pdfManager = e1, this.xref = t, this.#fe = t.getCatalogObj(), !(this.#fe instanceof Dict)) throw new ti("Catalog object is not a dictionary.");
        this.toplevelPagesDict;
    }
    cloneDict() {
        return this.#fe.clone();
    }
    get version() {
        const e1 = this.#fe.get("Version");
        if (e1 instanceof Name) {
            if (gi.test(e1.name)) return shadow$1(this, "version", e1.name);
            warn$1(`Invalid PDF catalog version: ${e1.name}`);
        }
        return shadow$1(this, "version", null);
    }
    get lang() {
        const e1 = this.#fe.get("Lang");
        return shadow$1(this, "lang", e1 && "string" == typeof e1 ? stringToPDFString(e1) : null);
    }
    get needsRendering() {
        const e1 = this.#fe.get("NeedsRendering");
        return shadow$1(this, "needsRendering", "boolean" == typeof e1 && e1);
    }
    get collection() {
        let e1 = null;
        try {
            const t = this.#fe.get("Collection");
            t instanceof Dict && t.size > 0 && (e1 = t);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info$1("Cannot fetch Collection entry; assuming no collection is present.");
        }
        return shadow$1(this, "collection", e1);
    }
    get acroForm() {
        let e1 = null;
        try {
            const t = this.#fe.get("AcroForm");
            t instanceof Dict && t.size > 0 && (e1 = t);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info$1("Cannot fetch AcroForm entry; assuming no forms are present.");
        }
        return shadow$1(this, "acroForm", e1);
    }
    get acroFormRef() {
        const e1 = this.#fe.getRaw("AcroForm");
        return shadow$1(this, "acroFormRef", e1 instanceof Ref ? e1 : null);
    }
    get metadata() {
        const e1 = this.#fe.getRaw("Metadata");
        if (!(e1 instanceof Ref)) return shadow$1(this, "metadata", null);
        let t = null;
        try {
            const i = this.xref.fetch(e1, !this.xref.encrypt?.encryptMetadata);
            if (i instanceof BaseStream && i.dict instanceof Dict) {
                const e1 = i.dict.get("Type"), n = i.dict.get("Subtype");
                if (isName(e1, "Metadata") && isName(n, "XML")) {
                    const e1 = stringToUTF8String$1(i.getString());
                    e1 && (t = new MetadataParser(e1).serializable);
                }
            }
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info$1(`Skipping invalid Metadata: "${e1}".`);
        }
        return shadow$1(this, "metadata", t);
    }
    get markInfo() {
        let e1 = null;
        try {
            e1 = this.#pe();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn$1("Unable to read mark info.");
        }
        return shadow$1(this, "markInfo", e1);
    }
    #pe() {
        const e1 = this.#fe.get("MarkInfo");
        if (!(e1 instanceof Dict)) return null;
        const t = {
            Marked: !1,
            UserProperties: !1,
            Suspects: !1
        };
        for(const i in t){
            const n = e1.get(i);
            "boolean" == typeof n && (t[i] = n);
        }
        return t;
    }
    get structTreeRoot() {
        let e1 = null;
        try {
            e1 = this.#me();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn$1("Unable read to structTreeRoot info.");
        }
        return shadow$1(this, "structTreeRoot", e1);
    }
    #me() {
        const e1 = this.#fe.getRaw("StructTreeRoot"), t = this.xref.fetchIfRef(e1);
        if (!(t instanceof Dict)) return null;
        const i = new StructTreeRoot(this.xref, t, e1);
        return i.init(), i;
    }
    get toplevelPagesDict() {
        const e1 = this.#fe.get("Pages");
        if (!(e1 instanceof Dict)) throw new ti("Invalid top-level pages dictionary.");
        return shadow$1(this, "toplevelPagesDict", e1);
    }
    get documentOutline() {
        let e1 = null;
        try {
            e1 = this.#be();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn$1("Unable to read document outline.");
        }
        return shadow$1(this, "documentOutline", e1);
    }
    #be() {
        let e1 = this.#fe.get("Outlines");
        if (!(e1 instanceof Dict)) return null;
        if (e1 = e1.getRaw("First"), !(e1 instanceof Ref)) return null;
        const t = {
            items: []
        }, i = [
            {
                obj: e1,
                parent: t
            }
        ], n = new RefSet;
        n.put(e1);
        const a = this.xref, s = new Uint8ClampedArray(3);
        for(; i.length > 0;){
            const t = i.shift(), r = a.fetchIfRef(t.obj);
            if (null === r) continue;
            r.has("Title") || warn$1("Invalid outline item encountered.");
            const o = {
                url: null,
                dest: null,
                action: null
            };
            Catalog.parseDestDictionary({
                destDict: r,
                resultObj: o,
                docBaseUrl: this.baseUrl,
                docAttachments: this.attachments
            });
            const l = r.get("Title"), c = r.get("F") || 0, h = r.getArray("C"), d = r.get("Count");
            let u = s;
            !isNumberArray(h, 3) || 0 === h[0] && 0 === h[1] && 0 === h[2] || (u = ColorSpaceUtils.rgb.getRgb(h, 0));
            const g = {
                action: o.action,
                attachment: o.attachment,
                dest: o.dest,
                url: o.url,
                unsafeUrl: o.unsafeUrl,
                newWindow: o.newWindow,
                setOCGState: o.setOCGState,
                title: "string" == typeof l ? stringToPDFString(l) : "",
                color: u,
                count: Number.isInteger(d) ? d : void 0,
                bold: !!(2 & c),
                italic: !!(1 & c),
                items: []
            };
            t.parent.items.push(g), e1 = r.getRaw("First"), e1 instanceof Ref && !n.has(e1) && (i.push({
                obj: e1,
                parent: g
            }), n.put(e1)), e1 = r.getRaw("Next"), e1 instanceof Ref && !n.has(e1) && (i.push({
                obj: e1,
                parent: t.parent
            }), n.put(e1));
        }
        return t.items.length > 0 ? t.items : null;
    }
    get permissions() {
        let e1 = null;
        try {
            e1 = this.#ye();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn$1("Unable to read permissions.");
        }
        return shadow$1(this, "permissions", e1);
    }
    #ye() {
        const e1 = this.xref.trailer.get("Encrypt");
        if (!(e1 instanceof Dict)) return null;
        let t = e1.get("P");
        if ("number" != typeof t) return null;
        t += 2 ** 32;
        const i = [];
        for(const e1 in w){
            const n = w[e1];
            t & n && i.push(n);
        }
        return i;
    }
    get optionalContentConfig() {
        let e1 = null;
        try {
            const t = this.#fe.get("OCProperties");
            if (!t) return shadow$1(this, "optionalContentConfig", null);
            const i = t.get("D");
            if (!i) return shadow$1(this, "optionalContentConfig", null);
            const n = t.get("OCGs");
            if (!Array.isArray(n)) return shadow$1(this, "optionalContentConfig", null);
            const a = new RefSetCache;
            for (const e1 of n)e1 instanceof Ref && !a.has(e1) && a.put(e1, this.#we(e1));
            e1 = this.#Ae(i, a);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn$1(`Unable to read optional content config: ${e1}`);
        }
        return shadow$1(this, "optionalContentConfig", e1);
    }
    #we(e1) {
        const t = this.xref.fetch(e1), i = {
            id: e1.toString(),
            name: null,
            intent: null,
            usage: {
                print: null,
                view: null
            },
            rbGroups: []
        }, n = t.get("Name");
        "string" == typeof n && (i.name = stringToPDFString(n));
        let a = t.getArray("Intent");
        Array.isArray(a) || (a = [
            a
        ]), a.every((e1)=>e1 instanceof Name) && (i.intent = a.map((e1)=>e1.name));
        const s = t.get("Usage");
        if (!(s instanceof Dict)) return i;
        const r = i.usage, o = s.get("Print");
        if (o instanceof Dict) {
            const e1 = o.get("PrintState");
            if (e1 instanceof Name) switch(e1.name){
                case "ON":
                case "OFF":
                    r.print = {
                        printState: e1.name
                    };
            }
        }
        const l = s.get("View");
        if (l instanceof Dict) {
            const e1 = l.get("ViewState");
            if (e1 instanceof Name) switch(e1.name){
                case "ON":
                case "OFF":
                    r.view = {
                        viewState: e1.name
                    };
            }
        }
        return i;
    }
    #Ae(e1, t) {
        function parseOnOff(e1) {
            const i = [];
            if (Array.isArray(e1)) for (const n of e1)n instanceof Ref && t.has(n) && i.push(n.toString());
            return i;
        }
        function parseOrder(e1, i = 0) {
            if (!Array.isArray(e1)) return null;
            const a = [];
            for (const s of e1){
                if (s instanceof Ref && t.has(s)) {
                    n.put(s), a.push(s.toString());
                    continue;
                }
                const e1 = parseNestedOrder(s, i);
                e1 && a.push(e1);
            }
            if (i > 0) return a;
            const s = [];
            for (const [e1] of t.items())n.has(e1) || s.push(e1.toString());
            return s.length && a.push({
                name: null,
                order: s
            }), a;
        }
        function parseNestedOrder(e1, t) {
            if (++t > a) return warn$1("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
            const n = i.fetchIfRef(e1);
            if (!Array.isArray(n)) return null;
            const s = i.fetchIfRef(n[0]);
            if ("string" != typeof s) return null;
            const r = parseOrder(n.slice(1), t);
            return r?.length ? {
                name: stringToPDFString(s),
                order: r
            } : null;
        }
        const i = this.xref, n = new RefSet, a = 10;
        return function(e1) {
            if (Array.isArray(e1)) for (const n of e1){
                const e1 = i.fetchIfRef(n);
                if (!Array.isArray(e1) || !e1.length) continue;
                const a = new Set;
                for (const i of e1)i instanceof Ref && t.has(i) && !a.has(i.toString()) && (a.add(i.toString()), t.get(i).rbGroups.push(a));
            }
        }(e1.get("RBGroups")), {
            name: "string" == typeof e1.get("Name") ? stringToPDFString(e1.get("Name")) : null,
            creator: "string" == typeof e1.get("Creator") ? stringToPDFString(e1.get("Creator")) : null,
            baseState: e1.get("BaseState") instanceof Name ? e1.get("BaseState").name : null,
            on: parseOnOff(e1.get("ON")),
            off: parseOnOff(e1.get("OFF")),
            order: parseOrder(e1.get("Order")),
            groups: [
                ...t
            ]
        };
    }
    setActualNumPages(e1 = null) {
        this.#ge = e1;
    }
    get hasActualNumPages() {
        return null !== this.#ge;
    }
    get _pagesCount() {
        const e1 = this.toplevelPagesDict.get("Count");
        if (!Number.isInteger(e1)) throw new ti("Page count in top-level pages dictionary is not an integer.");
        return shadow$1(this, "_pagesCount", e1);
    }
    get numPages() {
        return this.#ge ?? this._pagesCount;
    }
    get destinations() {
        const e1 = this.#xe(), t = Object.create(null);
        for (const i of e1)if (i instanceof NameTree) for (const [e1, n] of i.getAll()){
            const i = fetchDest(n);
            i && (t[stringToPDFString(e1, !0)] = i);
        }
        else if (i instanceof Dict) for (const [e1, n] of i){
            const i = fetchDest(n);
            i && (t[stringToPDFString(e1, !0)] ||= i);
        }
        return shadow$1(this, "destinations", t);
    }
    getDestination(e1) {
        if (this.hasOwnProperty("destinations")) return this.destinations[e1] ?? null;
        const t = this.#xe();
        for (const i of t)if (i instanceof NameTree || i instanceof Dict) {
            const t = fetchDest(i.get(e1));
            if (t) return t;
        }
        if (t.length) {
            const t = this.destinations[e1];
            if (t) return t;
        }
        return null;
    }
    #xe() {
        const e1 = this.#fe.get("Names"), t = [];
        return e1?.has("Dests") && t.push(new NameTree(e1.getRaw("Dests"), this.xref)), this.#fe.has("Dests") && t.push(this.#fe.get("Dests")), t;
    }
    get pageLabels() {
        let e1 = null;
        try {
            e1 = this.#Se();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn$1("Unable to read page labels.");
        }
        return shadow$1(this, "pageLabels", e1);
    }
    #Se() {
        const e1 = this.#fe.getRaw("PageLabels");
        if (!e1) return null;
        const t = new Array(this.numPages);
        let i = null, n = "";
        const a = new NumberTree(e1, this.xref).getAll();
        let s = "", r = 1;
        for(let e1 = 0, o = this.numPages; e1 < o; e1++){
            const o = a.get(e1);
            if (void 0 !== o) {
                if (!(o instanceof Dict)) throw new ti("PageLabel is not a dictionary.");
                if (o.has("Type") && !isName(o.get("Type"), "PageLabel")) throw new ti("Invalid type in PageLabel dictionary.");
                if (o.has("S")) {
                    const e1 = o.get("S");
                    if (!(e1 instanceof Name)) throw new ti("Invalid style in PageLabel dictionary.");
                    i = e1.name;
                } else i = null;
                if (o.has("P")) {
                    const e1 = o.get("P");
                    if ("string" != typeof e1) throw new ti("Invalid prefix in PageLabel dictionary.");
                    n = stringToPDFString(e1);
                } else n = "";
                if (o.has("St")) {
                    const e1 = o.get("St");
                    if (!(Number.isInteger(e1) && e1 >= 1)) throw new ti("Invalid start in PageLabel dictionary.");
                    r = e1;
                } else r = 1;
            }
            switch(i){
                case "D":
                    s = r;
                    break;
                case "R":
                case "r":
                    s = toRomanNumerals(r, "r" === i);
                    break;
                case "A":
                case "a":
                    const e2 = 26, t1 = "a" === i ? 97 : 65, n1 = r - 1;
                    s = String.fromCharCode(t1 + n1 % e2).repeat(Math.floor(n1 / e2) + 1);
                    break;
                default:
                    if (i) throw new ti(`Invalid style "${i}" in PageLabel dictionary.`);
                    s = "";
            }
            t[e1] = n + s, r++;
        }
        return t;
    }
    get pageLayout() {
        const e1 = this.#fe.get("PageLayout");
        let t = "";
        if (e1 instanceof Name) switch(e1.name){
            case "SinglePage":
            case "OneColumn":
            case "TwoColumnLeft":
            case "TwoColumnRight":
            case "TwoPageLeft":
            case "TwoPageRight":
                t = e1.name;
        }
        return shadow$1(this, "pageLayout", t);
    }
    get pageMode() {
        const e1 = this.#fe.get("PageMode");
        let t = "UseNone";
        if (e1 instanceof Name) switch(e1.name){
            case "UseNone":
            case "UseOutlines":
            case "UseThumbs":
            case "FullScreen":
            case "UseOC":
            case "UseAttachments":
                t = e1.name;
        }
        return shadow$1(this, "pageMode", t);
    }
    get viewerPreferences() {
        const e1 = this.#fe.get("ViewerPreferences");
        if (!(e1 instanceof Dict)) return shadow$1(this, "viewerPreferences", null);
        let t = null;
        for (const [i, n] of e1){
            let e1;
            switch(i){
                case "HideToolbar":
                case "HideMenubar":
                case "HideWindowUI":
                case "FitWindow":
                case "CenterWindow":
                case "DisplayDocTitle":
                case "PickTrayByPDFSize":
                    "boolean" == typeof n && (e1 = n);
                    break;
                case "NonFullScreenPageMode":
                    if (n instanceof Name) switch(n.name){
                        case "UseNone":
                        case "UseOutlines":
                        case "UseThumbs":
                        case "UseOC":
                            e1 = n.name;
                            break;
                        default:
                            e1 = "UseNone";
                    }
                    break;
                case "Direction":
                    if (n instanceof Name) switch(n.name){
                        case "L2R":
                        case "R2L":
                            e1 = n.name;
                            break;
                        default:
                            e1 = "L2R";
                    }
                    break;
                case "ViewArea":
                case "ViewClip":
                case "PrintArea":
                case "PrintClip":
                    if (n instanceof Name) switch(n.name){
                        case "MediaBox":
                        case "CropBox":
                        case "BleedBox":
                        case "TrimBox":
                        case "ArtBox":
                            e1 = n.name;
                            break;
                        default:
                            e1 = "CropBox";
                    }
                    break;
                case "PrintScaling":
                    if (n instanceof Name) switch(n.name){
                        case "None":
                        case "AppDefault":
                            e1 = n.name;
                            break;
                        default:
                            e1 = "AppDefault";
                    }
                    break;
                case "Duplex":
                    if (n instanceof Name) switch(n.name){
                        case "Simplex":
                        case "DuplexFlipShortEdge":
                        case "DuplexFlipLongEdge":
                            e1 = n.name;
                            break;
                        default:
                            e1 = "None";
                    }
                    break;
                case "PrintPageRange":
                    if (Array.isArray(n) && n.length % 2 == 0) {
                        n.every((e1, t, i)=>Number.isInteger(e1) && e1 > 0 && (0 === t || e1 >= i[t - 1]) && e1 <= this.numPages) && (e1 = n);
                    }
                    break;
                case "NumCopies":
                    Number.isInteger(n) && n > 0 && (e1 = n);
                    break;
                default:
                    warn$1(`Ignoring non-standard key in ViewerPreferences: ${i}.`);
                    continue;
            }
            void 0 !== e1 ? (t ??= Object.create(null), t[i] = e1) : warn$1(`Bad value, for key "${i}", in ViewerPreferences: ${n}.`);
        }
        return shadow$1(this, "viewerPreferences", t);
    }
    get openAction() {
        const e1 = this.#fe.get("OpenAction"), t = Object.create(null);
        if (e1 instanceof Dict) {
            const i = new Dict(this.xref);
            i.set("A", e1);
            const n = {
                url: null,
                dest: null,
                action: null
            };
            Catalog.parseDestDictionary({
                destDict: i,
                resultObj: n
            }), Array.isArray(n.dest) ? t.dest = n.dest : n.action && (t.action = n.action);
        } else $s(e1) && (t.dest = e1);
        return shadow$1(this, "openAction", objectSize(t) > 0 ? t : null);
    }
    get attachments() {
        const e1 = this.#fe.get("Names");
        let t = null;
        if (e1 instanceof Dict && e1.has("EmbeddedFiles")) {
            const i = new NameTree(e1.getRaw("EmbeddedFiles"), this.xref);
            for (const [e1, n] of i.getAll()){
                const i = new FileSpec(n, this.xref);
                t ??= Object.create(null), t[stringToPDFString(e1, !0)] = i.serializable;
            }
        }
        return shadow$1(this, "attachments", t);
    }
    get xfaImages() {
        const e1 = this.#fe.get("Names");
        let t = null;
        if (e1 instanceof Dict && e1.has("XFAImages")) {
            const i = new NameTree(e1.getRaw("XFAImages"), this.xref);
            for (const [e1, n] of i.getAll())n instanceof BaseStream && (t ??= new Map, t.set(stringToPDFString(e1, !0), n.getBytes()));
        }
        return shadow$1(this, "xfaImages", t);
    }
    #ve() {
        const e1 = this.#fe.get("Names");
        let t = null;
        function appendIfJavaScriptDict(e1, i) {
            if (!(i instanceof Dict)) return;
            if (!isName(i.get("S"), "JavaScript")) return;
            let n = i.get("JS");
            if (n instanceof BaseStream) n = n.getString();
            else if ("string" != typeof n) return;
            n = stringToPDFString(n, !0).replaceAll("\0", ""), n && (t ||= new Map).set(e1, n);
        }
        if (e1 instanceof Dict && e1.has("JavaScript")) {
            const t = new NameTree(e1.getRaw("JavaScript"), this.xref);
            for (const [e1, i] of t.getAll())appendIfJavaScriptDict(stringToPDFString(e1, !0), i);
        }
        const i = this.#fe.get("OpenAction");
        return i && appendIfJavaScriptDict("OpenAction", i), t;
    }
    get jsActions() {
        const e1 = this.#ve();
        let t = collectActions(this.xref, this.#fe, ie);
        if (e1) {
            t ||= Object.create(null);
            for (const [i, n] of e1)i in t ? t[i].push(n) : t[i] = [
                n
            ];
        }
        return shadow$1(this, "jsActions", t);
    }
    async cleanup(e1 = !1) {
        clearGlobalCaches(), this.globalColorSpaceCache.clear(), this.globalImageCache.clear(e1), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.pageDictCache.clear(), this.nonBlendModesSet.clear();
        for (const { dict: e1 } of (await Promise.all(this.fontCache)))delete e1.cacheKey;
        this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear(), this.systemFontCache.clear();
    }
    async getPageDict(e1) {
        const t = [
            this.toplevelPagesDict
        ], i = new RefSet, n = this.#fe.getRaw("Pages");
        n instanceof Ref && i.put(n);
        const a = this.xref, s = this.pageKidsCountCache, r = this.pageIndexCache, o = this.pageDictCache;
        let l = 0;
        for(; t.length;){
            const n = t.pop();
            if (n instanceof Ref) {
                const c = s.get(n);
                if (c >= 0 && l + c <= e1) {
                    l += c;
                    continue;
                }
                if (i.has(n)) throw new ti("Pages tree contains circular reference.");
                i.put(n);
                const h = await (o.get(n) || a.fetchAsync(n));
                if (h instanceof Dict) {
                    let t = h.getRaw("Type");
                    if (t instanceof Ref && (t = await a.fetchAsync(t)), isName(t, "Page") || !h.has("Kids")) {
                        if (s.has(n) || s.put(n, 1), r.has(n) || r.put(n, l), l === e1) return [
                            h,
                            n
                        ];
                        l++;
                        continue;
                    }
                }
                t.push(h);
                continue;
            }
            if (!(n instanceof Dict)) throw new ti("Page dictionary kid reference points to wrong type of object.");
            const { objId: c } = n;
            let h = n.getRaw("Count");
            if (h instanceof Ref && (h = await a.fetchAsync(h)), Number.isInteger(h) && h >= 0 && (c && !s.has(c) && s.put(c, h), l + h <= e1)) {
                l += h;
                continue;
            }
            let d = n.getRaw("Kids");
            if (d instanceof Ref && (d = await a.fetchAsync(d)), !Array.isArray(d)) {
                let t = n.getRaw("Type");
                if (t instanceof Ref && (t = await a.fetchAsync(t)), isName(t, "Page") || !n.has("Kids")) {
                    if (l === e1) return [
                        n,
                        null
                    ];
                    l++;
                    continue;
                }
                throw new ti("Page dictionary kids object is not an array.");
            }
            for(let e1 = d.length - 1; e1 >= 0; e1--){
                const i = d[e1];
                t.push(i), n === this.toplevelPagesDict && i instanceof Ref && !o.has(i) && o.put(i, a.fetchAsync(i));
            }
        }
        throw new Error(`Page index ${e1} not found.`);
    }
    async getAllPageDicts(e1 = !1) {
        const { ignoreErrors: t } = this.pdfManager.evaluatorOptions, i = [
            {
                currentNode: this.toplevelPagesDict,
                posInKids: 0
            }
        ], n = new RefSet, a = this.#fe.getRaw("Pages");
        a instanceof Ref && n.put(a);
        const s = new Map, r = this.xref, o = this.pageIndexCache;
        let l = 0;
        function addPageDict(e1, t) {
            t && !o.has(t) && o.put(t, l), s.set(l++, [
                e1,
                t
            ]);
        }
        function addPageError(i) {
            if (i instanceof XRefEntryException && !e1) throw i;
            e1 && t && 0 === l && (warn$1(`getAllPageDicts - Skipping invalid first page: "${i}".`), i = Dict.empty), s.set(l++, [
                i,
                null
            ]);
        }
        for(; i.length > 0;){
            const e1 = i.at(-1), { currentNode: t, posInKids: a } = e1;
            let s = t.getRaw("Kids");
            if (s instanceof Ref) try {
                s = await r.fetchAsync(s);
            } catch (e1) {
                addPageError(e1);
                break;
            }
            if (!Array.isArray(s)) {
                addPageError(new ti("Page dictionary kids object is not an array."));
                break;
            }
            if (a >= s.length) {
                i.pop();
                continue;
            }
            const o = s[a];
            let l;
            if (o instanceof Ref) {
                if (n.has(o)) {
                    addPageError(new ti("Pages tree contains circular reference."));
                    break;
                }
                n.put(o);
                try {
                    l = await r.fetchAsync(o);
                } catch (e1) {
                    addPageError(e1);
                    break;
                }
            } else l = o;
            if (!(l instanceof Dict)) {
                addPageError(new ti("Page dictionary kid reference points to wrong type of object."));
                break;
            }
            let c = l.getRaw("Type");
            if (c instanceof Ref) try {
                c = await r.fetchAsync(c);
            } catch (e1) {
                addPageError(e1);
                break;
            }
            isName(c, "Page") || !l.has("Kids") ? addPageDict(l, o instanceof Ref ? o : null) : i.push({
                currentNode: l,
                posInKids: 0
            }), e1.posInKids++;
        }
        return s;
    }
    getPageIndex(e1) {
        const t = this.pageIndexCache.get(e1);
        if (void 0 !== t) return Promise.resolve(t);
        const i = this.xref;
        let n = 0;
        const next = (t)=>(function(t) {
                let n, a = 0;
                return i.fetchAsync(t).then(function(i) {
                    if (isRefsEqual(t, e1) && !isDict(i, "Page") && !(i instanceof Dict && !i.has("Type") && i.has("Contents"))) throw new ti("The reference does not point to a /Page dictionary.");
                    if (!i) return null;
                    if (!(i instanceof Dict)) throw new ti("Node must be a dictionary.");
                    return n = i.getRaw("Parent"), i.getAsync("Parent");
                }).then(function(e1) {
                    if (!e1) return null;
                    if (!(e1 instanceof Dict)) throw new ti("Parent must be a dictionary.");
                    return e1.getAsync("Kids");
                }).then(function(e1) {
                    if (!e1) return null;
                    const s = [];
                    let r = !1;
                    for (const n of e1){
                        if (!(n instanceof Ref)) throw new ti("Kid must be a reference.");
                        if (isRefsEqual(n, t)) {
                            r = !0;
                            break;
                        }
                        s.push(i.fetchAsync(n).then(function(e1) {
                            if (!(e1 instanceof Dict)) throw new ti("Kid node must be a dictionary.");
                            e1.has("Count") ? a += e1.get("Count") : a++;
                        }));
                    }
                    if (!r) throw new ti("Kid reference not found in parent's kids.");
                    return Promise.all(s).then(()=>[
                            a,
                            n
                        ]);
                });
            })(t).then((t)=>{
                if (!t) return this.pageIndexCache.put(e1, n), n;
                const [i, a] = t;
                return n += i, next(a);
            });
        return next(e1);
    }
    get baseUrl() {
        const e1 = this.#fe.get("URI");
        if (e1 instanceof Dict) {
            const t = e1.get("Base");
            if ("string" == typeof t) {
                const e1 = createValidAbsoluteUrl$1(t, null, {
                    tryConvertEncoding: !0
                });
                if (e1) return shadow$1(this, "baseUrl", e1.href);
            }
        }
        return shadow$1(this, "baseUrl", this.pdfManager.docBaseUrl);
    }
    static parseDestDictionary({ destDict: e1, resultObj: t, docBaseUrl: i = null, docAttachments: n = null }) {
        if (!(e1 instanceof Dict)) return void warn$1("parseDestDictionary: `destDict` must be a dictionary.");
        let a, s, r = e1.get("A");
        if (r instanceof Dict || (e1.has("Dest") ? r = e1.get("Dest") : (r = e1.get("AA"), r instanceof Dict && (r.has("D") ? r = r.get("D") : r.has("U") && (r = r.get("U"))))), r instanceof Dict) {
            const e1 = r.get("S");
            if (!(e1 instanceof Name)) return void warn$1("parseDestDictionary: Invalid type in Action dictionary.");
            const i = e1.name;
            switch(i){
                case "ResetForm":
                    const e2 = r.get("Flags"), o = !(1 & ("number" == typeof e2 ? e2 : 0)), l = [], c = [];
                    for (const e1 of r.get("Fields") || [])e1 instanceof Ref ? c.push(e1.toString()) : "string" == typeof e1 && l.push(stringToPDFString(e1));
                    t.resetForm = {
                        fields: l,
                        refs: c,
                        include: o
                    };
                    break;
                case "URI":
                    a = r.get("URI"), a instanceof Name && (a = "/" + a.name);
                    break;
                case "GoTo":
                    s = r.get("D");
                    break;
                case "Launch":
                case "GoToR":
                    const h = r.get("F");
                    if (h instanceof Dict) {
                        const e1 = new FileSpec(h, null, !0), { rawFilename: t } = e1.serializable;
                        a = t;
                    } else "string" == typeof h && (a = h);
                    const d = fetchRemoteDest(r);
                    d && "string" == typeof a && (a = a.split("#", 1)[0] + "#" + d);
                    const u = r.get("NewWindow");
                    "boolean" == typeof u && (t.newWindow = u);
                    break;
                case "GoToE":
                    const g = r.get("T");
                    let f;
                    if (n && g instanceof Dict) {
                        const e1 = g.get("R"), t = g.get("N");
                        isName(e1, "C") && "string" == typeof t && (f = n[stringToPDFString(t, !0)]);
                    }
                    if (f) {
                        t.attachment = f;
                        const e1 = fetchRemoteDest(r);
                        e1 && (t.attachmentDest = e1);
                    } else warn$1('parseDestDictionary - unimplemented "GoToE" action.');
                    break;
                case "Named":
                    const p = r.get("N");
                    p instanceof Name && (t.action = p.name);
                    break;
                case "SetOCGState":
                    const m = r.get("State"), b = r.get("PreserveRB");
                    if (!Array.isArray(m) || 0 === m.length) break;
                    const y = [];
                    for (const e1 of m)if (e1 instanceof Name) switch(e1.name){
                        case "ON":
                        case "OFF":
                        case "Toggle":
                            y.push(e1.name);
                    }
                    else e1 instanceof Ref && y.push(e1.toString());
                    if (y.length !== m.length) break;
                    t.setOCGState = {
                        state: y,
                        preserveRB: "boolean" != typeof b || b
                    };
                    break;
                case "JavaScript":
                    const w = r.get("JS");
                    let x;
                    w instanceof BaseStream ? x = w.getString() : "string" == typeof w && (x = w);
                    const S = x && recoverJsURL(stringToPDFString(x, !0));
                    if (S) {
                        a = S.url, t.newWindow = S.newWindow;
                        break;
                    }
                default:
                    if ("JavaScript" === i || "SubmitForm" === i) break;
                    warn$1(`parseDestDictionary - unsupported action: "${i}".`);
            }
        } else e1.has("Dest") && (s = e1.get("Dest"));
        if ("string" == typeof a) {
            const e1 = createValidAbsoluteUrl$1(a, i, {
                addDefaultProtocol: !0,
                tryConvertEncoding: !0
            });
            e1 && (t.url = e1.href), t.unsafeUrl = a;
        }
        s && (s instanceof Name && (s = s.name), "string" == typeof s ? t.dest = stringToPDFString(s, !0) : $s(s) && (t.dest = s));
    }
}
function mayHaveChildren(e1) {
    return e1 instanceof Ref || e1 instanceof Dict || e1 instanceof BaseStream || Array.isArray(e1);
}
function addChildren(e1, t) {
    if (e1 instanceof Dict) e1 = e1.getRawValues();
    else if (e1 instanceof BaseStream) e1 = e1.dict.getRawValues();
    else if (!Array.isArray(e1)) return;
    for (const i of e1)mayHaveChildren(i) && t.push(i);
}
class ObjectLoader {
    refSet = new RefSet;
    constructor(e1, t, i){
        this.dict = e1, this.keys = t, this.xref = i;
    }
    async load() {
        const { keys: e1, dict: t } = this, i = [];
        for (const n of e1){
            const e1 = t.getRaw(n);
            void 0 !== e1 && i.push(e1);
        }
        await this.#Ce(i), this.refSet = null;
    }
    async #Ce(e1) {
        const t = [], i = [];
        for(; e1.length;){
            let n = e1.pop();
            if (n instanceof Ref) {
                if (this.refSet.has(n)) continue;
                try {
                    this.refSet.put(n), n = this.xref.fetch(n);
                } catch (e1) {
                    if (!(e1 instanceof MissingDataException)) return warn$1(`ObjectLoader.#walk - requesting all data: "${e1}".`), void await this.xref.stream.manager.requestAllChunks();
                    t.push(n), i.push({
                        begin: e1.begin,
                        end: e1.end
                    });
                }
            }
            if (n instanceof BaseStream) {
                const e1 = n.getBaseStreams();
                if (e1) {
                    let a = !1;
                    for (const t of e1)t.isDataLoaded || (a = !0, i.push({
                        begin: t.start,
                        end: t.end
                    }));
                    a && t.push(n);
                }
            }
            addChildren(n, e1);
        }
        if (i.length) {
            await this.xref.stream.manager.requestRanges(i);
            for (const e1 of t)e1 instanceof Ref && this.refSet.remove(e1);
            await this.#Ce(t);
        }
    }
    static async load(e1, t, i) {
        if (i.stream.isDataLoaded) return;
        const n = new ObjectLoader(e1, t, i);
        await n.load();
    }
}
const Hs = Symbol(), Xs = Symbol(), qs = Symbol(), zs = Symbol(), Ws = Symbol(), Gs = Symbol(), Vs = Symbol(), Ks = Symbol(), Ys = Symbol(), Js = Symbol("content"), Zs = Symbol("data"), Qs = Symbol(), er = Symbol("extra"), tr = Symbol(), ir = Symbol(), nr = Symbol(), ar = Symbol(), sr = Symbol(), rr = Symbol(), or = Symbol(), lr = Symbol(), cr = Symbol(), hr = Symbol(), dr = Symbol(), ur = Symbol(), gr = Symbol(), fr = Symbol(), pr = Symbol(), mr = Symbol(), br = Symbol(), yr = Symbol(), wr = Symbol(), Ar = Symbol(), xr = Symbol(), Sr = Symbol(), vr = Symbol(), Cr = Symbol(), kr = Symbol(), Tr = Symbol(), Fr = Symbol(), Ir = Symbol(), Er = Symbol(), Mr = Symbol(), Dr = Symbol(), Or = Symbol(), _r = Symbol("namespaceId"), Pr = Symbol("nodeName"), Rr = Symbol(), Nr = Symbol(), Lr = Symbol(), Ur = Symbol(), jr = Symbol(), $r = Symbol(), Hr = Symbol(), Xr = Symbol(), qr = Symbol("root"), zr = Symbol(), Wr = Symbol(), Gr = Symbol(), Vr = Symbol(), Kr = Symbol(), Yr = Symbol(), Jr = Symbol(), Zr = Symbol(), Qr = Symbol(), eo = Symbol(), to = Symbol(), io = Symbol("uid"), no = Symbol(), ao = {
    config: {
        id: 0,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xci/")
    },
    connectionSet: {
        id: 1,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
    },
    datasets: {
        id: 2,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-data/")
    },
    form: {
        id: 3,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-form/")
    },
    localeSet: {
        id: 4,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
    },
    pdf: {
        id: 5,
        check: (e1)=>"http://ns.adobe.com/xdp/pdf/" === e1
    },
    signature: {
        id: 6,
        check: (e1)=>"http://www.w3.org/2000/09/xmldsig#" === e1
    },
    sourceSet: {
        id: 7,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-source-set/")
    },
    stylesheet: {
        id: 8,
        check: (e1)=>"http://www.w3.org/1999/XSL/Transform" === e1
    },
    template: {
        id: 9,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-template/")
    },
    xdc: {
        id: 10,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xdc/")
    },
    xdp: {
        id: 11,
        check: (e1)=>"http://ns.adobe.com/xdp/" === e1
    },
    xfdf: {
        id: 12,
        check: (e1)=>"http://ns.adobe.com/xfdf/" === e1
    },
    xhtml: {
        id: 13,
        check: (e1)=>"http://www.w3.org/1999/xhtml" === e1
    },
    xmpmeta: {
        id: 14,
        check: (e1)=>"http://ns.adobe.com/xmpmeta/" === e1
    }
}, so = {
    pt: (e1)=>e1,
    cm: (e1)=>e1 / 2.54 * 72,
    mm: (e1)=>e1 / 25.4 * 72,
    in: (e1)=>72 * e1,
    px: (e1)=>e1
}, ro = /([+-]?\d+\.?\d*)(.*)/;
function stripQuotes(e1) {
    return e1.startsWith("'") || e1.startsWith('"') ? e1.slice(1, -1) : e1;
}
function getInteger({ data: e1, defaultValue: t, validate: i }) {
    if (!e1) return t;
    e1 = e1.trim();
    const n = parseInt(e1, 10);
    return !isNaN(n) && i(n) ? n : t;
}
function getFloat({ data: e1, defaultValue: t, validate: i }) {
    if (!e1) return t;
    e1 = e1.trim();
    const n = parseFloat(e1);
    return !isNaN(n) && i(n) ? n : t;
}
function getKeyword({ data: e1, defaultValue: t, validate: i }) {
    return e1 && i(e1 = e1.trim()) ? e1 : t;
}
function getStringOption(e1, t) {
    return getKeyword({
        data: e1,
        defaultValue: t[0],
        validate: (e1)=>t.includes(e1)
    });
}
function getMeasurement(e1, t = "0") {
    if (t ||= "0", !e1) return getMeasurement(t);
    const i = e1.trim().match(ro);
    if (!i) return getMeasurement(t);
    const [, n, a] = i, s = parseFloat(n);
    if (isNaN(s)) return getMeasurement(t);
    if (0 === s) return 0;
    const r = so[a];
    return r ? r(s) : s;
}
function getRatio(e1) {
    if (!e1) return {
        num: 1,
        den: 1
    };
    const t = e1.split(":", 2).map((e1)=>parseFloat(e1.trim())).filter((e1)=>!isNaN(e1));
    if (1 === t.length && t.push(1), 0 === t.length) return {
        num: 1,
        den: 1
    };
    const [i, n] = t;
    return {
        num: i,
        den: n
    };
}
function getRelevant(e1) {
    return e1 ? e1.trim().split(/\s+/).map((e1)=>({
            excluded: "-" === e1[0],
            viewname: e1.substring(1)
        })) : [];
}
class HTMLResult {
    static get FAILURE() {
        return shadow$1(this, "FAILURE", new HTMLResult(!1, null, null, null));
    }
    static get EMPTY() {
        return shadow$1(this, "EMPTY", new HTMLResult(!0, null, null, null));
    }
    constructor(e1, t, i, n){
        this.success = e1, this.html = t, this.bbox = i, this.breakNode = n;
    }
    isBreak() {
        return !!this.breakNode;
    }
    static breakNode(e1) {
        return new HTMLResult(!1, null, null, e1);
    }
    static success(e1, t = null) {
        return new HTMLResult(!0, e1, t, null);
    }
}
class FontFinder {
    constructor(e1){
        this.fonts = new Map, this.cache = new Map, this.warned = new Set, this.defaultFont = null, this.add(e1);
    }
    add(e1, t = null) {
        for (const t of e1)this.addPdfFont(t);
        for (const e1 of this.fonts.values())e1.regular || (e1.regular = e1.italic || e1.bold || e1.bolditalic);
        if (!t || 0 === t.size) return;
        const i = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
        for (const e1 of t)this.fonts.set(e1, i);
    }
    addPdfFont(e1) {
        const t = e1.cssFontInfo, i = t.fontFamily;
        let n = this.fonts.get(i);
        n || (n = Object.create(null), this.fonts.set(i, n), this.defaultFont || (this.defaultFont = n));
        let a = "";
        const s = parseFloat(t.fontWeight);
        0 !== parseFloat(t.italicAngle) ? a = s >= 700 ? "bolditalic" : "italic" : s >= 700 && (a = "bold"), a || ((e1.name.includes("Bold") || e1.psName?.includes("Bold")) && (a = "bold"), (e1.name.includes("Italic") || e1.name.endsWith("It") || e1.psName?.includes("Italic") || e1.psName?.endsWith("It")) && (a += "italic")), a || (a = "regular"), n[a] = e1;
    }
    getDefault() {
        return this.defaultFont;
    }
    find(e1, t = !0) {
        let i = this.fonts.get(e1) || this.cache.get(e1);
        if (i) return i;
        const n = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
        let a = e1.replaceAll(n, "");
        if (i = this.fonts.get(a), i) return this.cache.set(e1, i), i;
        a = a.toLowerCase();
        const s = [];
        for (const [e1, t] of this.fonts.entries())e1.replaceAll(n, "").toLowerCase().startsWith(a) && s.push(t);
        if (0 === s.length) for (const [, e1] of this.fonts.entries())e1.regular.name?.replaceAll(n, "").toLowerCase().startsWith(a) && s.push(e1);
        if (0 === s.length) {
            a = a.replaceAll(/psmt|mt/gi, "");
            for (const [e1, t] of this.fonts.entries())e1.replaceAll(n, "").toLowerCase().startsWith(a) && s.push(t);
        }
        if (0 === s.length) for (const e1 of this.fonts.values())e1.regular.name?.replaceAll(n, "").toLowerCase().startsWith(a) && s.push(e1);
        return s.length >= 1 ? (1 !== s.length && t && warn$1(`XFA - Too many choices to guess the correct font: ${e1}`), this.cache.set(e1, s[0]), s[0]) : (t && !this.warned.has(e1) && (this.warned.add(e1), warn$1(`XFA - Cannot find the font: ${e1}`)), null);
    }
}
function selectFont(e1, t) {
    return "italic" === e1.posture ? "bold" === e1.weight ? t.bolditalic : t.italic : "bold" === e1.weight ? t.bold : t.regular;
}
class text_FontInfo {
    constructor(e1, t, i, n){
        if (this.lineHeight = i, this.paraMargin = t || {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        }, !e1) return void ([this.pdfFont, this.xfaFont] = this.defaultFont(n));
        this.xfaFont = {
            typeface: e1.typeface,
            posture: e1.posture,
            weight: e1.weight,
            size: e1.size,
            letterSpacing: e1.letterSpacing
        };
        const a = n.find(e1.typeface);
        a ? (this.pdfFont = selectFont(e1, a), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(n))) : [this.pdfFont, this.xfaFont] = this.defaultFont(n);
    }
    defaultFont(e1) {
        const t = e1.find("Helvetica", !1) || e1.find("Myriad Pro", !1) || e1.find("Arial", !1) || e1.getDefault();
        if (t?.regular) {
            const e1 = t.regular;
            return [
                e1,
                {
                    typeface: e1.cssFontInfo.fontFamily,
                    posture: "normal",
                    weight: "normal",
                    size: 10,
                    letterSpacing: 0
                }
            ];
        }
        return [
            null,
            {
                typeface: "Courier",
                posture: "normal",
                weight: "normal",
                size: 10,
                letterSpacing: 0
            }
        ];
    }
}
class FontSelector {
    constructor(e1, t, i, n){
        this.fontFinder = n, this.stack = [
            new text_FontInfo(e1, t, i, n)
        ];
    }
    pushData(e1, t, i) {
        const n = this.stack.at(-1);
        for (const t of [
            "typeface",
            "posture",
            "weight",
            "size",
            "letterSpacing"
        ])e1[t] || (e1[t] = n.xfaFont[t]);
        for (const e1 of [
            "top",
            "bottom",
            "left",
            "right"
        ])isNaN(t[e1]) && (t[e1] = n.paraMargin[e1]);
        const a = new text_FontInfo(e1, t, i || n.lineHeight, this.fontFinder);
        a.pdfFont || (a.pdfFont = n.pdfFont), this.stack.push(a);
    }
    popFont() {
        this.stack.pop();
    }
    topFont() {
        return this.stack.at(-1);
    }
}
class TextMeasure {
    constructor(e1, t, i, n){
        this.glyphs = [], this.fontSelector = new FontSelector(e1, t, i, n), this.extraHeight = 0;
    }
    pushData(e1, t, i) {
        this.fontSelector.pushData(e1, t, i);
    }
    popFont(e1) {
        return this.fontSelector.popFont();
    }
    addPara() {
        const e1 = this.fontSelector.topFont();
        this.extraHeight += e1.paraMargin.top + e1.paraMargin.bottom;
    }
    addString(e1) {
        if (!e1) return;
        const t = this.fontSelector.topFont(), i = t.xfaFont.size;
        if (t.pdfFont) {
            const n = t.xfaFont.letterSpacing, a = t.pdfFont, s = a.lineHeight || 1.2, r = t.lineHeight || Math.max(1.2, s) * i, o = s - (void 0 === a.lineGap ? .2 : a.lineGap), l = Math.max(1, o) * i, c = i / 1e3, h = a.defaultWidth || a.charsToGlyphs(" ")[0].width;
            for (const t of e1.split(/[\u2029\n]/)){
                const e1 = a.encodeString(t).join(""), i = a.charsToGlyphs(e1);
                for (const e1 of i){
                    const t = e1.width || h;
                    this.glyphs.push([
                        t * c + n,
                        r,
                        l,
                        e1.unicode,
                        !1
                    ]);
                }
                this.glyphs.push([
                    0,
                    0,
                    0,
                    "\n",
                    !0
                ]);
            }
            return void this.glyphs.pop();
        }
        for (const t of e1.split(/[\u2029\n]/)){
            for (const e1 of t.split(""))this.glyphs.push([
                i,
                1.2 * i,
                i,
                e1,
                !1
            ]);
            this.glyphs.push([
                0,
                0,
                0,
                "\n",
                !0
            ]);
        }
        this.glyphs.pop();
    }
    compute(e1) {
        let t = -1, i = 0, n = 0, a = 0, s = 0, r = 0, o = !1, l = !0;
        for(let c = 0, h = this.glyphs.length; c < h; c++){
            const [h, d, u, g, f] = this.glyphs[c], p = " " === g, m = l ? u : d;
            f ? (n = Math.max(n, s), s = 0, a += r, r = m, t = -1, i = 0, l = !1) : p ? s + h > e1 ? (n = Math.max(n, s), s = 0, a += r, r = m, t = -1, i = 0, o = !0, l = !1) : (r = Math.max(m, r), i = s, s += h, t = c) : s + h > e1 ? (a += r, r = m, -1 !== t ? (c = t, n = Math.max(n, i), s = 0, t = -1, i = 0) : (n = Math.max(n, s), s = h), o = !0, l = !1) : (s += h, r = Math.max(m, r));
        }
        return n = Math.max(n, s), a += r + this.extraHeight, {
            width: 1.02 * n,
            height: a,
            isBroken: o
        };
    }
}
const oo = /^[^.[]+/, lo = /^[^\]]+/, co = 0, ho = 1, uo = 2, go = 3, fo = 4, po = new Map([
    [
        "$data",
        (e1, t)=>e1.datasets ? e1.datasets.data : e1
    ],
    [
        "$record",
        (e1, t)=>(e1.datasets ? e1.datasets.data : e1)[ur]()[0]
    ],
    [
        "$template",
        (e1, t)=>e1.template
    ],
    [
        "$connectionSet",
        (e1, t)=>e1.connectionSet
    ],
    [
        "$form",
        (e1, t)=>e1.form
    ],
    [
        "$layout",
        (e1, t)=>e1.layout
    ],
    [
        "$host",
        (e1, t)=>e1.host
    ],
    [
        "$dataWindow",
        (e1, t)=>e1.dataWindow
    ],
    [
        "$event",
        (e1, t)=>e1.event
    ],
    [
        "!",
        (e1, t)=>e1.datasets
    ],
    [
        "$xfa",
        (e1, t)=>e1
    ],
    [
        "xfa",
        (e1, t)=>e1
    ],
    [
        "$",
        (e1, t)=>t
    ]
]), mo = new WeakMap;
function parseIndex(e1) {
    return "*" === (e1 = e1.trim()) ? 1 / 0 : parseInt(e1, 10) || 0;
}
function parseExpression(e1, t, i = !0) {
    let n = e1.match(oo);
    if (!n) return null;
    let [a] = n;
    const s = [
        {
            name: a,
            cacheName: "." + a,
            index: 0,
            js: null,
            formCalc: null,
            operator: co
        }
    ];
    let r = a.length;
    for(; r < e1.length;){
        const o = r;
        if ("[" === e1.charAt(r++)) {
            if (n = e1.slice(r).match(lo), !n) return warn$1("XFA - Invalid index in SOM expression"), null;
            s.at(-1).index = parseIndex(n[0]), r += n[0].length + 1;
            continue;
        }
        let l;
        switch(e1.charAt(r)){
            case ".":
                if (!t) return null;
                r++, l = ho;
                break;
            case "#":
                r++, l = uo;
                break;
            case "[":
                if (i) return warn$1("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
                l = go;
                break;
            case "(":
                if (i) return warn$1("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
                l = fo;
                break;
            default:
                l = co;
        }
        if (n = e1.slice(r).match(oo), !n) break;
        [a] = n, r += a.length, s.push({
            name: a,
            cacheName: e1.slice(o, r),
            operator: l,
            index: 0,
            js: null,
            formCalc: null
        });
    }
    return s;
}
function searchNode(e1, t, i, n = !0, a = !0) {
    const s = parseExpression(i, n);
    if (!s) return null;
    const r = po.get(s[0].name);
    let o, l = 0;
    r ? (o = !0, e1 = [
        r(e1, t)
    ], l = 1) : (o = null === t, e1 = [
        t || e1
    ]);
    for(let i = s.length; l < i; l++){
        const { name: i, cacheName: n, operator: r, index: c } = s[l], h = [];
        for (const t of e1){
            if (!t.isXFAObject) continue;
            let e1, s;
            if (a && (s = mo.get(t), s || (s = new Map, mo.set(t, s)), e1 = s.get(n)), !e1) {
                switch(r){
                    case co:
                        e1 = t[or](i, !1);
                        break;
                    case ho:
                        e1 = t[or](i, !0);
                        break;
                    case uo:
                        e1 = t[rr](i), e1 = e1.isXFAObjectArray ? e1.children : [
                            e1
                        ];
                }
                a && s.set(n, e1);
            }
            e1.length > 0 && h.push(e1);
        }
        if (0 === h.length && !o && 0 === l) {
            const i = t[mr]();
            if (!(t = i)) return null;
            l = -1, e1 = [
                t
            ];
            continue;
        }
        e1 = isFinite(c) ? h.filter((e1)=>c < e1.length).map((e1)=>e1[c]) : h.flat();
    }
    return 0 === e1.length ? null : e1;
}
function createDataNode(e1, t, i) {
    const n = parseExpression(i);
    if (!n) return null;
    if (n.some((e1)=>e1.operator === ho)) return null;
    const a = po.get(n[0].name);
    let s = 0;
    a ? (e1 = a(e1, t), s = 1) : e1 = t || e1;
    for(let t = n.length; s < t; s++){
        const { name: t, operator: i, index: a } = n[s];
        if (!isFinite(a)) return n[s].index = 0, e1.createNodes(n.slice(s));
        let r;
        switch(i){
            case co:
                r = e1[or](t, !1);
                break;
            case ho:
                r = e1[or](t, !0);
                break;
            case uo:
                r = e1[rr](t), r = r.isXFAObjectArray ? r.children : [
                    r
                ];
        }
        if (0 === r.length) return e1.createNodes(n.slice(s));
        if (!(a < r.length)) return n[s].index = a - r.length, e1.createNodes(n.slice(s));
        {
            const t = r[a];
            if (!t.isXFAObject) return warn$1("XFA - Cannot create a node."), null;
            e1 = t;
        }
    }
    return null;
}
const bo = Symbol(), yo = Symbol(), wo = Symbol(), Ao = Symbol("_children"), xo = Symbol(), So = Symbol(), vo = Symbol(), Co = Symbol(), ko = Symbol(), Fo = Symbol(), Io = Symbol(), Eo = Symbol(), Mo = Symbol(), Do = Symbol("parent"), Oo = Symbol(), _o = Symbol(), Po = Symbol();
let Ro = 0;
const Bo = ao.datasets.id;
class XFAObject {
    constructor(e1, t, i = !1){
        this[_r] = e1, this[Pr] = t, this[Io] = i, this[Do] = null, this[Ao] = [], this[io] = `${t}${Ro++}`, this[yr] = null;
    }
    get isXFAObject() {
        return !0;
    }
    get isXFAObjectArray() {
        return !1;
    }
    createNodes(e1) {
        let t = this, i = null;
        for (const { name: n, index: a } of e1){
            for(let e1 = 0, s = isFinite(a) ? a : 0; e1 <= s; e1++){
                const e1 = t[_r] === Bo ? -1 : t[_r];
                i = new XmlObject(e1, n), t[qs](i);
            }
            t = i;
        }
        return i;
    }
    [Nr](e1) {
        if (!this[Io] || !this[Lr](e1)) return !1;
        const t = e1[Pr], i = this[t];
        if (!(i instanceof XFAObjectArray)) return null !== i && this[Xr](i), this[t] = e1, this[qs](e1), !0;
        if (i.push(e1)) return this[qs](e1), !0;
        let n = "";
        return this.id ? n = ` (id: ${this.id})` : this.name && (n = ` (name: ${this.name} ${this.h.value})`), warn$1(`XFA - node "${this[Pr]}"${n} has already enough "${t}"!`), !1;
    }
    [Lr](e1) {
        return this.hasOwnProperty(e1[Pr]) && e1[_r] === this[_r];
    }
    [Fr]() {
        return !1;
    }
    [Hs]() {
        return !1;
    }
    [vr]() {
        return !1;
    }
    [Cr]() {
        return !1;
    }
    [$r]() {
        this.para && this[br]()[er].paraStack.pop();
    }
    [Hr]() {
        this[br]()[er].paraStack.push(this.para);
    }
    [Gr](e1) {
        this.id && this[_r] === ao.template.id && e1.set(this.id, this);
    }
    [br]() {
        return this[yr].template;
    }
    [Ir]() {
        return !1;
    }
    [Er]() {
        return !1;
    }
    [qs](e1) {
        e1[Do] = this, this[Ao].push(e1), !e1[yr] && this[yr] && (e1[yr] = this[yr]);
    }
    [Xr](e1) {
        const t = this[Ao].indexOf(e1);
        this[Ao].splice(t, 1);
    }
    [wr]() {
        return this.hasOwnProperty("value");
    }
    [Kr](e1) {}
    [Ur](e1) {}
    [tr]() {}
    [Ws](e1) {
        delete this[Io], this[Vs] && (e1.clean(this[Vs]), delete this[Vs]);
    }
    [xr](e1) {
        return this[Ao].indexOf(e1);
    }
    [Sr](e1, t) {
        t[Do] = this, this[Ao].splice(e1, 0, t), !t[yr] && this[yr] && (t[yr] = this[yr]);
    }
    [Mr]() {
        return !this.name;
    }
    [Or]() {
        return "";
    }
    [Jr]() {
        return 0 === this[Ao].length ? this[Js] : this[Ao].map((e1)=>e1[Jr]()).join("");
    }
    get [wo]() {
        const e1 = Object.getPrototypeOf(this);
        if (!e1._attributes) {
            const t = e1._attributes = new Set;
            for (const e1 of Object.getOwnPropertyNames(this)){
                if (null === this[e1] || this[e1] instanceof XFAObject || this[e1] instanceof XFAObjectArray) break;
                t.add(e1);
            }
        }
        return shadow$1(this, wo, e1._attributes);
    }
    [Tr](e1) {
        let t = this;
        for(; t;){
            if (t === e1) return !0;
            t = t[mr]();
        }
        return !1;
    }
    [mr]() {
        return this[Do];
    }
    [pr]() {
        return this[mr]();
    }
    [ur](e1 = null) {
        return e1 ? this[e1] : this[Ao];
    }
    [Qs]() {
        const e1 = Object.create(null);
        this[Js] && (e1.$content = this[Js]);
        for (const t of Object.getOwnPropertyNames(this)){
            const i = this[t];
            null !== i && (i instanceof XFAObject ? e1[t] = i[Qs]() : i instanceof XFAObjectArray ? i.isEmpty() || (e1[t] = i.dump()) : e1[t] = i);
        }
        return e1;
    }
    [to]() {
        return null;
    }
    [Qr]() {
        return HTMLResult.EMPTY;
    }
    *[gr]() {
        for (const e1 of this[ur]())yield e1;
    }
    *[Co](e1, t) {
        for (const i of this[gr]())if (!e1 || t === e1.has(i[Pr])) {
            const e1 = this[sr](), t = i[Qr](e1);
            t.success || (this[er].failingNode = i), yield t;
        }
    }
    [ir]() {
        return null;
    }
    [Xs](e1, t) {
        this[er].children.push(e1);
    }
    [sr]() {}
    [zs]({ filter: e1 = null, include: t = !0 }) {
        if (this[er].generator) {
            const e1 = this[sr](), t = this[er].failingNode[Qr](e1);
            if (!t.success) return t;
            t.html && this[Xs](t.html, t.bbox), delete this[er].failingNode;
        } else this[er].generator = this[Co](e1, t);
        for(;;){
            const e1 = this[er].generator.next();
            if (e1.done) break;
            const t = e1.value;
            if (!t.success) return t;
            t.html && this[Xs](t.html, t.bbox);
        }
        return this[er].generator = null, HTMLResult.EMPTY;
    }
    [Vr](e1) {
        this[_o] = new Set(Object.keys(e1));
    }
    [Fo](e1) {
        const t = this[wo], i = this[_o];
        return [
            ...e1
        ].filter((e1)=>t.has(e1) && !i.has(e1));
    }
    [zr](e1, t = new Set) {
        for (const i of this[Ao])i[Oo](e1, t);
    }
    [Oo](e1, t) {
        const i = this[ko](e1, t);
        i ? this[bo](i, e1, t) : this[zr](e1, t);
    }
    [ko](e1, t) {
        const { use: i, usehref: n } = this;
        if (!i && !n) return null;
        let a = null, s = null, r = null, o = i;
        if (n ? (o = n, n.startsWith("#som(") && n.endsWith(")") ? s = n.slice(5, -1) : n.startsWith(".#som(") && n.endsWith(")") ? s = n.slice(6, -1) : n.startsWith("#") ? r = n.slice(1) : n.startsWith(".#") && (r = n.slice(2))) : i.startsWith("#") ? r = i.slice(1) : s = i, this.use = this.usehref = "", r ? a = e1.get(r) : (a = searchNode(e1.get(qr), this, s, !0, !1), a && (a = a[0])), !a) return warn$1(`XFA - Invalid prototype reference: ${o}.`), null;
        if (a[Pr] !== this[Pr]) return warn$1(`XFA - Incompatible prototype: ${a[Pr]} !== ${this[Pr]}.`), null;
        if (t.has(a)) return warn$1("XFA - Cycle detected in prototypes use."), null;
        t.add(a);
        const l = a[ko](e1, t);
        return l && a[bo](l, e1, t), a[zr](e1, t), t.delete(a), a;
    }
    [bo](e1, t, i) {
        if (i.has(e1)) return void warn$1("XFA - Cycle detected in prototypes use.");
        !this[Js] && e1[Js] && (this[Js] = e1[Js]);
        new Set(i).add(e1);
        for (const t of this[Fo](e1[_o]))this[t] = e1[t], this[_o] && this[_o].add(t);
        for (const n of Object.getOwnPropertyNames(this)){
            if (this[wo].has(n)) continue;
            const a = this[n], s = e1[n];
            if (a instanceof XFAObjectArray) {
                for (const e1 of a[Ao])e1[Oo](t, i);
                for(let n = a[Ao].length, r = s[Ao].length; n < r; n++){
                    const s = e1[Ao][n][Ks]();
                    if (!a.push(s)) break;
                    s[Do] = this, this[Ao].push(s), s[Oo](t, i);
                }
            } else if (null === a) {
                if (null !== s) {
                    const e1 = s[Ks]();
                    e1[Do] = this, this[n] = e1, this[Ao].push(e1), e1[Oo](t, i);
                }
            } else a[zr](t, i), s && a[bo](s, t, i);
        }
    }
    static [xo](e1) {
        return Array.isArray(e1) ? e1.map((e1)=>XFAObject[xo](e1)) : "object" == typeof e1 && null !== e1 ? Object.assign({}, e1) : e1;
    }
    [Ks]() {
        const e1 = Object.create(Object.getPrototypeOf(this));
        for (const t of Object.getOwnPropertySymbols(this))try {
            e1[t] = this[t];
        } catch  {
            shadow$1(e1, t, this[t]);
        }
        e1[io] = `${e1[Pr]}${Ro++}`, e1[Ao] = [];
        for (const t of Object.getOwnPropertyNames(this)){
            if (this[wo].has(t)) {
                e1[t] = XFAObject[xo](this[t]);
                continue;
            }
            const i = this[t];
            e1[t] = i instanceof XFAObjectArray ? new XFAObjectArray(i[Eo]) : null;
        }
        for (const t of this[Ao]){
            const i = t[Pr], n = t[Ks]();
            e1[Ao].push(n), n[Do] = e1, null === e1[i] ? e1[i] = n : e1[i][Ao].push(n);
        }
        return e1;
    }
    [ur](e1 = null) {
        return e1 ? this[Ao].filter((t)=>t[Pr] === e1) : this[Ao];
    }
    [rr](e1) {
        return this[e1];
    }
    [or](e1, t, i = !0) {
        return Array.from(this[lr](e1, t, i));
    }
    *[lr](e1, t, i = !0) {
        if ("parent" !== e1) {
            for (const i of this[Ao])i[Pr] === e1 && (yield i), i.name === e1 && (yield i), (t || i[Mr]()) && (yield* i[lr](e1, t, !1));
            i && this[wo].has(e1) && (yield new XFAAttribute(this, e1, this[e1]));
        } else yield this[Do];
    }
}
class XFAObjectArray {
    constructor(e1 = 1 / 0){
        this[Eo] = e1, this[Ao] = [];
    }
    get isXFAObject() {
        return !1;
    }
    get isXFAObjectArray() {
        return !0;
    }
    push(e1) {
        return this[Ao].length <= this[Eo] ? (this[Ao].push(e1), !0) : (warn$1(`XFA - node "${e1[Pr]}" accepts no more than ${this[Eo]} children`), !1);
    }
    isEmpty() {
        return 0 === this[Ao].length;
    }
    dump() {
        return 1 === this[Ao].length ? this[Ao][0][Qs]() : this[Ao].map((e1)=>e1[Qs]());
    }
    [Ks]() {
        const e1 = new XFAObjectArray(this[Eo]);
        return e1[Ao] = this[Ao].map((e1)=>e1[Ks]()), e1;
    }
    get children() {
        return this[Ao];
    }
    clear() {
        this[Ao].length = 0;
    }
}
class XFAAttribute {
    constructor(e1, t, i){
        this[Do] = e1, this[Pr] = t, this[Js] = i, this[Ys] = !1, this[io] = "attribute" + Ro++;
    }
    [mr]() {
        return this[Do];
    }
    [kr]() {
        return !0;
    }
    [cr]() {
        return this[Js].trim();
    }
    [Kr](e1) {
        e1 = e1.value || "", this[Js] = e1.toString();
    }
    [Jr]() {
        return this[Js];
    }
    [Tr](e1) {
        return this[Do] === e1 || this[Do][Tr](e1);
    }
}
class XmlObject extends XFAObject {
    constructor(e1, t, i = {}){
        if (super(e1, t), this[Js] = "", this[So] = null, "#text" !== t) {
            const e1 = new Map;
            this[yo] = e1;
            for (const [t, n] of Object.entries(i))e1.set(t, new XFAAttribute(this, t, n));
            if (i.hasOwnProperty(Rr)) {
                const e1 = i[Rr].xfa.dataNode;
                void 0 !== e1 && ("dataGroup" === e1 ? this[So] = !1 : "dataValue" === e1 && (this[So] = !0));
            }
        }
        this[Ys] = !1;
    }
    [eo](e1) {
        const t = this[Pr];
        if ("#text" === t) return void e1.push(encodeToXmlString(this[Js]));
        const i = utf8StringToString(t), n = this[_r] === Bo ? "xfa:" : "";
        e1.push(`<${n}${i}`);
        for (const [t, i] of this[yo].entries()){
            const n = utf8StringToString(t);
            e1.push(` ${n}="${encodeToXmlString(i[Js])}"`);
        }
        if (null !== this[So] && (this[So] ? e1.push(' xfa:dataNode="dataValue"') : e1.push(' xfa:dataNode="dataGroup"')), this[Js] || 0 !== this[Ao].length) {
            if (e1.push(">"), this[Js]) "string" == typeof this[Js] ? e1.push(encodeToXmlString(this[Js])) : this[Js][eo](e1);
            else for (const t of this[Ao])t[eo](e1);
            e1.push(`</${n}${i}>`);
        } else e1.push("/>");
    }
    [Nr](e1) {
        if (this[Js]) {
            const e1 = new XmlObject(this[_r], "#text");
            this[qs](e1), e1[Js] = this[Js], this[Js] = "";
        }
        return this[qs](e1), !0;
    }
    [Ur](e1) {
        this[Js] += e1;
    }
    [tr]() {
        if (this[Js] && this[Ao].length > 0) {
            const e1 = new XmlObject(this[_r], "#text");
            this[qs](e1), e1[Js] = this[Js], delete this[Js];
        }
    }
    [Qr]() {
        return "#text" === this[Pr] ? HTMLResult.success({
            name: "#text",
            value: this[Js]
        }) : HTMLResult.EMPTY;
    }
    [ur](e1 = null) {
        return e1 ? this[Ao].filter((t)=>t[Pr] === e1) : this[Ao];
    }
    [ar]() {
        return this[yo];
    }
    [rr](e1) {
        const t = this[yo].get(e1);
        return void 0 !== t ? t : this[ur](e1);
    }
    *[lr](e1, t) {
        const i = this[yo].get(e1);
        i && (yield i);
        for (const i of this[Ao])i[Pr] === e1 && (yield i), t && (yield* i[lr](e1, t));
    }
    *[nr](e1, t) {
        const i = this[yo].get(e1);
        !i || t && i[Ys] || (yield i);
        for (const i of this[Ao])yield* i[nr](e1, t);
    }
    *[dr](e1, t, i) {
        for (const n of this[Ao])n[Pr] !== e1 || i && n[Ys] || (yield n), t && (yield* n[dr](e1, t, i));
    }
    [kr]() {
        return null === this[So] ? 0 === this[Ao].length || this[Ao][0][_r] === ao.xhtml.id : this[So];
    }
    [cr]() {
        return null === this[So] ? 0 === this[Ao].length ? this[Js].trim() : this[Ao][0][_r] === ao.xhtml.id ? this[Ao][0][Jr]().trim() : null : this[Js].trim();
    }
    [Kr](e1) {
        e1 = e1.value || "", this[Js] = e1.toString();
    }
    [Qs](e1 = !1) {
        const t = Object.create(null);
        e1 && (t.$ns = this[_r]), this[Js] && (t.$content = this[Js]), t.$name = this[Pr], t.children = [];
        for (const i of this[Ao])t.children.push(i[Qs](e1));
        t.attributes = Object.create(null);
        for (const [e1, i] of this[yo])t.attributes[e1] = i[Js];
        return t;
    }
}
class ContentObject extends XFAObject {
    constructor(e1, t){
        super(e1, t), this[Js] = "";
    }
    [Ur](e1) {
        this[Js] += e1;
    }
    [tr]() {}
}
class OptionObject extends ContentObject {
    constructor(e1, t, i){
        super(e1, t), this[Mo] = i;
    }
    [tr]() {
        this[Js] = getKeyword({
            data: this[Js],
            defaultValue: this[Mo][0],
            validate: (e1)=>this[Mo].includes(e1)
        });
    }
    [Ws](e1) {
        super[Ws](e1), delete this[Mo];
    }
}
class StringObject extends ContentObject {
    [tr]() {
        this[Js] = this[Js].trim();
    }
}
class IntegerObject extends ContentObject {
    constructor(e1, t, i, n){
        super(e1, t), this[vo] = i, this[Po] = n;
    }
    [tr]() {
        this[Js] = getInteger({
            data: this[Js],
            defaultValue: this[vo],
            validate: this[Po]
        });
    }
    [Ws](e1) {
        super[Ws](e1), delete this[vo], delete this[Po];
    }
}
class Option01 extends IntegerObject {
    constructor(e1, t){
        super(e1, t, 0, (e1)=>1 === e1);
    }
}
class Option10 extends IntegerObject {
    constructor(e1, t){
        super(e1, t, 1, (e1)=>0 === e1);
    }
}
function measureToString(e1) {
    return "string" == typeof e1 ? "0px" : Number.isInteger(e1) ? `${e1}px` : `${e1.toFixed(2)}px`;
}
const No = {
    anchorType (e1, t) {
        const i = e1[pr]();
        if (i && (!i.layout || "position" === i.layout)) switch("transform" in t || (t.transform = ""), e1.anchorType){
            case "bottomCenter":
                t.transform += "translate(-50%, -100%)";
                break;
            case "bottomLeft":
                t.transform += "translate(0,-100%)";
                break;
            case "bottomRight":
                t.transform += "translate(-100%,-100%)";
                break;
            case "middleCenter":
                t.transform += "translate(-50%,-50%)";
                break;
            case "middleLeft":
                t.transform += "translate(0,-50%)";
                break;
            case "middleRight":
                t.transform += "translate(-100%,-50%)";
                break;
            case "topCenter":
                t.transform += "translate(-50%,0)";
                break;
            case "topRight":
                t.transform += "translate(-100%,0)";
        }
    },
    dimensions (e1, t) {
        const i = e1[pr]();
        let n = e1.w;
        const a = e1.h;
        if (i.layout?.includes("row")) {
            const t = i[er], a = e1.colSpan;
            let s;
            -1 === a ? (s = Math.sumPrecise(t.columnWidths.slice(t.currentColumn)), t.currentColumn = 0) : (s = Math.sumPrecise(t.columnWidths.slice(t.currentColumn, t.currentColumn + a)), t.currentColumn = (t.currentColumn + e1.colSpan) % t.columnWidths.length), isNaN(s) || (n = e1.w = s);
        }
        t.width = "" !== n ? measureToString(n) : "auto", t.height = "" !== a ? measureToString(a) : "auto";
    },
    position (e1, t) {
        const i = e1[pr]();
        i?.layout && "position" !== i.layout || (t.position = "absolute", t.left = measureToString(e1.x), t.top = measureToString(e1.y));
    },
    rotate (e1, t) {
        e1.rotate && ("transform" in t || (t.transform = ""), t.transform += `rotate(-${e1.rotate}deg)`, t.transformOrigin = "top left");
    },
    presence (e1, t) {
        switch(e1.presence){
            case "invisible":
                t.visibility = "hidden";
                break;
            case "hidden":
            case "inactive":
                t.display = "none";
        }
    },
    hAlign (e1, t) {
        if ("para" === e1[Pr]) switch(e1.hAlign){
            case "justifyAll":
                t.textAlign = "justify-all";
                break;
            case "radix":
                t.textAlign = "left";
                break;
            default:
                t.textAlign = e1.hAlign;
        }
        else switch(e1.hAlign){
            case "left":
                t.alignSelf = "start";
                break;
            case "center":
                t.alignSelf = "center";
                break;
            case "right":
                t.alignSelf = "end";
        }
    },
    margin (e1, t) {
        e1.margin && (t.margin = e1.margin[to]().margin);
    }
};
function setMinMaxDimensions(e1, t) {
    "position" === e1[pr]().layout && (e1.minW > 0 && (t.minWidth = measureToString(e1.minW)), e1.maxW > 0 && (t.maxWidth = measureToString(e1.maxW)), e1.minH > 0 && (t.minHeight = measureToString(e1.minH)), e1.maxH > 0 && (t.maxHeight = measureToString(e1.maxH)));
}
function layoutText(e1, t, i, n, a, s) {
    const r = new TextMeasure(t, i, n, a);
    return "string" == typeof e1 ? r.addString(e1) : e1[jr](r), r.compute(s);
}
function layoutNode(e1, t) {
    let i = null, n = null, a = !1;
    if ((!e1.w || !e1.h) && e1.value) {
        let s = 0, r = 0;
        e1.margin && (s = e1.margin.leftInset + e1.margin.rightInset, r = e1.margin.topInset + e1.margin.bottomInset);
        let o = null, l = null;
        e1.para && (l = Object.create(null), o = "" === e1.para.lineHeight ? null : e1.para.lineHeight, l.top = "" === e1.para.spaceAbove ? 0 : e1.para.spaceAbove, l.bottom = "" === e1.para.spaceBelow ? 0 : e1.para.spaceBelow, l.left = "" === e1.para.marginLeft ? 0 : e1.para.marginLeft, l.right = "" === e1.para.marginRight ? 0 : e1.para.marginRight);
        let c = e1.font;
        if (!c) {
            const t = e1[br]();
            let i = e1[mr]();
            for(; i && i !== t;){
                if (i.font) {
                    c = i.font;
                    break;
                }
                i = i[mr]();
            }
        }
        const h = (e1.w || t.width) - s, d = e1[yr].fontFinder;
        if (e1.value.exData && e1.value.exData[Js] && "text/html" === e1.value.exData.contentType) {
            const t = layoutText(e1.value.exData[Js], c, l, o, d, h);
            n = t.width, i = t.height, a = t.isBroken;
        } else {
            const t = e1.value[Jr]();
            if (t) {
                const e1 = layoutText(t, c, l, o, d, h);
                n = e1.width, i = e1.height, a = e1.isBroken;
            }
        }
        null === n || e1.w || (n += s), null === i || e1.h || (i += r);
    }
    return {
        w: n,
        h: i,
        isBroken: a
    };
}
function computeBbox(e1, t, i) {
    let n;
    if ("" !== e1.w && "" !== e1.h) n = [
        e1.x,
        e1.y,
        e1.w,
        e1.h
    ];
    else {
        if (!i) return null;
        let a = e1.w;
        if ("" === a) {
            if (0 === e1.maxW) {
                const t = e1[pr]();
                a = "position" === t.layout && "" !== t.w ? 0 : e1.minW;
            } else a = Math.min(e1.maxW, i.width);
            t.attributes.style.width = measureToString(a);
        }
        let s = e1.h;
        if ("" === s) {
            if (0 === e1.maxH) {
                const t = e1[pr]();
                s = "position" === t.layout && "" !== t.h ? 0 : e1.minH;
            } else s = Math.min(e1.maxH, i.height);
            t.attributes.style.height = measureToString(s);
        }
        n = [
            e1.x,
            e1.y,
            a,
            s
        ];
    }
    return n;
}
function fixDimensions(e1) {
    const t = e1[pr]();
    if (t.layout?.includes("row")) {
        const i = t[er], n = e1.colSpan;
        let a;
        a = -1 === n ? Math.sumPrecise(i.columnWidths.slice(i.currentColumn)) : Math.sumPrecise(i.columnWidths.slice(i.currentColumn, i.currentColumn + n)), isNaN(a) || (e1.w = a);
    }
    t.layout && "position" !== t.layout && (e1.x = e1.y = 0), "table" === e1.layout && "" === e1.w && Array.isArray(e1.columnWidths) && (e1.w = Math.sumPrecise(e1.columnWidths));
}
function layoutClass(e1) {
    switch(e1.layout){
        case "position":
        default:
            return "xfaPosition";
        case "lr-tb":
            return "xfaLrTb";
        case "rl-row":
            return "xfaRlRow";
        case "rl-tb":
            return "xfaRlTb";
        case "row":
            return "xfaRow";
        case "table":
            return "xfaTable";
        case "tb":
            return "xfaTb";
    }
}
function toStyle(e1, ...t) {
    const i = Object.create(null);
    for (const n of t){
        const t = e1[n];
        if (null !== t) {
            if (No.hasOwnProperty(n)) No[n](e1, i);
            else if (t instanceof XFAObject) {
                const e1 = t[to]();
                e1 ? Object.assign(i, e1) : warn$1(`(DEBUG) - XFA - style for ${n} not implemented yet`);
            }
        }
    }
    return i;
}
function createWrapper(e1, t) {
    const { attributes: i } = t, { style: n } = i, a = {
        name: "div",
        attributes: {
            class: [
                "xfaWrapper"
            ],
            style: Object.create(null)
        },
        children: []
    };
    if (i.class.push("xfaWrapped"), e1.border) {
        const { widths: i, insets: s } = e1.border[er];
        let r, o, l = s[0], c = s[3];
        const h = s[0] + s[2], d = s[1] + s[3];
        switch(e1.border.hand){
            case "even":
                l -= i[0] / 2, c -= i[3] / 2, r = `calc(100% + ${(i[1] + i[3]) / 2 - d}px)`, o = `calc(100% + ${(i[0] + i[2]) / 2 - h}px)`;
                break;
            case "left":
                l -= i[0], c -= i[3], r = `calc(100% + ${i[1] + i[3] - d}px)`, o = `calc(100% + ${i[0] + i[2] - h}px)`;
                break;
            case "right":
                r = d ? `calc(100% - ${d}px)` : "100%", o = h ? `calc(100% - ${h}px)` : "100%";
        }
        const u = [
            "xfaBorder"
        ];
        isPrintOnly(e1.border) && u.push("xfaPrintOnly");
        const g = {
            name: "div",
            attributes: {
                class: u,
                style: {
                    top: `${l}px`,
                    left: `${c}px`,
                    width: r,
                    height: o
                }
            },
            children: []
        };
        for (const e1 of [
            "border",
            "borderWidth",
            "borderColor",
            "borderRadius",
            "borderStyle"
        ])void 0 !== n[e1] && (g.attributes.style[e1] = n[e1], delete n[e1]);
        a.children.push(g, t);
    } else a.children.push(t);
    for (const e1 of [
        "background",
        "backgroundClip",
        "top",
        "left",
        "width",
        "height",
        "minWidth",
        "minHeight",
        "maxWidth",
        "maxHeight",
        "transform",
        "transformOrigin",
        "visibility"
    ])void 0 !== n[e1] && (a.attributes.style[e1] = n[e1], delete n[e1]);
    return a.attributes.style.position = "absolute" === n.position ? "absolute" : "relative", delete n.position, n.alignSelf && (a.attributes.style.alignSelf = n.alignSelf, delete n.alignSelf), a;
}
function fixTextIndent(e1) {
    const t = getMeasurement(e1.textIndent, "0px");
    if (t >= 0) return;
    const i = "padding" + ("left" === ("right" === e1.textAlign ? "right" : "left") ? "Left" : "Right"), n = getMeasurement(e1[i], "0px");
    e1[i] = n - t + "px";
}
function setAccess(e1, t) {
    switch(e1.access){
        case "nonInteractive":
            t.push("xfaNonInteractive");
            break;
        case "readOnly":
            t.push("xfaReadOnly");
            break;
        case "protected":
            t.push("xfaDisabled");
    }
}
function isPrintOnly(e1) {
    return e1.relevant.length > 0 && !e1.relevant[0].excluded && "print" === e1.relevant[0].viewname;
}
function getCurrentPara(e1) {
    const t = e1[br]()[er].paraStack;
    return t.length ? t.at(-1) : null;
}
function setPara(e1, t, i) {
    if (i.attributes.class?.includes("xfaRich")) {
        t && ("" === e1.h && (t.height = "auto"), "" === e1.w && (t.width = "auto"));
        const n = getCurrentPara(e1);
        if (n) {
            const e1 = i.attributes.style;
            switch(e1.display = "flex", e1.flexDirection = "column", n.vAlign){
                case "top":
                    e1.justifyContent = "start";
                    break;
                case "bottom":
                    e1.justifyContent = "end";
                    break;
                case "middle":
                    e1.justifyContent = "center";
            }
            const t = n[to]();
            for (const [i, n] of Object.entries(t))i in e1 || (e1[i] = n);
        }
    }
}
function setFontFamily(e1, t, i, n) {
    if (!i) return void delete n.fontFamily;
    const a = stripQuotes(e1.typeface);
    n.fontFamily = `"${a}"`;
    const s = i.find(a);
    if (s) {
        const { fontFamily: i } = s.regular.cssFontInfo;
        i !== a && (n.fontFamily = `"${i}"`);
        const r = getCurrentPara(t);
        if (r && "" !== r.lineHeight) return;
        if (n.lineHeight) return;
        const o = selectFont(e1, s);
        o && (n.lineHeight = Math.max(1.2, o.lineHeight));
    }
}
function fixURL(e1) {
    const t = createValidAbsoluteUrl$1(e1, null, {
        addDefaultProtocol: !0,
        tryConvertEncoding: !0
    });
    return t ? t.href : null;
}
function createLine(e1, t) {
    return {
        name: "div",
        attributes: {
            class: [
                "lr-tb" === e1.layout ? "xfaLr" : "xfaRl"
            ]
        },
        children: t
    };
}
function flushHTML(e1) {
    if (!e1[er]) return null;
    const t = {
        name: "div",
        attributes: e1[er].attributes,
        children: e1[er].children
    };
    if (e1[er].failingNode) {
        const i = e1[er].failingNode[ir]();
        i && (e1.layout.endsWith("-tb") ? t.children.push(createLine(e1, [
            i
        ])) : t.children.push(i));
    }
    return 0 === t.children.length ? null : t;
}
function addHTML(e1, t, i) {
    const n = e1[er], a = n.availableSpace, [s, r, o, l] = i;
    switch(e1.layout){
        case "position":
            n.width = Math.max(n.width, s + o), n.height = Math.max(n.height, r + l), n.children.push(t);
            break;
        case "lr-tb":
        case "rl-tb":
            n.line && 1 !== n.attempt || (n.line = createLine(e1, []), n.children.push(n.line), n.numberInLine = 0), n.numberInLine += 1, n.line.children.push(t), 0 === n.attempt ? (n.currentWidth += o, n.height = Math.max(n.height, n.prevHeight + l)) : (n.currentWidth = o, n.prevHeight = n.height, n.height += l, n.attempt = 0), n.width = Math.max(n.width, n.currentWidth);
            break;
        case "rl-row":
        case "row":
            {
                n.children.push(t), n.width += o, n.height = Math.max(n.height, l);
                const e1 = measureToString(n.height);
                for (const t of n.children)t.attributes.style.height = e1;
                break;
            }
        case "table":
        case "tb":
            n.width = MathClamp$1(o, n.width, a.width), n.height += l, n.children.push(t);
    }
}
function getAvailableSpace(e1) {
    const t = e1[er].availableSpace, i = e1.margin ? e1.margin.topInset + e1.margin.bottomInset : 0, n = e1.margin ? e1.margin.leftInset + e1.margin.rightInset : 0;
    switch(e1.layout){
        case "lr-tb":
        case "rl-tb":
            return 0 === e1[er].attempt ? {
                width: t.width - n - e1[er].currentWidth,
                height: t.height - i - e1[er].prevHeight
            } : {
                width: t.width - n,
                height: t.height - i - e1[er].height
            };
        case "rl-row":
        case "row":
            return {
                width: Math.sumPrecise(e1[er].columnWidths.slice(e1[er].currentColumn)),
                height: t.height - n
            };
        case "table":
        case "tb":
            return {
                width: t.width - n,
                height: t.height - i - e1[er].height
            };
        default:
            return t;
    }
}
function checkDimensions(e1, t) {
    if (null === e1[br]()[er].firstUnsplittable) return !0;
    if (0 === e1.w || 0 === e1.h) return !0;
    const i = e1[pr](), n = i[er]?.attempt || 0, [, a, s, r] = function(e1) {
        let t, i, n = "" === e1.w ? NaN : e1.w, a = "" === e1.h ? NaN : e1.h, [s, r] = [
            0,
            0
        ];
        switch(e1.anchorType || ""){
            case "bottomCenter":
                [s, r] = [
                    n / 2,
                    a
                ];
                break;
            case "bottomLeft":
                [s, r] = [
                    0,
                    a
                ];
                break;
            case "bottomRight":
                [s, r] = [
                    n,
                    a
                ];
                break;
            case "middleCenter":
                [s, r] = [
                    n / 2,
                    a / 2
                ];
                break;
            case "middleLeft":
                [s, r] = [
                    0,
                    a / 2
                ];
                break;
            case "middleRight":
                [s, r] = [
                    n,
                    a / 2
                ];
                break;
            case "topCenter":
                [s, r] = [
                    n / 2,
                    0
                ];
                break;
            case "topRight":
                [s, r] = [
                    n,
                    0
                ];
        }
        switch(e1.rotate || 0){
            case 0:
                [t, i] = [
                    -s,
                    -r
                ];
                break;
            case 90:
                [t, i] = [
                    -r,
                    s
                ], [n, a] = [
                    a,
                    -n
                ];
                break;
            case 180:
                [t, i] = [
                    s,
                    r
                ], [n, a] = [
                    -n,
                    -a
                ];
                break;
            case 270:
                [t, i] = [
                    r,
                    -s
                ], [n, a] = [
                    -a,
                    n
                ];
        }
        return [
            e1.x + t + Math.min(0, n),
            e1.y + i + Math.min(0, a),
            Math.abs(n),
            Math.abs(a)
        ];
    }(e1);
    switch(i.layout){
        case "lr-tb":
        case "rl-tb":
            return 0 === n ? e1[br]()[er].noLayoutFailure ? "" !== e1.w ? Math.round(s - t.width) <= 2 : t.width > 2 : !("" !== e1.h && Math.round(r - t.height) > 2) && ("" !== e1.w ? Math.round(s - t.width) <= 2 || 0 === i[er].numberInLine && t.height > 2 : t.width > 2) : !!e1[br]()[er].noLayoutFailure || !("" !== e1.h && Math.round(r - t.height) > 2) && ("" === e1.w || Math.round(s - t.width) <= 2 || !i[Er]()) && t.height > 2;
        case "table":
        case "tb":
            return !!e1[br]()[er].noLayoutFailure || ("" === e1.h || e1[Ir]() ? ("" === e1.w || Math.round(s - t.width) <= 2 || !i[Er]()) && t.height > 2 : Math.round(r - t.height) <= 2);
        case "position":
            if (e1[br]()[er].noLayoutFailure) return !0;
            if ("" === e1.h || Math.round(r + a - t.height) <= 2) return !0;
            return r + a > e1[br]()[er].currentContentArea.h;
        case "rl-row":
        case "row":
            return !!e1[br]()[er].noLayoutFailure || "" === e1.h || Math.round(r - t.height) <= 2;
        default:
            return !0;
    }
}
const Lo = ao.template.id, Uo = "http://www.w3.org/2000/svg", jo = /^H(\d+)$/, $o = new Set([
    "image/gif",
    "image/jpeg",
    "image/jpg",
    "image/pjpeg",
    "image/png",
    "image/apng",
    "image/x-png",
    "image/bmp",
    "image/x-ms-bmp",
    "image/tiff",
    "image/tif",
    "application/octet-stream"
]), Ho = [
    [
        [
            66,
            77
        ],
        "image/bmp"
    ],
    [
        [
            255,
            216,
            255
        ],
        "image/jpeg"
    ],
    [
        [
            73,
            73,
            42,
            0
        ],
        "image/tiff"
    ],
    [
        [
            77,
            77,
            0,
            42
        ],
        "image/tiff"
    ],
    [
        [
            71,
            73,
            70,
            56,
            57,
            97
        ],
        "image/gif"
    ],
    [
        [
            137,
            80,
            78,
            71,
            13,
            10,
            26,
            10
        ],
        "image/png"
    ]
];
function getBorderDims(e1) {
    if (!e1 || !e1.border) return {
        w: 0,
        h: 0
    };
    const t = e1.border[hr]();
    return t ? {
        w: t.widths[0] + t.widths[2] + t.insets[0] + t.insets[2],
        h: t.widths[1] + t.widths[3] + t.insets[1] + t.insets[3]
    } : {
        w: 0,
        h: 0
    };
}
function hasMargin(e1) {
    return e1.margin && (e1.margin.topInset || e1.margin.rightInset || e1.margin.bottomInset || e1.margin.leftInset);
}
function _setValue(e1, t) {
    if (!e1.value) {
        const t = new Value({});
        e1[qs](t), e1.value = t;
    }
    e1.value[Kr](t);
}
function* getContainedChildren(e1) {
    for (const t of e1[ur]())t instanceof SubformSet ? yield* t[gr]() : yield t;
}
function isRequired(e1) {
    return "error" === e1.validate?.nullTest;
}
function setTabIndex(e1) {
    for(; e1;){
        if (!e1.traversal) return void (e1[Yr] = e1[mr]()[Yr]);
        if (e1[Yr]) return;
        let t = null;
        for (const i of e1.traversal[ur]())if ("next" === i.operation) {
            t = i;
            break;
        }
        if (!t || !t.ref) return void (e1[Yr] = e1[mr]()[Yr]);
        const i = e1[br]();
        e1[Yr] = ++i[Yr];
        const n = i[Wr](t.ref, e1);
        if (!n) return;
        e1 = n[0];
    }
}
function applyAssist(e1, t) {
    const i = e1.assist;
    if (i) {
        const e1 = i[Qr]();
        e1 && (t.title = e1);
        const n = i.role.match(jo);
        if (n) {
            const e1 = "heading", i = n[1];
            t.role = e1, t["aria-level"] = i;
        }
    }
    if ("table" === e1.layout) t.role = "table";
    else if ("row" === e1.layout) t.role = "row";
    else {
        const i = e1[mr]();
        "row" === i.layout && (t.role = "TH" === i.assist?.role ? "columnheader" : "cell");
    }
}
function ariaLabel(e1) {
    if (!e1.assist) return null;
    const t = e1.assist;
    return t.speak && "" !== t.speak[Js] ? t.speak[Js] : t.toolTip ? t.toolTip[Js] : null;
}
function valueToHtml(e1) {
    return HTMLResult.success({
        name: "div",
        attributes: {
            class: [
                "xfaRich"
            ],
            style: Object.create(null)
        },
        children: [
            {
                name: "span",
                attributes: {
                    style: Object.create(null)
                },
                value: e1
            }
        ]
    });
}
function setFirstUnsplittable(e1) {
    const t = e1[br]();
    null === t[er].firstUnsplittable && (t[er].firstUnsplittable = e1, t[er].noLayoutFailure = !0);
}
function unsetFirstUnsplittable(e1) {
    const t = e1[br]();
    t[er].firstUnsplittable === e1 && (t[er].noLayoutFailure = !1);
}
function handleBreak(e1) {
    if (e1[er]) return !1;
    if (e1[er] = Object.create(null), "auto" === e1.targetType) return !1;
    const t = e1[br]();
    let i = null;
    if (e1.target) {
        if (i = t[Wr](e1.target, e1[mr]()), !i) return !1;
        i = i[0];
    }
    const { currentPageArea: n, currentContentArea: a } = t[er];
    if ("pageArea" === e1.targetType) return i instanceof PageArea || (i = null), e1.startNew ? (e1[er].target = i || n, !0) : !(!i || i === n) && (e1[er].target = i, !0);
    i instanceof ContentArea || (i = null);
    const s = i && i[mr]();
    let r, o = s;
    if (e1.startNew) if (i) {
        const e1 = s.contentArea.children, t = e1.indexOf(a), n = e1.indexOf(i);
        -1 !== t && t < n && (o = null), r = n - 1;
    } else r = n.contentArea.children.indexOf(a);
    else {
        if (!i || i === a) return !1;
        r = s.contentArea.children.indexOf(i) - 1, o = s === n ? null : s;
    }
    return e1[er].target = o, e1[er].index = r, !0;
}
function handleOverflow(e1, t, i) {
    const n = e1[br](), a = n[er].noLayoutFailure, s = t[pr];
    t[pr] = ()=>e1, n[er].noLayoutFailure = !0;
    const r = t[Qr](i);
    e1[Xs](r.html, r.bbox), n[er].noLayoutFailure = a, t[pr] = s;
}
class AppearanceFilter extends StringObject {
    constructor(e1){
        super(Lo, "appearanceFilter"), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Arc extends XFAObject {
    constructor(e1){
        super(Lo, "arc", !0), this.circular = getInteger({
            data: e1.circular,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.hand = getStringOption(e1.hand, [
            "even",
            "left",
            "right"
        ]), this.id = e1.id || "", this.startAngle = getFloat({
            data: e1.startAngle,
            defaultValue: 0,
            validate: (e1)=>!0
        }), this.sweepAngle = getFloat({
            data: e1.sweepAngle,
            defaultValue: 360,
            validate: (e1)=>!0
        }), this.use = e1.use || "", this.usehref = e1.usehref || "", this.edge = null, this.fill = null;
    }
    [Qr]() {
        const e1 = this.edge || new Edge({}), t = e1[to](), i = Object.create(null);
        let n;
        "visible" === this.fill?.presence ? Object.assign(i, this.fill[to]()) : i.fill = "transparent", i.strokeWidth = measureToString("visible" === e1.presence ? e1.thickness : 0), i.stroke = t.color;
        const a = {
            xmlns: Uo,
            style: {
                width: "100%",
                height: "100%",
                overflow: "visible"
            }
        };
        if (360 === this.sweepAngle) n = {
            name: "ellipse",
            attributes: {
                xmlns: Uo,
                cx: "50%",
                cy: "50%",
                rx: "50%",
                ry: "50%",
                style: i
            }
        };
        else {
            const e1 = this.startAngle * Math.PI / 180, t = this.sweepAngle * Math.PI / 180, s = this.sweepAngle > 180 ? 1 : 0, [r, o, l, c] = [
                50 * (1 + Math.cos(e1)),
                50 * (1 - Math.sin(e1)),
                50 * (1 + Math.cos(e1 + t)),
                50 * (1 - Math.sin(e1 + t))
            ];
            n = {
                name: "path",
                attributes: {
                    xmlns: Uo,
                    d: `M ${r} ${o} A 50 50 0 ${s} 0 ${l} ${c}`,
                    vectorEffect: "non-scaling-stroke",
                    style: i
                }
            }, Object.assign(a, {
                viewBox: "0 0 100 100",
                preserveAspectRatio: "none"
            });
        }
        const s = {
            name: "svg",
            children: [
                n
            ],
            attributes: a
        };
        return hasMargin(this[mr]()[mr]()) ? HTMLResult.success({
            name: "div",
            attributes: {
                style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                }
            },
            children: [
                s
            ]
        }) : (s.attributes.style.position = "absolute", HTMLResult.success(s));
    }
}
class Area extends XFAObject {
    constructor(e1){
        super(Lo, "area", !0), this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        }), this.id = e1.id || "", this.name = e1.name || "", this.relevant = getRelevant(e1.relevant), this.use = e1.use || "", this.usehref = e1.usehref || "", this.x = getMeasurement(e1.x, "0pt"), this.y = getMeasurement(e1.y, "0pt"), this.desc = null, this.extras = null, this.area = new XFAObjectArray, this.draw = new XFAObjectArray, this.exObject = new XFAObjectArray, this.exclGroup = new XFAObjectArray, this.field = new XFAObjectArray, this.subform = new XFAObjectArray, this.subformSet = new XFAObjectArray;
    }
    *[gr]() {
        yield* getContainedChildren(this);
    }
    [Mr]() {
        return !0;
    }
    [Cr]() {
        return !0;
    }
    [Xs](e1, t) {
        const [i, n, a, s] = t;
        this[er].width = Math.max(this[er].width, i + a), this[er].height = Math.max(this[er].height, n + s), this[er].children.push(e1);
    }
    [sr]() {
        return this[er].availableSpace;
    }
    [Qr](e1) {
        const t = toStyle(this, "position"), i = {
            style: t,
            id: this[io],
            class: [
                "xfaArea"
            ]
        };
        isPrintOnly(this) && i.class.push("xfaPrintOnly"), this.name && (i.xfaName = this.name);
        const n = [];
        this[er] = {
            children: n,
            width: 0,
            height: 0,
            availableSpace: e1
        };
        const a = this[zs]({
            filter: new Set([
                "area",
                "draw",
                "field",
                "exclGroup",
                "subform",
                "subformSet"
            ]),
            include: !0
        });
        if (!a.success) return a.isBreak() ? a : (delete this[er], HTMLResult.FAILURE);
        t.width = measureToString(this[er].width), t.height = measureToString(this[er].height);
        const s = {
            name: "div",
            attributes: i,
            children: n
        }, r = [
            this.x,
            this.y,
            this[er].width,
            this[er].height
        ];
        return delete this[er], HTMLResult.success(s, r);
    }
}
class Assist extends XFAObject {
    constructor(e1){
        super(Lo, "assist", !0), this.id = e1.id || "", this.role = e1.role || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.speak = null, this.toolTip = null;
    }
    [Qr]() {
        return this.toolTip?.[Js] || null;
    }
}
class Barcode extends XFAObject {
    constructor(e1){
        super(Lo, "barcode", !0), this.charEncoding = getKeyword({
            data: e1.charEncoding ? e1.charEncoding.toLowerCase() : "",
            defaultValue: "",
            validate: (e1)=>[
                    "utf-8",
                    "big-five",
                    "fontspecific",
                    "gbk",
                    "gb-18030",
                    "gb-2312",
                    "ksc-5601",
                    "none",
                    "shift-jis",
                    "ucs-2",
                    "utf-16"
                ].includes(e1) || e1.match(/iso-8859-\d{2}/)
        }), this.checksum = getStringOption(e1.checksum, [
            "none",
            "1mod10",
            "1mod10_1mod11",
            "2mod10",
            "auto"
        ]), this.dataColumnCount = getInteger({
            data: e1.dataColumnCount,
            defaultValue: -1,
            validate: (e1)=>e1 >= 0
        }), this.dataLength = getInteger({
            data: e1.dataLength,
            defaultValue: -1,
            validate: (e1)=>e1 >= 0
        }), this.dataPrep = getStringOption(e1.dataPrep, [
            "none",
            "flateCompress"
        ]), this.dataRowCount = getInteger({
            data: e1.dataRowCount,
            defaultValue: -1,
            validate: (e1)=>e1 >= 0
        }), this.endChar = e1.endChar || "", this.errorCorrectionLevel = getInteger({
            data: e1.errorCorrectionLevel,
            defaultValue: -1,
            validate: (e1)=>e1 >= 0 && e1 <= 8
        }), this.id = e1.id || "", this.moduleHeight = getMeasurement(e1.moduleHeight, "5mm"), this.moduleWidth = getMeasurement(e1.moduleWidth, "0.25mm"), this.printCheckDigit = getInteger({
            data: e1.printCheckDigit,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.rowColumnRatio = getRatio(e1.rowColumnRatio), this.startChar = e1.startChar || "", this.textLocation = getStringOption(e1.textLocation, [
            "below",
            "above",
            "aboveEmbedded",
            "belowEmbedded",
            "none"
        ]), this.truncate = getInteger({
            data: e1.truncate,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.type = getStringOption(e1.type ? e1.type.toLowerCase() : "", [
            "aztec",
            "codabar",
            "code2of5industrial",
            "code2of5interleaved",
            "code2of5matrix",
            "code2of5standard",
            "code3of9",
            "code3of9extended",
            "code11",
            "code49",
            "code93",
            "code128",
            "code128a",
            "code128b",
            "code128c",
            "code128sscc",
            "datamatrix",
            "ean8",
            "ean8add2",
            "ean8add5",
            "ean13",
            "ean13add2",
            "ean13add5",
            "ean13pwcd",
            "fim",
            "logmars",
            "maxicode",
            "msi",
            "pdf417",
            "pdf417macro",
            "plessey",
            "postauscust2",
            "postauscust3",
            "postausreplypaid",
            "postausstandard",
            "postukrm4scc",
            "postusdpbc",
            "postusimb",
            "postusstandard",
            "postus5zip",
            "qrcode",
            "rfid",
            "rss14",
            "rss14expanded",
            "rss14limited",
            "rss14stacked",
            "rss14stackedomni",
            "rss14truncated",
            "telepen",
            "ucc128",
            "ucc128random",
            "ucc128sscc",
            "upca",
            "upcaadd2",
            "upcaadd5",
            "upcapwcd",
            "upce",
            "upceadd2",
            "upceadd5",
            "upcean2",
            "upcean5",
            "upsmaxicode"
        ]), this.upsMode = getStringOption(e1.upsMode, [
            "usCarrier",
            "internationalCarrier",
            "secureSymbol",
            "standardSymbol"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.wideNarrowRatio = getRatio(e1.wideNarrowRatio), this.encrypt = null, this.extras = null;
    }
}
class Bind extends XFAObject {
    constructor(e1){
        super(Lo, "bind", !0), this.match = getStringOption(e1.match, [
            "once",
            "dataRef",
            "global",
            "none"
        ]), this.ref = e1.ref || "", this.picture = null;
    }
}
class BindItems extends XFAObject {
    constructor(e1){
        super(Lo, "bindItems"), this.connection = e1.connection || "", this.labelRef = e1.labelRef || "", this.ref = e1.ref || "", this.valueRef = e1.valueRef || "";
    }
}
class Bookend extends XFAObject {
    constructor(e1){
        super(Lo, "bookend"), this.id = e1.id || "", this.leader = e1.leader || "", this.trailer = e1.trailer || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class BooleanElement extends Option01 {
    constructor(e1){
        super(Lo, "boolean"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [Qr](e1) {
        return valueToHtml(1 === this[Js] ? "1" : "0");
    }
}
class Border extends XFAObject {
    constructor(e1){
        super(Lo, "border", !0), this.break = getStringOption(e1.break, [
            "close",
            "open"
        ]), this.hand = getStringOption(e1.hand, [
            "even",
            "left",
            "right"
        ]), this.id = e1.id || "", this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]), this.relevant = getRelevant(e1.relevant), this.use = e1.use || "", this.usehref = e1.usehref || "", this.corner = new XFAObjectArray(4), this.edge = new XFAObjectArray(4), this.extras = null, this.fill = null, this.margin = null;
    }
    [hr]() {
        if (!this[er]) {
            const e1 = this.edge.children.slice();
            if (e1.length < 4) {
                const t = e1.at(-1) || new Edge({});
                for(let i = e1.length; i < 4; i++)e1.push(t);
            }
            const t = e1.map((e1)=>e1.thickness), i = [
                0,
                0,
                0,
                0
            ];
            this.margin && (i[0] = this.margin.topInset, i[1] = this.margin.rightInset, i[2] = this.margin.bottomInset, i[3] = this.margin.leftInset), this[er] = {
                widths: t,
                insets: i,
                edges: e1
            };
        }
        return this[er];
    }
    [to]() {
        const { edges: e1 } = this[hr](), t = e1.map((e1)=>{
            const t = e1[to]();
            return t.color ||= "#000000", t;
        }), i = Object.create(null);
        if (this.margin && Object.assign(i, this.margin[to]()), "visible" === this.fill?.presence && Object.assign(i, this.fill[to]()), this.corner.children.some((e1)=>0 !== e1.radius)) {
            const e1 = this.corner.children.map((e1)=>e1[to]());
            if (2 === e1.length || 3 === e1.length) {
                const t = e1.at(-1);
                for(let i = e1.length; i < 4; i++)e1.push(t);
            }
            i.borderRadius = e1.map((e1)=>e1.radius).join(" ");
        }
        switch(this.presence){
            case "invisible":
            case "hidden":
                i.borderStyle = "";
                break;
            case "inactive":
                i.borderStyle = "none";
                break;
            default:
                i.borderStyle = t.map((e1)=>e1.style).join(" ");
        }
        return i.borderWidth = t.map((e1)=>e1.width).join(" "), i.borderColor = t.map((e1)=>e1.color).join(" "), i;
    }
}
class Break extends XFAObject {
    constructor(e1){
        super(Lo, "break", !0), this.after = getStringOption(e1.after, [
            "auto",
            "contentArea",
            "pageArea",
            "pageEven",
            "pageOdd"
        ]), this.afterTarget = e1.afterTarget || "", this.before = getStringOption(e1.before, [
            "auto",
            "contentArea",
            "pageArea",
            "pageEven",
            "pageOdd"
        ]), this.beforeTarget = e1.beforeTarget || "", this.bookendLeader = e1.bookendLeader || "", this.bookendTrailer = e1.bookendTrailer || "", this.id = e1.id || "", this.overflowLeader = e1.overflowLeader || "", this.overflowTarget = e1.overflowTarget || "", this.overflowTrailer = e1.overflowTrailer || "", this.startNew = getInteger({
            data: e1.startNew,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null;
    }
}
class BreakAfter extends XFAObject {
    constructor(e1){
        super(Lo, "breakAfter", !0), this.id = e1.id || "", this.leader = e1.leader || "", this.startNew = getInteger({
            data: e1.startNew,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.target = e1.target || "", this.targetType = getStringOption(e1.targetType, [
            "auto",
            "contentArea",
            "pageArea"
        ]), this.trailer = e1.trailer || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.script = null;
    }
}
class BreakBefore extends XFAObject {
    constructor(e1){
        super(Lo, "breakBefore", !0), this.id = e1.id || "", this.leader = e1.leader || "", this.startNew = getInteger({
            data: e1.startNew,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.target = e1.target || "", this.targetType = getStringOption(e1.targetType, [
            "auto",
            "contentArea",
            "pageArea"
        ]), this.trailer = e1.trailer || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.script = null;
    }
    [Qr](e1) {
        return this[er] = {}, HTMLResult.FAILURE;
    }
}
class Button extends XFAObject {
    constructor(e1){
        super(Lo, "button", !0), this.highlight = getStringOption(e1.highlight, [
            "inverted",
            "none",
            "outline",
            "push"
        ]), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null;
    }
    [Qr](e1) {
        const t = this[mr]()[mr](), i = {
            name: "button",
            attributes: {
                id: this[io],
                class: [
                    "xfaButton"
                ],
                style: {}
            },
            children: []
        };
        for (const e1 of t.event.children){
            if ("click" !== e1.activity || !e1.script) continue;
            const t = recoverJsURL(e1.script[Js]);
            if (!t) continue;
            const n = fixURL(t.url);
            n && i.children.push({
                name: "a",
                attributes: {
                    id: "link" + this[io],
                    href: n,
                    newWindow: t.newWindow,
                    class: [
                        "xfaLink"
                    ],
                    style: {}
                },
                children: []
            });
        }
        return HTMLResult.success(i);
    }
}
class Calculate extends XFAObject {
    constructor(e1){
        super(Lo, "calculate", !0), this.id = e1.id || "", this.override = getStringOption(e1.override, [
            "disabled",
            "error",
            "ignore",
            "warning"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null, this.message = null, this.script = null;
    }
}
class Caption extends XFAObject {
    constructor(e1){
        super(Lo, "caption", !0), this.id = e1.id || "", this.placement = getStringOption(e1.placement, [
            "left",
            "bottom",
            "inline",
            "right",
            "top"
        ]), this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]), this.reserve = Math.ceil(getMeasurement(e1.reserve)), this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
    }
    [Kr](e1) {
        _setValue(this, e1);
    }
    [hr](e1) {
        if (!this[er]) {
            let { width: t, height: i } = e1;
            switch(this.placement){
                case "left":
                case "right":
                case "inline":
                    t = this.reserve <= 0 ? t : this.reserve;
                    break;
                case "top":
                case "bottom":
                    i = this.reserve <= 0 ? i : this.reserve;
            }
            this[er] = layoutNode(this, {
                width: t
            });
        }
        return this[er];
    }
    [Qr](e1) {
        if (!this.value) return HTMLResult.EMPTY;
        this[Hr]();
        const t = this.value[Qr](e1).html;
        if (!t) return this[$r](), HTMLResult.EMPTY;
        const i = this.reserve;
        if (this.reserve <= 0) {
            const { w: t, h: i } = this[hr](e1);
            switch(this.placement){
                case "left":
                case "right":
                case "inline":
                    this.reserve = t;
                    break;
                case "top":
                case "bottom":
                    this.reserve = i;
            }
        }
        const n = [];
        "string" == typeof t ? n.push({
            name: "#text",
            value: t
        }) : n.push(t);
        const a = toStyle(this, "font", "margin", "visibility");
        switch(this.placement){
            case "left":
            case "right":
                this.reserve > 0 && (a.width = measureToString(this.reserve));
                break;
            case "top":
            case "bottom":
                this.reserve > 0 && (a.height = measureToString(this.reserve));
        }
        return setPara(this, null, t), this[$r](), this.reserve = i, HTMLResult.success({
            name: "div",
            attributes: {
                style: a,
                class: [
                    "xfaCaption"
                ]
            },
            children: n
        });
    }
}
class Certificate extends StringObject {
    constructor(e1){
        super(Lo, "certificate"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Certificates extends XFAObject {
    constructor(e1){
        super(Lo, "certificates", !0), this.credentialServerPolicy = getStringOption(e1.credentialServerPolicy, [
            "optional",
            "required"
        ]), this.id = e1.id || "", this.url = e1.url || "", this.urlPolicy = e1.urlPolicy || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
    }
}
class CheckButton extends XFAObject {
    constructor(e1){
        super(Lo, "checkButton", !0), this.id = e1.id || "", this.mark = getStringOption(e1.mark, [
            "default",
            "check",
            "circle",
            "cross",
            "diamond",
            "square",
            "star"
        ]), this.shape = getStringOption(e1.shape, [
            "square",
            "round"
        ]), this.size = getMeasurement(e1.size, "10pt"), this.use = e1.use || "", this.usehref = e1.usehref || "", this.border = null, this.extras = null, this.margin = null;
    }
    [Qr](e1) {
        const t = toStyle(this, "margin"), i = measureToString(this.size);
        let n, a, s;
        t.width = t.height = i;
        const r = this[mr]()[mr](), o = r.items.children.length && r.items.children[0][Qr]().html || [], l = {
            on: (void 0 !== o[0] ? o[0] : "on").toString(),
            off: (void 0 !== o[1] ? o[1] : "off").toString()
        }, c = (r.value?.[Jr]() || "off") === l.on || void 0, h = r[pr](), d = r[io];
        let u;
        h instanceof ExclGroup ? (s = h[io], n = "radio", a = "xfaRadio", u = h[Zs]?.[io] || h[io]) : (n = "checkbox", a = "xfaCheckbox", u = r[Zs]?.[io] || r[io]);
        const g = {
            name: "input",
            attributes: {
                class: [
                    a
                ],
                style: t,
                fieldId: d,
                dataId: u,
                type: n,
                checked: c,
                xfaOn: l.on,
                xfaOff: l.off,
                "aria-label": ariaLabel(r),
                "aria-required": !1
            }
        };
        return s && (g.attributes.name = s), isRequired(r) && (g.attributes["aria-required"] = !0, g.attributes.required = !0), HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                g
            ]
        });
    }
}
class ChoiceList extends XFAObject {
    constructor(e1){
        super(Lo, "choiceList", !0), this.commitOn = getStringOption(e1.commitOn, [
            "select",
            "exit"
        ]), this.id = e1.id || "", this.open = getStringOption(e1.open, [
            "userControl",
            "always",
            "multiSelect",
            "onEntry"
        ]), this.textEntry = getInteger({
            data: e1.textEntry,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.use = e1.use || "", this.usehref = e1.usehref || "", this.border = null, this.extras = null, this.margin = null;
    }
    [Qr](e1) {
        const t = toStyle(this, "border", "margin"), i = this[mr]()[mr](), n = {
            fontSize: `calc(${i.font?.size || 10}px * var(--total-scale-factor))`
        }, a = [];
        if (i.items.children.length > 0) {
            const e1 = i.items;
            let t = 0, s = 0;
            2 === e1.children.length && (t = e1.children[0].save, s = 1 - t);
            const r = e1.children[t][Qr]().html, o = e1.children[s][Qr]().html;
            let l = !1;
            const c = i.value?.[Jr]() || "";
            for(let e1 = 0, t = r.length; e1 < t; e1++){
                const t = {
                    name: "option",
                    attributes: {
                        value: o[e1] || r[e1],
                        style: n
                    },
                    value: r[e1]
                };
                o[e1] === c && (t.attributes.selected = l = !0), a.push(t);
            }
            l || a.splice(0, 0, {
                name: "option",
                attributes: {
                    hidden: !0,
                    selected: !0
                },
                value: " "
            });
        }
        const s = {
            class: [
                "xfaSelect"
            ],
            fieldId: i[io],
            dataId: i[Zs]?.[io] || i[io],
            style: t,
            "aria-label": ariaLabel(i),
            "aria-required": !1
        };
        return isRequired(i) && (s["aria-required"] = !0, s.required = !0), "multiSelect" === this.open && (s.multiple = !0), HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                {
                    name: "select",
                    children: a,
                    attributes: s
                }
            ]
        });
    }
}
class Color extends XFAObject {
    constructor(e1){
        super(Lo, "color", !0), this.cSpace = getStringOption(e1.cSpace, [
            "SRGB"
        ]), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.value = e1.value ? function(e1, t = [
            0,
            0,
            0
        ]) {
            let [i, n, a] = t;
            if (!e1) return {
                r: i,
                g: n,
                b: a
            };
            const s = e1.split(",", 3).map((e1)=>MathClamp$1(parseInt(e1.trim(), 10), 0, 255)).map((e1)=>isNaN(e1) ? 0 : e1);
            return s.length < 3 || ([i, n, a] = s), {
                r: i,
                g: n,
                b: a
            };
        }(e1.value) : "", this.extras = null;
    }
    [wr]() {
        return !1;
    }
    [to]() {
        return this.value ? ai.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
    }
}
class Comb extends XFAObject {
    constructor(e1){
        super(Lo, "comb"), this.id = e1.id || "", this.numberOfCells = getInteger({
            data: e1.numberOfCells,
            defaultValue: 0,
            validate: (e1)=>e1 >= 0
        }), this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Connect extends XFAObject {
    constructor(e1){
        super(Lo, "connect", !0), this.connection = e1.connection || "", this.id = e1.id || "", this.ref = e1.ref || "", this.usage = getStringOption(e1.usage, [
            "exportAndImport",
            "exportOnly",
            "importOnly"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.picture = null;
    }
}
class ContentArea extends XFAObject {
    constructor(e1){
        super(Lo, "contentArea", !0), this.h = getMeasurement(e1.h), this.id = e1.id || "", this.name = e1.name || "", this.relevant = getRelevant(e1.relevant), this.use = e1.use || "", this.usehref = e1.usehref || "", this.w = getMeasurement(e1.w), this.x = getMeasurement(e1.x, "0pt"), this.y = getMeasurement(e1.y, "0pt"), this.desc = null, this.extras = null;
    }
    [Qr](e1) {
        const t = {
            left: measureToString(this.x),
            top: measureToString(this.y),
            width: measureToString(this.w),
            height: measureToString(this.h)
        }, i = [
            "xfaContentarea"
        ];
        return isPrintOnly(this) && i.push("xfaPrintOnly"), HTMLResult.success({
            name: "div",
            children: [],
            attributes: {
                style: t,
                class: i,
                id: this[io]
            }
        });
    }
}
class Corner extends XFAObject {
    constructor(e1){
        super(Lo, "corner", !0), this.id = e1.id || "", this.inverted = getInteger({
            data: e1.inverted,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.join = getStringOption(e1.join, [
            "square",
            "round"
        ]), this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]), this.radius = getMeasurement(e1.radius), this.stroke = getStringOption(e1.stroke, [
            "solid",
            "dashDot",
            "dashDotDot",
            "dashed",
            "dotted",
            "embossed",
            "etched",
            "lowered",
            "raised"
        ]), this.thickness = getMeasurement(e1.thickness, "0.5pt"), this.use = e1.use || "", this.usehref = e1.usehref || "", this.color = null, this.extras = null;
    }
    [to]() {
        const e1 = toStyle(this, "visibility");
        return e1.radius = measureToString("square" === this.join ? 0 : this.radius), e1;
    }
}
class DateElement extends ContentObject {
    constructor(e1){
        super(Lo, "date"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [tr]() {
        const e1 = this[Js].trim();
        this[Js] = e1 ? new Date(e1) : null;
    }
    [Qr](e1) {
        return valueToHtml(this[Js] ? this[Js].toString() : "");
    }
}
class DateTime extends ContentObject {
    constructor(e1){
        super(Lo, "dateTime"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [tr]() {
        const e1 = this[Js].trim();
        this[Js] = e1 ? new Date(e1) : null;
    }
    [Qr](e1) {
        return valueToHtml(this[Js] ? this[Js].toString() : "");
    }
}
class DateTimeEdit extends XFAObject {
    constructor(e1){
        super(Lo, "dateTimeEdit", !0), this.hScrollPolicy = getStringOption(e1.hScrollPolicy, [
            "auto",
            "off",
            "on"
        ]), this.id = e1.id || "", this.picker = getStringOption(e1.picker, [
            "host",
            "none"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
    }
    [Qr](e1) {
        const t = toStyle(this, "border", "font", "margin"), i = this[mr]()[mr](), n = {
            name: "input",
            attributes: {
                type: "text",
                fieldId: i[io],
                dataId: i[Zs]?.[io] || i[io],
                class: [
                    "xfaTextfield"
                ],
                style: t,
                "aria-label": ariaLabel(i),
                "aria-required": !1
            }
        };
        return isRequired(i) && (n.attributes["aria-required"] = !0, n.attributes.required = !0), HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                n
            ]
        });
    }
}
class Decimal extends ContentObject {
    constructor(e1){
        super(Lo, "decimal"), this.fracDigits = getInteger({
            data: e1.fracDigits,
            defaultValue: 2,
            validate: (e1)=>!0
        }), this.id = e1.id || "", this.leadDigits = getInteger({
            data: e1.leadDigits,
            defaultValue: -1,
            validate: (e1)=>!0
        }), this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [tr]() {
        const e1 = parseFloat(this[Js].trim());
        this[Js] = isNaN(e1) ? null : e1;
    }
    [Qr](e1) {
        return valueToHtml(null !== this[Js] ? this[Js].toString() : "");
    }
}
class DefaultUi extends XFAObject {
    constructor(e1){
        super(Lo, "defaultUi", !0), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null;
    }
}
class Desc extends XFAObject {
    constructor(e1){
        super(Lo, "desc", !0), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.boolean = new XFAObjectArray, this.date = new XFAObjectArray, this.dateTime = new XFAObjectArray, this.decimal = new XFAObjectArray, this.exData = new XFAObjectArray, this.float = new XFAObjectArray, this.image = new XFAObjectArray, this.integer = new XFAObjectArray, this.text = new XFAObjectArray, this.time = new XFAObjectArray;
    }
}
class DigestMethod extends OptionObject {
    constructor(e1){
        super(Lo, "digestMethod", [
            "",
            "SHA1",
            "SHA256",
            "SHA512",
            "RIPEMD160"
        ]), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class DigestMethods extends XFAObject {
    constructor(e1){
        super(Lo, "digestMethods", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.digestMethod = new XFAObjectArray;
    }
}
class Draw extends XFAObject {
    constructor(e1){
        super(Lo, "draw", !0), this.anchorType = getStringOption(e1.anchorType, [
            "topLeft",
            "bottomCenter",
            "bottomLeft",
            "bottomRight",
            "middleCenter",
            "middleLeft",
            "middleRight",
            "topCenter",
            "topRight"
        ]), this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        }), this.h = e1.h ? getMeasurement(e1.h) : "", this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]), this.id = e1.id || "", this.locale = e1.locale || "", this.maxH = getMeasurement(e1.maxH, "0pt"), this.maxW = getMeasurement(e1.maxW, "0pt"), this.minH = getMeasurement(e1.minH, "0pt"), this.minW = getMeasurement(e1.minW, "0pt"), this.name = e1.name || "", this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]), this.relevant = getRelevant(e1.relevant), this.rotate = getInteger({
            data: e1.rotate,
            defaultValue: 0,
            validate: (e1)=>e1 % 90 == 0
        }), this.use = e1.use || "", this.usehref = e1.usehref || "", this.w = e1.w ? getMeasurement(e1.w) : "", this.x = getMeasurement(e1.x, "0pt"), this.y = getMeasurement(e1.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new XFAObjectArray;
    }
    [Kr](e1) {
        _setValue(this, e1);
    }
    [Qr](e1) {
        if (setTabIndex(this), "hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
        fixDimensions(this), this[Hr]();
        const t = this.w, i = this.h, { w: n, h: a, isBroken: s } = layoutNode(this, e1);
        if (n && "" === this.w) {
            if (s && this[pr]()[Er]()) return this[$r](), HTMLResult.FAILURE;
            this.w = n;
        }
        if (a && "" === this.h && (this.h = a), setFirstUnsplittable(this), !checkDimensions(this, e1)) return this.w = t, this.h = i, this[$r](), HTMLResult.FAILURE;
        unsetFirstUnsplittable(this);
        const r = toStyle(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
        setMinMaxDimensions(this, r), r.margin && (r.padding = r.margin, delete r.margin);
        const o = [
            "xfaDraw"
        ];
        this.font && o.push("xfaFont"), isPrintOnly(this) && o.push("xfaPrintOnly");
        const l = {
            style: r,
            id: this[io],
            class: o
        };
        this.name && (l.xfaName = this.name);
        const c = {
            name: "div",
            attributes: l,
            children: []
        };
        applyAssist(this, l);
        const h = computeBbox(this, c, e1), d = this.value ? this.value[Qr](e1).html : null;
        return null === d ? (this.w = t, this.h = i, this[$r](), HTMLResult.success(createWrapper(this, c), h)) : (c.children.push(d), setPara(this, r, d), this.w = t, this.h = i, this[$r](), HTMLResult.success(createWrapper(this, c), h));
    }
}
class Edge extends XFAObject {
    constructor(e1){
        super(Lo, "edge", !0), this.cap = getStringOption(e1.cap, [
            "square",
            "butt",
            "round"
        ]), this.id = e1.id || "", this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]), this.stroke = getStringOption(e1.stroke, [
            "solid",
            "dashDot",
            "dashDotDot",
            "dashed",
            "dotted",
            "embossed",
            "etched",
            "lowered",
            "raised"
        ]), this.thickness = getMeasurement(e1.thickness, "0.5pt"), this.use = e1.use || "", this.usehref = e1.usehref || "", this.color = null, this.extras = null;
    }
    [to]() {
        const e1 = toStyle(this, "visibility");
        if (Object.assign(e1, {
            linecap: this.cap,
            width: measureToString(this.thickness),
            color: this.color ? this.color[to]() : "#000000",
            style: ""
        }), "visible" !== this.presence) e1.style = "none";
        else switch(this.stroke){
            case "solid":
                e1.style = "solid";
                break;
            case "dashDot":
            case "dashDotDot":
            case "dashed":
                e1.style = "dashed";
                break;
            case "dotted":
                e1.style = "dotted";
                break;
            case "embossed":
                e1.style = "ridge";
                break;
            case "etched":
                e1.style = "groove";
                break;
            case "lowered":
                e1.style = "inset";
                break;
            case "raised":
                e1.style = "outset";
        }
        return e1;
    }
}
class Encoding extends OptionObject {
    constructor(e1){
        super(Lo, "encoding", [
            "adbe.x509.rsa_sha1",
            "adbe.pkcs7.detached",
            "adbe.pkcs7.sha1"
        ]), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Encodings extends XFAObject {
    constructor(e1){
        super(Lo, "encodings", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.encoding = new XFAObjectArray;
    }
}
class Encrypt extends XFAObject {
    constructor(e1){
        super(Lo, "encrypt", !0), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.certificate = null;
    }
}
class EncryptData extends XFAObject {
    constructor(e1){
        super(Lo, "encryptData", !0), this.id = e1.id || "", this.operation = getStringOption(e1.operation, [
            "encrypt",
            "decrypt"
        ]), this.target = e1.target || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.filter = null, this.manifest = null;
    }
}
class Encryption extends XFAObject {
    constructor(e1){
        super(Lo, "encryption", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.certificate = new XFAObjectArray;
    }
}
class EncryptionMethod extends OptionObject {
    constructor(e1){
        super(Lo, "encryptionMethod", [
            "",
            "AES256-CBC",
            "TRIPLEDES-CBC",
            "AES128-CBC",
            "AES192-CBC"
        ]), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class EncryptionMethods extends XFAObject {
    constructor(e1){
        super(Lo, "encryptionMethods", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.encryptionMethod = new XFAObjectArray;
    }
}
let Xo = class extends XFAObject {
    constructor(e1){
        super(Lo, "event", !0), this.activity = getStringOption(e1.activity, [
            "click",
            "change",
            "docClose",
            "docReady",
            "enter",
            "exit",
            "full",
            "indexChange",
            "initialize",
            "mouseDown",
            "mouseEnter",
            "mouseExit",
            "mouseUp",
            "postExecute",
            "postOpen",
            "postPrint",
            "postSave",
            "postSign",
            "postSubmit",
            "preExecute",
            "preOpen",
            "prePrint",
            "preSave",
            "preSign",
            "preSubmit",
            "ready",
            "validationState"
        ]), this.id = e1.id || "", this.listen = getStringOption(e1.listen, [
            "refOnly",
            "refAndDescendents"
        ]), this.name = e1.name || "", this.ref = e1.ref || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
    }
};
class ExData extends ContentObject {
    constructor(e1){
        super(Lo, "exData"), this.contentType = e1.contentType || "", this.href = e1.href || "", this.id = e1.id || "", this.maxLength = getInteger({
            data: e1.maxLength,
            defaultValue: -1,
            validate: (e1)=>e1 >= -1
        }), this.name = e1.name || "", this.rid = e1.rid || "", this.transferEncoding = getStringOption(e1.transferEncoding, [
            "none",
            "base64",
            "package"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [vr]() {
        return "text/html" === this.contentType;
    }
    [Nr](e1) {
        return ("text/html" === this.contentType && e1[_r] === ao.xhtml.id || "text/xml" === this.contentType) && (this[Js] = e1, !0);
    }
    [Qr](e1) {
        return "text/html" === this.contentType && this[Js] ? this[Js][Qr](e1) : HTMLResult.EMPTY;
    }
}
class ExObject extends XFAObject {
    constructor(e1){
        super(Lo, "exObject", !0), this.archive = e1.archive || "", this.classId = e1.classId || "", this.codeBase = e1.codeBase || "", this.codeType = e1.codeType || "", this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null, this.boolean = new XFAObjectArray, this.date = new XFAObjectArray, this.dateTime = new XFAObjectArray, this.decimal = new XFAObjectArray, this.exData = new XFAObjectArray, this.exObject = new XFAObjectArray, this.float = new XFAObjectArray, this.image = new XFAObjectArray, this.integer = new XFAObjectArray, this.text = new XFAObjectArray, this.time = new XFAObjectArray;
    }
}
class ExclGroup extends XFAObject {
    constructor(e1){
        super(Lo, "exclGroup", !0), this.access = getStringOption(e1.access, [
            "open",
            "nonInteractive",
            "protected",
            "readOnly"
        ]), this.accessKey = e1.accessKey || "", this.anchorType = getStringOption(e1.anchorType, [
            "topLeft",
            "bottomCenter",
            "bottomLeft",
            "bottomRight",
            "middleCenter",
            "middleLeft",
            "middleRight",
            "topCenter",
            "topRight"
        ]), this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        }), this.h = e1.h ? getMeasurement(e1.h) : "", this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]), this.id = e1.id || "", this.layout = getStringOption(e1.layout, [
            "position",
            "lr-tb",
            "rl-row",
            "rl-tb",
            "row",
            "table",
            "tb"
        ]), this.maxH = getMeasurement(e1.maxH, "0pt"), this.maxW = getMeasurement(e1.maxW, "0pt"), this.minH = getMeasurement(e1.minH, "0pt"), this.minW = getMeasurement(e1.minW, "0pt"), this.name = e1.name || "", this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]), this.relevant = getRelevant(e1.relevant), this.use = e1.use || "", this.usehref = e1.usehref || "", this.w = e1.w ? getMeasurement(e1.w) : "", this.x = getMeasurement(e1.x, "0pt"), this.y = getMeasurement(e1.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new XFAObjectArray, this.event = new XFAObjectArray, this.field = new XFAObjectArray, this.setProperty = new XFAObjectArray;
    }
    [Cr]() {
        return !0;
    }
    [wr]() {
        return !0;
    }
    [Kr](e1) {
        for (const t of this.field.children){
            if (!t.value) {
                const e1 = new Value({});
                t[qs](e1), t.value = e1;
            }
            t.value[Kr](e1);
        }
    }
    [Er]() {
        return this.layout.endsWith("-tb") && 0 === this[er].attempt && this[er].numberInLine > 0 || this[mr]()[Er]();
    }
    [Ir]() {
        const e1 = this[pr]();
        return !!e1[Ir]() && (void 0 !== this[er]._isSplittable ? this[er]._isSplittable : "position" === this.layout || this.layout.includes("row") ? (this[er]._isSplittable = !1, !1) : (!e1.layout?.endsWith("-tb") || 0 === e1[er].numberInLine) && (this[er]._isSplittable = !0, !0));
    }
    [ir]() {
        return flushHTML(this);
    }
    [Xs](e1, t) {
        addHTML(this, e1, t);
    }
    [sr]() {
        return getAvailableSpace(this);
    }
    [Qr](e1) {
        if (setTabIndex(this), "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
        fixDimensions(this);
        const t = [], i = {
            id: this[io],
            class: []
        };
        setAccess(this, i.class), this[er] ||= Object.create(null), Object.assign(this[er], {
            children: t,
            attributes: i,
            attempt: 0,
            line: null,
            numberInLine: 0,
            availableSpace: {
                width: Math.min(this.w || 1 / 0, e1.width),
                height: Math.min(this.h || 1 / 0, e1.height)
            },
            width: 0,
            height: 0,
            prevHeight: 0,
            currentWidth: 0
        });
        const n = this[Ir]();
        if (n || setFirstUnsplittable(this), !checkDimensions(this, e1)) return HTMLResult.FAILURE;
        const a = new Set([
            "field"
        ]);
        if (this.layout.includes("row")) {
            const e1 = this[pr]().columnWidths;
            Array.isArray(e1) && e1.length > 0 && (this[er].columnWidths = e1, this[er].currentColumn = 0);
        }
        const s = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), r = [
            "xfaExclgroup"
        ], o = layoutClass(this);
        o && r.push(o), isPrintOnly(this) && r.push("xfaPrintOnly"), i.style = s, i.class = r, this.name && (i.xfaName = this.name), this[Hr]();
        const l = "lr-tb" === this.layout || "rl-tb" === this.layout, c = l ? 2 : 1;
        for(; this[er].attempt < c; this[er].attempt++){
            l && 1 === this[er].attempt && (this[er].numberInLine = 0);
            const e1 = this[zs]({
                filter: a,
                include: !0
            });
            if (e1.success) break;
            if (e1.isBreak()) return this[$r](), e1;
            if (l && 0 === this[er].attempt && 0 === this[er].numberInLine && !this[br]()[er].noLayoutFailure) {
                this[er].attempt = c;
                break;
            }
        }
        if (this[$r](), n || unsetFirstUnsplittable(this), this[er].attempt === c) return n || delete this[er], HTMLResult.FAILURE;
        let h = 0, d = 0;
        this.margin && (h = this.margin.leftInset + this.margin.rightInset, d = this.margin.topInset + this.margin.bottomInset);
        const u = Math.max(this[er].width + h, this.w || 0), g = Math.max(this[er].height + d, this.h || 0), f = [
            this.x,
            this.y,
            u,
            g
        ];
        "" === this.w && (s.width = measureToString(u)), "" === this.h && (s.height = measureToString(g));
        const p = {
            name: "div",
            attributes: i,
            children: t
        };
        return applyAssist(this, i), delete this[er], HTMLResult.success(createWrapper(this, p), f);
    }
}
class Execute extends XFAObject {
    constructor(e1){
        super(Lo, "execute"), this.connection = e1.connection || "", this.executeType = getStringOption(e1.executeType, [
            "import",
            "remerge"
        ]), this.id = e1.id || "", this.runAt = getStringOption(e1.runAt, [
            "client",
            "both",
            "server"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Extras extends XFAObject {
    constructor(e1){
        super(Lo, "extras", !0), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.boolean = new XFAObjectArray, this.date = new XFAObjectArray, this.dateTime = new XFAObjectArray, this.decimal = new XFAObjectArray, this.exData = new XFAObjectArray, this.extras = new XFAObjectArray, this.float = new XFAObjectArray, this.image = new XFAObjectArray, this.integer = new XFAObjectArray, this.text = new XFAObjectArray, this.time = new XFAObjectArray;
    }
}
class Field extends XFAObject {
    constructor(e1){
        super(Lo, "field", !0), this.access = getStringOption(e1.access, [
            "open",
            "nonInteractive",
            "protected",
            "readOnly"
        ]), this.accessKey = e1.accessKey || "", this.anchorType = getStringOption(e1.anchorType, [
            "topLeft",
            "bottomCenter",
            "bottomLeft",
            "bottomRight",
            "middleCenter",
            "middleLeft",
            "middleRight",
            "topCenter",
            "topRight"
        ]), this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        }), this.h = e1.h ? getMeasurement(e1.h) : "", this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]), this.id = e1.id || "", this.locale = e1.locale || "", this.maxH = getMeasurement(e1.maxH, "0pt"), this.maxW = getMeasurement(e1.maxW, "0pt"), this.minH = getMeasurement(e1.minH, "0pt"), this.minW = getMeasurement(e1.minW, "0pt"), this.name = e1.name || "", this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]), this.relevant = getRelevant(e1.relevant), this.rotate = getInteger({
            data: e1.rotate,
            defaultValue: 0,
            validate: (e1)=>e1 % 90 == 0
        }), this.use = e1.use || "", this.usehref = e1.usehref || "", this.w = e1.w ? getMeasurement(e1.w) : "", this.x = getMeasurement(e1.x, "0pt"), this.y = getMeasurement(e1.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new XFAObjectArray(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new XFAObjectArray, this.connect = new XFAObjectArray, this.event = new XFAObjectArray, this.setProperty = new XFAObjectArray;
    }
    [Cr]() {
        return !0;
    }
    [Kr](e1) {
        _setValue(this, e1);
    }
    [Qr](e1) {
        if (setTabIndex(this), !this.ui) {
            let e1;
            switch(this.ui = new Ui({}), this.ui[yr] = this[yr], this[qs](this.ui), this.items.children.length){
                case 0:
                    e1 = new TextEdit({}), this.ui.textEdit = e1;
                    break;
                case 1:
                    e1 = new CheckButton({}), this.ui.checkButton = e1;
                    break;
                case 2:
                    e1 = new ChoiceList({}), this.ui.choiceList = e1;
            }
            this.ui[qs](e1);
        }
        if (!this.ui || "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
        this.caption && delete this.caption[er], this[Hr]();
        const t = this.caption ? this.caption[Qr](e1).html : null, i = this.w, n = this.h;
        let a = 0, s = 0;
        this.margin && (a = this.margin.leftInset + this.margin.rightInset, s = this.margin.topInset + this.margin.bottomInset);
        let r = null;
        if ("" === this.w || "" === this.h) {
            let t = null, i = null, n = 0, o = 0;
            if (this.ui.checkButton) n = o = this.ui.checkButton.size;
            else {
                const { w: t, h: i } = layoutNode(this, e1);
                null !== t ? (n = t, o = i) : o = function(e1, t = !1) {
                    let i = null;
                    if (e1) {
                        const t = stripQuotes(e1.typeface), n = e1[yr].fontFinder.find(t);
                        i = selectFont(e1, n);
                    }
                    if (!i) return {
                        lineHeight: 12,
                        lineGap: 2,
                        lineNoGap: 10
                    };
                    const n = e1.size || 10, a = i.lineHeight ? Math.max(t ? 0 : 1.2, i.lineHeight) : 1.2, s = void 0 === i.lineGap ? .2 : i.lineGap;
                    return {
                        lineHeight: a * n,
                        lineGap: s * n,
                        lineNoGap: Math.max(1, a - s) * n
                    };
                }(this.font, !0).lineNoGap;
            }
            if (r = getBorderDims(this.ui[hr]()), n += r.w, o += r.h, this.caption) {
                const { w: a, h: s, isBroken: r } = this.caption[hr](e1);
                if (r && this[pr]()[Er]()) return this[$r](), HTMLResult.FAILURE;
                switch(t = a, i = s, this.caption.placement){
                    case "left":
                    case "right":
                    case "inline":
                        t += n;
                        break;
                    case "top":
                    case "bottom":
                        i += o;
                }
            } else t = n, i = o;
            t && "" === this.w && (t += a, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t ? t : this.minW)), i && "" === this.h && (i += s, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < i ? i : this.minH));
        }
        if (this[$r](), fixDimensions(this), setFirstUnsplittable(this), !checkDimensions(this, e1)) return this.w = i, this.h = n, this[$r](), HTMLResult.FAILURE;
        unsetFirstUnsplittable(this);
        const o = toStyle(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
        setMinMaxDimensions(this, o);
        const l = [
            "xfaField"
        ];
        this.font && l.push("xfaFont"), isPrintOnly(this) && l.push("xfaPrintOnly");
        const c = {
            style: o,
            id: this[io],
            class: l
        };
        o.margin && (o.padding = o.margin, delete o.margin), setAccess(this, l), this.name && (c.xfaName = this.name);
        const h = [], d = {
            name: "div",
            attributes: c,
            children: h
        };
        applyAssist(this, c);
        const u = this.border ? this.border[to]() : null, g = computeBbox(this, d, e1), f = this.ui[Qr]().html;
        if (!f) return Object.assign(o, u), HTMLResult.success(createWrapper(this, d), g);
        this[Yr] && (f.children?.[0] ? f.children[0].attributes.tabindex = this[Yr] : f.attributes.tabindex = this[Yr]), f.attributes.style ||= Object.create(null);
        let p = null;
        if (this.ui.button ? (1 === f.children.length && ([p] = f.children.splice(0, 1)), Object.assign(f.attributes.style, u)) : Object.assign(o, u), h.push(f), this.value) {
            if (this.ui.imageEdit) f.children.push(this.value[Qr]().html);
            else if (!this.ui.button) {
                let e1 = "";
                if (this.value.exData) e1 = this.value.exData[Jr]();
                else if (this.value.text) e1 = this.value.text[hr]();
                else {
                    const t = this.value[Qr]().html;
                    null !== t && (e1 = t.children[0].value);
                }
                this.ui.textEdit && this.value.text?.maxChars && (f.children[0].attributes.maxLength = this.value.text.maxChars), e1 && (this.ui.numericEdit && (e1 = parseFloat(e1), e1 = isNaN(e1) ? "" : e1.toString()), "textarea" === f.children[0].name ? f.children[0].attributes.textContent = e1 : f.children[0].attributes.value = e1);
            }
        }
        if (!this.ui.imageEdit && f.children?.[0] && this.h) {
            r = r || getBorderDims(this.ui[hr]());
            let t = 0;
            if (this.caption && [
                "top",
                "bottom"
            ].includes(this.caption.placement)) {
                t = this.caption.reserve, t <= 0 && (t = this.caption[hr](e1).h);
                const i = this.h - t - s - r.h;
                f.children[0].attributes.style.height = measureToString(i);
            } else f.children[0].attributes.style.height = "100%";
        }
        if (p && f.children.push(p), !t) return f.attributes.class && f.attributes.class.push("xfaLeft"), this.w = i, this.h = n, HTMLResult.success(createWrapper(this, d), g);
        if (this.ui.button) return o.padding && delete o.padding, "div" === t.name && (t.name = "span"), f.children.push(t), HTMLResult.success(d, g);
        switch(this.ui.checkButton && (t.attributes.class[0] = "xfaCaptionForCheckButton"), f.attributes.class ||= [], f.children.splice(0, 0, t), this.caption.placement){
            case "left":
            case "inline":
                f.attributes.class.push("xfaLeft");
                break;
            case "right":
                f.attributes.class.push("xfaRight");
                break;
            case "top":
                f.attributes.class.push("xfaTop");
                break;
            case "bottom":
                f.attributes.class.push("xfaBottom");
        }
        return this.w = i, this.h = n, HTMLResult.success(createWrapper(this, d), g);
    }
}
class Fill extends XFAObject {
    constructor(e1){
        super(Lo, "fill", !0), this.id = e1.id || "", this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
    }
    [to]() {
        const e1 = this[mr](), t = e1[mr]()[mr](), i = Object.create(null);
        let n = "color", a = n;
        e1 instanceof Border && (n = "background-color", a = "background", t instanceof Ui && (i.backgroundColor = "white")), (e1 instanceof Rectangle || e1 instanceof Arc) && (n = a = "fill", i.fill = "white");
        for (const e1 of Object.getOwnPropertyNames(this)){
            if ("extras" === e1 || "color" === e1) continue;
            const t = this[e1];
            if (!(t instanceof XFAObject)) continue;
            const s = t[to](this.color);
            return s && (i[s.startsWith("#") ? n : a] = s), i;
        }
        if (this.color?.value) {
            const e1 = this.color[to]();
            i[e1.startsWith("#") ? n : a] = e1;
        }
        return i;
    }
}
class Filter extends XFAObject {
    constructor(e1){
        super(Lo, "filter", !0), this.addRevocationInfo = getStringOption(e1.addRevocationInfo, [
            "",
            "required",
            "optional",
            "none"
        ]), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.version = getInteger({
            data: this.version,
            defaultValue: 5,
            validate: (e1)=>e1 >= 1 && e1 <= 5
        }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
    }
}
class Float extends ContentObject {
    constructor(e1){
        super(Lo, "float"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [tr]() {
        const e1 = parseFloat(this[Js].trim());
        this[Js] = isNaN(e1) ? null : e1;
    }
    [Qr](e1) {
        return valueToHtml(null !== this[Js] ? this[Js].toString() : "");
    }
}
class template_Font extends XFAObject {
    constructor(e1){
        super(Lo, "font", !0), this.baselineShift = getMeasurement(e1.baselineShift), this.fontHorizontalScale = getFloat({
            data: e1.fontHorizontalScale,
            defaultValue: 100,
            validate: (e1)=>e1 >= 0
        }), this.fontVerticalScale = getFloat({
            data: e1.fontVerticalScale,
            defaultValue: 100,
            validate: (e1)=>e1 >= 0
        }), this.id = e1.id || "", this.kerningMode = getStringOption(e1.kerningMode, [
            "none",
            "pair"
        ]), this.letterSpacing = getMeasurement(e1.letterSpacing, "0"), this.lineThrough = getInteger({
            data: e1.lineThrough,
            defaultValue: 0,
            validate: (e1)=>1 === e1 || 2 === e1
        }), this.lineThroughPeriod = getStringOption(e1.lineThroughPeriod, [
            "all",
            "word"
        ]), this.overline = getInteger({
            data: e1.overline,
            defaultValue: 0,
            validate: (e1)=>1 === e1 || 2 === e1
        }), this.overlinePeriod = getStringOption(e1.overlinePeriod, [
            "all",
            "word"
        ]), this.posture = getStringOption(e1.posture, [
            "normal",
            "italic"
        ]), this.size = getMeasurement(e1.size, "10pt"), this.typeface = e1.typeface || "Courier", this.underline = getInteger({
            data: e1.underline,
            defaultValue: 0,
            validate: (e1)=>1 === e1 || 2 === e1
        }), this.underlinePeriod = getStringOption(e1.underlinePeriod, [
            "all",
            "word"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.weight = getStringOption(e1.weight, [
            "normal",
            "bold"
        ]), this.extras = null, this.fill = null;
    }
    [Ws](e1) {
        super[Ws](e1), this[yr].usedTypefaces.add(this.typeface);
    }
    [to]() {
        const e1 = toStyle(this, "fill"), t = e1.color;
        return t && ("#000000" === t ? delete e1.color : t.startsWith("#") || (e1.background = t, e1.backgroundClip = "text", e1.color = "transparent")), this.baselineShift && (e1.verticalAlign = measureToString(this.baselineShift)), e1.fontKerning = "none" === this.kerningMode ? "none" : "normal", e1.letterSpacing = measureToString(this.letterSpacing), 0 !== this.lineThrough && (e1.textDecoration = "line-through", 2 === this.lineThrough && (e1.textDecorationStyle = "double")), 0 !== this.overline && (e1.textDecoration = "overline", 2 === this.overline && (e1.textDecorationStyle = "double")), e1.fontStyle = this.posture, e1.fontSize = measureToString(.99 * this.size), setFontFamily(this, this, this[yr].fontFinder, e1), 0 !== this.underline && (e1.textDecoration = "underline", 2 === this.underline && (e1.textDecorationStyle = "double")), e1.fontWeight = this.weight, e1;
    }
}
class Format extends XFAObject {
    constructor(e1){
        super(Lo, "format", !0), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null, this.picture = null;
    }
}
class Handler extends StringObject {
    constructor(e1){
        super(Lo, "handler"), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Hyphenation extends XFAObject {
    constructor(e1){
        super(Lo, "hyphenation"), this.excludeAllCaps = getInteger({
            data: e1.excludeAllCaps,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.excludeInitialCap = getInteger({
            data: e1.excludeInitialCap,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.hyphenate = getInteger({
            data: e1.hyphenate,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.id = e1.id || "", this.pushCharacterCount = getInteger({
            data: e1.pushCharacterCount,
            defaultValue: 3,
            validate: (e1)=>e1 >= 0
        }), this.remainCharacterCount = getInteger({
            data: e1.remainCharacterCount,
            defaultValue: 3,
            validate: (e1)=>e1 >= 0
        }), this.use = e1.use || "", this.usehref = e1.usehref || "", this.wordCharacterCount = getInteger({
            data: e1.wordCharacterCount,
            defaultValue: 7,
            validate: (e1)=>e1 >= 0
        });
    }
}
let qo = class extends StringObject {
    constructor(e1){
        super(Lo, "image"), this.aspect = getStringOption(e1.aspect, [
            "fit",
            "actual",
            "height",
            "none",
            "width"
        ]), this.contentType = e1.contentType || "", this.href = e1.href || "", this.id = e1.id || "", this.name = e1.name || "", this.transferEncoding = getStringOption(e1.transferEncoding, [
            "base64",
            "none",
            "package"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [Qr]() {
        if (this.contentType && !$o.has(this.contentType.toLowerCase())) return HTMLResult.EMPTY;
        let e1 = this[yr].images?.get(this.href);
        if (!e1 && (this.href || !this[Js])) return HTMLResult.EMPTY;
        var t;
        if (e1 || "base64" !== this.transferEncoding || (t = this[Js], e1 = Uint8Array.fromBase64 ? Uint8Array.fromBase64(t) : stringToBytes$1(atob(t))), !e1) return HTMLResult.EMPTY;
        if (!this.contentType) {
            for (const [t, i] of Ho)if (e1.length > t.length && t.every((t, i)=>t === e1[i])) {
                this.contentType = i;
                break;
            }
            if (!this.contentType) return HTMLResult.EMPTY;
        }
        const i = new Blob([
            e1
        ], {
            type: this.contentType
        });
        let n;
        switch(this.aspect){
            case "fit":
            case "actual":
                break;
            case "height":
                n = {
                    height: "100%",
                    objectFit: "fill"
                };
                break;
            case "none":
                n = {
                    width: "100%",
                    height: "100%",
                    objectFit: "fill"
                };
                break;
            case "width":
                n = {
                    width: "100%",
                    objectFit: "fill"
                };
        }
        const a = this[mr]();
        return HTMLResult.success({
            name: "img",
            attributes: {
                class: [
                    "xfaImage"
                ],
                style: n,
                src: URL.createObjectURL(i),
                alt: a ? ariaLabel(a[mr]()) : null
            }
        });
    }
};
class ImageEdit extends XFAObject {
    constructor(e1){
        super(Lo, "imageEdit", !0), this.data = getStringOption(e1.data, [
            "link",
            "embed"
        ]), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.border = null, this.extras = null, this.margin = null;
    }
    [Qr](e1) {
        return "embed" === this.data ? HTMLResult.success({
            name: "div",
            children: [],
            attributes: {}
        }) : HTMLResult.EMPTY;
    }
}
class Integer extends ContentObject {
    constructor(e1){
        super(Lo, "integer"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [tr]() {
        const e1 = parseInt(this[Js].trim(), 10);
        this[Js] = isNaN(e1) ? null : e1;
    }
    [Qr](e1) {
        return valueToHtml(null !== this[Js] ? this[Js].toString() : "");
    }
}
class Issuers extends XFAObject {
    constructor(e1){
        super(Lo, "issuers", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.certificate = new XFAObjectArray;
    }
}
class Items extends XFAObject {
    constructor(e1){
        super(Lo, "items", !0), this.id = e1.id || "", this.name = e1.name || "", this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]), this.ref = e1.ref || "", this.save = getInteger({
            data: e1.save,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.use = e1.use || "", this.usehref = e1.usehref || "", this.boolean = new XFAObjectArray, this.date = new XFAObjectArray, this.dateTime = new XFAObjectArray, this.decimal = new XFAObjectArray, this.exData = new XFAObjectArray, this.float = new XFAObjectArray, this.image = new XFAObjectArray, this.integer = new XFAObjectArray, this.text = new XFAObjectArray, this.time = new XFAObjectArray;
    }
    [Qr]() {
        const e1 = [];
        for (const t of this[ur]())e1.push(t[Jr]());
        return HTMLResult.success(e1);
    }
}
class Keep extends XFAObject {
    constructor(e1){
        super(Lo, "keep", !0), this.id = e1.id || "";
        const t = [
            "none",
            "contentArea",
            "pageArea"
        ];
        this.intact = getStringOption(e1.intact, t), this.next = getStringOption(e1.next, t), this.previous = getStringOption(e1.previous, t), this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null;
    }
}
class KeyUsage extends XFAObject {
    constructor(e1){
        super(Lo, "keyUsage");
        const t = [
            "",
            "yes",
            "no"
        ];
        this.crlSign = getStringOption(e1.crlSign, t), this.dataEncipherment = getStringOption(e1.dataEncipherment, t), this.decipherOnly = getStringOption(e1.decipherOnly, t), this.digitalSignature = getStringOption(e1.digitalSignature, t), this.encipherOnly = getStringOption(e1.encipherOnly, t), this.id = e1.id || "", this.keyAgreement = getStringOption(e1.keyAgreement, t), this.keyCertSign = getStringOption(e1.keyCertSign, t), this.keyEncipherment = getStringOption(e1.keyEncipherment, t), this.nonRepudiation = getStringOption(e1.nonRepudiation, t), this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Line extends XFAObject {
    constructor(e1){
        super(Lo, "line", !0), this.hand = getStringOption(e1.hand, [
            "even",
            "left",
            "right"
        ]), this.id = e1.id || "", this.slope = getStringOption(e1.slope, [
            "\\",
            "/"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.edge = null;
    }
    [Qr]() {
        const e1 = this[mr]()[mr](), t = this.edge || new Edge({}), i = t[to](), n = Object.create(null), a = "visible" === t.presence ? t.thickness : 0;
        let s, r, o, l;
        n.strokeWidth = measureToString(a), n.stroke = i.color;
        let c = "100%", h = "100%";
        e1.w <= a ? ([s, r, o, l] = [
            "50%",
            0,
            "50%",
            "100%"
        ], c = n.strokeWidth) : e1.h <= a ? ([s, r, o, l] = [
            0,
            "50%",
            "100%",
            "50%"
        ], h = n.strokeWidth) : "\\" === this.slope ? [s, r, o, l] = [
            0,
            0,
            "100%",
            "100%"
        ] : [s, r, o, l] = [
            0,
            "100%",
            "100%",
            0
        ];
        const d = {
            name: "svg",
            children: [
                {
                    name: "line",
                    attributes: {
                        xmlns: Uo,
                        x1: s,
                        y1: r,
                        x2: o,
                        y2: l,
                        style: n
                    }
                }
            ],
            attributes: {
                xmlns: Uo,
                width: c,
                height: h,
                style: {
                    overflow: "visible"
                }
            }
        };
        return hasMargin(e1) ? HTMLResult.success({
            name: "div",
            attributes: {
                style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                }
            },
            children: [
                d
            ]
        }) : (d.attributes.style.position = "absolute", HTMLResult.success(d));
    }
}
class Linear extends XFAObject {
    constructor(e1){
        super(Lo, "linear", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "toRight",
            "toBottom",
            "toLeft",
            "toTop"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.color = null, this.extras = null;
    }
    [to](e1) {
        e1 = e1 ? e1[to]() : "#FFFFFF";
        return `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${e1}, ${this.color ? this.color[to]() : "#000000"})`;
    }
}
class LockDocument extends ContentObject {
    constructor(e1){
        super(Lo, "lockDocument"), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [tr]() {
        this[Js] = getStringOption(this[Js], [
            "auto",
            "0",
            "1"
        ]);
    }
}
class Manifest extends XFAObject {
    constructor(e1){
        super(Lo, "manifest", !0), this.action = getStringOption(e1.action, [
            "include",
            "all",
            "exclude"
        ]), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null, this.ref = new XFAObjectArray;
    }
}
class Margin extends XFAObject {
    constructor(e1){
        super(Lo, "margin", !0), this.bottomInset = getMeasurement(e1.bottomInset, "0"), this.id = e1.id || "", this.leftInset = getMeasurement(e1.leftInset, "0"), this.rightInset = getMeasurement(e1.rightInset, "0"), this.topInset = getMeasurement(e1.topInset, "0"), this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null;
    }
    [to]() {
        return {
            margin: measureToString(this.topInset) + " " + measureToString(this.rightInset) + " " + measureToString(this.bottomInset) + " " + measureToString(this.leftInset)
        };
    }
}
class Mdp extends XFAObject {
    constructor(e1){
        super(Lo, "mdp"), this.id = e1.id || "", this.permissions = getInteger({
            data: e1.permissions,
            defaultValue: 2,
            validate: (e1)=>1 === e1 || 3 === e1
        }), this.signatureType = getStringOption(e1.signatureType, [
            "filler",
            "author"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Medium extends XFAObject {
    constructor(e1){
        super(Lo, "medium"), this.id = e1.id || "", this.imagingBBox = function(e1) {
            const t = -1;
            if (!e1) return {
                x: t,
                y: t,
                width: t,
                height: t
            };
            const i = e1.split(",", 4).map((e1)=>getMeasurement(e1.trim(), "-1"));
            if (i.length < 4 || i[2] < 0 || i[3] < 0) return {
                x: t,
                y: t,
                width: t,
                height: t
            };
            const [n, a, s, r] = i;
            return {
                x: n,
                y: a,
                width: s,
                height: r
            };
        }(e1.imagingBBox), this.long = getMeasurement(e1.long), this.orientation = getStringOption(e1.orientation, [
            "portrait",
            "landscape"
        ]), this.short = getMeasurement(e1.short), this.stock = e1.stock || "", this.trayIn = getStringOption(e1.trayIn, [
            "auto",
            "delegate",
            "pageFront"
        ]), this.trayOut = getStringOption(e1.trayOut, [
            "auto",
            "delegate"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Message extends XFAObject {
    constructor(e1){
        super(Lo, "message", !0), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.text = new XFAObjectArray;
    }
}
class NumericEdit extends XFAObject {
    constructor(e1){
        super(Lo, "numericEdit", !0), this.hScrollPolicy = getStringOption(e1.hScrollPolicy, [
            "auto",
            "off",
            "on"
        ]), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
    }
    [Qr](e1) {
        const t = toStyle(this, "border", "font", "margin"), i = this[mr]()[mr](), n = {
            name: "input",
            attributes: {
                type: "text",
                fieldId: i[io],
                dataId: i[Zs]?.[io] || i[io],
                class: [
                    "xfaTextfield"
                ],
                style: t,
                "aria-label": ariaLabel(i),
                "aria-required": !1
            }
        };
        return isRequired(i) && (n.attributes["aria-required"] = !0, n.attributes.required = !0), HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                n
            ]
        });
    }
}
class Occur extends XFAObject {
    constructor(e1){
        super(Lo, "occur", !0), this.id = e1.id || "", this.initial = "" !== e1.initial ? getInteger({
            data: e1.initial,
            defaultValue: "",
            validate: (e1)=>!0
        }) : "", this.max = "" !== e1.max ? getInteger({
            data: e1.max,
            defaultValue: 1,
            validate: (e1)=>!0
        }) : "", this.min = "" !== e1.min ? getInteger({
            data: e1.min,
            defaultValue: 1,
            validate: (e1)=>!0
        }) : "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null;
    }
    [Ws]() {
        const e1 = this[mr](), t = this.min;
        "" === this.min && (this.min = e1 instanceof PageArea || e1 instanceof PageSet ? 0 : 1), "" === this.max && (this.max = "" === t ? e1 instanceof PageArea || e1 instanceof PageSet ? -1 : 1 : this.min), -1 !== this.max && this.max < this.min && (this.max = this.min), "" === this.initial && (this.initial = e1 instanceof Template ? 1 : this.min);
    }
}
class Oid extends StringObject {
    constructor(e1){
        super(Lo, "oid"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Oids extends XFAObject {
    constructor(e1){
        super(Lo, "oids", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.oid = new XFAObjectArray;
    }
}
class Overflow extends XFAObject {
    constructor(e1){
        super(Lo, "overflow"), this.id = e1.id || "", this.leader = e1.leader || "", this.target = e1.target || "", this.trailer = e1.trailer || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [hr]() {
        if (!this[er]) {
            const e1 = this[mr](), t = this[br](), i = t[Wr](this.target, e1), n = t[Wr](this.leader, e1), a = t[Wr](this.trailer, e1);
            this[er] = {
                target: i?.[0] || null,
                leader: n?.[0] || null,
                trailer: a?.[0] || null,
                addLeader: !1,
                addTrailer: !1
            };
        }
        return this[er];
    }
}
class PageArea extends XFAObject {
    constructor(e1){
        super(Lo, "pageArea", !0), this.blankOrNotBlank = getStringOption(e1.blankOrNotBlank, [
            "any",
            "blank",
            "notBlank"
        ]), this.id = e1.id || "", this.initialNumber = getInteger({
            data: e1.initialNumber,
            defaultValue: 1,
            validate: (e1)=>!0
        }), this.name = e1.name || "", this.numbered = getInteger({
            data: e1.numbered,
            defaultValue: 1,
            validate: (e1)=>!0
        }), this.oddOrEven = getStringOption(e1.oddOrEven, [
            "any",
            "even",
            "odd"
        ]), this.pagePosition = getStringOption(e1.pagePosition, [
            "any",
            "first",
            "last",
            "only",
            "rest"
        ]), this.relevant = getRelevant(e1.relevant), this.use = e1.use || "", this.usehref = e1.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new XFAObjectArray, this.contentArea = new XFAObjectArray, this.draw = new XFAObjectArray, this.exclGroup = new XFAObjectArray, this.field = new XFAObjectArray, this.subform = new XFAObjectArray;
    }
    [Dr]() {
        return this[er] ? !this.occur || -1 === this.occur.max || this[er].numberOfUse < this.occur.max : (this[er] = {
            numberOfUse: 0
        }, !0);
    }
    [Gs]() {
        delete this[er];
    }
    [fr]() {
        this[er] ||= {
            numberOfUse: 0
        };
        const e1 = this[mr]();
        return "orderedOccurrence" === e1.relation && this[Dr]() ? (this[er].numberOfUse += 1, this) : e1[fr]();
    }
    [sr]() {
        return this[er].space || {
            width: 0,
            height: 0
        };
    }
    [Qr]() {
        this[er] ||= {
            numberOfUse: 1
        };
        const e1 = [];
        this[er].children = e1;
        const t = Object.create(null);
        if (this.medium && this.medium.short && this.medium.long) {
            if (t.width = measureToString(this.medium.short), t.height = measureToString(this.medium.long), this[er].space = {
                width: this.medium.short,
                height: this.medium.long
            }, "landscape" === this.medium.orientation) {
                const e1 = t.width;
                t.width = t.height, t.height = e1, this[er].space = {
                    width: this.medium.long,
                    height: this.medium.short
                };
            }
        } else warn$1("XFA - No medium specified in pageArea: please file a bug.");
        return this[zs]({
            filter: new Set([
                "area",
                "draw",
                "field",
                "subform"
            ]),
            include: !0
        }), this[zs]({
            filter: new Set([
                "contentArea"
            ]),
            include: !0
        }), HTMLResult.success({
            name: "div",
            children: e1,
            attributes: {
                class: [
                    "xfaPage"
                ],
                id: this[io],
                style: t,
                xfaName: this.name
            }
        });
    }
}
class PageSet extends XFAObject {
    constructor(e1){
        super(Lo, "pageSet", !0), this.duplexImposition = getStringOption(e1.duplexImposition, [
            "longEdge",
            "shortEdge"
        ]), this.id = e1.id || "", this.name = e1.name || "", this.relation = getStringOption(e1.relation, [
            "orderedOccurrence",
            "duplexPaginated",
            "simplexPaginated"
        ]), this.relevant = getRelevant(e1.relevant), this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null, this.occur = null, this.pageArea = new XFAObjectArray, this.pageSet = new XFAObjectArray;
    }
    [Gs]() {
        for (const e1 of this.pageArea.children)e1[Gs]();
        for (const e1 of this.pageSet.children)e1[Gs]();
    }
    [Dr]() {
        return !this.occur || -1 === this.occur.max || this[er].numberOfUse < this.occur.max;
    }
    [fr]() {
        if (this[er] ||= {
            numberOfUse: 1,
            pageIndex: -1,
            pageSetIndex: -1
        }, "orderedOccurrence" === this.relation) {
            if (this[er].pageIndex + 1 < this.pageArea.children.length) {
                this[er].pageIndex += 1;
                return this.pageArea.children[this[er].pageIndex][fr]();
            }
            if (this[er].pageSetIndex + 1 < this.pageSet.children.length) return this[er].pageSetIndex += 1, this.pageSet.children[this[er].pageSetIndex][fr]();
            if (this[Dr]()) return this[er].numberOfUse += 1, this[er].pageIndex = -1, this[er].pageSetIndex = -1, this[fr]();
            const e1 = this[mr]();
            return e1 instanceof PageSet ? e1[fr]() : (this[Gs](), this[fr]());
        }
        const e1 = this[br]()[er].pageNumber, t = e1 % 2 == 0 ? "even" : "odd", i = 0 === e1 ? "first" : "rest";
        let n = this.pageArea.children.find((e1)=>e1.oddOrEven === t && e1.pagePosition === i);
        return n || (n = this.pageArea.children.find((e1)=>"any" === e1.oddOrEven && e1.pagePosition === i), n || (n = this.pageArea.children.find((e1)=>"any" === e1.oddOrEven && "any" === e1.pagePosition), n || this.pageArea.children[0]));
    }
}
class Para extends XFAObject {
    constructor(e1){
        super(Lo, "para", !0), this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]), this.id = e1.id || "", this.lineHeight = e1.lineHeight ? getMeasurement(e1.lineHeight, "0pt") : "", this.marginLeft = e1.marginLeft ? getMeasurement(e1.marginLeft, "0pt") : "", this.marginRight = e1.marginRight ? getMeasurement(e1.marginRight, "0pt") : "", this.orphans = getInteger({
            data: e1.orphans,
            defaultValue: 0,
            validate: (e1)=>e1 >= 0
        }), this.preserve = e1.preserve || "", this.radixOffset = e1.radixOffset ? getMeasurement(e1.radixOffset, "0pt") : "", this.spaceAbove = e1.spaceAbove ? getMeasurement(e1.spaceAbove, "0pt") : "", this.spaceBelow = e1.spaceBelow ? getMeasurement(e1.spaceBelow, "0pt") : "", this.tabDefault = e1.tabDefault ? getMeasurement(this.tabDefault) : "", this.tabStops = (e1.tabStops || "").trim().split(/\s+/).map((e1, t)=>t % 2 == 1 ? getMeasurement(e1) : e1), this.textIndent = e1.textIndent ? getMeasurement(e1.textIndent, "0pt") : "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.vAlign = getStringOption(e1.vAlign, [
            "top",
            "bottom",
            "middle"
        ]), this.widows = getInteger({
            data: e1.widows,
            defaultValue: 0,
            validate: (e1)=>e1 >= 0
        }), this.hyphenation = null;
    }
    [to]() {
        const e1 = toStyle(this, "hAlign");
        return "" !== this.marginLeft && (e1.paddingLeft = measureToString(this.marginLeft)), "" !== this.marginRight && (e1.paddingRight = measureToString(this.marginRight)), "" !== this.spaceAbove && (e1.paddingTop = measureToString(this.spaceAbove)), "" !== this.spaceBelow && (e1.paddingBottom = measureToString(this.spaceBelow)), "" !== this.textIndent && (e1.textIndent = measureToString(this.textIndent), fixTextIndent(e1)), this.lineHeight > 0 && (e1.lineHeight = measureToString(this.lineHeight)), "" !== this.tabDefault && (e1.tabSize = measureToString(this.tabDefault)), this.tabStops.length, this.hyphenatation && Object.assign(e1, this.hyphenatation[to]()), e1;
    }
}
class PasswordEdit extends XFAObject {
    constructor(e1){
        super(Lo, "passwordEdit", !0), this.hScrollPolicy = getStringOption(e1.hScrollPolicy, [
            "auto",
            "off",
            "on"
        ]), this.id = e1.id || "", this.passwordChar = e1.passwordChar || "*", this.use = e1.use || "", this.usehref = e1.usehref || "", this.border = null, this.extras = null, this.margin = null;
    }
}
class template_Pattern extends XFAObject {
    constructor(e1){
        super(Lo, "pattern", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "crossHatch",
            "crossDiagonal",
            "diagonalLeft",
            "diagonalRight",
            "horizontal",
            "vertical"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.color = null, this.extras = null;
    }
    [to](e1) {
        e1 = e1 ? e1[to]() : "#FFFFFF";
        const t = this.color ? this.color[to]() : "#000000", i = "repeating-linear-gradient", n = `${e1},${e1} 5px,${t} 5px,${t} 10px`;
        switch(this.type){
            case "crossHatch":
                return `${i}(to top,${n}) ${i}(to right,${n})`;
            case "crossDiagonal":
                return `${i}(45deg,${n}) ${i}(-45deg,${n})`;
            case "diagonalLeft":
                return `${i}(45deg,${n})`;
            case "diagonalRight":
                return `${i}(-45deg,${n})`;
            case "horizontal":
                return `${i}(to top,${n})`;
            case "vertical":
                return `${i}(to right,${n})`;
        }
        return "";
    }
}
class Picture extends StringObject {
    constructor(e1){
        super(Lo, "picture"), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Proto extends XFAObject {
    constructor(e1){
        super(Lo, "proto", !0), this.appearanceFilter = new XFAObjectArray, this.arc = new XFAObjectArray, this.area = new XFAObjectArray, this.assist = new XFAObjectArray, this.barcode = new XFAObjectArray, this.bindItems = new XFAObjectArray, this.bookend = new XFAObjectArray, this.boolean = new XFAObjectArray, this.border = new XFAObjectArray, this.break = new XFAObjectArray, this.breakAfter = new XFAObjectArray, this.breakBefore = new XFAObjectArray, this.button = new XFAObjectArray, this.calculate = new XFAObjectArray, this.caption = new XFAObjectArray, this.certificate = new XFAObjectArray, this.certificates = new XFAObjectArray, this.checkButton = new XFAObjectArray, this.choiceList = new XFAObjectArray, this.color = new XFAObjectArray, this.comb = new XFAObjectArray, this.connect = new XFAObjectArray, this.contentArea = new XFAObjectArray, this.corner = new XFAObjectArray, this.date = new XFAObjectArray, this.dateTime = new XFAObjectArray, this.dateTimeEdit = new XFAObjectArray, this.decimal = new XFAObjectArray, this.defaultUi = new XFAObjectArray, this.desc = new XFAObjectArray, this.digestMethod = new XFAObjectArray, this.digestMethods = new XFAObjectArray, this.draw = new XFAObjectArray, this.edge = new XFAObjectArray, this.encoding = new XFAObjectArray, this.encodings = new XFAObjectArray, this.encrypt = new XFAObjectArray, this.encryptData = new XFAObjectArray, this.encryption = new XFAObjectArray, this.encryptionMethod = new XFAObjectArray, this.encryptionMethods = new XFAObjectArray, this.event = new XFAObjectArray, this.exData = new XFAObjectArray, this.exObject = new XFAObjectArray, this.exclGroup = new XFAObjectArray, this.execute = new XFAObjectArray, this.extras = new XFAObjectArray, this.field = new XFAObjectArray, this.fill = new XFAObjectArray, this.filter = new XFAObjectArray, this.float = new XFAObjectArray, this.font = new XFAObjectArray, this.format = new XFAObjectArray, this.handler = new XFAObjectArray, this.hyphenation = new XFAObjectArray, this.image = new XFAObjectArray, this.imageEdit = new XFAObjectArray, this.integer = new XFAObjectArray, this.issuers = new XFAObjectArray, this.items = new XFAObjectArray, this.keep = new XFAObjectArray, this.keyUsage = new XFAObjectArray, this.line = new XFAObjectArray, this.linear = new XFAObjectArray, this.lockDocument = new XFAObjectArray, this.manifest = new XFAObjectArray, this.margin = new XFAObjectArray, this.mdp = new XFAObjectArray, this.medium = new XFAObjectArray, this.message = new XFAObjectArray, this.numericEdit = new XFAObjectArray, this.occur = new XFAObjectArray, this.oid = new XFAObjectArray, this.oids = new XFAObjectArray, this.overflow = new XFAObjectArray, this.pageArea = new XFAObjectArray, this.pageSet = new XFAObjectArray, this.para = new XFAObjectArray, this.passwordEdit = new XFAObjectArray, this.pattern = new XFAObjectArray, this.picture = new XFAObjectArray, this.radial = new XFAObjectArray, this.reason = new XFAObjectArray, this.reasons = new XFAObjectArray, this.rectangle = new XFAObjectArray, this.ref = new XFAObjectArray, this.script = new XFAObjectArray, this.setProperty = new XFAObjectArray, this.signData = new XFAObjectArray, this.signature = new XFAObjectArray, this.signing = new XFAObjectArray, this.solid = new XFAObjectArray, this.speak = new XFAObjectArray, this.stipple = new XFAObjectArray, this.subform = new XFAObjectArray, this.subformSet = new XFAObjectArray, this.subjectDN = new XFAObjectArray, this.subjectDNs = new XFAObjectArray, this.submit = new XFAObjectArray, this.text = new XFAObjectArray, this.textEdit = new XFAObjectArray, this.time = new XFAObjectArray, this.timeStamp = new XFAObjectArray, this.toolTip = new XFAObjectArray, this.traversal = new XFAObjectArray, this.traverse = new XFAObjectArray, this.ui = new XFAObjectArray, this.validate = new XFAObjectArray, this.value = new XFAObjectArray, this.variables = new XFAObjectArray;
    }
}
class Radial extends XFAObject {
    constructor(e1){
        super(Lo, "radial", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "toEdge",
            "toCenter"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.color = null, this.extras = null;
    }
    [to](e1) {
        e1 = e1 ? e1[to]() : "#FFFFFF";
        const t = this.color ? this.color[to]() : "#000000";
        return `radial-gradient(circle at center, ${"toEdge" === this.type ? `${e1},${t}` : `${t},${e1}`})`;
    }
}
class Reason extends StringObject {
    constructor(e1){
        super(Lo, "reason"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Reasons extends XFAObject {
    constructor(e1){
        super(Lo, "reasons", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.reason = new XFAObjectArray;
    }
}
class Rectangle extends XFAObject {
    constructor(e1){
        super(Lo, "rectangle", !0), this.hand = getStringOption(e1.hand, [
            "even",
            "left",
            "right"
        ]), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.corner = new XFAObjectArray(4), this.edge = new XFAObjectArray(4), this.fill = null;
    }
    [Qr]() {
        const e1 = this.edge.children.length ? this.edge.children[0] : new Edge({}), t = e1[to](), i = Object.create(null);
        "visible" === this.fill?.presence ? Object.assign(i, this.fill[to]()) : i.fill = "transparent", i.strokeWidth = measureToString("visible" === e1.presence ? e1.thickness : 0), i.stroke = t.color;
        const n = (this.corner.children.length ? this.corner.children[0] : new Corner({}))[to](), a = {
            name: "svg",
            children: [
                {
                    name: "rect",
                    attributes: {
                        xmlns: Uo,
                        width: "100%",
                        height: "100%",
                        x: 0,
                        y: 0,
                        rx: n.radius,
                        ry: n.radius,
                        style: i
                    }
                }
            ],
            attributes: {
                xmlns: Uo,
                style: {
                    overflow: "visible"
                },
                width: "100%",
                height: "100%"
            }
        };
        return hasMargin(this[mr]()[mr]()) ? HTMLResult.success({
            name: "div",
            attributes: {
                style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                }
            },
            children: [
                a
            ]
        }) : (a.attributes.style.position = "absolute", HTMLResult.success(a));
    }
}
class RefElement extends StringObject {
    constructor(e1){
        super(Lo, "ref"), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Script extends StringObject {
    constructor(e1){
        super(Lo, "script"), this.binding = e1.binding || "", this.contentType = e1.contentType || "", this.id = e1.id || "", this.name = e1.name || "", this.runAt = getStringOption(e1.runAt, [
            "client",
            "both",
            "server"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class SetProperty extends XFAObject {
    constructor(e1){
        super(Lo, "setProperty"), this.connection = e1.connection || "", this.ref = e1.ref || "", this.target = e1.target || "";
    }
}
class SignData extends XFAObject {
    constructor(e1){
        super(Lo, "signData", !0), this.id = e1.id || "", this.operation = getStringOption(e1.operation, [
            "sign",
            "clear",
            "verify"
        ]), this.ref = e1.ref || "", this.target = e1.target || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.filter = null, this.manifest = null;
    }
}
class Signature extends XFAObject {
    constructor(e1){
        super(Lo, "signature", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "PDF1.3",
            "PDF1.6"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
    }
}
class Signing extends XFAObject {
    constructor(e1){
        super(Lo, "signing", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.certificate = new XFAObjectArray;
    }
}
class Solid extends XFAObject {
    constructor(e1){
        super(Lo, "solid", !0), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null;
    }
    [to](e1) {
        return e1 ? e1[to]() : "#FFFFFF";
    }
}
class Speak extends StringObject {
    constructor(e1){
        super(Lo, "speak"), this.disable = getInteger({
            data: e1.disable,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.id = e1.id || "", this.priority = getStringOption(e1.priority, [
            "custom",
            "caption",
            "name",
            "toolTip"
        ]), this.rid = e1.rid || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Stipple extends XFAObject {
    constructor(e1){
        super(Lo, "stipple", !0), this.id = e1.id || "", this.rate = getInteger({
            data: e1.rate,
            defaultValue: 50,
            validate: (e1)=>e1 >= 0 && e1 <= 100
        }), this.use = e1.use || "", this.usehref = e1.usehref || "", this.color = null, this.extras = null;
    }
    [to](e1) {
        const t = this.rate / 100;
        return ai.makeHexColor(Math.round(e1.value.r * (1 - t) + this.value.r * t), Math.round(e1.value.g * (1 - t) + this.value.g * t), Math.round(e1.value.b * (1 - t) + this.value.b * t));
    }
}
class Subform extends XFAObject {
    constructor(e1){
        super(Lo, "subform", !0), this.access = getStringOption(e1.access, [
            "open",
            "nonInteractive",
            "protected",
            "readOnly"
        ]), this.allowMacro = getInteger({
            data: e1.allowMacro,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.anchorType = getStringOption(e1.anchorType, [
            "topLeft",
            "bottomCenter",
            "bottomLeft",
            "bottomRight",
            "middleCenter",
            "middleLeft",
            "middleRight",
            "topCenter",
            "topRight"
        ]), this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        }), this.columnWidths = (e1.columnWidths || "").trim().split(/\s+/).map((e1)=>"-1" === e1 ? -1 : getMeasurement(e1)), this.h = e1.h ? getMeasurement(e1.h) : "", this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]), this.id = e1.id || "", this.layout = getStringOption(e1.layout, [
            "position",
            "lr-tb",
            "rl-row",
            "rl-tb",
            "row",
            "table",
            "tb"
        ]), this.locale = e1.locale || "", this.maxH = getMeasurement(e1.maxH, "0pt"), this.maxW = getMeasurement(e1.maxW, "0pt"), this.mergeMode = getStringOption(e1.mergeMode, [
            "consumeData",
            "matchTemplate"
        ]), this.minH = getMeasurement(e1.minH, "0pt"), this.minW = getMeasurement(e1.minW, "0pt"), this.name = e1.name || "", this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]), this.relevant = getRelevant(e1.relevant), this.restoreState = getStringOption(e1.restoreState, [
            "manual",
            "auto"
        ]), this.scope = getStringOption(e1.scope, [
            "name",
            "none"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.w = e1.w ? getMeasurement(e1.w) : "", this.x = getMeasurement(e1.x, "0pt"), this.y = getMeasurement(e1.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new XFAObjectArray, this.breakAfter = new XFAObjectArray, this.breakBefore = new XFAObjectArray, this.connect = new XFAObjectArray, this.draw = new XFAObjectArray, this.event = new XFAObjectArray, this.exObject = new XFAObjectArray, this.exclGroup = new XFAObjectArray, this.field = new XFAObjectArray, this.proto = new XFAObjectArray, this.setProperty = new XFAObjectArray, this.subform = new XFAObjectArray, this.subformSet = new XFAObjectArray;
    }
    [pr]() {
        const e1 = this[mr]();
        return e1 instanceof SubformSet ? e1[pr]() : e1;
    }
    [Cr]() {
        return !0;
    }
    [Er]() {
        return this.layout.endsWith("-tb") && 0 === this[er].attempt && this[er].numberInLine > 0 || this[mr]()[Er]();
    }
    *[gr]() {
        yield* getContainedChildren(this);
    }
    [ir]() {
        return flushHTML(this);
    }
    [Xs](e1, t) {
        addHTML(this, e1, t);
    }
    [sr]() {
        return getAvailableSpace(this);
    }
    [Ir]() {
        const e1 = this[pr]();
        return !!e1[Ir]() && (void 0 !== this[er]._isSplittable ? this[er]._isSplittable : "position" === this.layout || this.layout.includes("row") || this.keep && "none" !== this.keep.intact ? (this[er]._isSplittable = !1, !1) : (!e1.layout?.endsWith("-tb") || 0 === e1[er].numberInLine) && (this[er]._isSplittable = !0, !0));
    }
    [Qr](e1) {
        if (setTabIndex(this), this.break) {
            if ("auto" !== this.break.after || "" !== this.break.afterTarget) {
                const e1 = new BreakAfter({
                    targetType: this.break.after,
                    target: this.break.afterTarget,
                    startNew: this.break.startNew.toString()
                });
                e1[yr] = this[yr], this[qs](e1), this.breakAfter.push(e1);
            }
            if ("auto" !== this.break.before || "" !== this.break.beforeTarget) {
                const e1 = new BreakBefore({
                    targetType: this.break.before,
                    target: this.break.beforeTarget,
                    startNew: this.break.startNew.toString()
                });
                e1[yr] = this[yr], this[qs](e1), this.breakBefore.push(e1);
            }
            if ("" !== this.break.overflowTarget) {
                const e1 = new Overflow({
                    target: this.break.overflowTarget,
                    leader: this.break.overflowLeader,
                    trailer: this.break.overflowTrailer
                });
                e1[yr] = this[yr], this[qs](e1), this.overflow.push(e1);
            }
            this[Xr](this.break), this.break = null;
        }
        if ("hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
        if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && warn$1("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
            const e1 = this.breakBefore.children[0];
            if (handleBreak(e1)) return HTMLResult.breakNode(e1);
        }
        if (this[er]?.afterBreakAfter) return HTMLResult.EMPTY;
        fixDimensions(this);
        const t = [], i = {
            id: this[io],
            class: []
        };
        setAccess(this, i.class), this[er] ||= Object.create(null), Object.assign(this[er], {
            children: t,
            line: null,
            attributes: i,
            attempt: 0,
            numberInLine: 0,
            availableSpace: {
                width: Math.min(this.w || 1 / 0, e1.width),
                height: Math.min(this.h || 1 / 0, e1.height)
            },
            width: 0,
            height: 0,
            prevHeight: 0,
            currentWidth: 0
        });
        const n = this[br](), a = n[er].noLayoutFailure, s = this[Ir]();
        if (s || setFirstUnsplittable(this), !checkDimensions(this, e1)) return HTMLResult.FAILURE;
        const r = new Set([
            "area",
            "draw",
            "exclGroup",
            "field",
            "subform",
            "subformSet"
        ]);
        if (this.layout.includes("row")) {
            const e1 = this[pr]().columnWidths;
            Array.isArray(e1) && e1.length > 0 && (this[er].columnWidths = e1, this[er].currentColumn = 0);
        }
        const o = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), l = [
            "xfaSubform"
        ], c = layoutClass(this);
        if (c && l.push(c), i.style = o, i.class = l, this.name && (i.xfaName = this.name), this.overflow) {
            const t = this.overflow[hr]();
            t.addLeader && (t.addLeader = !1, handleOverflow(this, t.leader, e1));
        }
        this[Hr]();
        const h = "lr-tb" === this.layout || "rl-tb" === this.layout, d = h ? 2 : 1;
        for(; this[er].attempt < d; this[er].attempt++){
            h && 1 === this[er].attempt && (this[er].numberInLine = 0);
            const e1 = this[zs]({
                filter: r,
                include: !0
            });
            if (e1.success) break;
            if (e1.isBreak()) return this[$r](), e1;
            if (h && 0 === this[er].attempt && 0 === this[er].numberInLine && !n[er].noLayoutFailure) {
                this[er].attempt = d;
                break;
            }
        }
        if (this[$r](), s || unsetFirstUnsplittable(this), n[er].noLayoutFailure = a, this[er].attempt === d) return this.overflow && (this[br]()[er].overflowNode = this.overflow), s || delete this[er], HTMLResult.FAILURE;
        if (this.overflow) {
            const t = this.overflow[hr]();
            t.addTrailer && (t.addTrailer = !1, handleOverflow(this, t.trailer, e1));
        }
        let u = 0, g = 0;
        this.margin && (u = this.margin.leftInset + this.margin.rightInset, g = this.margin.topInset + this.margin.bottomInset);
        const f = Math.max(this[er].width + u, this.w || 0), p = Math.max(this[er].height + g, this.h || 0), m = [
            this.x,
            this.y,
            f,
            p
        ];
        if ("" === this.w && (o.width = measureToString(f)), "" === this.h && (o.height = measureToString(p)), ("0px" === o.width || "0px" === o.height) && 0 === t.length) return HTMLResult.EMPTY;
        const b = {
            name: "div",
            attributes: i,
            children: t
        };
        applyAssist(this, i);
        const y = HTMLResult.success(createWrapper(this, b), m);
        if (this.breakAfter.children.length >= 1) {
            const e1 = this.breakAfter.children[0];
            if (handleBreak(e1)) return this[er].afterBreakAfter = y, HTMLResult.breakNode(e1);
        }
        return delete this[er], y;
    }
}
class SubformSet extends XFAObject {
    constructor(e1){
        super(Lo, "subformSet", !0), this.id = e1.id || "", this.name = e1.name || "", this.relation = getStringOption(e1.relation, [
            "ordered",
            "choice",
            "unordered"
        ]), this.relevant = getRelevant(e1.relevant), this.use = e1.use || "", this.usehref = e1.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new XFAObjectArray, this.breakBefore = new XFAObjectArray, this.subform = new XFAObjectArray, this.subformSet = new XFAObjectArray;
    }
    *[gr]() {
        yield* getContainedChildren(this);
    }
    [pr]() {
        let e1 = this[mr]();
        for(; !(e1 instanceof Subform);)e1 = e1[mr]();
        return e1;
    }
    [Cr]() {
        return !0;
    }
}
class SubjectDN extends ContentObject {
    constructor(e1){
        super(Lo, "subjectDN"), this.delimiter = e1.delimiter || ",", this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [tr]() {
        this[Js] = new Map(this[Js].split(this.delimiter).map((e1)=>((e1 = e1.split("=", 2))[0] = e1[0].trim(), e1)));
    }
}
class SubjectDNs extends XFAObject {
    constructor(e1){
        super(Lo, "subjectDNs", !0), this.id = e1.id || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.subjectDN = new XFAObjectArray;
    }
}
class Submit extends XFAObject {
    constructor(e1){
        super(Lo, "submit", !0), this.embedPDF = getInteger({
            data: e1.embedPDF,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.format = getStringOption(e1.format, [
            "xdp",
            "formdata",
            "pdf",
            "urlencoded",
            "xfd",
            "xml"
        ]), this.id = e1.id || "", this.target = e1.target || "", this.textEncoding = getKeyword({
            data: e1.textEncoding ? e1.textEncoding.toLowerCase() : "",
            defaultValue: "",
            validate: (e1)=>[
                    "utf-8",
                    "big-five",
                    "fontspecific",
                    "gbk",
                    "gb-18030",
                    "gb-2312",
                    "ksc-5601",
                    "none",
                    "shift-jis",
                    "ucs-2",
                    "utf-16"
                ].includes(e1) || e1.match(/iso-8859-\d{2}/)
        }), this.use = e1.use || "", this.usehref = e1.usehref || "", this.xdpContent = e1.xdpContent || "", this.encrypt = null, this.encryptData = new XFAObjectArray, this.signData = new XFAObjectArray;
    }
}
class Template extends XFAObject {
    constructor(e1){
        super(Lo, "template", !0), this.baseProfile = getStringOption(e1.baseProfile, [
            "full",
            "interactiveForms"
        ]), this.extras = null, this.subform = new XFAObjectArray;
    }
    [tr]() {
        0 === this.subform.children.length && warn$1("XFA - No subforms in template node."), this.subform.children.length >= 2 && warn$1("XFA - Several subforms in template node: please file a bug."), this[Yr] = 5e3;
    }
    [Ir]() {
        return !0;
    }
    [Wr](e1, t) {
        return e1.startsWith("#") ? [
            this[Ar].get(e1.slice(1))
        ] : searchNode(this, t, e1, !0, !0);
    }
    *[Zr]() {
        if (!this.subform.children.length) return HTMLResult.success({
            name: "div",
            children: []
        });
        this[er] = {
            overflowNode: null,
            firstUnsplittable: null,
            currentContentArea: null,
            currentPageArea: null,
            noLayoutFailure: !1,
            pageNumber: 1,
            pagePosition: "first",
            oddOrEven: "odd",
            blankOrNotBlank: "nonBlank",
            paraStack: []
        };
        const e1 = this.subform.children[0];
        e1.pageSet[Gs]();
        const t = e1.pageSet.pageArea.children, i = {
            name: "div",
            children: []
        };
        let n = null, a = null, s = null;
        if (e1.breakBefore.children.length >= 1 ? (a = e1.breakBefore.children[0], s = a.target) : e1.subform.children.length >= 1 && e1.subform.children[0].breakBefore.children.length >= 1 ? (a = e1.subform.children[0].breakBefore.children[0], s = a.target) : e1.break?.beforeTarget ? (a = e1.break, s = a.beforeTarget) : e1.subform.children.length >= 1 && e1.subform.children[0].break?.beforeTarget && (a = e1.subform.children[0].break, s = a.beforeTarget), a) {
            const e1 = this[Wr](s, a[mr]());
            e1 instanceof PageArea && (n = e1, a[er] = {});
        }
        n ||= t[0], n[er] = {
            numberOfUse: 1
        };
        const r = n[mr]();
        let o;
        r[er] = {
            numberOfUse: 1,
            pageIndex: r.pageArea.children.indexOf(n),
            pageSetIndex: 0
        };
        let l = null, c = null, h = !0, d = 0, u = 0;
        for(;;){
            if (h) d = 0;
            else if (i.children.pop(), 3 === ++d) return warn$1("XFA - Something goes wrong: please file a bug."), i;
            o = null, this[er].currentPageArea = n;
            const t = n[Qr]().html;
            i.children.push(t), l && (this[er].noLayoutFailure = !0, t.children.push(l[Qr](n[er].space).html), l = null), c && (this[er].noLayoutFailure = !0, t.children.push(c[Qr](n[er].space).html), c = null);
            const a = n.contentArea.children, s = t.children.filter((e1)=>e1.attributes.class.includes("xfaContentarea"));
            h = !1, this[er].firstUnsplittable = null, this[er].noLayoutFailure = !1;
            const flush = (t)=>{
                const i = e1[ir]();
                i && (h ||= i.children?.length > 0, s[t].children.push(i));
            };
            for(let t = u, n = a.length; t < n; t++){
                const n = this[er].currentContentArea = a[t], r = {
                    width: n.w,
                    height: n.h
                };
                u = 0, l && (s[t].children.push(l[Qr](r).html), l = null), c && (s[t].children.push(c[Qr](r).html), c = null);
                const d = e1[Qr](r);
                if (d.success) return d.html ? (h ||= d.html.children?.length > 0, s[t].children.push(d.html)) : !h && i.children.length > 1 && i.children.pop(), i;
                if (d.isBreak()) {
                    const e1 = d.breakNode;
                    if (flush(t), "auto" === e1.targetType) continue;
                    e1.leader && (l = this[Wr](e1.leader, e1[mr]()), l = l ? l[0] : null), e1.trailer && (c = this[Wr](e1.trailer, e1[mr]()), c = c ? c[0] : null), "pageArea" === e1.targetType ? (o = e1[er].target, t = 1 / 0) : e1[er].target ? (o = e1[er].target, u = e1[er].index + 1, t = 1 / 0) : t = e1[er].index;
                    continue;
                }
                if (this[er].overflowNode) {
                    const e1 = this[er].overflowNode;
                    this[er].overflowNode = null;
                    const i = e1[hr](), n = i.target;
                    i.addLeader = null !== i.leader, i.addTrailer = null !== i.trailer, flush(t);
                    const s = t;
                    if (t = 1 / 0, n instanceof PageArea) o = n;
                    else if (n instanceof ContentArea) {
                        const e1 = a.indexOf(n);
                        -1 !== e1 ? e1 > s ? t = e1 - 1 : u = e1 : (o = n[mr](), u = o.contentArea.children.indexOf(n));
                    }
                    continue;
                }
                flush(t);
            }
            this[er].pageNumber += 1, o && (o[Dr]() ? o[er].numberOfUse += 1 : o = null), n = o || n[fr](), yield null;
        }
    }
}
class Text extends ContentObject {
    constructor(e1){
        super(Lo, "text"), this.id = e1.id || "", this.maxChars = getInteger({
            data: e1.maxChars,
            defaultValue: 0,
            validate: (e1)=>e1 >= 0
        }), this.name = e1.name || "", this.rid = e1.rid || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [Hs]() {
        return !0;
    }
    [Nr](e1) {
        return e1[_r] === ao.xhtml.id ? (this[Js] = e1, !0) : (warn$1(`XFA - Invalid content in Text: ${e1[Pr]}.`), !1);
    }
    [Ur](e1) {
        this[Js] instanceof XFAObject || super[Ur](e1);
    }
    [tr]() {
        "string" == typeof this[Js] && (this[Js] = this[Js].replaceAll("\r\n", "\n"));
    }
    [hr]() {
        return "string" == typeof this[Js] ? this[Js].split(/[\u2029\u2028\n]/).filter((e1)=>!!e1).join("\n") : this[Js][Jr]();
    }
    [Qr](e1) {
        if ("string" == typeof this[Js]) {
            const e1 = valueToHtml(this[Js]).html;
            return this[Js].includes("\u2029") ? (e1.name = "div", e1.children = [], this[Js].split("\u2029").map((e1)=>e1.split(/[\u2028\n]/).flatMap((e1)=>[
                        {
                            name: "span",
                            value: e1
                        },
                        {
                            name: "br"
                        }
                    ])).forEach((t)=>{
                e1.children.push({
                    name: "p",
                    children: t
                });
            })) : /[\u2028\n]/.test(this[Js]) && (e1.name = "div", e1.children = [], this[Js].split(/[\u2028\n]/).forEach((t)=>{
                e1.children.push({
                    name: "span",
                    value: t
                }, {
                    name: "br"
                });
            })), HTMLResult.success(e1);
        }
        return this[Js][Qr](e1);
    }
}
class TextEdit extends XFAObject {
    constructor(e1){
        super(Lo, "textEdit", !0), this.allowRichText = getInteger({
            data: e1.allowRichText,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.hScrollPolicy = getStringOption(e1.hScrollPolicy, [
            "auto",
            "off",
            "on"
        ]), this.id = e1.id || "", this.multiLine = getInteger({
            data: e1.multiLine,
            defaultValue: "",
            validate: (e1)=>0 === e1 || 1 === e1
        }), this.use = e1.use || "", this.usehref = e1.usehref || "", this.vScrollPolicy = getStringOption(e1.vScrollPolicy, [
            "auto",
            "off",
            "on"
        ]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
    }
    [Qr](e1) {
        const t = toStyle(this, "border", "font", "margin");
        let i;
        const n = this[mr]()[mr]();
        return "" === this.multiLine && (this.multiLine = n instanceof Draw ? 1 : 0), i = 1 === this.multiLine ? {
            name: "textarea",
            attributes: {
                dataId: n[Zs]?.[io] || n[io],
                fieldId: n[io],
                class: [
                    "xfaTextfield"
                ],
                style: t,
                "aria-label": ariaLabel(n),
                "aria-required": !1
            }
        } : {
            name: "input",
            attributes: {
                type: "text",
                dataId: n[Zs]?.[io] || n[io],
                fieldId: n[io],
                class: [
                    "xfaTextfield"
                ],
                style: t,
                "aria-label": ariaLabel(n),
                "aria-required": !1
            }
        }, isRequired(n) && (i.attributes["aria-required"] = !0, i.attributes.required = !0), HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                i
            ]
        });
    }
}
class Time extends StringObject {
    constructor(e1){
        super(Lo, "time"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
    [tr]() {
        const e1 = this[Js].trim();
        this[Js] = e1 ? new Date(e1) : null;
    }
    [Qr](e1) {
        return valueToHtml(this[Js] ? this[Js].toString() : "");
    }
}
class TimeStamp extends XFAObject {
    constructor(e1){
        super(Lo, "timeStamp"), this.id = e1.id || "", this.server = e1.server || "", this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class ToolTip extends StringObject {
    constructor(e1){
        super(Lo, "toolTip"), this.id = e1.id || "", this.rid = e1.rid || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Traversal extends XFAObject {
    constructor(e1){
        super(Lo, "traversal", !0), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null, this.traverse = new XFAObjectArray;
    }
}
class Traverse extends XFAObject {
    constructor(e1){
        super(Lo, "traverse", !0), this.id = e1.id || "", this.operation = getStringOption(e1.operation, [
            "next",
            "back",
            "down",
            "first",
            "left",
            "right",
            "up"
        ]), this.ref = e1.ref || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null, this.script = null;
    }
    get name() {
        return this.operation;
    }
    [Mr]() {
        return !1;
    }
}
class Ui extends XFAObject {
    constructor(e1){
        super(Lo, "ui", !0), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
    }
    [hr]() {
        if (void 0 === this[er]) {
            for (const e1 of Object.getOwnPropertyNames(this)){
                if ("extras" === e1 || "picture" === e1) continue;
                const t = this[e1];
                if (t instanceof XFAObject) return this[er] = t, t;
            }
            this[er] = null;
        }
        return this[er];
    }
    [Qr](e1) {
        const t = this[hr]();
        return t ? t[Qr](e1) : HTMLResult.EMPTY;
    }
}
class Validate extends XFAObject {
    constructor(e1){
        super(Lo, "validate", !0), this.formatTest = getStringOption(e1.formatTest, [
            "warning",
            "disabled",
            "error"
        ]), this.id = e1.id || "", this.nullTest = getStringOption(e1.nullTest, [
            "disabled",
            "error",
            "warning"
        ]), this.scriptTest = getStringOption(e1.scriptTest, [
            "error",
            "disabled",
            "warning"
        ]), this.use = e1.use || "", this.usehref = e1.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
    }
}
class Value extends XFAObject {
    constructor(e1){
        super(Lo, "value", !0), this.id = e1.id || "", this.override = getInteger({
            data: e1.override,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.relevant = getRelevant(e1.relevant), this.use = e1.use || "", this.usehref = e1.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
    }
    [Kr](e1) {
        const t = this[mr]();
        if (t instanceof Field && t.ui?.imageEdit) return this.image || (this.image = new qo({}), this[qs](this.image)), void (this.image[Js] = e1[Js]);
        const i = e1[Pr];
        if (null === this[i]) {
            for (const e1 of Object.getOwnPropertyNames(this)){
                const t = this[e1];
                t instanceof XFAObject && (this[e1] = null, this[Xr](t));
            }
            this[e1[Pr]] = e1, this[qs](e1);
        } else this[i][Js] = e1[Js];
    }
    [Jr]() {
        if (this.exData) return "string" == typeof this.exData[Js] ? this.exData[Js].trim() : this.exData[Js][Jr]().trim();
        for (const e1 of Object.getOwnPropertyNames(this)){
            if ("image" === e1) continue;
            const t = this[e1];
            if (t instanceof XFAObject) return (t[Js] || "").toString().trim();
        }
        return null;
    }
    [Qr](e1) {
        for (const t of Object.getOwnPropertyNames(this)){
            const i = this[t];
            if (i instanceof XFAObject) return i[Qr](e1);
        }
        return HTMLResult.EMPTY;
    }
}
class Variables extends XFAObject {
    constructor(e1){
        super(Lo, "variables", !0), this.id = e1.id || "", this.use = e1.use || "", this.usehref = e1.usehref || "", this.boolean = new XFAObjectArray, this.date = new XFAObjectArray, this.dateTime = new XFAObjectArray, this.decimal = new XFAObjectArray, this.exData = new XFAObjectArray, this.float = new XFAObjectArray, this.image = new XFAObjectArray, this.integer = new XFAObjectArray, this.manifest = new XFAObjectArray, this.script = new XFAObjectArray, this.text = new XFAObjectArray, this.time = new XFAObjectArray;
    }
    [Mr]() {
        return !0;
    }
}
class TemplateNamespace {
    static [no](e1, t) {
        if (TemplateNamespace.hasOwnProperty(e1)) {
            const i = TemplateNamespace[e1](t);
            return i[Vr](t), i;
        }
    }
    static appearanceFilter(e1) {
        return new AppearanceFilter(e1);
    }
    static arc(e1) {
        return new Arc(e1);
    }
    static area(e1) {
        return new Area(e1);
    }
    static assist(e1) {
        return new Assist(e1);
    }
    static barcode(e1) {
        return new Barcode(e1);
    }
    static bind(e1) {
        return new Bind(e1);
    }
    static bindItems(e1) {
        return new BindItems(e1);
    }
    static bookend(e1) {
        return new Bookend(e1);
    }
    static boolean(e1) {
        return new BooleanElement(e1);
    }
    static border(e1) {
        return new Border(e1);
    }
    static break(e1) {
        return new Break(e1);
    }
    static breakAfter(e1) {
        return new BreakAfter(e1);
    }
    static breakBefore(e1) {
        return new BreakBefore(e1);
    }
    static button(e1) {
        return new Button(e1);
    }
    static calculate(e1) {
        return new Calculate(e1);
    }
    static caption(e1) {
        return new Caption(e1);
    }
    static certificate(e1) {
        return new Certificate(e1);
    }
    static certificates(e1) {
        return new Certificates(e1);
    }
    static checkButton(e1) {
        return new CheckButton(e1);
    }
    static choiceList(e1) {
        return new ChoiceList(e1);
    }
    static color(e1) {
        return new Color(e1);
    }
    static comb(e1) {
        return new Comb(e1);
    }
    static connect(e1) {
        return new Connect(e1);
    }
    static contentArea(e1) {
        return new ContentArea(e1);
    }
    static corner(e1) {
        return new Corner(e1);
    }
    static date(e1) {
        return new DateElement(e1);
    }
    static dateTime(e1) {
        return new DateTime(e1);
    }
    static dateTimeEdit(e1) {
        return new DateTimeEdit(e1);
    }
    static decimal(e1) {
        return new Decimal(e1);
    }
    static defaultUi(e1) {
        return new DefaultUi(e1);
    }
    static desc(e1) {
        return new Desc(e1);
    }
    static digestMethod(e1) {
        return new DigestMethod(e1);
    }
    static digestMethods(e1) {
        return new DigestMethods(e1);
    }
    static draw(e1) {
        return new Draw(e1);
    }
    static edge(e1) {
        return new Edge(e1);
    }
    static encoding(e1) {
        return new Encoding(e1);
    }
    static encodings(e1) {
        return new Encodings(e1);
    }
    static encrypt(e1) {
        return new Encrypt(e1);
    }
    static encryptData(e1) {
        return new EncryptData(e1);
    }
    static encryption(e1) {
        return new Encryption(e1);
    }
    static encryptionMethod(e1) {
        return new EncryptionMethod(e1);
    }
    static encryptionMethods(e1) {
        return new EncryptionMethods(e1);
    }
    static event(e1) {
        return new Xo(e1);
    }
    static exData(e1) {
        return new ExData(e1);
    }
    static exObject(e1) {
        return new ExObject(e1);
    }
    static exclGroup(e1) {
        return new ExclGroup(e1);
    }
    static execute(e1) {
        return new Execute(e1);
    }
    static extras(e1) {
        return new Extras(e1);
    }
    static field(e1) {
        return new Field(e1);
    }
    static fill(e1) {
        return new Fill(e1);
    }
    static filter(e1) {
        return new Filter(e1);
    }
    static float(e1) {
        return new Float(e1);
    }
    static font(e1) {
        return new template_Font(e1);
    }
    static format(e1) {
        return new Format(e1);
    }
    static handler(e1) {
        return new Handler(e1);
    }
    static hyphenation(e1) {
        return new Hyphenation(e1);
    }
    static image(e1) {
        return new qo(e1);
    }
    static imageEdit(e1) {
        return new ImageEdit(e1);
    }
    static integer(e1) {
        return new Integer(e1);
    }
    static issuers(e1) {
        return new Issuers(e1);
    }
    static items(e1) {
        return new Items(e1);
    }
    static keep(e1) {
        return new Keep(e1);
    }
    static keyUsage(e1) {
        return new KeyUsage(e1);
    }
    static line(e1) {
        return new Line(e1);
    }
    static linear(e1) {
        return new Linear(e1);
    }
    static lockDocument(e1) {
        return new LockDocument(e1);
    }
    static manifest(e1) {
        return new Manifest(e1);
    }
    static margin(e1) {
        return new Margin(e1);
    }
    static mdp(e1) {
        return new Mdp(e1);
    }
    static medium(e1) {
        return new Medium(e1);
    }
    static message(e1) {
        return new Message(e1);
    }
    static numericEdit(e1) {
        return new NumericEdit(e1);
    }
    static occur(e1) {
        return new Occur(e1);
    }
    static oid(e1) {
        return new Oid(e1);
    }
    static oids(e1) {
        return new Oids(e1);
    }
    static overflow(e1) {
        return new Overflow(e1);
    }
    static pageArea(e1) {
        return new PageArea(e1);
    }
    static pageSet(e1) {
        return new PageSet(e1);
    }
    static para(e1) {
        return new Para(e1);
    }
    static passwordEdit(e1) {
        return new PasswordEdit(e1);
    }
    static pattern(e1) {
        return new template_Pattern(e1);
    }
    static picture(e1) {
        return new Picture(e1);
    }
    static proto(e1) {
        return new Proto(e1);
    }
    static radial(e1) {
        return new Radial(e1);
    }
    static reason(e1) {
        return new Reason(e1);
    }
    static reasons(e1) {
        return new Reasons(e1);
    }
    static rectangle(e1) {
        return new Rectangle(e1);
    }
    static ref(e1) {
        return new RefElement(e1);
    }
    static script(e1) {
        return new Script(e1);
    }
    static setProperty(e1) {
        return new SetProperty(e1);
    }
    static signData(e1) {
        return new SignData(e1);
    }
    static signature(e1) {
        return new Signature(e1);
    }
    static signing(e1) {
        return new Signing(e1);
    }
    static solid(e1) {
        return new Solid(e1);
    }
    static speak(e1) {
        return new Speak(e1);
    }
    static stipple(e1) {
        return new Stipple(e1);
    }
    static subform(e1) {
        return new Subform(e1);
    }
    static subformSet(e1) {
        return new SubformSet(e1);
    }
    static subjectDN(e1) {
        return new SubjectDN(e1);
    }
    static subjectDNs(e1) {
        return new SubjectDNs(e1);
    }
    static submit(e1) {
        return new Submit(e1);
    }
    static template(e1) {
        return new Template(e1);
    }
    static text(e1) {
        return new Text(e1);
    }
    static textEdit(e1) {
        return new TextEdit(e1);
    }
    static time(e1) {
        return new Time(e1);
    }
    static timeStamp(e1) {
        return new TimeStamp(e1);
    }
    static toolTip(e1) {
        return new ToolTip(e1);
    }
    static traversal(e1) {
        return new Traversal(e1);
    }
    static traverse(e1) {
        return new Traverse(e1);
    }
    static ui(e1) {
        return new Ui(e1);
    }
    static validate(e1) {
        return new Validate(e1);
    }
    static value(e1) {
        return new Value(e1);
    }
    static variables(e1) {
        return new Variables(e1);
    }
}
const zo = ao.datasets.id;
function createText(e1) {
    const t = new Text({});
    return t[Js] = e1, t;
}
class Binder {
    constructor(e1){
        this.root = e1, this.datasets = e1.datasets, this.data = e1.datasets?.data || new XmlObject(ao.datasets.id, "data"), this.emptyMerge = 0 === this.data[ur]().length, this.root.form = this.form = e1.template[Ks]();
    }
    _isConsumeData() {
        return !this.emptyMerge && this._mergeMode;
    }
    _isMatchTemplate() {
        return !this._isConsumeData();
    }
    bind() {
        return this._bindElement(this.form, this.data), this.form;
    }
    getData() {
        return this.data;
    }
    _bindValue(e1, t, i) {
        if (e1[Zs] = t, e1[wr]()) if (t[kr]()) {
            const i = t[cr]();
            e1[Kr](createText(i));
        } else if (e1 instanceof Field && "multiSelect" === e1.ui?.choiceList?.open) {
            const i = t[ur]().map((e1)=>e1[Js].trim()).join("\n");
            e1[Kr](createText(i));
        } else this._isConsumeData() && warn$1("XFA - Nodes haven't the same type.");
        else !t[kr]() || this._isMatchTemplate() ? this._bindElement(e1, t) : warn$1("XFA - Nodes haven't the same type.");
    }
    _findDataByNameToConsume(e1, t, i, n) {
        if (!e1) return null;
        let a, s;
        for(let n = 0; n < 3; n++){
            for(a = i[dr](e1, !1, !0); s = a.next().value, s;)if (t === s[kr]()) return s;
            if (i[_r] === ao.datasets.id && "data" === i[Pr]) break;
            i = i[mr]();
        }
        return n ? (a = this.data[dr](e1, !0, !1), s = a.next().value, s || (a = this.data[nr](e1, !0), s = a.next().value, s?.[kr]() ? s : null)) : null;
    }
    _setProperties(e1, t) {
        if (e1.hasOwnProperty("setProperty")) for (const { ref: i, target: n, connection: a } of e1.setProperty.children){
            if (a) continue;
            if (!i) continue;
            const s = searchNode(this.root, t, i, !1, !1);
            if (!s) {
                warn$1(`XFA - Invalid reference: ${i}.`);
                continue;
            }
            const [r] = s;
            if (!r[Tr](this.data)) {
                warn$1("XFA - Invalid node: must be a data node.");
                continue;
            }
            const o = searchNode(this.root, e1, n, !1, !1);
            if (!o) {
                warn$1(`XFA - Invalid target: ${n}.`);
                continue;
            }
            const [l] = o;
            if (!l[Tr](e1)) {
                warn$1("XFA - Invalid target: must be a property or subproperty.");
                continue;
            }
            const c = l[mr]();
            if (l instanceof SetProperty || c instanceof SetProperty) {
                warn$1("XFA - Invalid target: cannot be a setProperty or one of its properties.");
                continue;
            }
            if (l instanceof BindItems || c instanceof BindItems) {
                warn$1("XFA - Invalid target: cannot be a bindItems or one of its properties.");
                continue;
            }
            const h = r[Jr](), d = l[Pr];
            if (l instanceof XFAAttribute) {
                const e1 = Object.create(null);
                e1[d] = h;
                const t = Reflect.construct(Object.getPrototypeOf(c).constructor, [
                    e1
                ]);
                c[d] = t[d];
                continue;
            }
            l.hasOwnProperty(Js) ? (l[Zs] = r, l[Js] = h, l[tr]()) : warn$1("XFA - Invalid node to use in setProperty");
        }
    }
    _bindItems(e1, t) {
        if (!e1.hasOwnProperty("items") || !e1.hasOwnProperty("bindItems") || e1.bindItems.isEmpty()) return;
        for (const t of e1.items.children)e1[Xr](t);
        e1.items.clear();
        const i = new Items({}), n = new Items({});
        e1[qs](i), e1.items.push(i), e1[qs](n), e1.items.push(n);
        for (const { ref: a, labelRef: s, valueRef: r, connection: o } of e1.bindItems.children){
            if (o) continue;
            if (!a) continue;
            const e1 = searchNode(this.root, t, a, !1, !1);
            if (e1) for (const t of e1){
                if (!t[Tr](this.datasets)) {
                    warn$1(`XFA - Invalid ref (${a}): must be a datasets child.`);
                    continue;
                }
                const e1 = searchNode(this.root, t, s, !0, !1);
                if (!e1) {
                    warn$1(`XFA - Invalid label: ${s}.`);
                    continue;
                }
                const [o] = e1;
                if (!o[Tr](this.datasets)) {
                    warn$1("XFA - Invalid label: must be a datasets child.");
                    continue;
                }
                const l = searchNode(this.root, t, r, !0, !1);
                if (!l) {
                    warn$1(`XFA - Invalid value: ${r}.`);
                    continue;
                }
                const [c] = l;
                if (!c[Tr](this.datasets)) {
                    warn$1("XFA - Invalid value: must be a datasets child.");
                    continue;
                }
                const h = createText(o[Jr]()), d = createText(c[Jr]());
                i[qs](h), i.text.push(h), n[qs](d), n.text.push(d);
            }
            else warn$1(`XFA - Invalid reference: ${a}.`);
        }
    }
    _bindOccurrences(e1, t, i) {
        let n;
        if (t.length > 1 && (n = e1[Ks](), n[Xr](n.occur), n.occur = null), this._bindValue(e1, t[0], i), this._setProperties(e1, t[0]), this._bindItems(e1, t[0]), 1 === t.length) return;
        const a = e1[mr](), s = e1[Pr], r = a[xr](e1);
        for(let e1 = 1, o = t.length; e1 < o; e1++){
            const o = t[e1], l = n[Ks]();
            a[s].push(l), a[Sr](r + e1, l), this._bindValue(l, o, i), this._setProperties(l, o), this._bindItems(l, o);
        }
    }
    _createOccurrences(e1) {
        if (!this.emptyMerge) return;
        const { occur: t } = e1;
        if (!t || t.initial <= 1) return;
        const i = e1[mr](), n = e1[Pr];
        if (!(i[n] instanceof XFAObjectArray)) return;
        let a;
        a = e1.name ? i[n].children.filter((t)=>t.name === e1.name).length : i[n].children.length;
        const s = i[xr](e1) + 1, r = t.initial - a;
        if (r) {
            const t = e1[Ks]();
            t[Xr](t.occur), t.occur = null, i[n].push(t), i[Sr](s, t);
            for(let e1 = 1; e1 < r; e1++){
                const a = t[Ks]();
                i[n].push(a), i[Sr](s + e1, a);
            }
        }
    }
    _getOccurInfo(e1) {
        const { name: t, occur: i } = e1;
        if (!i || !t) return [
            1,
            1
        ];
        const n = -1 === i.max ? 1 / 0 : i.max;
        return [
            i.min,
            n
        ];
    }
    _setAndBind(e1, t) {
        this._setProperties(e1, t), this._bindItems(e1, t), this._bindElement(e1, t);
    }
    _bindElement(e1, t) {
        const i = [];
        this._createOccurrences(e1);
        for (const n of e1[ur]()){
            if (n[Zs]) continue;
            if (void 0 === this._mergeMode && "subform" === n[Pr]) {
                this._mergeMode = "consumeData" === n.mergeMode;
                const e1 = t[ur]();
                if (e1.length > 0) this._bindOccurrences(n, [
                    e1[0]
                ], null);
                else if (this.emptyMerge) {
                    const e1 = t[_r] === zo ? -1 : t[_r], i = n[Zs] = new XmlObject(e1, n.name || "root");
                    t[qs](i), this._bindElement(n, i);
                }
                continue;
            }
            if (!n[Cr]()) continue;
            let e1 = !1, a = null, s = null, r = null;
            if (n.bind) {
                switch(n.bind.match){
                    case "none":
                        this._setAndBind(n, t);
                        continue;
                    case "global":
                        e1 = !0;
                        break;
                    case "dataRef":
                        if (!n.bind.ref) {
                            warn$1(`XFA - ref is empty in node ${n[Pr]}.`), this._setAndBind(n, t);
                            continue;
                        }
                        s = n.bind.ref;
                }
                n.bind.picture && (a = n.bind.picture[Js]);
            }
            const [o, l] = this._getOccurInfo(n);
            if (s) {
                if (r = searchNode(this.root, t, s, !0, !1), null === r) {
                    if (r = createDataNode(this.data, t, s), !r) continue;
                    this._isConsumeData() && (r[Ys] = !0), this._setAndBind(n, r);
                    continue;
                }
                this._isConsumeData() && (r = r.filter((e1)=>!e1[Ys])), r.length > l ? r = r.slice(0, l) : 0 === r.length && (r = null), r && this._isConsumeData() && r.forEach((e1)=>{
                    e1[Ys] = !0;
                });
            } else {
                if (!n.name) {
                    this._setAndBind(n, t);
                    continue;
                }
                if (this._isConsumeData()) {
                    const i = [];
                    for(; i.length < l;){
                        const a = this._findDataByNameToConsume(n.name, n[wr](), t, e1);
                        if (!a) break;
                        a[Ys] = !0, i.push(a);
                    }
                    r = i.length > 0 ? i : null;
                } else {
                    if (r = t[dr](n.name, !1, this.emptyMerge).next().value, !r) {
                        if (0 === o) {
                            i.push(n);
                            continue;
                        }
                        const e1 = t[_r] === zo ? -1 : t[_r];
                        r = n[Zs] = new XmlObject(e1, n.name), this.emptyMerge && (r[Ys] = !0), t[qs](r), this._setAndBind(n, r);
                        continue;
                    }
                    this.emptyMerge && (r[Ys] = !0), r = [
                        r
                    ];
                }
            }
            r ? this._bindOccurrences(n, r, a) : o > 0 ? this._setAndBind(n, t) : i.push(n);
        }
        i.forEach((e1)=>e1[mr]()[Xr](e1));
    }
}
class DataHandler {
    constructor(e1, t){
        this.data = t, this.dataset = e1.datasets || null;
    }
    serialize(e1) {
        const t = [
            [
                -1,
                this.data[ur]()
            ]
        ];
        for(; t.length > 0;){
            const i = t.at(-1), [n, a] = i;
            if (n + 1 === a.length) {
                t.pop();
                continue;
            }
            const s = a[++i[0]], r = e1.get(s[io]);
            if (r) s[Kr](r);
            else {
                const t = s[ar]();
                for (const i of t.values()){
                    const t = e1.get(i[io]);
                    if (t) {
                        i[Kr](t);
                        break;
                    }
                }
            }
            const o = s[ur]();
            o.length > 0 && t.push([
                -1,
                o
            ]);
        }
        const i = [
            '<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'
        ];
        if (this.dataset) for (const e1 of this.dataset[ur]())"data" !== e1[Pr] && e1[eo](i);
        return this.data[eo](i), i.push("</xfa:datasets>"), i.join("");
    }
}
const Wo = ao.config.id;
class Acrobat extends XFAObject {
    constructor(e1){
        super(Wo, "acrobat", !0), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new XFAObjectArray;
    }
}
class Acrobat7 extends XFAObject {
    constructor(e1){
        super(Wo, "acrobat7", !0), this.dynamicRender = null;
    }
}
class ADBE_JSConsole extends OptionObject {
    constructor(e1){
        super(Wo, "ADBE_JSConsole", [
            "delegate",
            "Enable",
            "Disable"
        ]);
    }
}
class ADBE_JSDebugger extends OptionObject {
    constructor(e1){
        super(Wo, "ADBE_JSDebugger", [
            "delegate",
            "Enable",
            "Disable"
        ]);
    }
}
class AddSilentPrint extends Option01 {
    constructor(e1){
        super(Wo, "addSilentPrint");
    }
}
class AddViewerPreferences extends Option01 {
    constructor(e1){
        super(Wo, "addViewerPreferences");
    }
}
class AdjustData extends Option10 {
    constructor(e1){
        super(Wo, "adjustData");
    }
}
class AdobeExtensionLevel extends IntegerObject {
    constructor(e1){
        super(Wo, "adobeExtensionLevel", 0, (e1)=>e1 >= 1 && e1 <= 8);
    }
}
class Agent extends XFAObject {
    constructor(e1){
        super(Wo, "agent", !0), this.name = e1.name ? e1.name.trim() : "", this.common = new XFAObjectArray;
    }
}
class AlwaysEmbed extends ContentObject {
    constructor(e1){
        super(Wo, "alwaysEmbed");
    }
}
class Amd extends StringObject {
    constructor(e1){
        super(Wo, "amd");
    }
}
class config_Area extends XFAObject {
    constructor(e1){
        super(Wo, "area"), this.level = getInteger({
            data: e1.level,
            defaultValue: 0,
            validate: (e1)=>e1 >= 1 && e1 <= 3
        }), this.name = getStringOption(e1.name, [
            "",
            "barcode",
            "coreinit",
            "deviceDriver",
            "font",
            "general",
            "layout",
            "merge",
            "script",
            "signature",
            "sourceSet",
            "templateCache"
        ]);
    }
}
class Attributes extends OptionObject {
    constructor(e1){
        super(Wo, "attributes", [
            "preserve",
            "delegate",
            "ignore"
        ]);
    }
}
class AutoSave extends OptionObject {
    constructor(e1){
        super(Wo, "autoSave", [
            "disabled",
            "enabled"
        ]);
    }
}
class Base extends StringObject {
    constructor(e1){
        super(Wo, "base");
    }
}
class BatchOutput extends XFAObject {
    constructor(e1){
        super(Wo, "batchOutput"), this.format = getStringOption(e1.format, [
            "none",
            "concat",
            "zip",
            "zipCompress"
        ]);
    }
}
class BehaviorOverride extends ContentObject {
    constructor(e1){
        super(Wo, "behaviorOverride");
    }
    [tr]() {
        this[Js] = new Map(this[Js].trim().split(/\s+/).filter((e1)=>e1.includes(":")).map((e1)=>e1.split(":", 2)));
    }
}
class Cache extends XFAObject {
    constructor(e1){
        super(Wo, "cache", !0), this.templateCache = null;
    }
}
class Change extends Option01 {
    constructor(e1){
        super(Wo, "change");
    }
}
class Common extends XFAObject {
    constructor(e1){
        super(Wo, "common", !0), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new XFAObjectArray;
    }
}
class Compress extends XFAObject {
    constructor(e1){
        super(Wo, "compress"), this.scope = getStringOption(e1.scope, [
            "imageOnly",
            "document"
        ]);
    }
}
class CompressLogicalStructure extends Option01 {
    constructor(e1){
        super(Wo, "compressLogicalStructure");
    }
}
class CompressObjectStream extends Option10 {
    constructor(e1){
        super(Wo, "compressObjectStream");
    }
}
class Compression extends XFAObject {
    constructor(e1){
        super(Wo, "compression", !0), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
    }
}
class Config extends XFAObject {
    constructor(e1){
        super(Wo, "config", !0), this.acrobat = null, this.present = null, this.trace = null, this.agent = new XFAObjectArray;
    }
}
class Conformance extends OptionObject {
    constructor(e1){
        super(Wo, "conformance", [
            "A",
            "B"
        ]);
    }
}
class ContentCopy extends Option01 {
    constructor(e1){
        super(Wo, "contentCopy");
    }
}
class Copies extends IntegerObject {
    constructor(e1){
        super(Wo, "copies", 1, (e1)=>e1 >= 1);
    }
}
class Creator extends StringObject {
    constructor(e1){
        super(Wo, "creator");
    }
}
class CurrentPage extends IntegerObject {
    constructor(e1){
        super(Wo, "currentPage", 0, (e1)=>e1 >= 0);
    }
}
class Data extends XFAObject {
    constructor(e1){
        super(Wo, "data", !0), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new XFAObjectArray, this.transform = new XFAObjectArray;
    }
}
class Debug extends XFAObject {
    constructor(e1){
        super(Wo, "debug", !0), this.uri = null;
    }
}
class DefaultTypeface extends ContentObject {
    constructor(e1){
        super(Wo, "defaultTypeface"), this.writingScript = getStringOption(e1.writingScript, [
            "*",
            "Arabic",
            "Cyrillic",
            "EastEuropeanRoman",
            "Greek",
            "Hebrew",
            "Japanese",
            "Korean",
            "Roman",
            "SimplifiedChinese",
            "Thai",
            "TraditionalChinese",
            "Vietnamese"
        ]);
    }
}
class Destination extends OptionObject {
    constructor(e1){
        super(Wo, "destination", [
            "pdf",
            "pcl",
            "ps",
            "webClient",
            "zpl"
        ]);
    }
}
class DocumentAssembly extends Option01 {
    constructor(e1){
        super(Wo, "documentAssembly");
    }
}
class Driver extends XFAObject {
    constructor(e1){
        super(Wo, "driver", !0), this.name = e1.name ? e1.name.trim() : "", this.fontInfo = null, this.xdc = null;
    }
}
class DuplexOption extends OptionObject {
    constructor(e1){
        super(Wo, "duplexOption", [
            "simplex",
            "duplexFlipLongEdge",
            "duplexFlipShortEdge"
        ]);
    }
}
class DynamicRender extends OptionObject {
    constructor(e1){
        super(Wo, "dynamicRender", [
            "forbidden",
            "required"
        ]);
    }
}
class Embed extends Option01 {
    constructor(e1){
        super(Wo, "embed");
    }
}
class config_Encrypt extends Option01 {
    constructor(e1){
        super(Wo, "encrypt");
    }
}
class config_Encryption extends XFAObject {
    constructor(e1){
        super(Wo, "encryption", !0), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
    }
}
class EncryptionLevel extends OptionObject {
    constructor(e1){
        super(Wo, "encryptionLevel", [
            "40bit",
            "128bit"
        ]);
    }
}
class Enforce extends StringObject {
    constructor(e1){
        super(Wo, "enforce");
    }
}
class Equate extends XFAObject {
    constructor(e1){
        super(Wo, "equate"), this.force = getInteger({
            data: e1.force,
            defaultValue: 1,
            validate: (e1)=>0 === e1
        }), this.from = e1.from || "", this.to = e1.to || "";
    }
}
class EquateRange extends XFAObject {
    constructor(e1){
        super(Wo, "equateRange"), this.from = e1.from || "", this.to = e1.to || "", this._unicodeRange = e1.unicodeRange || "";
    }
    get unicodeRange() {
        const e1 = [], t = /U\+([0-9a-fA-F]+)/, i = this._unicodeRange;
        for (let n of i.split(",").map((e1)=>e1.trim()).filter((e1)=>!!e1))n = n.split("-", 2).map((e1)=>{
            const i = e1.match(t);
            return i ? parseInt(i[1], 16) : 0;
        }), 1 === n.length && n.push(n[0]), e1.push(n);
        return shadow$1(this, "unicodeRange", e1);
    }
}
class Exclude extends ContentObject {
    constructor(e1){
        super(Wo, "exclude");
    }
    [tr]() {
        this[Js] = this[Js].trim().split(/\s+/).filter((e1)=>e1 && [
                "calculate",
                "close",
                "enter",
                "exit",
                "initialize",
                "ready",
                "validate"
            ].includes(e1));
    }
}
class ExcludeNS extends StringObject {
    constructor(e1){
        super(Wo, "excludeNS");
    }
}
class FlipLabel extends OptionObject {
    constructor(e1){
        super(Wo, "flipLabel", [
            "usePrinterSetting",
            "on",
            "off"
        ]);
    }
}
class config_FontInfo extends XFAObject {
    constructor(e1){
        super(Wo, "fontInfo", !0), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new XFAObjectArray, this.defaultTypeface = new XFAObjectArray, this.neverEmbed = new XFAObjectArray;
    }
}
class FormFieldFilling extends Option01 {
    constructor(e1){
        super(Wo, "formFieldFilling");
    }
}
class GroupParent extends StringObject {
    constructor(e1){
        super(Wo, "groupParent");
    }
}
class IfEmpty extends OptionObject {
    constructor(e1){
        super(Wo, "ifEmpty", [
            "dataValue",
            "dataGroup",
            "ignore",
            "remove"
        ]);
    }
}
class IncludeXDPContent extends StringObject {
    constructor(e1){
        super(Wo, "includeXDPContent");
    }
}
class IncrementalLoad extends OptionObject {
    constructor(e1){
        super(Wo, "incrementalLoad", [
            "none",
            "forwardOnly"
        ]);
    }
}
class IncrementalMerge extends Option01 {
    constructor(e1){
        super(Wo, "incrementalMerge");
    }
}
class Interactive extends Option01 {
    constructor(e1){
        super(Wo, "interactive");
    }
}
class Jog extends OptionObject {
    constructor(e1){
        super(Wo, "jog", [
            "usePrinterSetting",
            "none",
            "pageSet"
        ]);
    }
}
class LabelPrinter extends XFAObject {
    constructor(e1){
        super(Wo, "labelPrinter", !0), this.name = getStringOption(e1.name, [
            "zpl",
            "dpl",
            "ipl",
            "tcpl"
        ]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
    }
}
class Layout extends OptionObject {
    constructor(e1){
        super(Wo, "layout", [
            "paginate",
            "panel"
        ]);
    }
}
class Level extends IntegerObject {
    constructor(e1){
        super(Wo, "level", 0, (e1)=>e1 > 0);
    }
}
class Linearized extends Option01 {
    constructor(e1){
        super(Wo, "linearized");
    }
}
class Locale extends StringObject {
    constructor(e1){
        super(Wo, "locale");
    }
}
class LocaleSet extends StringObject {
    constructor(e1){
        super(Wo, "localeSet");
    }
}
class Log extends XFAObject {
    constructor(e1){
        super(Wo, "log", !0), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
    }
}
class MapElement extends XFAObject {
    constructor(e1){
        super(Wo, "map", !0), this.equate = new XFAObjectArray, this.equateRange = new XFAObjectArray;
    }
}
class MediumInfo extends XFAObject {
    constructor(e1){
        super(Wo, "mediumInfo", !0), this.map = null;
    }
}
class config_Message extends XFAObject {
    constructor(e1){
        super(Wo, "message", !0), this.msgId = null, this.severity = null;
    }
}
class Messaging extends XFAObject {
    constructor(e1){
        super(Wo, "messaging", !0), this.message = new XFAObjectArray;
    }
}
class Mode extends OptionObject {
    constructor(e1){
        super(Wo, "mode", [
            "append",
            "overwrite"
        ]);
    }
}
class ModifyAnnots extends Option01 {
    constructor(e1){
        super(Wo, "modifyAnnots");
    }
}
class MsgId extends IntegerObject {
    constructor(e1){
        super(Wo, "msgId", 1, (e1)=>e1 >= 1);
    }
}
class NameAttr extends StringObject {
    constructor(e1){
        super(Wo, "nameAttr");
    }
}
class NeverEmbed extends ContentObject {
    constructor(e1){
        super(Wo, "neverEmbed");
    }
}
class NumberOfCopies extends IntegerObject {
    constructor(e1){
        super(Wo, "numberOfCopies", null, (e1)=>e1 >= 2 && e1 <= 5);
    }
}
class OpenAction extends XFAObject {
    constructor(e1){
        super(Wo, "openAction", !0), this.destination = null;
    }
}
class Output extends XFAObject {
    constructor(e1){
        super(Wo, "output", !0), this.to = null, this.type = null, this.uri = null;
    }
}
class OutputBin extends StringObject {
    constructor(e1){
        super(Wo, "outputBin");
    }
}
class OutputXSL extends XFAObject {
    constructor(e1){
        super(Wo, "outputXSL", !0), this.uri = null;
    }
}
class Overprint extends OptionObject {
    constructor(e1){
        super(Wo, "overprint", [
            "none",
            "both",
            "draw",
            "field"
        ]);
    }
}
class Packets extends StringObject {
    constructor(e1){
        super(Wo, "packets");
    }
    [tr]() {
        "*" !== this[Js] && (this[Js] = this[Js].trim().split(/\s+/).filter((e1)=>[
                "config",
                "datasets",
                "template",
                "xfdf",
                "xslt"
            ].includes(e1)));
    }
}
class PageOffset extends XFAObject {
    constructor(e1){
        super(Wo, "pageOffset"), this.x = getInteger({
            data: e1.x,
            defaultValue: "useXDCSetting",
            validate: (e1)=>!0
        }), this.y = getInteger({
            data: e1.y,
            defaultValue: "useXDCSetting",
            validate: (e1)=>!0
        });
    }
}
class PageRange extends StringObject {
    constructor(e1){
        super(Wo, "pageRange");
    }
    [tr]() {
        const e1 = this[Js].trim().split(/\s+/).map((e1)=>parseInt(e1, 10)), t = [];
        for(let i = 0, n = e1.length; i < n; i += 2)t.push(e1.slice(i, i + 2));
        this[Js] = t;
    }
}
class Pagination extends OptionObject {
    constructor(e1){
        super(Wo, "pagination", [
            "simplex",
            "duplexShortEdge",
            "duplexLongEdge"
        ]);
    }
}
class PaginationOverride extends OptionObject {
    constructor(e1){
        super(Wo, "paginationOverride", [
            "none",
            "forceDuplex",
            "forceDuplexLongEdge",
            "forceDuplexShortEdge",
            "forceSimplex"
        ]);
    }
}
class Part extends IntegerObject {
    constructor(e1){
        super(Wo, "part", 1, (e1)=>!1);
    }
}
class Pcl extends XFAObject {
    constructor(e1){
        super(Wo, "pcl", !0), this.name = e1.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
    }
}
class Pdf extends XFAObject {
    constructor(e1){
        super(Wo, "pdf", !0), this.name = e1.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
    }
}
class Pdfa extends XFAObject {
    constructor(e1){
        super(Wo, "pdfa", !0), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
    }
}
class Permissions extends XFAObject {
    constructor(e1){
        super(Wo, "permissions", !0), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
    }
}
class PickTrayByPDFSize extends Option01 {
    constructor(e1){
        super(Wo, "pickTrayByPDFSize");
    }
}
class config_Picture extends StringObject {
    constructor(e1){
        super(Wo, "picture");
    }
}
class PlaintextMetadata extends Option01 {
    constructor(e1){
        super(Wo, "plaintextMetadata");
    }
}
class Presence extends OptionObject {
    constructor(e1){
        super(Wo, "presence", [
            "preserve",
            "dissolve",
            "dissolveStructure",
            "ignore",
            "remove"
        ]);
    }
}
class Present extends XFAObject {
    constructor(e1){
        super(Wo, "present", !0), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new XFAObjectArray, this.labelPrinter = new XFAObjectArray, this.pcl = new XFAObjectArray, this.pdf = new XFAObjectArray, this.ps = new XFAObjectArray, this.submitUrl = new XFAObjectArray, this.webClient = new XFAObjectArray, this.zpl = new XFAObjectArray;
    }
}
class Print extends Option01 {
    constructor(e1){
        super(Wo, "print");
    }
}
class PrintHighQuality extends Option01 {
    constructor(e1){
        super(Wo, "printHighQuality");
    }
}
class PrintScaling extends OptionObject {
    constructor(e1){
        super(Wo, "printScaling", [
            "appdefault",
            "noScaling"
        ]);
    }
}
class PrinterName extends StringObject {
    constructor(e1){
        super(Wo, "printerName");
    }
}
class Producer extends StringObject {
    constructor(e1){
        super(Wo, "producer");
    }
}
class Ps extends XFAObject {
    constructor(e1){
        super(Wo, "ps", !0), this.name = e1.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
    }
}
let Go = class extends ContentObject {
    constructor(e1){
        super(Wo, "range");
    }
    [tr]() {
        this[Js] = this[Js].split(",", 2).map((e1)=>e1.split("-").map((e1)=>parseInt(e1.trim(), 10))).filter((e1)=>e1.every((e1)=>!isNaN(e1))).map((e1)=>(1 === e1.length && e1.push(e1[0]), e1));
    }
};
class Record extends ContentObject {
    constructor(e1){
        super(Wo, "record");
    }
    [tr]() {
        this[Js] = this[Js].trim();
        const e1 = parseInt(this[Js], 10);
        !isNaN(e1) && e1 >= 0 && (this[Js] = e1);
    }
}
class Relevant extends ContentObject {
    constructor(e1){
        super(Wo, "relevant");
    }
    [tr]() {
        this[Js] = this[Js].trim().split(/\s+/);
    }
}
class Rename extends ContentObject {
    constructor(e1){
        super(Wo, "rename");
    }
    [tr]() {
        this[Js] = this[Js].trim(), (this[Js].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[Js])) && warn$1("XFA - Rename: invalid XFA name");
    }
}
class RenderPolicy extends OptionObject {
    constructor(e1){
        super(Wo, "renderPolicy", [
            "server",
            "client"
        ]);
    }
}
class RunScripts extends OptionObject {
    constructor(e1){
        super(Wo, "runScripts", [
            "both",
            "client",
            "none",
            "server"
        ]);
    }
}
class config_Script extends XFAObject {
    constructor(e1){
        super(Wo, "script", !0), this.currentPage = null, this.exclude = null, this.runScripts = null;
    }
}
class ScriptModel extends OptionObject {
    constructor(e1){
        super(Wo, "scriptModel", [
            "XFA",
            "none"
        ]);
    }
}
class Severity extends OptionObject {
    constructor(e1){
        super(Wo, "severity", [
            "ignore",
            "error",
            "information",
            "trace",
            "warning"
        ]);
    }
}
class SilentPrint extends XFAObject {
    constructor(e1){
        super(Wo, "silentPrint", !0), this.addSilentPrint = null, this.printerName = null;
    }
}
class Staple extends XFAObject {
    constructor(e1){
        super(Wo, "staple"), this.mode = getStringOption(e1.mode, [
            "usePrinterSetting",
            "on",
            "off"
        ]);
    }
}
class StartNode extends StringObject {
    constructor(e1){
        super(Wo, "startNode");
    }
}
class StartPage extends IntegerObject {
    constructor(e1){
        super(Wo, "startPage", 0, (e1)=>!0);
    }
}
class SubmitFormat extends OptionObject {
    constructor(e1){
        super(Wo, "submitFormat", [
            "html",
            "delegate",
            "fdf",
            "xml",
            "pdf"
        ]);
    }
}
class SubmitUrl extends StringObject {
    constructor(e1){
        super(Wo, "submitUrl");
    }
}
class SubsetBelow extends IntegerObject {
    constructor(e1){
        super(Wo, "subsetBelow", 100, (e1)=>e1 >= 0 && e1 <= 100);
    }
}
class SuppressBanner extends Option01 {
    constructor(e1){
        super(Wo, "suppressBanner");
    }
}
class Tagged extends Option01 {
    constructor(e1){
        super(Wo, "tagged");
    }
}
class config_Template extends XFAObject {
    constructor(e1){
        super(Wo, "template", !0), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
    }
}
class Threshold extends OptionObject {
    constructor(e1){
        super(Wo, "threshold", [
            "trace",
            "error",
            "information",
            "warning"
        ]);
    }
}
class To extends OptionObject {
    constructor(e1){
        super(Wo, "to", [
            "null",
            "memory",
            "stderr",
            "stdout",
            "system",
            "uri"
        ]);
    }
}
class TemplateCache extends XFAObject {
    constructor(e1){
        super(Wo, "templateCache"), this.maxEntries = getInteger({
            data: e1.maxEntries,
            defaultValue: 5,
            validate: (e1)=>e1 >= 0
        });
    }
}
class Trace extends XFAObject {
    constructor(e1){
        super(Wo, "trace", !0), this.area = new XFAObjectArray;
    }
}
class Transform extends XFAObject {
    constructor(e1){
        super(Wo, "transform", !0), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
    }
}
class Type extends OptionObject {
    constructor(e1){
        super(Wo, "type", [
            "none",
            "ascii85",
            "asciiHex",
            "ccittfax",
            "flate",
            "lzw",
            "runLength",
            "native",
            "xdp",
            "mergedXDP"
        ]);
    }
}
class Uri extends StringObject {
    constructor(e1){
        super(Wo, "uri");
    }
}
class config_Validate extends OptionObject {
    constructor(e1){
        super(Wo, "validate", [
            "preSubmit",
            "prePrint",
            "preExecute",
            "preSave"
        ]);
    }
}
class ValidateApprovalSignatures extends ContentObject {
    constructor(e1){
        super(Wo, "validateApprovalSignatures");
    }
    [tr]() {
        this[Js] = this[Js].trim().split(/\s+/).filter((e1)=>[
                "docReady",
                "postSign"
            ].includes(e1));
    }
}
class ValidationMessaging extends OptionObject {
    constructor(e1){
        super(Wo, "validationMessaging", [
            "allMessagesIndividually",
            "allMessagesTogether",
            "firstMessageOnly",
            "noMessages"
        ]);
    }
}
class Version extends OptionObject {
    constructor(e1){
        super(Wo, "version", [
            "1.7",
            "1.6",
            "1.5",
            "1.4",
            "1.3",
            "1.2"
        ]);
    }
}
class VersionControl extends XFAObject {
    constructor(e1){
        super(Wo, "VersionControl"), this.outputBelow = getStringOption(e1.outputBelow, [
            "warn",
            "error",
            "update"
        ]), this.sourceAbove = getStringOption(e1.sourceAbove, [
            "warn",
            "error"
        ]), this.sourceBelow = getStringOption(e1.sourceBelow, [
            "update",
            "maintain"
        ]);
    }
}
class ViewerPreferences extends XFAObject {
    constructor(e1){
        super(Wo, "viewerPreferences", !0), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
    }
}
class WebClient extends XFAObject {
    constructor(e1){
        super(Wo, "webClient", !0), this.name = e1.name ? e1.name.trim() : "", this.fontInfo = null, this.xdc = null;
    }
}
class Whitespace extends OptionObject {
    constructor(e1){
        super(Wo, "whitespace", [
            "preserve",
            "ltrim",
            "normalize",
            "rtrim",
            "trim"
        ]);
    }
}
class Window extends ContentObject {
    constructor(e1){
        super(Wo, "window");
    }
    [tr]() {
        const e1 = this[Js].split(",", 2).map((e1)=>parseInt(e1.trim(), 10));
        e1.some((e1)=>isNaN(e1)) ? this[Js] = [
            0,
            0
        ] : (1 === e1.length && e1.push(e1[0]), this[Js] = e1);
    }
}
class Xdc extends XFAObject {
    constructor(e1){
        super(Wo, "xdc", !0), this.uri = new XFAObjectArray, this.xsl = new XFAObjectArray;
    }
}
class Xdp extends XFAObject {
    constructor(e1){
        super(Wo, "xdp", !0), this.packets = null;
    }
}
class Xsl extends XFAObject {
    constructor(e1){
        super(Wo, "xsl", !0), this.debug = null, this.uri = null;
    }
}
class Zpl extends XFAObject {
    constructor(e1){
        super(Wo, "zpl", !0), this.name = e1.name ? e1.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
    }
}
class ConfigNamespace {
    static [no](e1, t) {
        if (ConfigNamespace.hasOwnProperty(e1)) return ConfigNamespace[e1](t);
    }
    static acrobat(e1) {
        return new Acrobat(e1);
    }
    static acrobat7(e1) {
        return new Acrobat7(e1);
    }
    static ADBE_JSConsole(e1) {
        return new ADBE_JSConsole(e1);
    }
    static ADBE_JSDebugger(e1) {
        return new ADBE_JSDebugger(e1);
    }
    static addSilentPrint(e1) {
        return new AddSilentPrint(e1);
    }
    static addViewerPreferences(e1) {
        return new AddViewerPreferences(e1);
    }
    static adjustData(e1) {
        return new AdjustData(e1);
    }
    static adobeExtensionLevel(e1) {
        return new AdobeExtensionLevel(e1);
    }
    static agent(e1) {
        return new Agent(e1);
    }
    static alwaysEmbed(e1) {
        return new AlwaysEmbed(e1);
    }
    static amd(e1) {
        return new Amd(e1);
    }
    static area(e1) {
        return new config_Area(e1);
    }
    static attributes(e1) {
        return new Attributes(e1);
    }
    static autoSave(e1) {
        return new AutoSave(e1);
    }
    static base(e1) {
        return new Base(e1);
    }
    static batchOutput(e1) {
        return new BatchOutput(e1);
    }
    static behaviorOverride(e1) {
        return new BehaviorOverride(e1);
    }
    static cache(e1) {
        return new Cache(e1);
    }
    static change(e1) {
        return new Change(e1);
    }
    static common(e1) {
        return new Common(e1);
    }
    static compress(e1) {
        return new Compress(e1);
    }
    static compressLogicalStructure(e1) {
        return new CompressLogicalStructure(e1);
    }
    static compressObjectStream(e1) {
        return new CompressObjectStream(e1);
    }
    static compression(e1) {
        return new Compression(e1);
    }
    static config(e1) {
        return new Config(e1);
    }
    static conformance(e1) {
        return new Conformance(e1);
    }
    static contentCopy(e1) {
        return new ContentCopy(e1);
    }
    static copies(e1) {
        return new Copies(e1);
    }
    static creator(e1) {
        return new Creator(e1);
    }
    static currentPage(e1) {
        return new CurrentPage(e1);
    }
    static data(e1) {
        return new Data(e1);
    }
    static debug(e1) {
        return new Debug(e1);
    }
    static defaultTypeface(e1) {
        return new DefaultTypeface(e1);
    }
    static destination(e1) {
        return new Destination(e1);
    }
    static documentAssembly(e1) {
        return new DocumentAssembly(e1);
    }
    static driver(e1) {
        return new Driver(e1);
    }
    static duplexOption(e1) {
        return new DuplexOption(e1);
    }
    static dynamicRender(e1) {
        return new DynamicRender(e1);
    }
    static embed(e1) {
        return new Embed(e1);
    }
    static encrypt(e1) {
        return new config_Encrypt(e1);
    }
    static encryption(e1) {
        return new config_Encryption(e1);
    }
    static encryptionLevel(e1) {
        return new EncryptionLevel(e1);
    }
    static enforce(e1) {
        return new Enforce(e1);
    }
    static equate(e1) {
        return new Equate(e1);
    }
    static equateRange(e1) {
        return new EquateRange(e1);
    }
    static exclude(e1) {
        return new Exclude(e1);
    }
    static excludeNS(e1) {
        return new ExcludeNS(e1);
    }
    static flipLabel(e1) {
        return new FlipLabel(e1);
    }
    static fontInfo(e1) {
        return new config_FontInfo(e1);
    }
    static formFieldFilling(e1) {
        return new FormFieldFilling(e1);
    }
    static groupParent(e1) {
        return new GroupParent(e1);
    }
    static ifEmpty(e1) {
        return new IfEmpty(e1);
    }
    static includeXDPContent(e1) {
        return new IncludeXDPContent(e1);
    }
    static incrementalLoad(e1) {
        return new IncrementalLoad(e1);
    }
    static incrementalMerge(e1) {
        return new IncrementalMerge(e1);
    }
    static interactive(e1) {
        return new Interactive(e1);
    }
    static jog(e1) {
        return new Jog(e1);
    }
    static labelPrinter(e1) {
        return new LabelPrinter(e1);
    }
    static layout(e1) {
        return new Layout(e1);
    }
    static level(e1) {
        return new Level(e1);
    }
    static linearized(e1) {
        return new Linearized(e1);
    }
    static locale(e1) {
        return new Locale(e1);
    }
    static localeSet(e1) {
        return new LocaleSet(e1);
    }
    static log(e1) {
        return new Log(e1);
    }
    static map(e1) {
        return new MapElement(e1);
    }
    static mediumInfo(e1) {
        return new MediumInfo(e1);
    }
    static message(e1) {
        return new config_Message(e1);
    }
    static messaging(e1) {
        return new Messaging(e1);
    }
    static mode(e1) {
        return new Mode(e1);
    }
    static modifyAnnots(e1) {
        return new ModifyAnnots(e1);
    }
    static msgId(e1) {
        return new MsgId(e1);
    }
    static nameAttr(e1) {
        return new NameAttr(e1);
    }
    static neverEmbed(e1) {
        return new NeverEmbed(e1);
    }
    static numberOfCopies(e1) {
        return new NumberOfCopies(e1);
    }
    static openAction(e1) {
        return new OpenAction(e1);
    }
    static output(e1) {
        return new Output(e1);
    }
    static outputBin(e1) {
        return new OutputBin(e1);
    }
    static outputXSL(e1) {
        return new OutputXSL(e1);
    }
    static overprint(e1) {
        return new Overprint(e1);
    }
    static packets(e1) {
        return new Packets(e1);
    }
    static pageOffset(e1) {
        return new PageOffset(e1);
    }
    static pageRange(e1) {
        return new PageRange(e1);
    }
    static pagination(e1) {
        return new Pagination(e1);
    }
    static paginationOverride(e1) {
        return new PaginationOverride(e1);
    }
    static part(e1) {
        return new Part(e1);
    }
    static pcl(e1) {
        return new Pcl(e1);
    }
    static pdf(e1) {
        return new Pdf(e1);
    }
    static pdfa(e1) {
        return new Pdfa(e1);
    }
    static permissions(e1) {
        return new Permissions(e1);
    }
    static pickTrayByPDFSize(e1) {
        return new PickTrayByPDFSize(e1);
    }
    static picture(e1) {
        return new config_Picture(e1);
    }
    static plaintextMetadata(e1) {
        return new PlaintextMetadata(e1);
    }
    static presence(e1) {
        return new Presence(e1);
    }
    static present(e1) {
        return new Present(e1);
    }
    static print(e1) {
        return new Print(e1);
    }
    static printHighQuality(e1) {
        return new PrintHighQuality(e1);
    }
    static printScaling(e1) {
        return new PrintScaling(e1);
    }
    static printerName(e1) {
        return new PrinterName(e1);
    }
    static producer(e1) {
        return new Producer(e1);
    }
    static ps(e1) {
        return new Ps(e1);
    }
    static range(e1) {
        return new Go(e1);
    }
    static record(e1) {
        return new Record(e1);
    }
    static relevant(e1) {
        return new Relevant(e1);
    }
    static rename(e1) {
        return new Rename(e1);
    }
    static renderPolicy(e1) {
        return new RenderPolicy(e1);
    }
    static runScripts(e1) {
        return new RunScripts(e1);
    }
    static script(e1) {
        return new config_Script(e1);
    }
    static scriptModel(e1) {
        return new ScriptModel(e1);
    }
    static severity(e1) {
        return new Severity(e1);
    }
    static silentPrint(e1) {
        return new SilentPrint(e1);
    }
    static staple(e1) {
        return new Staple(e1);
    }
    static startNode(e1) {
        return new StartNode(e1);
    }
    static startPage(e1) {
        return new StartPage(e1);
    }
    static submitFormat(e1) {
        return new SubmitFormat(e1);
    }
    static submitUrl(e1) {
        return new SubmitUrl(e1);
    }
    static subsetBelow(e1) {
        return new SubsetBelow(e1);
    }
    static suppressBanner(e1) {
        return new SuppressBanner(e1);
    }
    static tagged(e1) {
        return new Tagged(e1);
    }
    static template(e1) {
        return new config_Template(e1);
    }
    static templateCache(e1) {
        return new TemplateCache(e1);
    }
    static threshold(e1) {
        return new Threshold(e1);
    }
    static to(e1) {
        return new To(e1);
    }
    static trace(e1) {
        return new Trace(e1);
    }
    static transform(e1) {
        return new Transform(e1);
    }
    static type(e1) {
        return new Type(e1);
    }
    static uri(e1) {
        return new Uri(e1);
    }
    static validate(e1) {
        return new config_Validate(e1);
    }
    static validateApprovalSignatures(e1) {
        return new ValidateApprovalSignatures(e1);
    }
    static validationMessaging(e1) {
        return new ValidationMessaging(e1);
    }
    static version(e1) {
        return new Version(e1);
    }
    static versionControl(e1) {
        return new VersionControl(e1);
    }
    static viewerPreferences(e1) {
        return new ViewerPreferences(e1);
    }
    static webClient(e1) {
        return new WebClient(e1);
    }
    static whitespace(e1) {
        return new Whitespace(e1);
    }
    static window(e1) {
        return new Window(e1);
    }
    static xdc(e1) {
        return new Xdc(e1);
    }
    static xdp(e1) {
        return new Xdp(e1);
    }
    static xsl(e1) {
        return new Xsl(e1);
    }
    static zpl(e1) {
        return new Zpl(e1);
    }
}
const Vo = ao.connectionSet.id;
class ConnectionSet extends XFAObject {
    constructor(e1){
        super(Vo, "connectionSet", !0), this.wsdlConnection = new XFAObjectArray, this.xmlConnection = new XFAObjectArray, this.xsdConnection = new XFAObjectArray;
    }
}
class EffectiveInputPolicy extends XFAObject {
    constructor(e1){
        super(Vo, "effectiveInputPolicy"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class EffectiveOutputPolicy extends XFAObject {
    constructor(e1){
        super(Vo, "effectiveOutputPolicy"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class Operation extends StringObject {
    constructor(e1){
        super(Vo, "operation"), this.id = e1.id || "", this.input = e1.input || "", this.name = e1.name || "", this.output = e1.output || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class RootElement extends StringObject {
    constructor(e1){
        super(Vo, "rootElement"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class SoapAction extends StringObject {
    constructor(e1){
        super(Vo, "soapAction"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class SoapAddress extends StringObject {
    constructor(e1){
        super(Vo, "soapAddress"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class connection_set_Uri extends StringObject {
    constructor(e1){
        super(Vo, "uri"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class WsdlAddress extends StringObject {
    constructor(e1){
        super(Vo, "wsdlAddress"), this.id = e1.id || "", this.name = e1.name || "", this.use = e1.use || "", this.usehref = e1.usehref || "";
    }
}
class WsdlConnection extends XFAObject {
    constructor(e1){
        super(Vo, "wsdlConnection", !0), this.dataDescription = e1.dataDescription || "", this.name = e1.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
    }
}
class XmlConnection extends XFAObject {
    constructor(e1){
        super(Vo, "xmlConnection", !0), this.dataDescription = e1.dataDescription || "", this.name = e1.name || "", this.uri = null;
    }
}
class XsdConnection extends XFAObject {
    constructor(e1){
        super(Vo, "xsdConnection", !0), this.dataDescription = e1.dataDescription || "", this.name = e1.name || "", this.rootElement = null, this.uri = null;
    }
}
class ConnectionSetNamespace {
    static [no](e1, t) {
        if (ConnectionSetNamespace.hasOwnProperty(e1)) return ConnectionSetNamespace[e1](t);
    }
    static connectionSet(e1) {
        return new ConnectionSet(e1);
    }
    static effectiveInputPolicy(e1) {
        return new EffectiveInputPolicy(e1);
    }
    static effectiveOutputPolicy(e1) {
        return new EffectiveOutputPolicy(e1);
    }
    static operation(e1) {
        return new Operation(e1);
    }
    static rootElement(e1) {
        return new RootElement(e1);
    }
    static soapAction(e1) {
        return new SoapAction(e1);
    }
    static soapAddress(e1) {
        return new SoapAddress(e1);
    }
    static uri(e1) {
        return new connection_set_Uri(e1);
    }
    static wsdlAddress(e1) {
        return new WsdlAddress(e1);
    }
    static wsdlConnection(e1) {
        return new WsdlConnection(e1);
    }
    static xmlConnection(e1) {
        return new XmlConnection(e1);
    }
    static xsdConnection(e1) {
        return new XsdConnection(e1);
    }
}
const Ko = ao.datasets.id;
class datasets_Data extends XmlObject {
    constructor(e1){
        super(Ko, "data", e1);
    }
    [Fr]() {
        return !0;
    }
}
class Datasets extends XFAObject {
    constructor(e1){
        super(Ko, "datasets", !0), this.data = null, this.Signature = null;
    }
    [Nr](e1) {
        const t = e1[Pr];
        ("data" === t && e1[_r] === Ko || "Signature" === t && e1[_r] === ao.signature.id) && (this[t] = e1), this[qs](e1);
    }
}
class DatasetsNamespace {
    static [no](e1, t) {
        if (DatasetsNamespace.hasOwnProperty(e1)) return DatasetsNamespace[e1](t);
    }
    static datasets(e1) {
        return new Datasets(e1);
    }
    static data(e1) {
        return new datasets_Data(e1);
    }
}
const Yo = ao.localeSet.id;
class CalendarSymbols extends XFAObject {
    constructor(e1){
        super(Yo, "calendarSymbols", !0), this.name = "gregorian", this.dayNames = new XFAObjectArray(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new XFAObjectArray(2);
    }
}
class CurrencySymbol extends StringObject {
    constructor(e1){
        super(Yo, "currencySymbol"), this.name = getStringOption(e1.name, [
            "symbol",
            "isoname",
            "decimal"
        ]);
    }
}
class CurrencySymbols extends XFAObject {
    constructor(e1){
        super(Yo, "currencySymbols", !0), this.currencySymbol = new XFAObjectArray(3);
    }
}
class DatePattern extends StringObject {
    constructor(e1){
        super(Yo, "datePattern"), this.name = getStringOption(e1.name, [
            "full",
            "long",
            "med",
            "short"
        ]);
    }
}
class DatePatterns extends XFAObject {
    constructor(e1){
        super(Yo, "datePatterns", !0), this.datePattern = new XFAObjectArray(4);
    }
}
class DateTimeSymbols extends ContentObject {
    constructor(e1){
        super(Yo, "dateTimeSymbols");
    }
}
class Day extends StringObject {
    constructor(e1){
        super(Yo, "day");
    }
}
class DayNames extends XFAObject {
    constructor(e1){
        super(Yo, "dayNames", !0), this.abbr = getInteger({
            data: e1.abbr,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.day = new XFAObjectArray(7);
    }
}
class Era extends StringObject {
    constructor(e1){
        super(Yo, "era");
    }
}
class EraNames extends XFAObject {
    constructor(e1){
        super(Yo, "eraNames", !0), this.era = new XFAObjectArray(2);
    }
}
class locale_set_Locale extends XFAObject {
    constructor(e1){
        super(Yo, "locale", !0), this.desc = e1.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
    }
}
class locale_set_LocaleSet extends XFAObject {
    constructor(e1){
        super(Yo, "localeSet", !0), this.locale = new XFAObjectArray;
    }
}
class Meridiem extends StringObject {
    constructor(e1){
        super(Yo, "meridiem");
    }
}
class MeridiemNames extends XFAObject {
    constructor(e1){
        super(Yo, "meridiemNames", !0), this.meridiem = new XFAObjectArray(2);
    }
}
class Month extends StringObject {
    constructor(e1){
        super(Yo, "month");
    }
}
class MonthNames extends XFAObject {
    constructor(e1){
        super(Yo, "monthNames", !0), this.abbr = getInteger({
            data: e1.abbr,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        }), this.month = new XFAObjectArray(12);
    }
}
class NumberPattern extends StringObject {
    constructor(e1){
        super(Yo, "numberPattern"), this.name = getStringOption(e1.name, [
            "full",
            "long",
            "med",
            "short"
        ]);
    }
}
class NumberPatterns extends XFAObject {
    constructor(e1){
        super(Yo, "numberPatterns", !0), this.numberPattern = new XFAObjectArray(4);
    }
}
class NumberSymbol extends StringObject {
    constructor(e1){
        super(Yo, "numberSymbol"), this.name = getStringOption(e1.name, [
            "decimal",
            "grouping",
            "percent",
            "minus",
            "zero"
        ]);
    }
}
class NumberSymbols extends XFAObject {
    constructor(e1){
        super(Yo, "numberSymbols", !0), this.numberSymbol = new XFAObjectArray(5);
    }
}
class TimePattern extends StringObject {
    constructor(e1){
        super(Yo, "timePattern"), this.name = getStringOption(e1.name, [
            "full",
            "long",
            "med",
            "short"
        ]);
    }
}
class TimePatterns extends XFAObject {
    constructor(e1){
        super(Yo, "timePatterns", !0), this.timePattern = new XFAObjectArray(4);
    }
}
class TypeFace extends XFAObject {
    constructor(e1){
        super(Yo, "typeFace", !0), this.name = "" | e1.name;
    }
}
class TypeFaces extends XFAObject {
    constructor(e1){
        super(Yo, "typeFaces", !0), this.typeFace = new XFAObjectArray;
    }
}
class LocaleSetNamespace {
    static [no](e1, t) {
        if (LocaleSetNamespace.hasOwnProperty(e1)) return LocaleSetNamespace[e1](t);
    }
    static calendarSymbols(e1) {
        return new CalendarSymbols(e1);
    }
    static currencySymbol(e1) {
        return new CurrencySymbol(e1);
    }
    static currencySymbols(e1) {
        return new CurrencySymbols(e1);
    }
    static datePattern(e1) {
        return new DatePattern(e1);
    }
    static datePatterns(e1) {
        return new DatePatterns(e1);
    }
    static dateTimeSymbols(e1) {
        return new DateTimeSymbols(e1);
    }
    static day(e1) {
        return new Day(e1);
    }
    static dayNames(e1) {
        return new DayNames(e1);
    }
    static era(e1) {
        return new Era(e1);
    }
    static eraNames(e1) {
        return new EraNames(e1);
    }
    static locale(e1) {
        return new locale_set_Locale(e1);
    }
    static localeSet(e1) {
        return new locale_set_LocaleSet(e1);
    }
    static meridiem(e1) {
        return new Meridiem(e1);
    }
    static meridiemNames(e1) {
        return new MeridiemNames(e1);
    }
    static month(e1) {
        return new Month(e1);
    }
    static monthNames(e1) {
        return new MonthNames(e1);
    }
    static numberPattern(e1) {
        return new NumberPattern(e1);
    }
    static numberPatterns(e1) {
        return new NumberPatterns(e1);
    }
    static numberSymbol(e1) {
        return new NumberSymbol(e1);
    }
    static numberSymbols(e1) {
        return new NumberSymbols(e1);
    }
    static timePattern(e1) {
        return new TimePattern(e1);
    }
    static timePatterns(e1) {
        return new TimePatterns(e1);
    }
    static typeFace(e1) {
        return new TypeFace(e1);
    }
    static typeFaces(e1) {
        return new TypeFaces(e1);
    }
}
const Jo = ao.signature.id;
class signature_Signature extends XFAObject {
    constructor(e1){
        super(Jo, "signature", !0);
    }
}
class SignatureNamespace {
    static [no](e1, t) {
        if (SignatureNamespace.hasOwnProperty(e1)) return SignatureNamespace[e1](t);
    }
    static signature(e1) {
        return new signature_Signature(e1);
    }
}
const Zo = ao.stylesheet.id;
class Stylesheet extends XFAObject {
    constructor(e1){
        super(Zo, "stylesheet", !0);
    }
}
class StylesheetNamespace {
    static [no](e1, t) {
        if (StylesheetNamespace.hasOwnProperty(e1)) return StylesheetNamespace[e1](t);
    }
    static stylesheet(e1) {
        return new Stylesheet(e1);
    }
}
const Qo = ao.xdp.id;
class xdp_Xdp extends XFAObject {
    constructor(e1){
        super(Qo, "xdp", !0), this.uuid = e1.uuid || "", this.timeStamp = e1.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new XFAObjectArray, this.template = null;
    }
    [Lr](e1) {
        const t = ao[e1[Pr]];
        return t && e1[_r] === t.id;
    }
}
class XdpNamespace {
    static [no](e1, t) {
        if (XdpNamespace.hasOwnProperty(e1)) return XdpNamespace[e1](t);
    }
    static xdp(e1) {
        return new xdp_Xdp(e1);
    }
}
const el = ao.xhtml.id, tl = Symbol(), il = new Set([
    "color",
    "font",
    "font-family",
    "font-size",
    "font-stretch",
    "font-style",
    "font-weight",
    "margin",
    "margin-bottom",
    "margin-left",
    "margin-right",
    "margin-top",
    "letter-spacing",
    "line-height",
    "orphans",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "tab-interval",
    "tab-stop",
    "text-align",
    "text-decoration",
    "text-indent",
    "vertical-align",
    "widows",
    "kerning-mode",
    "xfa-font-horizontal-scale",
    "xfa-font-vertical-scale",
    "xfa-spacerun",
    "xfa-tab-stops"
]), nl = new Map([
    [
        "page-break-after",
        "breakAfter"
    ],
    [
        "page-break-before",
        "breakBefore"
    ],
    [
        "page-break-inside",
        "breakInside"
    ],
    [
        "kerning-mode",
        (e1)=>"none" === e1 ? "none" : "normal"
    ],
    [
        "xfa-font-horizontal-scale",
        (e1)=>`scaleX(${Math.max(0, parseInt(e1) / 100).toFixed(2)})`
    ],
    [
        "xfa-font-vertical-scale",
        (e1)=>`scaleY(${Math.max(0, parseInt(e1) / 100).toFixed(2)})`
    ],
    [
        "xfa-spacerun",
        ""
    ],
    [
        "xfa-tab-stops",
        ""
    ],
    [
        "font-size",
        (e1, t)=>measureToString(.99 * (e1 = t.fontSize = Math.abs(getMeasurement(e1))))
    ],
    [
        "letter-spacing",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "line-height",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin-bottom",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin-left",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin-right",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin-top",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "text-indent",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "font-family",
        (e1)=>e1
    ],
    [
        "vertical-align",
        (e1)=>measureToString(getMeasurement(e1))
    ]
]), al = /\s+/g, sl = /[\r\n]+/g, rl = /\r\n?/g;
function mapStyle(e1, t, i) {
    const n = Object.create(null);
    if (!e1) return n;
    const a = Object.create(null);
    for (const [t, i] of e1.split(";").map((e1)=>e1.split(":", 2))){
        const e1 = nl.get(t);
        if ("" === e1) continue;
        let s = i;
        e1 && (s = "string" == typeof e1 ? e1 : e1(i, a)), t.endsWith("scale") ? n.transform = n.transform ? `${n[t]} ${s}` : s : n[t.replaceAll(/-([a-zA-Z])/g, (e1, t)=>t.toUpperCase())] = s;
    }
    if (n.fontFamily && setFontFamily({
        typeface: n.fontFamily,
        weight: n.fontWeight || "normal",
        posture: n.fontStyle || "normal",
        size: a.fontSize || 0
    }, t, t[yr].fontFinder, n), i && n.verticalAlign && "0px" !== n.verticalAlign && n.fontSize) {
        const e1 = .583, t = .333, i = getMeasurement(n.fontSize);
        n.fontSize = measureToString(i * e1), n.verticalAlign = measureToString(Math.sign(getMeasurement(n.verticalAlign)) * i * t);
    }
    return i && n.fontSize && (n.fontSize = `calc(${n.fontSize} * var(--total-scale-factor))`), fixTextIndent(n), n;
}
const ol = new Set([
    "body",
    "html"
]);
class XhtmlObject extends XmlObject {
    constructor(e1, t){
        super(el, t), this[tl] = !1, this.style = e1.style || "";
    }
    [Ws](e1) {
        var t;
        super[Ws](e1), this.style = (t = this).style ? t.style.split(";").filter((e1)=>!!e1.trim()).map((e1)=>e1.split(":", 2).map((e1)=>e1.trim())).filter(([e1, i])=>("font-family" === e1 && t[yr].usedTypefaces.add(i), il.has(e1))).map((e1)=>e1.join(":")).join(";") : "";
    }
    [Hs]() {
        return !ol.has(this[Pr]);
    }
    [Ur](e1, t = !1) {
        t ? this[tl] = !0 : (e1 = e1.replaceAll(sl, ""), this.style.includes("xfa-spacerun:yes") || (e1 = e1.replaceAll(al, " "))), e1 && (this[Js] += e1);
    }
    [jr](e1, t = !0) {
        const i = Object.create(null), n = {
            top: NaN,
            bottom: NaN,
            left: NaN,
            right: NaN
        };
        let a = null;
        for (const [e1, t] of this.style.split(";").map((e1)=>e1.split(":", 2)))switch(e1){
            case "font-family":
                i.typeface = stripQuotes(t);
                break;
            case "font-size":
                i.size = getMeasurement(t);
                break;
            case "font-weight":
                i.weight = t;
                break;
            case "font-style":
                i.posture = t;
                break;
            case "letter-spacing":
                i.letterSpacing = getMeasurement(t);
                break;
            case "margin":
                const e2 = t.split(/ \t/).map((e1)=>getMeasurement(e1));
                switch(e2.length){
                    case 1:
                        n.top = n.bottom = n.left = n.right = e2[0];
                        break;
                    case 2:
                        n.top = n.bottom = e2[0], n.left = n.right = e2[1];
                        break;
                    case 3:
                        n.top = e2[0], n.bottom = e2[2], n.left = n.right = e2[1];
                        break;
                    case 4:
                        n.top = e2[0], n.left = e2[1], n.bottom = e2[2], n.right = e2[3];
                }
                break;
            case "margin-top":
                n.top = getMeasurement(t);
                break;
            case "margin-bottom":
                n.bottom = getMeasurement(t);
                break;
            case "margin-left":
                n.left = getMeasurement(t);
                break;
            case "margin-right":
                n.right = getMeasurement(t);
                break;
            case "line-height":
                a = getMeasurement(t);
        }
        if (e1.pushData(i, n, a), this[Js]) e1.addString(this[Js]);
        else for (const t of this[ur]())"#text" !== t[Pr] ? t[jr](e1) : e1.addString(t[Js]);
        t && e1.popFont();
    }
    [Qr](e1) {
        const t = [];
        if (this[er] = {
            children: t
        }, this[zs]({}), 0 === t.length && !this[Js]) return HTMLResult.EMPTY;
        let i;
        return i = this[tl] ? this[Js] ? this[Js].replaceAll(rl, "\n") : void 0 : this[Js] || void 0, HTMLResult.success({
            name: this[Pr],
            attributes: {
                href: this.href,
                style: mapStyle(this.style, this, this[tl])
            },
            children: t,
            value: i
        });
    }
}
class A extends XhtmlObject {
    constructor(e1){
        super(e1, "a"), this.href = fixURL(e1.href) || "";
    }
}
class B extends XhtmlObject {
    constructor(e1){
        super(e1, "b");
    }
    [jr](e1) {
        e1.pushFont({
            weight: "bold"
        }), super[jr](e1), e1.popFont();
    }
}
class Body extends XhtmlObject {
    constructor(e1){
        super(e1, "body");
    }
    [Qr](e1) {
        const t = super[Qr](e1), { html: i } = t;
        return i ? (i.name = "div", i.attributes.class = [
            "xfaRich"
        ], t) : HTMLResult.EMPTY;
    }
}
class Br extends XhtmlObject {
    constructor(e1){
        super(e1, "br");
    }
    [Jr]() {
        return "\n";
    }
    [jr](e1) {
        e1.addString("\n");
    }
    [Qr](e1) {
        return HTMLResult.success({
            name: "br"
        });
    }
}
class Html extends XhtmlObject {
    constructor(e1){
        super(e1, "html");
    }
    [Qr](e1) {
        const t = [];
        if (this[er] = {
            children: t
        }, this[zs]({}), 0 === t.length) return HTMLResult.success({
            name: "div",
            attributes: {
                class: [
                    "xfaRich"
                ],
                style: {}
            },
            value: this[Js] || ""
        });
        if (1 === t.length) {
            const e1 = t[0];
            if (e1.attributes?.class.includes("xfaRich")) return HTMLResult.success(e1);
        }
        return HTMLResult.success({
            name: "div",
            attributes: {
                class: [
                    "xfaRich"
                ],
                style: {}
            },
            children: t
        });
    }
}
class I extends XhtmlObject {
    constructor(e1){
        super(e1, "i");
    }
    [jr](e1) {
        e1.pushFont({
            posture: "italic"
        }), super[jr](e1), e1.popFont();
    }
}
class Li extends XhtmlObject {
    constructor(e1){
        super(e1, "li");
    }
}
class Ol extends XhtmlObject {
    constructor(e1){
        super(e1, "ol");
    }
}
class P extends XhtmlObject {
    constructor(e1){
        super(e1, "p");
    }
    [jr](e1) {
        super[jr](e1, !1), e1.addString("\n"), e1.addPara(), e1.popFont();
    }
    [Jr]() {
        return this[mr]()[ur]().at(-1) === this ? super[Jr]() : super[Jr]() + "\n";
    }
}
class Span extends XhtmlObject {
    constructor(e1){
        super(e1, "span");
    }
}
class Sub extends XhtmlObject {
    constructor(e1){
        super(e1, "sub");
    }
}
class Sup extends XhtmlObject {
    constructor(e1){
        super(e1, "sup");
    }
}
class Ul extends XhtmlObject {
    constructor(e1){
        super(e1, "ul");
    }
}
class XhtmlNamespace {
    static [no](e1, t) {
        if (XhtmlNamespace.hasOwnProperty(e1)) return XhtmlNamespace[e1](t);
    }
    static a(e1) {
        return new A(e1);
    }
    static b(e1) {
        return new B(e1);
    }
    static body(e1) {
        return new Body(e1);
    }
    static br(e1) {
        return new Br(e1);
    }
    static html(e1) {
        return new Html(e1);
    }
    static i(e1) {
        return new I(e1);
    }
    static li(e1) {
        return new Li(e1);
    }
    static ol(e1) {
        return new Ol(e1);
    }
    static p(e1) {
        return new P(e1);
    }
    static span(e1) {
        return new Span(e1);
    }
    static sub(e1) {
        return new Sub(e1);
    }
    static sup(e1) {
        return new Sup(e1);
    }
    static ul(e1) {
        return new Ul(e1);
    }
}
const ll = {
    config: ConfigNamespace,
    connection: ConnectionSetNamespace,
    datasets: DatasetsNamespace,
    localeSet: LocaleSetNamespace,
    signature: SignatureNamespace,
    stylesheet: StylesheetNamespace,
    template: TemplateNamespace,
    xdp: XdpNamespace,
    xhtml: XhtmlNamespace
};
class UnknownNamespace {
    constructor(e1){
        this.namespaceId = e1;
    }
    [no](e1, t) {
        return new XmlObject(this.namespaceId, e1, t);
    }
}
class Root extends XFAObject {
    constructor(e1){
        super(-1, "root", Object.create(null)), this.element = null, this[Ar] = e1;
    }
    [Nr](e1) {
        return this.element = e1, !0;
    }
    [tr]() {
        super[tr](), this.element.template instanceof Template && (this[Ar].set(qr, this.element), this.element.template[zr](this[Ar]), this.element.template[Ar] = this[Ar]);
    }
}
class Empty extends XFAObject {
    constructor(){
        super(-1, "", Object.create(null));
    }
    [Nr](e1) {
        return !1;
    }
}
class Builder {
    constructor(e1 = null){
        this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = new Map, this._namespaces = new Map, this._nextNsId = Math.max(...Object.values(ao).map(({ id: e1 })=>e1)), this._currentNamespace = e1 || new UnknownNamespace(++this._nextNsId);
    }
    buildRoot(e1) {
        return new Root(e1);
    }
    build({ nsPrefix: e1, name: t, attributes: i, namespace: n, prefixes: a }) {
        const s = null !== n;
        if (s && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(n)), a && this._addNamespacePrefix(a), i.hasOwnProperty(Rr)) {
            const e1 = ll.datasets, t = i[Rr];
            let n = null;
            for (const [i, a] of Object.entries(t)){
                if (this._getNamespaceToUse(i) === e1) {
                    n = {
                        xfa: a
                    };
                    break;
                }
            }
            n ? i[Rr] = n : delete i[Rr];
        }
        const r = this._getNamespaceToUse(e1), o = r?.[no](t, i) || new Empty;
        return o[Fr]() && this._nsAgnosticLevel++, (s || a || o[Fr]()) && (o[Vs] = {
            hasNamespace: s,
            prefixes: a,
            nsAgnostic: o[Fr]()
        }), o;
    }
    isNsAgnostic() {
        return this._nsAgnosticLevel > 0;
    }
    _searchNamespace(e1) {
        let t = this._namespaces.get(e1);
        if (t) return t;
        for (const [i, { check: n }] of Object.entries(ao))if (n(e1)) {
            if (t = ll[i], t) return this._namespaces.set(e1, t), t;
            break;
        }
        return t = new UnknownNamespace(++this._nextNsId), this._namespaces.set(e1, t), t;
    }
    _addNamespacePrefix(e1) {
        for (const { prefix: t, value: i } of e1){
            const e1 = this._searchNamespace(i);
            let n = this._namespacePrefixes.get(t);
            n || (n = [], this._namespacePrefixes.set(t, n)), n.push(e1);
        }
    }
    _getNamespaceToUse(e1) {
        if (!e1) return this._currentNamespace;
        const t = this._namespacePrefixes.get(e1);
        return t?.length > 0 ? t.at(-1) : (warn$1(`Unknown namespace prefix: ${e1}.`), null);
    }
    clean(e1) {
        const { hasNamespace: t, prefixes: i, nsAgnostic: n } = e1;
        t && (this._currentNamespace = this._namespaceStack.pop()), i && i.forEach(({ prefix: e1 })=>{
            this._namespacePrefixes.get(e1).pop();
        }), n && this._nsAgnosticLevel--;
    }
}
class XFAParser extends XMLParserBase {
    constructor(e1 = null, t = !1){
        super(), this._builder = new Builder(e1), this._stack = [], this._globalData = {
            usedTypefaces: new Set
        }, this._ids = new Map, this._current = this._builder.buildRoot(this._ids), this._errorCode = Is, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = t;
    }
    parse(e1) {
        if (this.parseXml(e1), this._errorCode === Is) return this._current[tr](), this._current.element;
    }
    onText(e1) {
        e1 = e1.replace(this._nbsps, (e1)=>e1.slice(1) + " "), this._richText || this._current[Hs]() ? this._current[Ur](e1, this._richText) : this._whiteRegex.test(e1) || this._current[Ur](e1.trim());
    }
    onCdata(e1) {
        this._current[Ur](e1);
    }
    _mkAttributes(e1, t) {
        let i = null, n = null;
        const a = Object.create({});
        for (const { name: s, value: r } of e1)if ("xmlns" === s) i ? warn$1(`XFA - multiple namespace definition in <${t}>`) : i = r;
        else if (s.startsWith("xmlns:")) {
            const e1 = s.substring(6);
            n ??= [], n.push({
                prefix: e1,
                value: r
            });
        } else {
            const e1 = s.indexOf(":");
            if (-1 === e1) a[s] = r;
            else {
                const t = a[Rr] ??= Object.create(null), [i, n] = [
                    s.slice(0, e1),
                    s.slice(e1 + 1)
                ];
                (t[i] ||= Object.create(null))[n] = r;
            }
        }
        return [
            i,
            n,
            a
        ];
    }
    _getNameAndPrefix(e1, t) {
        const i = e1.indexOf(":");
        return -1 === i ? [
            e1,
            null
        ] : [
            e1.substring(i + 1),
            t ? "" : e1.substring(0, i)
        ];
    }
    onBeginElement(e1, t, i) {
        const [n, a, s] = this._mkAttributes(t, e1), [r, o] = this._getNameAndPrefix(e1, this._builder.isNsAgnostic()), l = this._builder.build({
            nsPrefix: o,
            name: r,
            attributes: s,
            namespace: n,
            prefixes: a
        });
        if (l[yr] = this._globalData, i) return l[tr](), this._current[Nr](l) && l[Gr](this._ids), void l[Ws](this._builder);
        this._stack.push(this._current), this._current = l;
    }
    onEndElement(e1) {
        const t = this._current;
        if (t[vr]() && "string" == typeof t[Js]) {
            const e1 = new XFAParser;
            e1._globalData = this._globalData;
            const i = e1.parse(t[Js]);
            t[Js] = null, t[Nr](i);
        }
        t[tr](), this._current = this._stack.pop(), this._current[Nr](t) && t[Gr](this._ids), t[Ws](this._builder);
    }
    onError(e1) {
        this._errorCode = e1;
    }
}
class XFAFactory {
    constructor(e1){
        try {
            this.root = (new XFAParser).parse(XFAFactory._createDocument(e1));
            const t = new Binder(this.root);
            this.form = t.bind(), this.dataHandler = new DataHandler(this.root, t.getData()), this.form[yr].template = this.form;
        } catch (e1) {
            warn$1(`XFA - an error occurred during parsing and binding: ${e1}`);
        }
    }
    isValid() {
        return !(!this.root || !this.form);
    }
    _createPagesHelper() {
        const e1 = this.form[Zr]();
        return new Promise((t, i)=>{
            const nextIteration = ()=>{
                try {
                    const i = e1.next();
                    i.done ? t(i.value) : setTimeout(nextIteration, 0);
                } catch (e1) {
                    i(e1);
                }
            };
            setTimeout(nextIteration, 0);
        });
    }
    async _createPages() {
        try {
            this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map((e1)=>{
                const { width: t, height: i } = e1.attributes.style;
                return [
                    0,
                    0,
                    parseInt(t),
                    parseInt(i)
                ];
            });
        } catch (e1) {
            warn$1(`XFA - an error occurred during layout: ${e1}`);
        }
    }
    getBoundingBox(e1) {
        return this.dims[e1];
    }
    async getNumPages() {
        return this.pages || await this._createPages(), this.dims.length;
    }
    setImages(e1) {
        this.form[yr].images = e1;
    }
    setFonts(e1) {
        this.form[yr].fontFinder = new FontFinder(e1);
        const t = [];
        for (let e1 of this.form[yr].usedTypefaces){
            e1 = stripQuotes(e1);
            this.form[yr].fontFinder.find(e1) || t.push(e1);
        }
        return t.length > 0 ? t : null;
    }
    appendFonts(e1, t) {
        this.form[yr].fontFinder.add(e1, t);
    }
    async getPages() {
        this.pages || await this._createPages();
        const e1 = this.pages;
        return this.pages = null, e1;
    }
    serializeData(e1) {
        return this.dataHandler.serialize(e1);
    }
    static _createDocument(e1) {
        return e1["/xdp:xdp"] ? Object.values(e1).join("") : e1["xdp:xdp"];
    }
    static getRichTextAsHtml(e1) {
        if (!e1 || "string" != typeof e1) return null;
        try {
            let t = new XFAParser(XhtmlNamespace, !0).parse(e1);
            if (![
                "body",
                "xhtml"
            ].includes(t[Pr])) {
                const e1 = XhtmlNamespace.body({});
                e1[qs](t), t = e1;
            }
            const i = t[Qr]();
            if (!i.success) return null;
            const { html: n } = i, { attributes: a } = n;
            return a && (a.class && (a.class = a.class.filter((e1)=>!e1.startsWith("xfa"))), a.dir = "auto"), {
                html: n,
                str: t[Jr]()
            };
        } catch (e1) {
            warn$1(`XFA - an error occurred during parsing of rich text: ${e1}`);
        }
        return null;
    }
}
class AnnotationFactory {
    static createGlobals(e1) {
        return Promise.all([
            e1.ensureCatalog("acroForm"),
            e1.ensureDoc("xfaDatasets"),
            e1.ensureCatalog("structTreeRoot"),
            e1.ensureCatalog("baseUrl"),
            e1.ensureCatalog("attachments"),
            e1.ensureCatalog("globalColorSpaceCache")
        ]).then(([t, i, n, a, s, r])=>({
                pdfManager: e1,
                acroForm: t instanceof Dict ? t : Dict.empty,
                xfaDatasets: i,
                structTreeRoot: n,
                baseUrl: a,
                attachments: s,
                globalColorSpaceCache: r
            }), (e1)=>(warn$1(`createGlobals: "${e1}".`), null));
    }
    static async create(e1, t, i, n, a, s, r, o) {
        const l = a ? await this._getPageIndex(e1, t, i.pdfManager) : null;
        return i.pdfManager.ensure(this, "_create", [
            e1,
            t,
            i,
            n,
            a,
            s,
            r,
            l,
            o
        ]);
    }
    static _create(e1, t, i, n, a = !1, s = null, r = null, o = null, l = null) {
        const c = e1.fetchIfRef(t);
        if (!(c instanceof Dict)) return;
        let h = c.get("Subtype");
        if (h = h instanceof Name ? h.name : null, r && !r.has(T[h.toUpperCase()])) return null;
        const { acroForm: d, pdfManager: u } = i, g = t instanceof Ref ? t.toString() : `annot_${n.createObjId()}`, f = {
            xref: e1,
            ref: t,
            dict: c,
            subtype: h,
            id: g,
            annotationGlobals: i,
            collectFields: a,
            orphanFields: s,
            needAppearances: !a && !0 === d.get("NeedAppearances"),
            pageIndex: o,
            evaluatorOptions: u.evaluatorOptions,
            pageRef: l
        };
        switch(h){
            case "Link":
                return new LinkAnnotation(f);
            case "Text":
                return new TextAnnotation(f);
            case "Widget":
                let e2 = getInheritableProperty({
                    dict: c,
                    key: "FT"
                });
                switch(e2 = e2 instanceof Name ? e2.name : null, e2){
                    case "Tx":
                        return new TextWidgetAnnotation(f);
                    case "Btn":
                        return new ButtonWidgetAnnotation(f);
                    case "Ch":
                        return new ChoiceWidgetAnnotation(f);
                    case "Sig":
                        return new SignatureWidgetAnnotation(f);
                }
                return warn$1(`Unimplemented widget field type "${e2}", falling back to base field type.`), new WidgetAnnotation(f);
            case "Popup":
                return new PopupAnnotation(f);
            case "FreeText":
                return new FreeTextAnnotation(f);
            case "Line":
                return new LineAnnotation(f);
            case "Square":
                return new SquareAnnotation(f);
            case "Circle":
                return new CircleAnnotation(f);
            case "PolyLine":
                return new PolylineAnnotation(f);
            case "Polygon":
                return new PolygonAnnotation(f);
            case "Caret":
                return new CaretAnnotation(f);
            case "Ink":
                return new InkAnnotation(f);
            case "Highlight":
                return new HighlightAnnotation(f);
            case "Underline":
                return new UnderlineAnnotation(f);
            case "Squiggly":
                return new SquigglyAnnotation(f);
            case "StrikeOut":
                return new StrikeOutAnnotation(f);
            case "Stamp":
                return new StampAnnotation(f);
            case "FileAttachment":
                return new FileAttachmentAnnotation(f);
            default:
                return a || warn$1(h ? `Unimplemented annotation type "${h}", falling back to base annotation.` : "Annotation is missing the required /Subtype."), new Annotation(f);
        }
    }
    static async _getPageIndex(e1, t, i) {
        try {
            const n = await e1.fetchIfRefAsync(t);
            if (!(n instanceof Dict)) return -1;
            const a = n.getRaw("P");
            if (a instanceof Ref) try {
                return await i.ensureCatalog("getPageIndex", [
                    a
                ]);
            } catch (e1) {
                info$1(`_getPageIndex -- not a valid page reference: "${e1}".`);
            }
            if (n.has("Kids")) return -1;
            const s = await i.ensureDoc("numPages");
            for(let e1 = 0; e1 < s; e1++){
                const n = await i.getPage(e1), a = await i.ensure(n, "annotations");
                for (const i of a)if (i instanceof Ref && isRefsEqual(i, t)) return e1;
            }
        } catch (e1) {
            warn$1(`_getPageIndex: "${e1}".`);
        }
        return -1;
    }
    static generateImages(e1, t, i) {
        if (!i) return warn$1("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."), null;
        let n;
        for (const { bitmapId: i, bitmap: a } of e1)a && (n ||= new Map, n.set(i, StampAnnotation.createImage(a, t)));
        return n;
    }
    static async saveNewAnnotations(e1, t, i, n, a) {
        const s = e1.xref;
        let r;
        const o = [], { isOffscreenCanvasSupported: l } = e1.options;
        for (const c of i)if (!c.deleted) switch(c.annotationType){
            case f:
                if (!r) {
                    const e1 = new Dict(s);
                    e1.setIfName("BaseFont", "Helvetica"), e1.setIfName("Type", "Font"), e1.setIfName("Subtype", "Type1"), e1.setIfName("Encoding", "WinAnsiEncoding"), r = s.getNewTemporaryRef(), a.put(r, {
                        data: e1
                    });
                }
                o.push(FreeTextAnnotation.createNewAnnotation(s, c, a, {
                    evaluator: e1,
                    task: t,
                    baseFontRef: r
                }));
                break;
            case p:
                c.quadPoints ? o.push(HighlightAnnotation.createNewAnnotation(s, c, a)) : o.push(InkAnnotation.createNewAnnotation(s, c, a));
                break;
            case b:
                o.push(InkAnnotation.createNewAnnotation(s, c, a));
                break;
            case m:
                const i = l ? await n?.get(c.bitmapId) : null;
                if (i?.imageStream) {
                    const { imageStream: e1, smaskStream: t } = i;
                    if (t) {
                        const i = s.getNewTemporaryRef();
                        a.put(i, {
                            data: t
                        }), e1.dict.set("SMask", i);
                    }
                    const n = i.imageRef = s.getNewTemporaryRef();
                    a.put(n, {
                        data: e1
                    }), i.imageStream = i.smaskStream = null;
                }
                o.push(StampAnnotation.createNewAnnotation(s, c, a, {
                    image: i
                }));
                break;
            case y:
                o.push(StampAnnotation.createNewAnnotation(s, c, a, {}));
        }
        return {
            annotations: (await Promise.all(o)).flat()
        };
    }
    static async printNewAnnotations(e1, t, i, n, a) {
        if (!n) return null;
        const { options: s, xref: r } = t, o = [];
        for (const l of n)if (!l.deleted) switch(l.annotationType){
            case f:
                o.push(FreeTextAnnotation.createNewPrintAnnotation(e1, r, l, {
                    evaluator: t,
                    task: i,
                    evaluatorOptions: s
                }));
                break;
            case p:
                l.quadPoints ? o.push(HighlightAnnotation.createNewPrintAnnotation(e1, r, l, {
                    evaluatorOptions: s
                })) : o.push(InkAnnotation.createNewPrintAnnotation(e1, r, l, {
                    evaluatorOptions: s
                }));
                break;
            case b:
                o.push(InkAnnotation.createNewPrintAnnotation(e1, r, l, {
                    evaluatorOptions: s
                }));
                break;
            case m:
                const n = s.isOffscreenCanvasSupported ? await a?.get(l.bitmapId) : null;
                if (n?.imageStream) {
                    const { imageStream: e1, smaskStream: t } = n;
                    t && e1.dict.set("SMask", t), n.imageRef = new JpegStream(e1, e1.length), n.imageStream = n.smaskStream = null;
                }
                o.push(StampAnnotation.createNewPrintAnnotation(e1, r, l, {
                    image: n,
                    evaluatorOptions: s
                }));
                break;
            case y:
                o.push(StampAnnotation.createNewPrintAnnotation(e1, r, l, {
                    evaluatorOptions: s
                }));
        }
        return Promise.all(o);
    }
}
function getRgbColor(e1, t = new Uint8ClampedArray(3)) {
    if (!Array.isArray(e1)) return t;
    const i = t || new Uint8ClampedArray(3);
    switch(e1.length){
        case 0:
            return null;
        case 1:
            return ColorSpaceUtils.gray.getRgbItem(e1, 0, i, 0), i;
        case 3:
            return ColorSpaceUtils.rgb.getRgbItem(e1, 0, i, 0), i;
        case 4:
            return ColorSpaceUtils.cmyk.getRgbItem(e1, 0, i, 0), i;
        default:
            return t;
    }
}
function getPdfColorArray(e1, t = null) {
    return e1 && Array.from(e1, (e1)=>e1 / 255) || t;
}
function getQuadPoints(e1, t) {
    const i = e1.getArray("QuadPoints");
    if (!isNumberArray(i, null) || 0 === i.length || i.length % 8 > 0) return null;
    const n = new Float32Array(i.length);
    for(let e1 = 0, a = i.length; e1 < a; e1 += 8){
        const [a, s, r, o, l, c, h, d] = i.slice(e1, e1 + 8), u = Math.min(a, r, l, h), g = Math.max(a, r, l, h), f = Math.min(s, o, c, d), p = Math.max(s, o, c, d);
        if (null !== t && (u < t[0] || g > t[2] || f < t[1] || p > t[3])) return null;
        n.set([
            u,
            p,
            g,
            p,
            u,
            f,
            g,
            f
        ], e1);
    }
    return n;
}
function getTransformMatrix(e1, t, i) {
    const n = new Float32Array([
        1 / 0,
        1 / 0,
        -1 / 0,
        -1 / 0
    ]);
    ai.axialAlignedBoundingBox(t, i, n);
    const [a, s, r, o] = n;
    if (a === r || s === o) return [
        1,
        0,
        0,
        1,
        e1[0],
        e1[1]
    ];
    const l = (e1[2] - e1[0]) / (r - a), c = (e1[3] - e1[1]) / (o - s);
    return [
        l,
        0,
        0,
        c,
        e1[0] - a * l,
        e1[1] - s * c
    ];
}
class Annotation {
    constructor(e1){
        const { dict: t, xref: i, annotationGlobals: n, ref: a, orphanFields: s } = e1, r = s?.get(a);
        r && t.set("Parent", r), this.setTitle(t.get("T")), this.setContents(t.get("Contents")), this.setModificationDate(t.get("M")), this.setFlags(t.get("F")), this.setRectangle(t.getArray("Rect")), this.setColor(t.getArray("C")), this.setBorderStyle(t), this.setAppearance(t), this.setOptionalContent(t);
        const o = t.get("MK");
        this.setBorderAndBackgroundColors(o), this.setRotation(o, t), this.ref = e1.ref instanceof Ref ? e1.ref : null, this._streams = [], this.appearance && this._streams.push(this.appearance);
        const l = !!(this.flags & N), c = !!(this.flags & L);
        if (this.data = {
            annotationFlags: this.flags,
            borderStyle: this.borderStyle,
            color: this.color,
            backgroundColor: this.backgroundColor,
            borderColor: this.borderColor,
            rotation: this.rotation,
            contentsObj: this._contents,
            hasAppearance: !!this.appearance,
            id: e1.id,
            modificationDate: this.modificationDate,
            rect: this.rectangle,
            subtype: e1.subtype,
            hasOwnCanvas: !1,
            noRotate: !!(this.flags & _),
            noHTML: l && c,
            isEditable: !1,
            structParent: -1
        }, n.structTreeRoot) {
            let i = t.get("StructParent");
            this.data.structParent = i = Number.isInteger(i) && i >= 0 ? i : -1, n.structTreeRoot.addAnnotationIdToPage(e1.pageRef, i);
        }
        if (e1.collectFields) {
            const n = t.get("Kids");
            if (Array.isArray(n)) {
                const e1 = [];
                for (const t of n)t instanceof Ref && e1.push(t.toString());
                0 !== e1.length && (this.data.kidIds = e1);
            }
            this.data.actions = collectActions(i, t, te), this.data.fieldName = this._constructFieldName(t), this.data.pageIndex = e1.pageIndex;
        }
        const h = t.get("IT");
        h instanceof Name && (this.data.it = h.name), this._isOffscreenCanvasSupported = e1.evaluatorOptions.isOffscreenCanvasSupported, this._fallbackFontDict = null, this._needAppearances = !1;
    }
    _hasFlag(e1, t) {
        return !!(e1 & t);
    }
    _buildFlags(e1, t) {
        let { flags: i } = this;
        if (void 0 === e1) {
            if (void 0 === t) return;
            return t ? -5 & i : -3 & i | O;
        }
        return e1 ? (i |= O, t ? -33 & i | D : -3 & i | R) : (i &= -35, t ? -5 & i : i | O);
    }
    _isViewable(e1) {
        return !this._hasFlag(e1, M) && !this._hasFlag(e1, R);
    }
    _isPrintable(e1) {
        return this._hasFlag(e1, O) && !this._hasFlag(e1, D) && !this._hasFlag(e1, M);
    }
    mustBeViewed(e1, t) {
        const i = e1?.get(this.data.id)?.noView;
        return void 0 !== i ? !i : this.viewable && !this._hasFlag(this.flags, D);
    }
    mustBePrinted(e1) {
        const t = e1?.get(this.data.id)?.noPrint;
        return void 0 !== t ? !t : this.printable;
    }
    mustBeViewedWhenEditing(e1, t = null) {
        return e1 ? !this.data.isEditable : !t?.has(this.data.id);
    }
    get viewable() {
        return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));
    }
    get printable() {
        return null !== this.data.quadPoints && 0 !== this.flags && this._isPrintable(this.flags);
    }
    _parseStringHelper(e1) {
        const t = "string" == typeof e1 ? stringToPDFString(e1) : "";
        return {
            str: t,
            dir: t && "rtl" === bidi(t).dir ? "rtl" : "ltr"
        };
    }
    setDefaultAppearance(e1) {
        const { dict: t, annotationGlobals: i } = e1, n = getInheritableProperty({
            dict: t,
            key: "DA"
        }) || i.acroForm.get("DA");
        this._defaultAppearance = "string" == typeof n ? n : "", this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);
    }
    setTitle(e1) {
        this._title = this._parseStringHelper(e1);
    }
    setContents(e1) {
        this._contents = this._parseStringHelper(e1);
    }
    setModificationDate(e1) {
        this.modificationDate = "string" == typeof e1 ? e1 : null;
    }
    setFlags(e1) {
        this.flags = Number.isInteger(e1) && e1 > 0 ? e1 : 0, this.flags & M && "Annotation" !== this.constructor.name && (this.flags ^= M);
    }
    hasFlag(e1) {
        return this._hasFlag(this.flags, e1);
    }
    setRectangle(e1) {
        this.rectangle = lookupNormalRect(e1, [
            0,
            0,
            0,
            0
        ]);
    }
    setColor(e1) {
        this.color = getRgbColor(e1);
    }
    setLineEndings(e1) {
        if (this.lineEndings = [
            "None",
            "None"
        ], Array.isArray(e1) && 2 === e1.length) for(let t = 0; t < 2; t++){
            const i = e1[t];
            if (i instanceof Name) switch(i.name){
                case "None":
                    continue;
                case "Square":
                case "Circle":
                case "Diamond":
                case "OpenArrow":
                case "ClosedArrow":
                case "Butt":
                case "ROpenArrow":
                case "RClosedArrow":
                case "Slash":
                    this.lineEndings[t] = i.name;
                    continue;
            }
            warn$1(`Ignoring invalid lineEnding: ${i}`);
        }
    }
    setRotation(e1, t) {
        this.rotation = 0;
        let i = e1 instanceof Dict ? e1.get("R") || 0 : t.get("Rotate") || 0;
        Number.isInteger(i) && 0 !== i && (i %= 360, i < 0 && (i += 360), i % 90 == 0 && (this.rotation = i));
    }
    setBorderAndBackgroundColors(e1) {
        e1 instanceof Dict ? (this.borderColor = getRgbColor(e1.getArray("BC"), null), this.backgroundColor = getRgbColor(e1.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
    }
    setBorderStyle(e1) {
        if (this.borderStyle = new AnnotationBorderStyle, e1 instanceof Dict) if (e1.has("BS")) {
            const t = e1.get("BS");
            if (t instanceof Dict) {
                const e1 = t.get("Type");
                e1 && !isName(e1, "Border") || (this.borderStyle.setWidth(t.get("W"), this.rectangle), this.borderStyle.setStyle(t.get("S")), this.borderStyle.setDashArray(t.getArray("D")));
            }
        } else if (e1.has("Border")) {
            const t = e1.getArray("Border");
            Array.isArray(t) && t.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(t[0]), this.borderStyle.setVerticalCornerRadius(t[1]), this.borderStyle.setWidth(t[2], this.rectangle), 4 === t.length && this.borderStyle.setDashArray(t[3], !0));
        } else this.borderStyle.setWidth(0);
    }
    setAppearance(e1) {
        this.appearance = null;
        const t = e1.get("AP");
        if (!(t instanceof Dict)) return;
        const i = t.get("N");
        if (i instanceof BaseStream) return void (this.appearance = i);
        if (!(i instanceof Dict)) return;
        const n = e1.get("AS");
        if (!(n instanceof Name && i.has(n.name))) return;
        const a = i.get(n.name);
        a instanceof BaseStream && (this.appearance = a);
    }
    setOptionalContent(e1) {
        this.oc = null;
        const t = e1.get("OC");
        t instanceof Name ? warn$1("setOptionalContent: Support for /Name-entry is not implemented.") : t instanceof Dict && (this.oc = t);
    }
    async loadResources(e1, t) {
        const i = await t.dict.getAsync("Resources");
        return i && await ObjectLoader.load(i, e1, i.xref), i;
    }
    async getOperatorList(e1, t, i, n) {
        const { hasOwnCanvas: a, id: s, rect: o } = this.data;
        let l = this.appearance;
        const c = !!(a && i & r);
        if (c && (0 === this.width || 0 === this.height)) return this.data.hasOwnCanvas = !1, {
            opList: new OperatorList,
            separateForm: !1,
            separateCanvas: !1
        };
        if (!l) {
            if (!c) return {
                opList: new OperatorList,
                separateForm: !1,
                separateCanvas: !1
            };
            l = new StringStream(""), l.dict = new Dict;
        }
        const h = l.dict, d = await this.loadResources(mi, l), u = lookupRect(h.getArray("BBox"), [
            0,
            0,
            1,
            1
        ]), g = lookupMatrix(h.getArray("Matrix"), pi), f = getTransformMatrix(o, u, g), p = new OperatorList;
        let m;
        return this.oc && (m = await e1.parseMarkedContentProps(this.oc, null)), void 0 !== m && p.addOp(xt, [
            "OC",
            m
        ]), p.addOp(Et, [
            s,
            o,
            f,
            g,
            c
        ]), await e1.getOperatorList({
            stream: l,
            task: t,
            resources: d,
            operatorList: p,
            fallbackFontDict: this._fallbackFontDict
        }), p.addOp(Mt, []), void 0 !== m && p.addOp(St, []), this.reset(), {
            opList: p,
            separateForm: !1,
            separateCanvas: c
        };
    }
    async save(e1, t, i, n) {
        return null;
    }
    get overlaysTextContent() {
        return !1;
    }
    get hasTextContent() {
        return !1;
    }
    async extractTextContent(e1, t, i) {
        if (!this.appearance) return;
        const n = await this.loadResources(bi, this.appearance), a = [], s = [];
        let r = null;
        const o = {
            desiredSize: Math.Infinity,
            ready: !0,
            enqueue (e1, t) {
                for (const t of e1.items)void 0 !== t.str && (r ||= t.transform.slice(-2), s.push(t.str), t.hasEOL && (a.push(s.join("").trimEnd()), s.length = 0));
            }
        };
        if (await e1.getTextContent({
            stream: this.appearance,
            task: t,
            resources: n,
            includeMarkedContent: !0,
            keepWhiteSpace: !0,
            sink: o,
            viewBox: i
        }), this.reset(), s.length && a.push(s.join("").trimEnd()), a.length > 1 || a[0]) {
            const e1 = this.appearance.dict, t = lookupRect(e1.getArray("BBox"), null), i = lookupMatrix(e1.getArray("Matrix"), null);
            this.data.textPosition = this._transformPoint(r, t, i), this.data.textContent = a;
        }
    }
    _transformPoint(e1, t, i) {
        const { rect: n } = this.data;
        t ||= [
            0,
            0,
            1,
            1
        ], i ||= [
            1,
            0,
            0,
            1,
            0,
            0
        ];
        const a = getTransformMatrix(n, t, i);
        a[4] -= n[0], a[5] -= n[1];
        const s = e1.slice();
        return ai.applyTransform(s, a), ai.applyTransform(s, i), s;
    }
    getFieldObject() {
        return this.data.kidIds ? {
            id: this.data.id,
            actions: this.data.actions,
            name: this.data.fieldName,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            type: "",
            kidIds: this.data.kidIds,
            page: this.data.pageIndex,
            rotation: this.rotation
        } : null;
    }
    reset() {
        for (const e1 of this._streams)e1.reset();
    }
    _constructFieldName(e1) {
        if (!e1.has("T") && !e1.has("Parent")) return warn$1("Unknown field name, falling back to empty field name."), "";
        if (!e1.has("Parent")) return stringToPDFString(e1.get("T"));
        const t = [];
        e1.has("T") && t.unshift(stringToPDFString(e1.get("T")));
        let i = e1;
        const n = new RefSet;
        for(e1.objId && n.put(e1.objId); i.has("Parent") && (i = i.get("Parent"), i instanceof Dict && (!i.objId || !n.has(i.objId)));)i.objId && n.put(i.objId), i.has("T") && t.unshift(stringToPDFString(i.get("T")));
        return t.join(".");
    }
    get width() {
        return this.data.rect[2] - this.data.rect[0];
    }
    get height() {
        return this.data.rect[3] - this.data.rect[1];
    }
}
class AnnotationBorderStyle {
    constructor(){
        this.width = 1, this.rawWidth = 1, this.style = Y, this.dashArray = [
            3
        ], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
    }
    setWidth(e1, t = [
        0,
        0,
        0,
        0
    ]) {
        if (e1 instanceof Name) this.width = 0;
        else if ("number" == typeof e1) {
            if (e1 > 0) {
                this.rawWidth = e1;
                const i = (t[2] - t[0]) / 2, n = (t[3] - t[1]) / 2;
                i > 0 && n > 0 && (e1 > i || e1 > n) && (warn$1(`AnnotationBorderStyle.setWidth - ignoring width: ${e1}`), e1 = 1);
            }
            this.width = e1;
        }
    }
    setStyle(e1) {
        if (e1 instanceof Name) switch(e1.name){
            case "S":
                this.style = Y;
                break;
            case "D":
                this.style = J;
                break;
            case "B":
                this.style = Z;
                break;
            case "I":
                this.style = Q;
                break;
            case "U":
                this.style = ee;
        }
    }
    setDashArray(e1, t = !1) {
        if (Array.isArray(e1)) {
            let i = !0, n = !0;
            for (const t of e1){
                if (!(+t >= 0)) {
                    i = !1;
                    break;
                }
                t > 0 && (n = !1);
            }
            0 === e1.length || i && !n ? (this.dashArray = e1, t && this.setStyle(Name.get("D"))) : this.width = 0;
        } else e1 && (this.width = 0);
    }
    setHorizontalCornerRadius(e1) {
        Number.isInteger(e1) && (this.horizontalCornerRadius = e1);
    }
    setVerticalCornerRadius(e1) {
        Number.isInteger(e1) && (this.verticalCornerRadius = e1);
    }
}
class MarkupAnnotation extends Annotation {
    constructor(e1){
        super(e1);
        const { dict: t } = e1;
        if (t.has("IRT")) {
            const e1 = t.getRaw("IRT");
            this.data.inReplyTo = e1 instanceof Ref ? e1.toString() : null;
            const i = t.get("RT");
            this.data.replyType = i instanceof Name ? i.name : E;
        }
        let i = null;
        if (this.data.replyType === F) {
            const e1 = t.get("IRT");
            this.setTitle(e1.get("T")), this.data.titleObj = this._title, this.setContents(e1.get("Contents")), this.data.contentsObj = this._contents, e1.has("CreationDate") ? (this.setCreationDate(e1.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, e1.has("M") ? (this.setModificationDate(e1.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i = e1.getRaw("Popup"), e1.has("C") ? (this.setColor(e1.getArray("C")), this.data.color = this.color) : this.data.color = null;
        } else this.data.titleObj = this._title, this.setCreationDate(t.get("CreationDate")), this.data.creationDate = this.creationDate, i = t.getRaw("Popup"), t.has("C") || (this.data.color = null);
        this.data.popupRef = i instanceof Ref ? i.toString() : null, t.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(t.get("RC")));
    }
    setCreationDate(e1) {
        this.creationDate = "string" == typeof e1 ? e1 : null;
    }
    _setDefaultAppearance({ xref: e1, extra: t, strokeColor: i, fillColor: n, blendMode: a, strokeAlpha: s, fillAlpha: r, pointsCallback: o }) {
        const l = this.data.rect = [
            1 / 0,
            1 / 0,
            -1 / 0,
            -1 / 0
        ], c = [
            "q"
        ];
        t && c.push(t), i && c.push(`${i[0]} ${i[1]} ${i[2]} RG`), n && c.push(`${n[0]} ${n[1]} ${n[2]} rg`);
        const h = this.data.quadPoints || Float32Array.from([
            this.rectangle[0],
            this.rectangle[3],
            this.rectangle[2],
            this.rectangle[3],
            this.rectangle[0],
            this.rectangle[1],
            this.rectangle[2],
            this.rectangle[1]
        ]);
        for(let e1 = 0, t = h.length; e1 < t; e1 += 8){
            const t = o(c, h.subarray(e1, e1 + 8));
            ai.rectBoundingBox(...t, l);
        }
        c.push("Q");
        const d = new Dict(e1), u = new Dict(e1);
        u.setIfName("Subtype", "Form");
        const g = new StringStream(c.join(" "));
        g.dict = u, d.set("Fm0", g);
        const f = new Dict(e1);
        a && f.setIfName("BM", a), f.setIfNumber("CA", s), f.setIfNumber("ca", r);
        const p = new Dict(e1);
        p.set("GS0", f);
        const m = new Dict(e1);
        m.set("ExtGState", p), m.set("XObject", d);
        const b = new Dict(e1);
        b.set("Resources", m), b.set("BBox", l), this.appearance = new StringStream("/GS0 gs /Fm0 Do"), this.appearance.dict = b, this._streams.push(this.appearance, g);
    }
    static async createNewAnnotation(e1, t, i, n) {
        const a = t.ref ||= e1.getNewTemporaryRef(), s = await this.createNewAppearanceStream(t, e1, n);
        let r;
        if (s) {
            const n = e1.getNewTemporaryRef();
            r = this.createNewDict(t, e1, {
                apRef: n
            }), i.put(n, {
                data: s
            });
        } else r = this.createNewDict(t, e1, {});
        Number.isInteger(t.parentTreeId) && r.set("StructParent", t.parentTreeId), i.put(a, {
            data: r
        });
        const o = {
            ref: a
        }, { popup: l } = t;
        if (l) {
            if (l.deleted) return r.delete("Popup"), r.delete("Contents"), r.delete("RC"), o;
            const t = l.ref ||= e1.getNewTemporaryRef();
            l.parent = a;
            const n = PopupAnnotation.createNewDict(l, e1);
            return i.put(t, {
                data: n
            }), r.setIfDefined("Contents", stringToAsciiOrUTF16BE(l.contents)), r.set("Popup", t), [
                o,
                {
                    ref: t
                }
            ];
        }
        return o;
    }
    static async createNewPrintAnnotation(e1, t, i, n) {
        const a = await this.createNewAppearanceStream(i, t, n), s = this.createNewDict(i, t, a ? {
            ap: a
        } : {}), r = new this.prototype.constructor({
            dict: s,
            xref: t,
            annotationGlobals: e1,
            evaluatorOptions: n.evaluatorOptions
        });
        return i.ref && (r.ref = r.refToReplace = i.ref), r;
    }
}
class WidgetAnnotation extends Annotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i, annotationGlobals: n } = e1, a = this.data;
        this._needAppearances = e1.needAppearances, a.annotationType = T.WIDGET, void 0 === a.fieldName && (a.fieldName = this._constructFieldName(t)), void 0 === a.actions && (a.actions = collectActions(i, t, te));
        let s = getInheritableProperty({
            dict: t,
            key: "V",
            getArray: !0
        });
        a.fieldValue = this._decodeFormValue(s);
        const r = getInheritableProperty({
            dict: t,
            key: "DV",
            getArray: !0
        });
        if (a.defaultFieldValue = this._decodeFormValue(r), void 0 === s && n.xfaDatasets) {
            const e1 = this._title.str;
            e1 && (this._hasValueFromXFA = !0, a.fieldValue = s = n.xfaDatasets.getValue(e1));
        }
        void 0 === s && null !== a.defaultFieldValue && (a.fieldValue = a.defaultFieldValue), a.alternativeText = stringToPDFString(t.get("TU") || ""), this.setDefaultAppearance(e1), a.hasAppearance ||= this._needAppearances && void 0 !== a.fieldValue && null !== a.fieldValue;
        const o = getInheritableProperty({
            dict: t,
            key: "FT"
        });
        a.fieldType = o instanceof Name ? o.name : null;
        const l = getInheritableProperty({
            dict: t,
            key: "DR"
        }), c = n.acroForm.get("DR"), h = this.appearance?.dict.get("Resources");
        this._fieldResources = {
            localResources: l,
            acroFormResources: c,
            appearanceResources: h,
            mergedResources: Dict.merge({
                xref: i,
                dictArray: [
                    l,
                    h,
                    c
                ],
                mergeSubDicts: !0
            })
        }, a.fieldFlags = getInheritableProperty({
            dict: t,
            key: "Ff"
        }), (!Number.isInteger(a.fieldFlags) || a.fieldFlags < 0) && (a.fieldFlags = 0), a.password = this.hasFieldFlag(H), a.readOnly = this.hasFieldFlag(U), a.required = this.hasFieldFlag(j), a.hidden = this._hasFlag(a.annotationFlags, D) || this._hasFlag(a.annotationFlags, R);
    }
    _decodeFormValue(e1) {
        return Array.isArray(e1) ? e1.filter((e1)=>"string" == typeof e1).map((e1)=>stringToPDFString(e1)) : e1 instanceof Name ? stringToPDFString(e1.name) : "string" == typeof e1 ? stringToPDFString(e1) : null;
    }
    hasFieldFlag(e1) {
        return !!(this.data.fieldFlags & e1);
    }
    _isViewable(e1) {
        return !0;
    }
    mustBeViewed(e1, t) {
        return t ? this.viewable : super.mustBeViewed(e1, t) && !this._hasFlag(this.flags, R);
    }
    getRotationMatrix(e1) {
        let t = e1?.get(this.data.id)?.rotation;
        return void 0 === t && (t = this.rotation), 0 === t ? pi : getRotationMatrix(t, this.width, this.height);
    }
    getBorderAndBackgroundAppearances(e1) {
        let t = e1?.get(this.data.id)?.rotation;
        if (void 0 === t && (t = this.rotation), !this.backgroundColor && !this.borderColor) return "";
        const i = 0 === t || 180 === t ? `0 0 ${this.width} ${this.height} re` : `0 0 ${this.height} ${this.width} re`;
        let n = "";
        if (this.backgroundColor && (n = `${getPdfColor(this.backgroundColor, !0)} ${i} f `), this.borderColor) {
            n += `${this.borderStyle.width || 1} w ${getPdfColor(this.borderColor, !1)} ${i} S `;
        }
        return n;
    }
    async getOperatorList(e1, t, i, n) {
        if (i & c && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) return {
            opList: new OperatorList,
            separateForm: !0,
            separateCanvas: !1
        };
        if (!this._hasText) return super.getOperatorList(e1, t, i, n);
        const a = await this._getAppearance(e1, t, i, n);
        if (this.appearance && null === a) return super.getOperatorList(e1, t, i, n);
        const s = new OperatorList;
        if (!this._defaultAppearance || null === a) return {
            opList: s,
            separateForm: !1,
            separateCanvas: !1
        };
        const o = !!(this.data.hasOwnCanvas && i & r), l = [
            0,
            0,
            this.width,
            this.height
        ], h = getTransformMatrix(this.data.rect, l, [
            1,
            0,
            0,
            1,
            0,
            0
        ]);
        let d;
        this.oc && (d = await e1.parseMarkedContentProps(this.oc, null)), void 0 !== d && s.addOp(xt, [
            "OC",
            d
        ]), s.addOp(Et, [
            this.data.id,
            this.data.rect,
            h,
            this.getRotationMatrix(n),
            o
        ]);
        const u = new StringStream(a);
        return await e1.getOperatorList({
            stream: u,
            task: t,
            resources: this._fieldResources.mergedResources,
            operatorList: s
        }), s.addOp(Mt, []), void 0 !== d && s.addOp(St, []), {
            opList: s,
            separateForm: !1,
            separateCanvas: o
        };
    }
    _getMKDict(e1) {
        const t = new Dict(null);
        return e1 && t.set("R", e1), t.setIfArray("BC", getPdfColorArray(this.borderColor)), t.setIfArray("BG", getPdfColorArray(this.backgroundColor)), t.size > 0 ? t : null;
    }
    amendSavedDict(e1, t) {}
    setValue(e1, t, i, n) {
        const { dict: a, ref: s } = function(e1, t, i) {
            const n = new RefSet, a = e1, s = {
                dict: null,
                ref: null
            };
            for(; e1 instanceof Dict && !n.has(t) && (n.put(t), !e1.has("T"));){
                if (!((t = e1.getRaw("Parent")) instanceof Ref)) return s;
                e1 = i.fetch(t);
            }
            return e1 instanceof Dict && e1 !== a && (s.dict = e1, s.ref = t), s;
        }(e1, this.ref, i);
        if (a) {
            if (!n.has(s)) {
                const e1 = a.clone();
                return e1.set("V", t), n.put(s, {
                    data: e1
                }), e1;
            }
        } else e1.set("V", t);
        return null;
    }
    async save(e1, t, i, n) {
        const a = i?.get(this.data.id), s = this._buildFlags(a?.noView, a?.noPrint);
        let r = a?.value, o = a?.rotation;
        if (r === this.data.fieldValue || void 0 === r) {
            if (!this._hasValueFromXFA && void 0 === o && void 0 === s) return;
            r ||= this.data.fieldValue;
        }
        if (void 0 === o && !this._hasValueFromXFA && Array.isArray(r) && Array.isArray(this.data.fieldValue) && isArrayEqual(r, this.data.fieldValue) && void 0 === s) return;
        void 0 === o && (o = this.rotation);
        let c = null;
        if (!this._needAppearances && (c = await this._getAppearance(e1, t, l, i), null === c && void 0 === s)) return;
        let h = !1;
        c?.needAppearances && (h = !0, c = null);
        const { xref: d } = e1, u = d.fetchIfRef(this.ref);
        if (!(u instanceof Dict)) return;
        const g = new Dict(d);
        for (const e1 of u.getKeys())"AP" !== e1 && g.set(e1, u.getRaw(e1));
        if (void 0 !== s && (g.set("F", s), null === c && !h)) {
            const e1 = u.getRaw("AP");
            e1 && g.set("AP", e1);
        }
        const f = {
            path: this.data.fieldName,
            value: r
        }, p = this.setValue(g, Array.isArray(r) ? r.map(stringToAsciiOrUTF16BE) : stringToAsciiOrUTF16BE(r), d, n);
        this.amendSavedDict(i, p || g);
        const m = this._getMKDict(o);
        if (m && g.set("MK", m), n.put(this.ref, {
            data: g,
            xfa: f,
            needAppearances: h
        }), null !== c) {
            const e1 = d.getNewTemporaryRef(), t = new Dict(d);
            g.set("AP", t), t.set("N", e1);
            const a = this._getSaveFieldResources(d), s = new StringStream(c), r = s.dict = new Dict(d);
            r.setIfName("Subtype", "Form"), r.set("Resources", a);
            const l = o % 180 == 0 ? [
                0,
                0,
                this.width,
                this.height
            ] : [
                0,
                0,
                this.height,
                this.width
            ];
            r.set("BBox", l);
            const h = this.getRotationMatrix(i);
            h !== pi && r.set("Matrix", h), n.put(e1, {
                data: s,
                xfa: null,
                needAppearances: !1
            });
        }
        g.set("M", `D:${getModificationDate()}`);
    }
    async _getAppearance(e1, t, i, n) {
        if (this.data.password) return null;
        const s = n?.get(this.data.id);
        let r, o;
        if (s && (r = s.formattedValue || s.value, o = s.rotation), void 0 === o && void 0 === r && !this._needAppearances && (!this._hasValueFromXFA || this.appearance)) return null;
        const c = this.getBorderAndBackgroundAppearances(n);
        if (void 0 === r && (r = this.data.fieldValue, !r)) return `/Tx BMC q ${c}Q EMC`;
        if (Array.isArray(r) && 1 === r.length && (r = r[0]), assert$1("string" == typeof r, "Expected `value` to be a string."), r = r.trimEnd(), this.data.combo) {
            const e1 = this.data.options.find(({ exportValue: e1 })=>r === e1);
            r = e1?.displayValue || r;
        }
        if ("" === r) return `/Tx BMC q ${c}Q EMC`;
        void 0 === o && (o = this.rotation);
        let h, d = -1;
        this.data.multiLine ? (h = r.split(/\r\n?|\n/).map((e1)=>e1.normalize("NFC")), d = h.length) : h = [
            r.replace(/\r\n?|\n/, "").normalize("NFC")
        ];
        let { width: u, height: g } = this;
        90 !== o && 270 !== o || ([u, g] = [
            g,
            u
        ]), this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
        let f, p, m, b = await WidgetAnnotation._getFontData(e1, t, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
        const y = [];
        let w = !1;
        for (const e1 of h){
            const t = b.encodeString(e1);
            t.length > 1 && (w = !0), y.push(t.join(""));
        }
        if (w && i & l) return {
            needAppearances: !0
        };
        if (w && this._isOffscreenCanvasSupported) {
            const i = this.data.comb ? "monospace" : "sans-serif", n = new FakeUnicodeFont(e1.xref, i), a = n.createFontResources(h.join("")), s = a.getRaw("Font");
            if (this._fieldResources.mergedResources.has("Font")) {
                const e1 = this._fieldResources.mergedResources.get("Font");
                for (const t of s.getKeys())e1.set(t, s.getRaw(t));
            } else this._fieldResources.mergedResources.set("Font", s);
            const o = n.fontName.name;
            b = await WidgetAnnotation._getFontData(e1, t, {
                fontName: o,
                fontSize: 0
            }, a);
            for(let e1 = 0, t = y.length; e1 < t; e1++)y[e1] = stringToUTF16String(h[e1]);
            const l = Object.assign(Object.create(null), this.data.defaultAppearanceData);
            this.data.defaultAppearanceData.fontSize = 0, this.data.defaultAppearanceData.fontName = o, [f, p, m] = this._computeFontSize(g - 2, u - 4, r, b, d), this.data.defaultAppearanceData = l;
        } else this._isOffscreenCanvasSupported || warn$1("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."), [f, p, m] = this._computeFontSize(g - 2, u - 4, r, b, d);
        let x = b.descent;
        x = isNaN(x) ? a * m : Math.max(a * m, Math.abs(x) * p);
        const S = Math.min(Math.floor((g - p) / 2), 1), v = this.data.textAlignment;
        if (this.data.multiLine) return this._getMultilineAppearance(f, y, b, p, u, g, v, 2, S, x, m, n);
        if (this.data.comb) return this._getCombAppearance(f, b, y[0], p, u, g, 2, S, x, m, n);
        const C = S + x;
        if (0 === v || v > 2) return `/Tx BMC q ${c}BT ` + f + ` 1 0 0 1 ${numberToString(2)} ${numberToString(C)} Tm (${escapeString(y[0])}) Tj ET Q EMC`;
        return `/Tx BMC q ${c}BT ` + f + ` 1 0 0 1 0 0 Tm ${this._renderText(y[0], b, p, u, v, {
            shift: 0
        }, 2, C)} ET Q EMC`;
    }
    static async _getFontData(e1, t, i, n) {
        const a = new OperatorList, s = {
            font: null,
            clone () {
                return this;
            }
        }, { fontName: r, fontSize: o } = i;
        return await e1.handleSetFont(n, [
            r && Name.get(r),
            o
        ], null, a, t, s, null), s.font;
    }
    _getTextWidth(e1, t) {
        return Math.sumPrecise(t.charsToGlyphs(e1).map((e1)=>e1.width)) / 1e3;
    }
    _computeFontSize(e1, t, n, a, s) {
        let { fontSize: r } = this.data.defaultAppearanceData, o = (r || 12) * i, l = Math.round(e1 / o);
        if (!r) {
            const roundWithTwoDigits = (e1)=>Math.floor(100 * e1) / 100;
            if (-1 === s) {
                const s = this._getTextWidth(n, a);
                r = roundWithTwoDigits(Math.min(e1 / i, t / s)), l = 1;
            } else {
                const c = n.split(/\r\n?|\n/), h = [];
                for (const e1 of c){
                    const t = a.encodeString(e1).join(""), i = a.charsToGlyphs(t), n = a.getCharPositions(t);
                    h.push({
                        line: t,
                        glyphs: i,
                        positions: n
                    });
                }
                const isTooBig = (i)=>{
                    let n = 0;
                    for (const s of h){
                        if (n += this._splitLine(null, a, i, t, s).length * i, n > e1) return !0;
                    }
                    return !1;
                };
                for(l = Math.max(l, s); o = e1 / l, r = roundWithTwoDigits(o / i), isTooBig(r);)l++;
            }
            const { fontName: c, fontColor: h } = this.data.defaultAppearanceData;
            this._defaultAppearance = function({ fontSize: e1, fontName: t, fontColor: i }) {
                return `/${escapePDFName(t)} ${e1} Tf ${getPdfColor(i, !0)}`;
            }({
                fontSize: r,
                fontName: c,
                fontColor: h
            });
        }
        return [
            this._defaultAppearance,
            r,
            e1 / l
        ];
    }
    _renderText(e1, t, i, n, a, s, r, o) {
        let l;
        if (1 === a) {
            l = (n - this._getTextWidth(e1, t) * i) / 2;
        } else if (2 === a) {
            l = n - this._getTextWidth(e1, t) * i - r;
        } else l = r;
        const c = numberToString(l - s.shift);
        return s.shift = l, `${c} ${o = numberToString(o)} Td (${escapeString(e1)}) Tj`;
    }
    _getSaveFieldResources(e1) {
        const { localResources: t, appearanceResources: i, acroFormResources: n } = this._fieldResources, a = this.data.defaultAppearanceData?.fontName;
        if (!a) return t || Dict.empty;
        for (const e1 of [
            t,
            i
        ])if (e1 instanceof Dict) {
            const t = e1.get("Font");
            if (t instanceof Dict && t.has(a)) return e1;
        }
        if (n instanceof Dict) {
            const i = n.get("Font");
            if (i instanceof Dict && i.has(a)) {
                const n = new Dict(e1);
                n.set(a, i.getRaw(a));
                const s = new Dict(e1);
                return s.set("Font", n), Dict.merge({
                    xref: e1,
                    dictArray: [
                        s,
                        t
                    ],
                    mergeSubDicts: !0
                });
            }
        }
        return t || Dict.empty;
    }
    getFieldObject() {
        return null;
    }
}
class TextWidgetAnnotation extends WidgetAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t } = e1;
        t.has("PMD") && (this.flags |= D, this.data.hidden = !0, warn$1("Barcodes are not supported")), this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML, this._hasText = !0, "string" != typeof this.data.fieldValue && (this.data.fieldValue = "");
        let i = getInheritableProperty({
            dict: t,
            key: "Q"
        });
        (!Number.isInteger(i) || i < 0 || i > 2) && (i = null), this.data.textAlignment = i;
        let n = getInheritableProperty({
            dict: t,
            key: "MaxLen"
        });
        (!Number.isInteger(n) || n < 0) && (n = 0), this.data.maxLen = n, this.data.multiLine = this.hasFieldFlag($), this.data.comb = this.hasFieldFlag(K) && !this.data.multiLine && !this.data.password && !this.hasFieldFlag(W) && 0 !== this.data.maxLen, this.data.doNotScroll = this.hasFieldFlag(V);
        const { data: { actions: a } } = this;
        if (!a) return;
        const s = /^AF(Date|Time)_(?:Keystroke|Format)(?:Ex)?\(['"]?([^'"]+)['"]?\);$/;
        let r = !1;
        (1 === a.Format?.length && 1 === a.Keystroke?.length && s.test(a.Format[0]) && s.test(a.Keystroke[0]) || 0 === a.Format?.length && 1 === a.Keystroke?.length && s.test(a.Keystroke[0]) || 0 === a.Keystroke?.length && 1 === a.Format?.length && s.test(a.Format[0])) && (r = !0);
        const o = [];
        a.Format && o.push(...a.Format), a.Keystroke && o.push(...a.Keystroke), r && (delete a.Keystroke, a.Format = o);
        for (const e1 of o){
            const t = e1.match(s);
            if (!t) continue;
            const i = "Date" === t[1];
            let n = t[2];
            const a = parseInt(n, 10);
            if (isNaN(a) || Math.floor(Math.log10(a)) + 1 !== t[2].length || (n = (i ? Ts : Fs)[a] ?? n), this.data.datetimeFormat = n, !r) break;
            if (i) {
                /HH|MM|ss|h/.test(n) ? (this.data.datetimeType = "datetime-local", this.data.timeStep = /ss/.test(n) ? 1 : 60) : this.data.datetimeType = "date";
                break;
            }
            this.data.datetimeType = "time", this.data.timeStep = /ss/.test(n) ? 1 : 60;
            break;
        }
    }
    get hasTextContent() {
        return !!this.appearance && !this._needAppearances;
    }
    _getCombAppearance(e1, t, i, n, a, s, r, o, l, c, h) {
        const d = a / this.data.maxLen, u = this.getBorderAndBackgroundAppearances(h), g = [], f = t.getCharPositions(i);
        for (const [e1, t] of f)g.push(`(${escapeString(i.substring(e1, t))}) Tj`);
        const p = g.join(` ${numberToString(d)} 0 Td `);
        return `/Tx BMC q ${u}BT ` + e1 + ` 1 0 0 1 ${numberToString(r)} ${numberToString(o + l)} Tm ${p} ET Q EMC`;
    }
    _getMultilineAppearance(e1, t, i, n, a, s, r, o, l, c, h, d) {
        const u = [], g = a - 2 * o, f = {
            shift: 0
        };
        for(let e1 = 0, s = t.length; e1 < s; e1++){
            const s = t[e1], d = this._splitLine(s, i, n, g);
            for(let t = 0, s = d.length; t < s; t++){
                const s = d[t], g = 0 === e1 && 0 === t ? -l - (h - c) : -h;
                u.push(this._renderText(s, i, n, a, r, f, o, g));
            }
        }
        const p = this.getBorderAndBackgroundAppearances(d), m = u.join("\n");
        return `/Tx BMC q ${p}BT ` + e1 + ` 1 0 0 1 0 ${numberToString(s)} Tm ${m} ET Q EMC`;
    }
    _splitLine(e1, t, i, n, a = {}) {
        e1 = a.line || e1;
        const s = a.glyphs || t.charsToGlyphs(e1);
        if (s.length <= 1) return [
            e1
        ];
        const r = a.positions || t.getCharPositions(e1), o = i / 1e3, l = [];
        let c = -1, h = -1, d = -1, u = 0, g = 0;
        for(let t = 0, i = s.length; t < i; t++){
            const [i, a] = r[t], f = s[t], p = f.width * o;
            " " === f.unicode ? g + p > n ? (l.push(e1.substring(u, i)), u = i, g = p, c = -1, d = -1) : (g += p, c = i, h = a, d = t) : g + p > n ? -1 !== c ? (l.push(e1.substring(u, h)), u = h, t = d + 1, c = -1, g = 0) : (l.push(e1.substring(u, i)), u = i, g = p) : g += p;
        }
        return u < e1.length && l.push(e1.substring(u, e1.length)), l;
    }
    async extractTextContent(e1, t, i) {
        await super.extractTextContent(e1, t, i);
        const n = this.data.textContent;
        if (!n) return;
        const a = n.join("\n");
        if (a === this.data.fieldValue) return;
        const s = a.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (e1, t)=>t ? `\\${t}` : "\\s+");
        new RegExp(`^\\s*${s}\\s*$`).test(this.data.fieldValue) && (this.data.textContent = this.data.fieldValue.split("\n"));
    }
    getFieldObject() {
        return {
            id: this.data.id,
            value: this.data.fieldValue,
            defaultValue: this.data.defaultFieldValue || "",
            multiline: this.data.multiLine,
            password: this.data.password,
            charLimit: this.data.maxLen,
            comb: this.data.comb,
            editable: !this.data.readOnly,
            hidden: this.data.hidden,
            name: this.data.fieldName,
            rect: this.data.rect,
            actions: this.data.actions,
            page: this.data.pageIndex,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            rotation: this.rotation,
            datetimeFormat: this.data.datetimeFormat,
            hasDatetimeHTML: !!this.data.datetimeType,
            type: "text"
        };
    }
}
class ButtonWidgetAnnotation extends WidgetAnnotation {
    constructor(e1){
        super(e1), this.checkedAppearance = null, this.uncheckedAppearance = null;
        const t = this.hasFieldFlag(X), i = this.hasFieldFlag(q);
        this.data.checkBox = !t && !i, this.data.radioButton = t && !i, this.data.pushButton = i, this.data.isTooltipOnly = !1, this.data.checkBox ? this._processCheckBox(e1) : this.data.radioButton ? this._processRadioButton(e1) : this.data.pushButton ? (this.data.hasOwnCanvas = !0, this.data.noHTML = !1, this._processPushButton(e1)) : warn$1("Invalid field flags for button widget annotation");
    }
    async getOperatorList(e1, t, i, n) {
        if (this.data.pushButton) return super.getOperatorList(e1, t, i, !1, n);
        let a = null, s = null;
        if (n) {
            const e1 = n.get(this.data.id);
            a = e1 ? e1.value : null, s = e1 ? e1.rotation : null;
        }
        if (null === a && this.appearance) return super.getOperatorList(e1, t, i, n);
        null == a && (a = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
        const r = a ? this.checkedAppearance : this.uncheckedAppearance;
        if (r) {
            const a = this.appearance, o = lookupMatrix(r.dict.getArray("Matrix"), pi);
            s && r.dict.set("Matrix", this.getRotationMatrix(n)), this.appearance = r;
            const l = super.getOperatorList(e1, t, i, n);
            return this.appearance = a, r.dict.set("Matrix", o), l;
        }
        return {
            opList: new OperatorList,
            separateForm: !1,
            separateCanvas: !1
        };
    }
    async save(e1, t, i, n) {
        this.data.checkBox ? this._saveCheckbox(e1, t, i, n) : this.data.radioButton && this._saveRadioButton(e1, t, i, n);
    }
    async _saveCheckbox(e1, t, i, n) {
        if (!i) return;
        const a = i.get(this.data.id), s = this._buildFlags(a?.noView, a?.noPrint);
        let r = a?.rotation, o = a?.value;
        if (void 0 === r && void 0 === s) {
            if (void 0 === o) return;
            if (this.data.fieldValue === this.data.exportValue === o) return;
        }
        let l = e1.xref.fetchIfRef(this.ref);
        if (!(l instanceof Dict)) return;
        l = l.clone(), void 0 === r && (r = this.rotation), void 0 === o && (o = this.data.fieldValue === this.data.exportValue);
        const c = {
            path: this.data.fieldName,
            value: o ? this.data.exportValue : ""
        }, h = Name.get(o ? this.data.exportValue : "Off");
        this.setValue(l, h, e1.xref, n), l.set("AS", h), l.set("M", `D:${getModificationDate()}`), void 0 !== s && l.set("F", s);
        const d = this._getMKDict(r);
        d && l.set("MK", d), n.put(this.ref, {
            data: l,
            xfa: c,
            needAppearances: !1
        });
    }
    async _saveRadioButton(e1, t, i, n) {
        if (!i) return;
        const a = i.get(this.data.id), s = this._buildFlags(a?.noView, a?.noPrint);
        let r = a?.rotation, o = a?.value;
        if (void 0 === r && void 0 === s) {
            if (void 0 === o) return;
            if (this.data.fieldValue === this.data.buttonValue === o) return;
        }
        let l = e1.xref.fetchIfRef(this.ref);
        if (!(l instanceof Dict)) return;
        l = l.clone(), void 0 === o && (o = this.data.fieldValue === this.data.buttonValue), void 0 === r && (r = this.rotation);
        const c = {
            path: this.data.fieldName,
            value: o ? this.data.buttonValue : ""
        }, h = Name.get(o ? this.data.buttonValue : "Off");
        o && this.setValue(l, h, e1.xref, n), l.set("AS", h), l.set("M", `D:${getModificationDate()}`), void 0 !== s && l.set("F", s);
        const d = this._getMKDict(r);
        d && l.set("MK", d), n.put(this.ref, {
            data: l,
            xfa: c,
            needAppearances: !1
        });
    }
    _getDefaultCheckedAppearance(e1, t) {
        const { width: i, height: n } = this, a = [
            0,
            0,
            i,
            n
        ], s = .8 * Math.min(i, n);
        let r, o;
        "check" === t ? (r = {
            width: .755 * s,
            height: .705 * s
        }, o = "3") : "disc" === t ? (r = {
            width: .791 * s,
            height: .705 * s
        }, o = "l") : unreachable$1(`_getDefaultCheckedAppearance - unsupported type: ${t}`);
        const l = `q BT /PdfJsZaDb ${s} Tf 0 g ${numberToString((i - r.width) / 2)} ${numberToString((n - r.height) / 2)} Td (${o}) Tj ET Q`, c = new Dict(e1.xref);
        c.set("FormType", 1), c.setIfName("Subtype", "Form"), c.setIfName("Type", "XObject"), c.set("BBox", a), c.set("Matrix", [
            1,
            0,
            0,
            1,
            0,
            0
        ]), c.set("Length", l.length);
        const h = new Dict(e1.xref), d = new Dict(e1.xref);
        d.set("PdfJsZaDb", this.fallbackFontDict), h.set("Font", d), c.set("Resources", h), this.checkedAppearance = new StringStream(l), this.checkedAppearance.dict = c, this._streams.push(this.checkedAppearance);
    }
    _processCheckBox(e1) {
        const t = e1.dict.get("AP");
        if (!(t instanceof Dict)) return;
        const i = t.get("N");
        if (!(i instanceof Dict)) return;
        const n = this._decodeFormValue(e1.dict.get("AS"));
        "string" == typeof n && (this.data.fieldValue = n);
        const a = null !== this.data.fieldValue && "Off" !== this.data.fieldValue ? this.data.fieldValue : "Yes", s = this._decodeFormValue(i.getKeys());
        if (0 === s.length) s.push("Off", a);
        else if (1 === s.length) "Off" === s[0] ? s.push(a) : s.unshift("Off");
        else if (s.includes(a)) s.length = 0, s.push("Off", a);
        else {
            const e1 = s.find((e1)=>"Off" !== e1);
            s.length = 0, s.push("Off", e1);
        }
        s.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = s[1];
        const r = i.get(this.data.exportValue);
        this.checkedAppearance = r instanceof BaseStream ? r : null;
        const o = i.get("Off");
        this.uncheckedAppearance = o instanceof BaseStream ? o : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e1, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
    }
    _processRadioButton(e1) {
        this.data.buttonValue = null;
        const t = e1.dict.get("Parent");
        if (t instanceof Dict) {
            this.parent = e1.dict.getRaw("Parent");
            const i = t.get("V");
            i instanceof Name && (this.data.fieldValue = this._decodeFormValue(i));
        }
        const i = e1.dict.get("AP");
        if (!(i instanceof Dict)) return;
        const n = i.get("N");
        if (!(n instanceof Dict)) return;
        for (const e1 of n.getKeys())if ("Off" !== e1) {
            this.data.buttonValue = this._decodeFormValue(e1);
            break;
        }
        const a = n.get(this.data.buttonValue);
        this.checkedAppearance = a instanceof BaseStream ? a : null;
        const s = n.get("Off");
        this.uncheckedAppearance = s instanceof BaseStream ? s : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e1, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
    }
    _processPushButton(e1) {
        const { dict: t, annotationGlobals: i } = e1;
        t.has("A") || t.has("AA") || this.data.alternativeText ? (this.data.isTooltipOnly = !t.has("A") && !t.has("AA"), Catalog.parseDestDictionary({
            destDict: t,
            resultObj: this.data,
            docBaseUrl: i.baseUrl,
            docAttachments: i.attachments
        })) : warn$1("Push buttons without action dictionaries are not supported");
    }
    getFieldObject() {
        let e1, t = "button";
        return this.data.checkBox ? (t = "checkbox", e1 = this.data.exportValue) : this.data.radioButton && (t = "radiobutton", e1 = this.data.buttonValue), {
            id: this.data.id,
            value: this.data.fieldValue || "Off",
            defaultValue: this.data.defaultFieldValue,
            exportValues: e1,
            editable: !this.data.readOnly,
            name: this.data.fieldName,
            rect: this.data.rect,
            hidden: this.data.hidden,
            actions: this.data.actions,
            page: this.data.pageIndex,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            rotation: this.rotation,
            type: t
        };
    }
    get fallbackFontDict() {
        const e1 = new Dict;
        return e1.setIfName("BaseFont", "ZapfDingbats"), e1.setIfName("Type", "FallbackType"), e1.setIfName("Subtype", "FallbackType"), e1.setIfName("Encoding", "ZapfDingbatsEncoding"), shadow$1(this, "fallbackFontDict", e1);
    }
}
class ChoiceWidgetAnnotation extends WidgetAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.indices = t.getArray("I"), this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0, this.data.options = [];
        const n = getInheritableProperty({
            dict: t,
            key: "Opt"
        });
        if (Array.isArray(n)) for(let e1 = 0, t = n.length; e1 < t; e1++){
            const t = i.fetchIfRef(n[e1]), a = Array.isArray(t);
            this.data.options[e1] = {
                exportValue: this._decodeFormValue(a ? i.fetchIfRef(t[0]) : t),
                displayValue: this._decodeFormValue(a ? i.fetchIfRef(t[1]) : t)
            };
        }
        if (this.hasIndices) {
            this.data.fieldValue = [];
            const e1 = this.data.options.length;
            for (const t of this.indices)Number.isInteger(t) && t >= 0 && t < e1 && this.data.fieldValue.push(this.data.options[t].exportValue);
        } else "string" == typeof this.data.fieldValue ? this.data.fieldValue = [
            this.data.fieldValue
        ] : this.data.fieldValue ||= [];
        0 === this.data.options.length && this.data.fieldValue.length > 0 && (this.data.options = this.data.fieldValue.map((e1)=>({
                exportValue: e1,
                displayValue: e1
            }))), this.data.combo = this.hasFieldFlag(z), this.data.multiSelect = this.hasFieldFlag(G), this._hasText = !0;
    }
    getFieldObject() {
        const e1 = this.data.combo ? "combobox" : "listbox", t = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
        return {
            id: this.data.id,
            value: t,
            defaultValue: this.data.defaultFieldValue,
            editable: !this.data.readOnly,
            name: this.data.fieldName,
            rect: this.data.rect,
            numItems: this.data.fieldValue.length,
            multipleSelection: this.data.multiSelect,
            hidden: this.data.hidden,
            actions: this.data.actions,
            items: this.data.options,
            page: this.data.pageIndex,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            rotation: this.rotation,
            type: e1
        };
    }
    amendSavedDict(e1, t) {
        if (!this.hasIndices) return;
        let i = e1?.get(this.data.id)?.value;
        Array.isArray(i) || (i = [
            i
        ]);
        const n = [], { options: a } = this.data;
        for(let e1 = 0, t = 0, s = a.length; e1 < s; e1++)a[e1].exportValue === i[t] && (n.push(e1), t += 1);
        t.set("I", n);
    }
    async _getAppearance(e1, t, n, a) {
        if (this.data.combo) return super._getAppearance(e1, t, n, a);
        let s, r;
        const o = a?.get(this.data.id);
        if (o && (r = o.rotation, s = o.value), void 0 === r && void 0 === s && !this._needAppearances) return null;
        void 0 === s ? s = this.data.fieldValue : Array.isArray(s) || (s = [
            s
        ]);
        let { width: l, height: c } = this;
        90 !== r && 270 !== r || ([l, c] = [
            c,
            l
        ]);
        const h = this.data.options.length, d = [];
        for(let e1 = 0; e1 < h; e1++){
            const { exportValue: t } = this.data.options[e1];
            s.includes(t) && d.push(e1);
        }
        this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
        const u = await WidgetAnnotation._getFontData(e1, t, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
        let g, { fontSize: f } = this.data.defaultAppearanceData;
        if (f) g = this._defaultAppearance;
        else {
            const e1 = (c - 1) / h;
            let t, i = -1;
            for (const { displayValue: e1 } of this.data.options){
                const n = this._getTextWidth(e1, u);
                n > i && (i = n, t = e1);
            }
            [g, f] = this._computeFontSize(e1, l - 4, t, u, -1);
        }
        const p = f * i, m = (p - f) / 2, b = Math.floor(c / p);
        let y = 0;
        if (d.length > 0) {
            const e1 = Math.min(...d), t = Math.max(...d);
            y = Math.max(0, t - b + 1), y > e1 && (y = e1);
        }
        const w = Math.min(y + b + 1, h), x = [
            "/Tx BMC q",
            `1 1 ${l} ${c} re W n`
        ];
        if (d.length) {
            x.push("0.600006 0.756866 0.854904 rg");
            for (const e1 of d)y <= e1 && e1 < w && x.push(`1 ${c - (e1 - y + 1) * p} ${l} ${p} re f`);
        }
        x.push("BT", g, `1 0 0 1 0 ${c} Tm`);
        const S = {
            shift: 0
        };
        for(let e1 = y; e1 < w; e1++){
            const { displayValue: t } = this.data.options[e1], i = e1 === y ? m : 0;
            x.push(this._renderText(t, u, f, l, 0, S, 2, -p + i));
        }
        return x.push("ET Q EMC"), x.join("\n");
    }
}
class SignatureWidgetAnnotation extends WidgetAnnotation {
    constructor(e1){
        super(e1), this.data.fieldValue = null, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !this.data.hasOwnCanvas;
    }
    getFieldObject() {
        return {
            id: this.data.id,
            value: null,
            page: this.data.pageIndex,
            type: "signature"
        };
    }
}
class TextAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1), this.data.noRotate = !0, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
        const { dict: t } = e1;
        this.data.annotationType = T.TEXT, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = t.has("Name") ? t.get("Name").name : "Note"), t.has("State") ? (this.data.state = t.get("State") || null, this.data.stateModel = t.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
    }
}
class LinkAnnotation extends Annotation {
    constructor(e1){
        super(e1);
        const { dict: t, annotationGlobals: i } = e1;
        this.data.annotationType = T.LINK, this.data.noHTML = !1;
        const n = getQuadPoints(t, this.rectangle);
        n && (this.data.quadPoints = n), this.data.borderColor ||= this.data.color, Catalog.parseDestDictionary({
            destDict: t,
            resultObj: this.data,
            docBaseUrl: i.baseUrl,
            docAttachments: i.attachments
        });
    }
    get overlaysTextContent() {
        return !0;
    }
}
class PopupAnnotation extends Annotation {
    constructor(e1){
        super(e1);
        const { dict: t } = e1;
        this.data.annotationType = T.POPUP, this.data.noHTML = !1, 0 !== this.width && 0 !== this.height || (this.data.rect = null);
        let i = t.get("Parent");
        if (!i) return void warn$1("Popup annotation has a missing or invalid parent annotation.");
        this.data.parentRect = lookupNormalRect(i.getArray("Rect"), null), this.data.creationDate = i.get("CreationDate") || "";
        if (isName(i.get("RT"), F) && (i = i.get("IRT")), i.has("M") ? (this.setModificationDate(i.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i.has("C") ? (this.setColor(i.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
            const e1 = i.get("F");
            this._isViewable(e1) && this.setFlags(e1);
        }
        this.setTitle(i.get("T")), this.data.titleObj = this._title, this.setContents(i.get("Contents")), this.data.contentsObj = this._contents, i.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(i.get("RC"))), this.data.open = !!t.get("Open");
    }
    static createNewDict(e1, t, i) {
        const { oldAnnotation: n, rect: a, parent: s } = e1, r = n || new Dict(t);
        return r.setIfNotExists("Type", Name.get("Annot")), r.setIfNotExists("Subtype", Name.get("Popup")), r.setIfNotExists("Open", !1), r.setIfArray("Rect", a), r.set("Parent", s), r;
    }
    static async createNewAppearanceStream(e1, t, i) {
        return null;
    }
}
class FreeTextAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1), this.data.hasOwnCanvas = this.data.noRotate, this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1;
        const { annotationGlobals: t, evaluatorOptions: i, xref: n } = e1;
        if (this.data.annotationType = T.FREETEXT, this.setDefaultAppearance(e1), this._hasAppearance = !!this.appearance, this._hasAppearance) {
            const { fontColor: e1, fontSize: a } = function(e1, t, i, n) {
                return new AppearanceStreamEvaluator(e1, t, i, n).parse();
            }(this.appearance, i, n, t.globalColorSpaceCache);
            this.data.defaultAppearanceData.fontColor = e1, this.data.defaultAppearanceData.fontSize = a || 10;
        } else {
            this.data.defaultAppearanceData.fontSize ||= 10;
            const { fontColor: t, fontSize: i } = this.data.defaultAppearanceData;
            if (this._contents.str) {
                this.data.textContent = this._contents.str.split(/\r\n?|\n/).map((e1)=>e1.trimEnd());
                const { coords: e1, bbox: t, matrix: n } = FakeUnicodeFont.getFirstPositionInfo(this.rectangle, this.rotation, i);
                this.data.textPosition = this._transformPoint(e1, t, n);
            }
            if (this._isOffscreenCanvasSupported) {
                const a = e1.dict.get("CA"), s = new FakeUnicodeFont(n, "sans-serif");
                this.appearance = s.createAppearance(this._contents.str, this.rectangle, this.rotation, i, t, a), this._streams.push(this.appearance);
            } else warn$1("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
        }
    }
    get hasTextContent() {
        return this._hasAppearance;
    }
    static createNewDict(e1, t, { apRef: i, ap: n }) {
        const { color: a, date: s, fontSize: r, oldAnnotation: o, rect: l, rotation: c, user: h, value: d } = e1, u = o || new Dict(t);
        u.setIfNotExists("Type", Name.get("Annot")), u.setIfNotExists("Subtype", Name.get("FreeText")), u.set(o ? "M" : "CreationDate", `D:${getModificationDate(s)}`), o && u.delete("RC"), u.setIfArray("Rect", l);
        const g = `/Helv ${r} Tf ${getPdfColor(a, !0)}`;
        if (u.set("DA", g), u.setIfDefined("Contents", stringToAsciiOrUTF16BE(d)), u.setIfNotExists("F", 4), u.setIfNotExists("Border", [
            0,
            0,
            0
        ]), u.setIfNumber("Rotate", c), u.setIfDefined("T", stringToAsciiOrUTF16BE(h)), i || n) {
            const e1 = new Dict(t);
            u.set("AP", e1), e1.set("N", i || n);
        }
        return u;
    }
    static async createNewAppearanceStream(e1, t, n) {
        const { baseFontRef: a, evaluator: s, task: r } = n, { color: o, fontSize: l, rect: c, rotation: h, value: d } = e1;
        if (!o) return null;
        const u = new Dict(t), g = new Dict(t);
        if (a) g.set("Helv", a);
        else {
            const e1 = new Dict(t);
            e1.setIfName("BaseFont", "Helvetica"), e1.setIfName("Type", "Font"), e1.setIfName("Subtype", "Type1"), e1.setIfName("Encoding", "WinAnsiEncoding"), g.set("Helv", e1);
        }
        u.set("Font", g);
        const f = await WidgetAnnotation._getFontData(s, r, {
            fontName: "Helv",
            fontSize: l
        }, u), [p, m, b, y] = c;
        let w = b - p, x = y - m;
        h % 180 != 0 && ([w, x] = [
            x,
            w
        ]);
        const S = d.split("\n"), v = l / 1e3;
        let C = -1 / 0;
        const k = [];
        for (let e1 of S){
            const t = f.encodeString(e1);
            if (t.length > 1) return null;
            e1 = t.join(""), k.push(e1);
            let i = 0;
            const n = f.charsToGlyphs(e1);
            for (const e1 of n)i += e1.width * v;
            C = Math.max(C, i);
        }
        let T = 1;
        C > w && (T = w / C);
        let F = 1;
        const E = i * l, M = 1 * l, D = E * S.length;
        D > x && (F = x / D);
        const O = l * Math.min(T, F);
        let _, R, N;
        switch(h){
            case 0:
                N = [
                    1,
                    0,
                    0,
                    1
                ], R = [
                    c[0],
                    c[1],
                    w,
                    x
                ], _ = [
                    c[0],
                    c[3] - M
                ];
                break;
            case 90:
                N = [
                    0,
                    1,
                    -1,
                    0
                ], R = [
                    c[1],
                    -c[2],
                    w,
                    x
                ], _ = [
                    c[1],
                    -c[0] - M
                ];
                break;
            case 180:
                N = [
                    -1,
                    0,
                    0,
                    -1
                ], R = [
                    -c[2],
                    -c[3],
                    w,
                    x
                ], _ = [
                    -c[2],
                    -c[1] - M
                ];
                break;
            case 270:
                N = [
                    0,
                    -1,
                    1,
                    0
                ], R = [
                    -c[3],
                    c[0],
                    w,
                    x
                ], _ = [
                    -c[3],
                    c[2] - M
                ];
        }
        const L = [
            "q",
            `${N.join(" ")} 0 0 cm`,
            `${R.join(" ")} re W n`,
            "BT",
            `${getPdfColor(o, !0)}`,
            `0 Tc /Helv ${numberToString(O)} Tf`
        ];
        L.push(`${_.join(" ")} Td (${escapeString(k[0])}) Tj`);
        const U = numberToString(E);
        for(let e1 = 1, t = k.length; e1 < t; e1++){
            const t = k[e1];
            L.push(`0 -${U} Td (${escapeString(t)}) Tj`);
        }
        L.push("ET", "Q");
        const j = L.join("\n"), $ = new Dict(t);
        $.set("FormType", 1), $.setIfName("Subtype", "Form"), $.setIfName("Type", "XObject"), $.set("BBox", c), $.set("Resources", u), $.set("Matrix", [
            1,
            0,
            0,
            1,
            -c[0],
            -c[1]
        ]);
        const H = new StringStream(j);
        return H.dict = $, H;
    }
}
class LineAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = T.LINE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
        const n = lookupRect(t.getArray("L"), [
            0,
            0,
            0,
            0
        ]);
        if (this.data.lineCoordinates = ai.normalizeRect(n), this.setLineEndings(t.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
            const e1 = getPdfColorArray(this.color, [
                0,
                0,
                0
            ]), a = t.get("CA"), s = getPdfColorArray(getRgbColor(t.getArray("IC"), null)), r = s ? a : null, o = this.borderStyle.width || 1, l = 2 * o, c = [
                this.data.lineCoordinates[0] - l,
                this.data.lineCoordinates[1] - l,
                this.data.lineCoordinates[2] + l,
                this.data.lineCoordinates[3] + l
            ];
            ai.intersect(this.rectangle, c) || (this.rectangle = c), this._setDefaultAppearance({
                xref: i,
                extra: `${o} w`,
                strokeColor: e1,
                fillColor: s,
                strokeAlpha: a,
                fillAlpha: r,
                pointsCallback: (e1, t)=>(e1.push(`${n[0]} ${n[1]} m`, `${n[2]} ${n[3]} l`, "S"), [
                        t[0] - o,
                        t[7] - o,
                        t[2] + o,
                        t[3] + o
                    ])
            });
        }
    }
}
class SquareAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        if (this.data.annotationType = T.SQUARE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, !this.appearance) {
            const e1 = getPdfColorArray(this.color, [
                0,
                0,
                0
            ]), n = t.get("CA"), a = getPdfColorArray(getRgbColor(t.getArray("IC"), null)), s = a ? n : null;
            if (0 === this.borderStyle.width && !a) return;
            this._setDefaultAppearance({
                xref: i,
                extra: `${this.borderStyle.width} w`,
                strokeColor: e1,
                fillColor: a,
                strokeAlpha: n,
                fillAlpha: s,
                pointsCallback: (e1, t)=>{
                    const i = t[4] + this.borderStyle.width / 2, n = t[5] + this.borderStyle.width / 2, s = t[6] - t[4] - this.borderStyle.width, r = t[3] - t[7] - this.borderStyle.width;
                    return e1.push(`${i} ${n} ${s} ${r} re`), a ? e1.push("B") : e1.push("S"), [
                        t[0],
                        t[7],
                        t[2],
                        t[3]
                    ];
                }
            });
        }
    }
}
class CircleAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        if (this.data.annotationType = T.CIRCLE, !this.appearance) {
            const e1 = getPdfColorArray(this.color, [
                0,
                0,
                0
            ]), n = t.get("CA"), a = getPdfColorArray(getRgbColor(t.getArray("IC"), null)), s = a ? n : null;
            if (0 === this.borderStyle.width && !a) return;
            const r = 4 / 3 * Math.tan(Math.PI / 8);
            this._setDefaultAppearance({
                xref: i,
                extra: `${this.borderStyle.width} w`,
                strokeColor: e1,
                fillColor: a,
                strokeAlpha: n,
                fillAlpha: s,
                pointsCallback: (e1, t)=>{
                    const i = t[0] + this.borderStyle.width / 2, n = t[1] - this.borderStyle.width / 2, s = t[6] - this.borderStyle.width / 2, o = t[7] + this.borderStyle.width / 2, l = i + (s - i) / 2, c = n + (o - n) / 2, h = (s - i) / 2 * r, d = (o - n) / 2 * r;
                    return e1.push(`${l} ${o} m`, `${l + h} ${o} ${s} ${c + d} ${s} ${c} c`, `${s} ${c - d} ${l + h} ${n} ${l} ${n} c`, `${l - h} ${n} ${i} ${c - d} ${i} ${c} c`, `${i} ${c + d} ${l - h} ${o} ${l} ${o} c`, "h"), a ? e1.push("B") : e1.push("S"), [
                        t[0],
                        t[7],
                        t[2],
                        t[3]
                    ];
                }
            });
        }
    }
}
class PolylineAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = T.POLYLINE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, this.data.vertices = null, this instanceof PolygonAnnotation || (this.setLineEndings(t.getArray("LE")), this.data.lineEndings = this.lineEndings);
        const n = t.getArray("Vertices");
        if (!isNumberArray(n, null)) return;
        const a = this.data.vertices = Float32Array.from(n);
        if (!this.appearance) {
            const e1 = getPdfColorArray(this.color, [
                0,
                0,
                0
            ]), n = t.get("CA");
            let s, r = getRgbColor(t.getArray("IC"), null);
            r && (r = getPdfColorArray(r)), s = r ? this.color ? r.every((t, i)=>t === e1[i]) ? "f" : "B" : "f" : "S";
            const o = this.borderStyle.width || 1, l = 2 * o, c = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            for(let e1 = 0, t = a.length; e1 < t; e1 += 2)ai.rectBoundingBox(a[e1] - l, a[e1 + 1] - l, a[e1] + l, a[e1 + 1] + l, c);
            ai.intersect(this.rectangle, c) || (this.rectangle = c), this._setDefaultAppearance({
                xref: i,
                extra: `${o} w`,
                strokeColor: e1,
                strokeAlpha: n,
                fillColor: r,
                fillAlpha: r ? n : null,
                pointsCallback: (e1, t)=>{
                    for(let t = 0, i = a.length; t < i; t += 2)e1.push(`${a[t]} ${a[t + 1]} ${0 === t ? "m" : "l"}`);
                    return e1.push(s), [
                        t[0],
                        t[7],
                        t[2],
                        t[3]
                    ];
                }
            });
        }
    }
}
class PolygonAnnotation extends PolylineAnnotation {
    constructor(e1){
        super(e1), this.data.annotationType = T.POLYGON;
    }
}
class CaretAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1), this.data.annotationType = T.CARET;
    }
}
class InkAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1), this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
        const { dict: t, xref: i } = e1;
        this.data.annotationType = T.INK, this.data.inkLists = [], this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1, this.data.opacity = t.get("CA") || 1;
        const n = t.getArray("InkList");
        if (Array.isArray(n)) {
            for(let e1 = 0, t = n.length; e1 < t; ++e1){
                if (!Array.isArray(n[e1])) continue;
                const t = new Float32Array(n[e1].length);
                this.data.inkLists.push(t);
                for(let a = 0, s = n[e1].length; a < s; a += 2){
                    const s = i.fetchIfRef(n[e1][a]), r = i.fetchIfRef(n[e1][a + 1]);
                    "number" == typeof s && "number" == typeof r && (t[a] = s, t[a + 1] = r);
                }
            }
            if (!this.appearance) {
                const e1 = getPdfColorArray(this.color, [
                    0,
                    0,
                    0
                ]), n = t.get("CA"), a = this.borderStyle.width || 1, s = 2 * a, r = [
                    1 / 0,
                    1 / 0,
                    -1 / 0,
                    -1 / 0
                ];
                for (const e1 of this.data.inkLists)for(let t = 0, i = e1.length; t < i; t += 2)ai.rectBoundingBox(e1[t] - s, e1[t + 1] - s, e1[t] + s, e1[t + 1] + s, r);
                ai.intersect(this.rectangle, r) || (this.rectangle = r), this._setDefaultAppearance({
                    xref: i,
                    extra: `${a} w`,
                    strokeColor: e1,
                    strokeAlpha: n,
                    pointsCallback: (e1, t)=>{
                        for (const t of this.data.inkLists){
                            for(let i = 0, n = t.length; i < n; i += 2)e1.push(`${t[i]} ${t[i + 1]} ${0 === i ? "m" : "l"}`);
                            e1.push("S");
                        }
                        return [
                            t[0],
                            t[7],
                            t[2],
                            t[3]
                        ];
                    }
                });
            }
        }
    }
    static createNewDict(e1, t, { apRef: i, ap: n }) {
        const { oldAnnotation: a, color: s, date: r, opacity: o, paths: l, outlines: c, rect: h, rotation: d, thickness: u, user: g } = e1, f = a || new Dict(t);
        if (f.setIfNotExists("Type", Name.get("Annot")), f.setIfNotExists("Subtype", Name.get("Ink")), f.set(a ? "M" : "CreationDate", `D:${getModificationDate(r)}`), f.setIfArray("Rect", h), f.setIfArray("InkList", c?.points || l?.points), f.setIfNotExists("F", 4), f.setIfNumber("Rotate", d), f.setIfDefined("T", stringToAsciiOrUTF16BE(g)), c && f.setIfName("IT", "InkHighlight"), u > 0) {
            const e1 = new Dict(t);
            f.set("BS", e1), e1.set("W", u);
        }
        if (f.setIfArray("C", getPdfColorArray(s)), f.setIfNumber("CA", o), n || i) {
            const e1 = new Dict(t);
            f.set("AP", e1), e1.set("N", i || n);
        }
        return f;
    }
    static async createNewAppearanceStream(e1, t, i) {
        if (e1.outlines) return this.createNewAppearanceStreamForHighlight(e1, t, i);
        const { color: n, rect: a, paths: s, thickness: r, opacity: o } = e1;
        if (!n) return null;
        const l = [
            `${r} w 1 J 1 j`,
            `${getPdfColor(n, !1)}`
        ];
        1 !== o && l.push("/R0 gs");
        for (const e1 of s.lines){
            l.push(`${numberToString(e1[4])} ${numberToString(e1[5])} m`);
            for(let t = 6, i = e1.length; t < i; t += 6)if (isNaN(e1[t])) l.push(`${numberToString(e1[t + 4])} ${numberToString(e1[t + 5])} l`);
            else {
                const [i, n, a, s, r, o] = e1.slice(t, t + 6);
                l.push([
                    i,
                    n,
                    a,
                    s,
                    r,
                    o
                ].map(numberToString).join(" ") + " c");
            }
            6 === e1.length && l.push(`${numberToString(e1[4])} ${numberToString(e1[5])} l`);
        }
        l.push("S");
        const c = l.join("\n"), h = new Dict(t);
        if (h.set("FormType", 1), h.setIfName("Subtype", "Form"), h.setIfName("Type", "XObject"), h.set("BBox", a), h.set("Length", c.length), 1 !== o) {
            const e1 = new Dict(t), i = new Dict(t), n = new Dict(t);
            n.set("CA", o), n.setIfName("Type", "ExtGState"), i.set("R0", n), e1.set("ExtGState", i), h.set("Resources", e1);
        }
        const d = new StringStream(c);
        return d.dict = h, d;
    }
    static async createNewAppearanceStreamForHighlight(e1, t, i) {
        const { color: n, rect: a, outlines: { outline: s }, opacity: r } = e1;
        if (!n) return null;
        const o = [
            `${getPdfColor(n, !0)}`,
            "/R0 gs"
        ];
        o.push(`${numberToString(s[4])} ${numberToString(s[5])} m`);
        for(let e1 = 6, t = s.length; e1 < t; e1 += 6)if (isNaN(s[e1])) o.push(`${numberToString(s[e1 + 4])} ${numberToString(s[e1 + 5])} l`);
        else {
            const [t, i, n, a, r, l] = s.slice(e1, e1 + 6);
            o.push([
                t,
                i,
                n,
                a,
                r,
                l
            ].map(numberToString).join(" ") + " c");
        }
        o.push("h f");
        const l = o.join("\n"), c = new Dict(t);
        c.set("FormType", 1), c.setIfName("Subtype", "Form"), c.setIfName("Type", "XObject"), c.set("BBox", a), c.set("Length", l.length);
        const h = new Dict(t), d = new Dict(t);
        h.set("ExtGState", d), c.set("Resources", h);
        const u = new Dict(t);
        d.set("R0", u), u.setIfName("BM", "Multiply"), 1 !== r && (u.set("ca", r), u.setIfName("Type", "ExtGState"));
        const g = new StringStream(l);
        return g.dict = c, g;
    }
}
class HighlightAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = T.HIGHLIGHT, this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1, this.data.opacity = t.get("CA") || 1;
        if (this.data.quadPoints = getQuadPoints(t, null)) {
            const e1 = this.appearance?.dict.get("Resources");
            if (!this.appearance || !e1?.has("ExtGState")) {
                this.appearance && warn$1("HighlightAnnotation - ignoring built-in appearance stream.");
                const e1 = getPdfColorArray(this.color, [
                    1,
                    1,
                    0
                ]), n = t.get("CA");
                this._setDefaultAppearance({
                    xref: i,
                    fillColor: e1,
                    blendMode: "Multiply",
                    fillAlpha: n,
                    pointsCallback: (e1, t)=>(e1.push(`${t[0]} ${t[1]} m`, `${t[2]} ${t[3]} l`, `${t[6]} ${t[7]} l`, `${t[4]} ${t[5]} l`, "f"), [
                            t[0],
                            t[7],
                            t[2],
                            t[3]
                        ])
                });
            }
        } else this.data.popupRef = null;
    }
    get overlaysTextContent() {
        return !0;
    }
    static createNewDict(e1, t, { apRef: i, ap: n }) {
        const { color: a, date: s, oldAnnotation: r, opacity: o, rect: l, rotation: c, user: h, quadPoints: d } = e1, u = r || new Dict(t);
        if (u.setIfNotExists("Type", Name.get("Annot")), u.setIfNotExists("Subtype", Name.get("Highlight")), u.set(r ? "M" : "CreationDate", `D:${getModificationDate(s)}`), u.setIfArray("Rect", l), u.setIfNotExists("F", 4), u.setIfNotExists("Border", [
            0,
            0,
            0
        ]), u.setIfNumber("Rotate", c), u.setIfArray("QuadPoints", d), u.setIfArray("C", getPdfColorArray(a)), u.setIfNumber("CA", o), u.setIfDefined("T", stringToAsciiOrUTF16BE(h)), i || n) {
            const e1 = new Dict(t);
            u.set("AP", e1), e1.set("N", i || n);
        }
        return u;
    }
    static async createNewAppearanceStream(e1, t, i) {
        const { color: n, rect: a, outlines: s, opacity: r } = e1;
        if (!n) return null;
        const o = [
            `${getPdfColor(n, !0)}`,
            "/R0 gs"
        ], l = [];
        for (const e1 of s){
            l.length = 0, l.push(`${numberToString(e1[0])} ${numberToString(e1[1])} m`);
            for(let t = 2, i = e1.length; t < i; t += 2)l.push(`${numberToString(e1[t])} ${numberToString(e1[t + 1])} l`);
            l.push("h"), o.push(l.join("\n"));
        }
        o.push("f*");
        const c = o.join("\n"), h = new Dict(t);
        h.set("FormType", 1), h.setIfName("Subtype", "Form"), h.setIfName("Type", "XObject"), h.set("BBox", a), h.set("Length", c.length);
        const d = new Dict(t), u = new Dict(t);
        d.set("ExtGState", u), h.set("Resources", d);
        const g = new Dict(t);
        u.set("R0", g), g.setIfName("BM", "Multiply"), 1 !== r && (g.set("ca", r), g.setIfName("Type", "ExtGState"));
        const f = new StringStream(c);
        return f.dict = h, f;
    }
}
class UnderlineAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = T.UNDERLINE;
        if (this.data.quadPoints = getQuadPoints(t, null)) {
            if (!this.appearance) {
                const e1 = getPdfColorArray(this.color, [
                    0,
                    0,
                    0
                ]), n = t.get("CA");
                this._setDefaultAppearance({
                    xref: i,
                    extra: "[] 0 d 0.571 w",
                    strokeColor: e1,
                    strokeAlpha: n,
                    pointsCallback: (e1, t)=>(e1.push(`${t[4]} ${t[5] + 1.3} m`, `${t[6]} ${t[7] + 1.3} l`, "S"), [
                            t[0],
                            t[7],
                            t[2],
                            t[3]
                        ])
                });
            }
        } else this.data.popupRef = null;
    }
    get overlaysTextContent() {
        return !0;
    }
}
class SquigglyAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = T.SQUIGGLY;
        if (this.data.quadPoints = getQuadPoints(t, null)) {
            if (!this.appearance) {
                const e1 = getPdfColorArray(this.color, [
                    0,
                    0,
                    0
                ]), n = t.get("CA");
                this._setDefaultAppearance({
                    xref: i,
                    extra: "[] 0 d 1 w",
                    strokeColor: e1,
                    strokeAlpha: n,
                    pointsCallback: (e1, t)=>{
                        const i = (t[1] - t[5]) / 6;
                        let n = i, a = t[4];
                        const s = t[5], r = t[6];
                        e1.push(`${a} ${s + n} m`);
                        do {
                            a += 2, n = 0 === n ? i : 0, e1.push(`${a} ${s + n} l`);
                        }while (a < r)
                        return e1.push("S"), [
                            t[4],
                            s - 2 * i,
                            r,
                            s + 2 * i
                        ];
                    }
                });
            }
        } else this.data.popupRef = null;
    }
    get overlaysTextContent() {
        return !0;
    }
}
class StrikeOutAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1;
        this.data.annotationType = T.STRIKEOUT;
        if (this.data.quadPoints = getQuadPoints(t, null)) {
            if (!this.appearance) {
                const e1 = getPdfColorArray(this.color, [
                    0,
                    0,
                    0
                ]), n = t.get("CA");
                this._setDefaultAppearance({
                    xref: i,
                    extra: "[] 0 d 1 w",
                    strokeColor: e1,
                    strokeAlpha: n,
                    pointsCallback: (e1, t)=>(e1.push((t[0] + t[4]) / 2 + " " + (t[1] + t[5]) / 2 + " m", (t[2] + t[6]) / 2 + " " + (t[3] + t[7]) / 2 + " l", "S"), [
                            t[0],
                            t[7],
                            t[2],
                            t[3]
                        ])
                });
            }
        } else this.data.popupRef = null;
    }
    get overlaysTextContent() {
        return !0;
    }
}
class StampAnnotation extends MarkupAnnotation {
    #ke = null;
    constructor(e1){
        super(e1), this.data.annotationType = T.STAMP, this.data.hasOwnCanvas = this.data.noRotate, this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1;
    }
    mustBeViewedWhenEditing(e1, t = null) {
        return e1 ? !this.data.isEditable || (this.#ke ??= this.data.hasOwnCanvas, this.data.hasOwnCanvas = !0, !0) : (null !== this.#ke && (this.data.hasOwnCanvas = this.#ke, this.#ke = null), !t?.has(this.data.id));
    }
    static async createImage(e1, t) {
        const { width: i, height: n } = e1, a = new OffscreenCanvas(i, n), s = a.getContext("2d", {
            alpha: !0
        });
        s.drawImage(e1, 0, 0);
        const r = s.getImageData(0, 0, i, n).data, o = new Uint32Array(r.buffer), l = o.some(FeatureTest.isLittleEndian ? (e1)=>e1 >>> 24 != 255 : (e1)=>!!(255 & ~e1));
        l && (s.fillStyle = "white", s.fillRect(0, 0, i, n), s.drawImage(e1, 0, 0));
        const c = a.convertToBlob({
            type: "image/jpeg",
            quality: 1
        }).then((e1)=>e1.arrayBuffer()), h = Name.get("XObject"), d = Name.get("Image"), u = new Dict(t);
        u.set("Type", h), u.set("Subtype", d), u.set("BitsPerComponent", 8), u.setIfName("ColorSpace", "DeviceRGB"), u.setIfName("Filter", "DCTDecode"), u.set("BBox", [
            0,
            0,
            i,
            n
        ]), u.set("Width", i), u.set("Height", n);
        let g = null;
        if (l) {
            const e1 = new Uint8Array(o.length);
            if (FeatureTest.isLittleEndian) for(let t = 0, i = o.length; t < i; t++)e1[t] = o[t] >>> 24;
            else for(let t = 0, i = o.length; t < i; t++)e1[t] = 255 & o[t];
            const a = new Dict(t);
            a.set("Type", h), a.set("Subtype", d), a.set("BitsPerComponent", 8), a.setIfName("ColorSpace", "DeviceGray"), a.set("Width", i), a.set("Height", n), g = new Stream(e1, 0, 0, a);
        }
        return {
            imageStream: new Stream(await c, 0, 0, u),
            smaskStream: g,
            width: i,
            height: n
        };
    }
    static createNewDict(e1, t, { apRef: i, ap: n }) {
        const { date: a, oldAnnotation: s, rect: r, rotation: o, user: l } = e1, c = s || new Dict(t);
        if (c.setIfNotExists("Type", Name.get("Annot")), c.setIfNotExists("Subtype", Name.get("Stamp")), c.set(s ? "M" : "CreationDate", `D:${getModificationDate(a)}`), c.setIfArray("Rect", r), c.setIfNotExists("F", 4), c.setIfNotExists("Border", [
            0,
            0,
            0
        ]), c.setIfNumber("Rotate", o), c.setIfDefined("T", stringToAsciiOrUTF16BE(l)), i || n) {
            const e1 = new Dict(t);
            c.set("AP", e1), e1.set("N", i || n);
        }
        return c;
    }
    static async #Te(e1, t) {
        const { areContours: i, color: n, rect: a, lines: s, thickness: r } = e1;
        if (!n) return null;
        const o = [
            `${r} w 1 J 1 j`,
            `${getPdfColor(n, i)}`
        ];
        for (const e1 of s){
            o.push(`${numberToString(e1[4])} ${numberToString(e1[5])} m`);
            for(let t = 6, i = e1.length; t < i; t += 6)if (isNaN(e1[t])) o.push(`${numberToString(e1[t + 4])} ${numberToString(e1[t + 5])} l`);
            else {
                const [i, n, a, s, r, l] = e1.slice(t, t + 6);
                o.push([
                    i,
                    n,
                    a,
                    s,
                    r,
                    l
                ].map(numberToString).join(" ") + " c");
            }
            6 === e1.length && o.push(`${numberToString(e1[4])} ${numberToString(e1[5])} l`);
        }
        o.push(i ? "F" : "S");
        const l = o.join("\n"), c = new Dict(t);
        c.set("FormType", 1), c.setIfName("Subtype", "Form"), c.setIfName("Type", "XObject"), c.set("BBox", a), c.set("Length", l.length);
        const h = new StringStream(l);
        return h.dict = c, h;
    }
    static async createNewAppearanceStream(e1, t, i) {
        if (e1.oldAnnotation) return null;
        if (e1.isSignature) return this.#Te(e1, t);
        const { rotation: n } = e1, { imageRef: a, width: s, height: r } = i.image, o = new Dict(t), l = new Dict(t);
        o.set("XObject", l), l.set("Im0", a);
        const c = `q ${s} 0 0 ${r} 0 0 cm /Im0 Do Q`, h = new Dict(t);
        if (h.set("FormType", 1), h.setIfName("Subtype", "Form"), h.setIfName("Type", "XObject"), h.set("BBox", [
            0,
            0,
            s,
            r
        ]), h.set("Resources", o), n) {
            const e1 = getRotationMatrix(n, s, r);
            h.set("Matrix", e1);
        }
        const d = new StringStream(c);
        return d.dict = h, d;
    }
}
class FileAttachmentAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: i } = e1, n = new FileSpec(t.get("FS"), i);
        this.data.annotationType = T.FILEATTACHMENT, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, this.data.file = n.serializable;
        const a = t.get("Name");
        this.data.name = a instanceof Name ? stringToPDFString(a.name) : "PushPin";
        const s = t.get("ca");
        this.data.fillAlpha = "number" == typeof s && s >= 0 && s <= 1 ? s : null;
    }
}
const cl = {
    get r () {
        return shadow$1(this, "r", new Uint8Array([
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21
        ]));
    },
    get k () {
        return shadow$1(this, "k", new Int32Array([
            -680876936,
            -389564586,
            606105819,
            -1044525330,
            -176418897,
            1200080426,
            -1473231341,
            -45705983,
            1770035416,
            -1958414417,
            -42063,
            -1990404162,
            1804603682,
            -40341101,
            -1502002290,
            1236535329,
            -165796510,
            -1069501632,
            643717713,
            -373897302,
            -701558691,
            38016083,
            -660478335,
            -405537848,
            568446438,
            -1019803690,
            -187363961,
            1163531501,
            -1444681467,
            -51403784,
            1735328473,
            -1926607734,
            -378558,
            -2022574463,
            1839030562,
            -35309556,
            -1530992060,
            1272893353,
            -155497632,
            -1094730640,
            681279174,
            -358537222,
            -722521979,
            76029189,
            -640364487,
            -421815835,
            530742520,
            -995338651,
            -198630844,
            1126891415,
            -1416354905,
            -57434055,
            1700485571,
            -1894986606,
            -1051523,
            -2054922799,
            1873313359,
            -30611744,
            -1560198380,
            1309151649,
            -145523070,
            -1120210379,
            718787259,
            -343485551
        ]));
    }
};
function calculateMD5(e1, t, i) {
    let n = 1732584193, a = -271733879, s = -1732584194, r = 271733878;
    const o = i + 72 & -64, l = new Uint8Array(o);
    let c, h;
    for(c = 0; c < i; ++c)l[c] = e1[t++];
    l[c++] = 128;
    const d = o - 8;
    c < d && (c = d), l[c++] = i << 3 & 255, l[c++] = i >> 5 & 255, l[c++] = i >> 13 & 255, l[c++] = i >> 21 & 255, l[c++] = i >>> 29 & 255, c += 3;
    const u = new Int32Array(16), { k: g, r: f } = cl;
    for(c = 0; c < o;){
        for(h = 0; h < 16; ++h, c += 4)u[h] = l[c] | l[c + 1] << 8 | l[c + 2] << 16 | l[c + 3] << 24;
        let e1, t, i = n, o = a, d = s, p = r;
        for(h = 0; h < 64; ++h){
            h < 16 ? (e1 = o & d | ~o & p, t = h) : h < 32 ? (e1 = p & o | ~p & d, t = 5 * h + 1 & 15) : h < 48 ? (e1 = o ^ d ^ p, t = 3 * h + 5 & 15) : (e1 = d ^ (o | ~p), t = 7 * h & 15);
            const n = p, a = i + e1 + g[h] + u[t] | 0, s = f[h];
            p = d, d = o, o = o + (a << s | a >>> 32 - s) | 0, i = n;
        }
        n = n + i | 0, a = a + o | 0, s = s + d | 0, r = r + p | 0;
    }
    return new Uint8Array([
        255 & n,
        n >> 8 & 255,
        n >> 16 & 255,
        n >>> 24 & 255,
        255 & a,
        a >> 8 & 255,
        a >> 16 & 255,
        a >>> 24 & 255,
        255 & s,
        s >> 8 & 255,
        s >> 16 & 255,
        s >>> 24 & 255,
        255 & r,
        r >> 8 & 255,
        r >> 16 & 255,
        r >>> 24 & 255
    ]);
}
function decodeString(e1) {
    try {
        return stringToUTF8String$1(e1);
    } catch (t) {
        return warn$1(`UTF-8 decoding failed: "${t}".`), e1;
    }
}
class DatasetXMLParser extends SimpleXMLParser {
    constructor(e1){
        super(e1), this.node = null;
    }
    onEndElement(e1) {
        const t = super.onEndElement(e1);
        if (t && "xfa:datasets" === e1) throw this.node = t, new Error("Aborting DatasetXMLParser.");
    }
}
class DatasetReader {
    constructor(e1){
        if (e1.datasets) this.node = new SimpleXMLParser({
            hasAttributes: !0
        }).parseFromString(e1.datasets).documentElement;
        else {
            const t = new DatasetXMLParser({
                hasAttributes: !0
            });
            try {
                t.parseFromString(e1["xdp:xdp"]);
            } catch  {}
            this.node = t.node;
        }
    }
    getValue(e1) {
        if (!this.node || !e1) return "";
        const t = this.node.searchNode(parseXFAPath(e1), 0);
        if (!t) return "";
        const i = t.firstChild;
        return "value" === i?.nodeName ? t.children.map((e1)=>decodeString(e1.textContent)) : decodeString(t.textContent);
    }
}
class SingleIntersector {
    #Fe;
    #Ie = 1 / 0;
    #Ee = 1 / 0;
    #Me = -1 / 0;
    #De = -1 / 0;
    #Oe = null;
    #_e = [];
    #Pe = [];
    #Re = -1;
    #Be = !1;
    constructor(e1){
        this.#Fe = e1;
        const t = e1.data.quadPoints;
        if (t) {
            for(let e1 = 0, i = t.length; e1 < i; e1 += 8)this.#Ie = Math.min(this.#Ie, t[e1]), this.#Me = Math.max(this.#Me, t[e1 + 2]), this.#Ee = Math.min(this.#Ee, t[e1 + 5]), this.#De = Math.max(this.#De, t[e1 + 1]);
            t.length > 8 && (this.#Oe = t);
        } else [this.#Ie, this.#Ee, this.#Me, this.#De] = e1.data.rect;
    }
    overlaps(e1) {
        return !(this.#Ie >= e1.#Me || this.#Me <= e1.#Ie || this.#Ee >= e1.#De || this.#De <= e1.#Ee);
    }
    #Ne(e1, t) {
        if (this.#Ie >= e1 || this.#Me <= e1 || this.#Ee >= t || this.#De <= t) return !1;
        const i = this.#Oe;
        if (!i) return !0;
        if (this.#Re >= 0) {
            const n = this.#Re;
            if (!(i[n] >= e1 || i[n + 2] <= e1 || i[n + 5] >= t || i[n + 1] <= t)) return !0;
            this.#Re = -1;
        }
        for(let n = 0, a = i.length; n < a; n += 8)if (!(i[n] >= e1 || i[n + 2] <= e1 || i[n + 5] >= t || i[n + 1] <= t)) return this.#Re = n, !0;
        return !1;
    }
    addGlyph(e1, t, i) {
        return this.#Ne(e1, t) ? (this.#Pe.length > 0 && (this.#_e.push(this.#Pe.join("")), this.#Pe.length = 0), this.#_e.push(i), this.#Be = !0, !0) : (this.disableExtraChars(), !1);
    }
    addExtraChar(e1) {
        this.#Be && this.#Pe.push(e1);
    }
    disableExtraChars() {
        this.#Be && (this.#Be = !1, this.#Pe.length = 0);
    }
    setText() {
        this.#Fe.data.overlaidText = this.#_e.join("");
    }
}
class Intersector {
    #Le = new Map;
    constructor(e1){
        for (const t of e1){
            if (!t.data.quadPoints && !t.data.rect) continue;
            const e1 = new SingleIntersector(t);
            for (const [t, i] of this.#Le)t.overlaps(e1) && (i ? i.add(e1) : this.#Le.set(t, new Set([
                e1
            ])));
            this.#Le.set(e1, null);
        }
    }
    addGlyph(e1, t, i, n) {
        const a = e1[4] + t / 2, s = e1[5] + i / 2;
        let r;
        for (const [e1, t] of this.#Le)r ? r.has(e1) ? e1.addGlyph(a, s, n) : e1.disableExtraChars() : e1.addGlyph(a, s, n) && (r = t);
    }
    addExtraChar(e1) {
        for (const t of this.#Le.keys())t.addExtraChar(e1);
    }
    setText() {
        for (const e1 of this.#Le.keys())e1.setText();
    }
}
class Word64 {
    constructor(e1, t){
        this.high = 0 | e1, this.low = 0 | t;
    }
    and(e1) {
        this.high &= e1.high, this.low &= e1.low;
    }
    xor(e1) {
        this.high ^= e1.high, this.low ^= e1.low;
    }
    shiftRight(e1) {
        e1 >= 32 ? (this.low = this.high >>> e1 - 32 | 0, this.high = 0) : (this.low = this.low >>> e1 | this.high << 32 - e1, this.high = this.high >>> e1 | 0);
    }
    rotateRight(e1) {
        let t, i;
        32 & e1 ? (i = this.low, t = this.high) : (t = this.low, i = this.high), e1 &= 31, this.low = t >>> e1 | i << 32 - e1, this.high = i >>> e1 | t << 32 - e1;
    }
    not() {
        this.high = ~this.high, this.low = ~this.low;
    }
    add(e1) {
        const t = (this.low >>> 0) + (e1.low >>> 0);
        let i = (this.high >>> 0) + (e1.high >>> 0);
        t > 4294967295 && (i += 1), this.low = 0 | t, this.high = 0 | i;
    }
    copyTo(e1, t) {
        e1[t] = this.high >>> 24 & 255, e1[t + 1] = this.high >> 16 & 255, e1[t + 2] = this.high >> 8 & 255, e1[t + 3] = 255 & this.high, e1[t + 4] = this.low >>> 24 & 255, e1[t + 5] = this.low >> 16 & 255, e1[t + 6] = this.low >> 8 & 255, e1[t + 7] = 255 & this.low;
    }
    assign(e1) {
        this.high = e1.high, this.low = e1.low;
    }
}
const hl = {
    get k () {
        return shadow$1(this, "k", [
            new Word64(1116352408, 3609767458),
            new Word64(1899447441, 602891725),
            new Word64(3049323471, 3964484399),
            new Word64(3921009573, 2173295548),
            new Word64(961987163, 4081628472),
            new Word64(1508970993, 3053834265),
            new Word64(2453635748, 2937671579),
            new Word64(2870763221, 3664609560),
            new Word64(3624381080, 2734883394),
            new Word64(310598401, 1164996542),
            new Word64(607225278, 1323610764),
            new Word64(1426881987, 3590304994),
            new Word64(1925078388, 4068182383),
            new Word64(2162078206, 991336113),
            new Word64(2614888103, 633803317),
            new Word64(3248222580, 3479774868),
            new Word64(3835390401, 2666613458),
            new Word64(4022224774, 944711139),
            new Word64(264347078, 2341262773),
            new Word64(604807628, 2007800933),
            new Word64(770255983, 1495990901),
            new Word64(1249150122, 1856431235),
            new Word64(1555081692, 3175218132),
            new Word64(1996064986, 2198950837),
            new Word64(2554220882, 3999719339),
            new Word64(2821834349, 766784016),
            new Word64(2952996808, 2566594879),
            new Word64(3210313671, 3203337956),
            new Word64(3336571891, 1034457026),
            new Word64(3584528711, 2466948901),
            new Word64(113926993, 3758326383),
            new Word64(338241895, 168717936),
            new Word64(666307205, 1188179964),
            new Word64(773529912, 1546045734),
            new Word64(1294757372, 1522805485),
            new Word64(1396182291, 2643833823),
            new Word64(1695183700, 2343527390),
            new Word64(1986661051, 1014477480),
            new Word64(2177026350, 1206759142),
            new Word64(2456956037, 344077627),
            new Word64(2730485921, 1290863460),
            new Word64(2820302411, 3158454273),
            new Word64(3259730800, 3505952657),
            new Word64(3345764771, 106217008),
            new Word64(3516065817, 3606008344),
            new Word64(3600352804, 1432725776),
            new Word64(4094571909, 1467031594),
            new Word64(275423344, 851169720),
            new Word64(430227734, 3100823752),
            new Word64(506948616, 1363258195),
            new Word64(659060556, 3750685593),
            new Word64(883997877, 3785050280),
            new Word64(958139571, 3318307427),
            new Word64(1322822218, 3812723403),
            new Word64(1537002063, 2003034995),
            new Word64(1747873779, 3602036899),
            new Word64(1955562222, 1575990012),
            new Word64(2024104815, 1125592928),
            new Word64(2227730452, 2716904306),
            new Word64(2361852424, 442776044),
            new Word64(2428436474, 593698344),
            new Word64(2756734187, 3733110249),
            new Word64(3204031479, 2999351573),
            new Word64(3329325298, 3815920427),
            new Word64(3391569614, 3928383900),
            new Word64(3515267271, 566280711),
            new Word64(3940187606, 3454069534),
            new Word64(4118630271, 4000239992),
            new Word64(116418474, 1914138554),
            new Word64(174292421, 2731055270),
            new Word64(289380356, 3203993006),
            new Word64(460393269, 320620315),
            new Word64(685471733, 587496836),
            new Word64(852142971, 1086792851),
            new Word64(1017036298, 365543100),
            new Word64(1126000580, 2618297676),
            new Word64(1288033470, 3409855158),
            new Word64(1501505948, 4234509866),
            new Word64(1607167915, 987167468),
            new Word64(1816402316, 1246189591)
        ]);
    }
};
function ch(e1, t, i, n, a) {
    e1.assign(t), e1.and(i), a.assign(t), a.not(), a.and(n), e1.xor(a);
}
function maj(e1, t, i, n, a) {
    e1.assign(t), e1.and(i), a.assign(t), a.and(n), e1.xor(a), a.assign(i), a.and(n), e1.xor(a);
}
function sigma(e1, t, i) {
    e1.assign(t), e1.rotateRight(28), i.assign(t), i.rotateRight(34), e1.xor(i), i.assign(t), i.rotateRight(39), e1.xor(i);
}
function sigmaPrime(e1, t, i) {
    e1.assign(t), e1.rotateRight(14), i.assign(t), i.rotateRight(18), e1.xor(i), i.assign(t), i.rotateRight(41), e1.xor(i);
}
function littleSigma(e1, t, i) {
    e1.assign(t), e1.rotateRight(1), i.assign(t), i.rotateRight(8), e1.xor(i), i.assign(t), i.shiftRight(7), e1.xor(i);
}
function littleSigmaPrime(e1, t, i) {
    e1.assign(t), e1.rotateRight(19), i.assign(t), i.rotateRight(61), e1.xor(i), i.assign(t), i.shiftRight(6), e1.xor(i);
}
function calculateSHA512(e1, t, i, n = !1) {
    let a, s, r, o, l, c, h, d;
    n ? (a = new Word64(3418070365, 3238371032), s = new Word64(1654270250, 914150663), r = new Word64(2438529370, 812702999), o = new Word64(355462360, 4144912697), l = new Word64(1731405415, 4290775857), c = new Word64(2394180231, 1750603025), h = new Word64(3675008525, 1694076839), d = new Word64(1203062813, 3204075428)) : (a = new Word64(1779033703, 4089235720), s = new Word64(3144134277, 2227873595), r = new Word64(1013904242, 4271175723), o = new Word64(2773480762, 1595750129), l = new Word64(1359893119, 2917565137), c = new Word64(2600822924, 725511199), h = new Word64(528734635, 4215389547), d = new Word64(1541459225, 327033209));
    const u = 128 * Math.ceil((i + 17) / 128), g = new Uint8Array(u);
    let f, p;
    for(f = 0; f < i; ++f)g[f] = e1[t++];
    g[f++] = 128;
    const m = u - 16;
    f < m && (f = m), f += 11, g[f++] = i >>> 29 & 255, g[f++] = i >> 21 & 255, g[f++] = i >> 13 & 255, g[f++] = i >> 5 & 255, g[f++] = i << 3 & 255;
    const b = new Array(80);
    for(f = 0; f < 80; f++)b[f] = new Word64(0, 0);
    const { k: y } = hl;
    let w = new Word64(0, 0), x = new Word64(0, 0), S = new Word64(0, 0), v = new Word64(0, 0), C = new Word64(0, 0), k = new Word64(0, 0), T = new Word64(0, 0), F = new Word64(0, 0);
    const E = new Word64(0, 0), M = new Word64(0, 0), D = new Word64(0, 0), O = new Word64(0, 0);
    let _, R;
    for(f = 0; f < u;){
        for(p = 0; p < 16; ++p)b[p].high = g[f] << 24 | g[f + 1] << 16 | g[f + 2] << 8 | g[f + 3], b[p].low = g[f + 4] << 24 | g[f + 5] << 16 | g[f + 6] << 8 | g[f + 7], f += 8;
        for(p = 16; p < 80; ++p)_ = b[p], littleSigmaPrime(_, b[p - 2], O), _.add(b[p - 7]), littleSigma(D, b[p - 15], O), _.add(D), _.add(b[p - 16]);
        for(w.assign(a), x.assign(s), S.assign(r), v.assign(o), C.assign(l), k.assign(c), T.assign(h), F.assign(d), p = 0; p < 80; ++p)E.assign(F), sigmaPrime(D, C, O), E.add(D), ch(D, C, k, T, O), E.add(D), E.add(y[p]), E.add(b[p]), sigma(M, w, O), maj(D, w, x, S, O), M.add(D), _ = F, F = T, T = k, k = C, v.add(E), C = v, v = S, S = x, x = w, _.assign(E), _.add(M), w = _;
        a.add(w), s.add(x), r.add(S), o.add(v), l.add(C), c.add(k), h.add(T), d.add(F);
    }
    return n ? (R = new Uint8Array(48), a.copyTo(R, 0), s.copyTo(R, 8), r.copyTo(R, 16), o.copyTo(R, 24), l.copyTo(R, 32), c.copyTo(R, 40)) : (R = new Uint8Array(64), a.copyTo(R, 0), s.copyTo(R, 8), r.copyTo(R, 16), o.copyTo(R, 24), l.copyTo(R, 32), c.copyTo(R, 40), h.copyTo(R, 48), d.copyTo(R, 56)), R;
}
function calculateSHA384(e1, t, i) {
    return calculateSHA512(e1, t, i, !0);
}
const dl = {
    get k () {
        return shadow$1(this, "k", [
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
        ]);
    }
};
function rotr(e1, t) {
    return e1 >>> t | e1 << 32 - t;
}
function calculate_sha256_ch(e1, t, i) {
    return e1 & t ^ ~e1 & i;
}
function calculate_sha256_maj(e1, t, i) {
    return e1 & t ^ e1 & i ^ t & i;
}
function calculate_sha256_sigma(e1) {
    return rotr(e1, 2) ^ rotr(e1, 13) ^ rotr(e1, 22);
}
function calculate_sha256_sigmaPrime(e1) {
    return rotr(e1, 6) ^ rotr(e1, 11) ^ rotr(e1, 25);
}
function calculate_sha256_littleSigma(e1) {
    return rotr(e1, 7) ^ rotr(e1, 18) ^ e1 >>> 3;
}
function calculate_sha256_littleSigmaPrime(e1) {
    return rotr(e1, 17) ^ rotr(e1, 19) ^ e1 >>> 10;
}
function calculateSHA256(e1, t, i) {
    let n = 1779033703, a = 3144134277, s = 1013904242, r = 2773480762, o = 1359893119, l = 2600822924, c = 528734635, h = 1541459225;
    const d = 64 * Math.ceil((i + 9) / 64), u = new Uint8Array(d);
    let g, f;
    for(g = 0; g < i; ++g)u[g] = e1[t++];
    u[g++] = 128;
    const p = d - 8;
    g < p && (g = p), g += 3, u[g++] = i >>> 29 & 255, u[g++] = i >> 21 & 255, u[g++] = i >> 13 & 255, u[g++] = i >> 5 & 255, u[g++] = i << 3 & 255;
    const m = new Uint32Array(64), { k: b } = dl;
    for(g = 0; g < d;){
        for(f = 0; f < 16; ++f)m[f] = u[g] << 24 | u[g + 1] << 16 | u[g + 2] << 8 | u[g + 3], g += 4;
        for(f = 16; f < 64; ++f)m[f] = calculate_sha256_littleSigmaPrime(m[f - 2]) + m[f - 7] + calculate_sha256_littleSigma(m[f - 15]) + m[f - 16] | 0;
        let e1, t, i = n, d = a, p = s, y = r, w = o, x = l, S = c, v = h;
        for(f = 0; f < 64; ++f)e1 = v + calculate_sha256_sigmaPrime(w) + calculate_sha256_ch(w, x, S) + b[f] + m[f], t = calculate_sha256_sigma(i) + calculate_sha256_maj(i, d, p), v = S, S = x, x = w, w = y + e1 | 0, y = p, p = d, d = i, i = e1 + t | 0;
        n = n + i | 0, a = a + d | 0, s = s + p | 0, r = r + y | 0, o = o + w | 0, l = l + x | 0, c = c + S | 0, h = h + v | 0;
    }
    return new Uint8Array([
        n >> 24 & 255,
        n >> 16 & 255,
        n >> 8 & 255,
        255 & n,
        a >> 24 & 255,
        a >> 16 & 255,
        a >> 8 & 255,
        255 & a,
        s >> 24 & 255,
        s >> 16 & 255,
        s >> 8 & 255,
        255 & s,
        r >> 24 & 255,
        r >> 16 & 255,
        r >> 8 & 255,
        255 & r,
        o >> 24 & 255,
        o >> 16 & 255,
        o >> 8 & 255,
        255 & o,
        l >> 24 & 255,
        l >> 16 & 255,
        l >> 8 & 255,
        255 & l,
        c >> 24 & 255,
        c >> 16 & 255,
        c >> 8 & 255,
        255 & c,
        h >> 24 & 255,
        h >> 16 & 255,
        h >> 8 & 255,
        255 & h
    ]);
}
class DecryptStream extends DecodeStream {
    constructor(e1, t, i){
        super(t), this.str = e1, this.dict = e1.dict, this.decrypt = i, this.nextChunk = null, this.initialized = !1;
    }
    readBlock() {
        let e1;
        if (this.initialized ? e1 = this.nextChunk : (e1 = this.str.getBytes(512), this.initialized = !0), !e1?.length) return void (this.eof = !0);
        this.nextChunk = this.str.getBytes(512);
        const t = this.nextChunk?.length > 0;
        e1 = (0, this.decrypt)(e1, !t);
        const i = this.bufferLength, n = i + e1.length;
        this.ensureBuffer(n).set(e1, i), this.bufferLength = n;
    }
}
class ARCFourCipher {
    constructor(e1){
        this.a = 0, this.b = 0;
        const t = new Uint8Array(256), i = e1.length;
        for(let e1 = 0; e1 < 256; ++e1)t[e1] = e1;
        for(let n = 0, a = 0; n < 256; ++n){
            const s = t[n];
            a = a + s + e1[n % i] & 255, t[n] = t[a], t[a] = s;
        }
        this.s = t;
    }
    encryptBlock(e1) {
        let t = this.a, i = this.b;
        const n = this.s, a = e1.length, s = new Uint8Array(a);
        for(let r = 0; r < a; ++r){
            t = t + 1 & 255;
            const a = n[t];
            i = i + a & 255;
            const o = n[i];
            n[t] = o, n[i] = a, s[r] = e1[r] ^ n[a + o & 255];
        }
        return this.a = t, this.b = i, s;
    }
    decryptBlock(e1) {
        return this.encryptBlock(e1);
    }
    encrypt(e1) {
        return this.encryptBlock(e1);
    }
}
class NullCipher {
    decryptBlock(e1) {
        return e1;
    }
    encrypt(e1) {
        return e1;
    }
}
class AESBaseCipher {
    _s = new Uint8Array([
        99,
        124,
        119,
        123,
        242,
        107,
        111,
        197,
        48,
        1,
        103,
        43,
        254,
        215,
        171,
        118,
        202,
        130,
        201,
        125,
        250,
        89,
        71,
        240,
        173,
        212,
        162,
        175,
        156,
        164,
        114,
        192,
        183,
        253,
        147,
        38,
        54,
        63,
        247,
        204,
        52,
        165,
        229,
        241,
        113,
        216,
        49,
        21,
        4,
        199,
        35,
        195,
        24,
        150,
        5,
        154,
        7,
        18,
        128,
        226,
        235,
        39,
        178,
        117,
        9,
        131,
        44,
        26,
        27,
        110,
        90,
        160,
        82,
        59,
        214,
        179,
        41,
        227,
        47,
        132,
        83,
        209,
        0,
        237,
        32,
        252,
        177,
        91,
        106,
        203,
        190,
        57,
        74,
        76,
        88,
        207,
        208,
        239,
        170,
        251,
        67,
        77,
        51,
        133,
        69,
        249,
        2,
        127,
        80,
        60,
        159,
        168,
        81,
        163,
        64,
        143,
        146,
        157,
        56,
        245,
        188,
        182,
        218,
        33,
        16,
        255,
        243,
        210,
        205,
        12,
        19,
        236,
        95,
        151,
        68,
        23,
        196,
        167,
        126,
        61,
        100,
        93,
        25,
        115,
        96,
        129,
        79,
        220,
        34,
        42,
        144,
        136,
        70,
        238,
        184,
        20,
        222,
        94,
        11,
        219,
        224,
        50,
        58,
        10,
        73,
        6,
        36,
        92,
        194,
        211,
        172,
        98,
        145,
        149,
        228,
        121,
        231,
        200,
        55,
        109,
        141,
        213,
        78,
        169,
        108,
        86,
        244,
        234,
        101,
        122,
        174,
        8,
        186,
        120,
        37,
        46,
        28,
        166,
        180,
        198,
        232,
        221,
        116,
        31,
        75,
        189,
        139,
        138,
        112,
        62,
        181,
        102,
        72,
        3,
        246,
        14,
        97,
        53,
        87,
        185,
        134,
        193,
        29,
        158,
        225,
        248,
        152,
        17,
        105,
        217,
        142,
        148,
        155,
        30,
        135,
        233,
        206,
        85,
        40,
        223,
        140,
        161,
        137,
        13,
        191,
        230,
        66,
        104,
        65,
        153,
        45,
        15,
        176,
        84,
        187,
        22
    ]);
    _inv_s = new Uint8Array([
        82,
        9,
        106,
        213,
        48,
        54,
        165,
        56,
        191,
        64,
        163,
        158,
        129,
        243,
        215,
        251,
        124,
        227,
        57,
        130,
        155,
        47,
        255,
        135,
        52,
        142,
        67,
        68,
        196,
        222,
        233,
        203,
        84,
        123,
        148,
        50,
        166,
        194,
        35,
        61,
        238,
        76,
        149,
        11,
        66,
        250,
        195,
        78,
        8,
        46,
        161,
        102,
        40,
        217,
        36,
        178,
        118,
        91,
        162,
        73,
        109,
        139,
        209,
        37,
        114,
        248,
        246,
        100,
        134,
        104,
        152,
        22,
        212,
        164,
        92,
        204,
        93,
        101,
        182,
        146,
        108,
        112,
        72,
        80,
        253,
        237,
        185,
        218,
        94,
        21,
        70,
        87,
        167,
        141,
        157,
        132,
        144,
        216,
        171,
        0,
        140,
        188,
        211,
        10,
        247,
        228,
        88,
        5,
        184,
        179,
        69,
        6,
        208,
        44,
        30,
        143,
        202,
        63,
        15,
        2,
        193,
        175,
        189,
        3,
        1,
        19,
        138,
        107,
        58,
        145,
        17,
        65,
        79,
        103,
        220,
        234,
        151,
        242,
        207,
        206,
        240,
        180,
        230,
        115,
        150,
        172,
        116,
        34,
        231,
        173,
        53,
        133,
        226,
        249,
        55,
        232,
        28,
        117,
        223,
        110,
        71,
        241,
        26,
        113,
        29,
        41,
        197,
        137,
        111,
        183,
        98,
        14,
        170,
        24,
        190,
        27,
        252,
        86,
        62,
        75,
        198,
        210,
        121,
        32,
        154,
        219,
        192,
        254,
        120,
        205,
        90,
        244,
        31,
        221,
        168,
        51,
        136,
        7,
        199,
        49,
        177,
        18,
        16,
        89,
        39,
        128,
        236,
        95,
        96,
        81,
        127,
        169,
        25,
        181,
        74,
        13,
        45,
        229,
        122,
        159,
        147,
        201,
        156,
        239,
        160,
        224,
        59,
        77,
        174,
        42,
        245,
        176,
        200,
        235,
        187,
        60,
        131,
        83,
        153,
        97,
        23,
        43,
        4,
        126,
        186,
        119,
        214,
        38,
        225,
        105,
        20,
        99,
        85,
        33,
        12,
        125
    ]);
    _mix = new Uint32Array([
        0,
        235474187,
        470948374,
        303765277,
        941896748,
        908933415,
        607530554,
        708780849,
        1883793496,
        2118214995,
        1817866830,
        1649639237,
        1215061108,
        1181045119,
        1417561698,
        1517767529,
        3767586992,
        4003061179,
        4236429990,
        4069246893,
        3635733660,
        3602770327,
        3299278474,
        3400528769,
        2430122216,
        2664543715,
        2362090238,
        2193862645,
        2835123396,
        2801107407,
        3035535058,
        3135740889,
        3678124923,
        3576870512,
        3341394285,
        3374361702,
        3810496343,
        3977675356,
        4279080257,
        4043610186,
        2876494627,
        2776292904,
        3076639029,
        3110650942,
        2472011535,
        2640243204,
        2403728665,
        2169303058,
        1001089995,
        899835584,
        666464733,
        699432150,
        59727847,
        226906860,
        530400753,
        294930682,
        1273168787,
        1172967064,
        1475418501,
        1509430414,
        1942435775,
        2110667444,
        1876241833,
        1641816226,
        2910219766,
        2743034109,
        2976151520,
        3211623147,
        2505202138,
        2606453969,
        2302690252,
        2269728455,
        3711829422,
        3543599269,
        3240894392,
        3475313331,
        3843699074,
        3943906441,
        4178062228,
        4144047775,
        1306967366,
        1139781709,
        1374988112,
        1610459739,
        1975683434,
        2076935265,
        1775276924,
        1742315127,
        1034867998,
        866637845,
        566021896,
        800440835,
        92987698,
        193195065,
        429456164,
        395441711,
        1984812685,
        2017778566,
        1784663195,
        1683407248,
        1315562145,
        1080094634,
        1383856311,
        1551037884,
        101039829,
        135050206,
        437757123,
        337553864,
        1042385657,
        807962610,
        573804783,
        742039012,
        2531067453,
        2564033334,
        2328828971,
        2227573024,
        2935566865,
        2700099354,
        3001755655,
        3168937228,
        3868552805,
        3902563182,
        4203181171,
        4102977912,
        3736164937,
        3501741890,
        3265478751,
        3433712980,
        1106041591,
        1340463100,
        1576976609,
        1408749034,
        2043211483,
        2009195472,
        1708848333,
        1809054150,
        832877231,
        1068351396,
        766945465,
        599762354,
        159417987,
        126454664,
        361929877,
        463180190,
        2709260871,
        2943682380,
        3178106961,
        3009879386,
        2572697195,
        2538681184,
        2236228733,
        2336434550,
        3509871135,
        3745345300,
        3441850377,
        3274667266,
        3910161971,
        3877198648,
        4110568485,
        4211818798,
        2597806476,
        2497604743,
        2261089178,
        2295101073,
        2733856160,
        2902087851,
        3202437046,
        2968011453,
        3936291284,
        3835036895,
        4136440770,
        4169408201,
        3535486456,
        3702665459,
        3467192302,
        3231722213,
        2051518780,
        1951317047,
        1716890410,
        1750902305,
        1113818384,
        1282050075,
        1584504582,
        1350078989,
        168810852,
        67556463,
        371049330,
        404016761,
        841739592,
        1008918595,
        775550814,
        540080725,
        3969562369,
        3801332234,
        4035489047,
        4269907996,
        3569255213,
        3669462566,
        3366754619,
        3332740144,
        2631065433,
        2463879762,
        2160117071,
        2395588676,
        2767645557,
        2868897406,
        3102011747,
        3069049960,
        202008497,
        33778362,
        270040487,
        504459436,
        875451293,
        975658646,
        675039627,
        641025152,
        2084704233,
        1917518562,
        1615861247,
        1851332852,
        1147550661,
        1248802510,
        1484005843,
        1451044056,
        933301370,
        967311729,
        733156972,
        632953703,
        260388950,
        25965917,
        328671808,
        496906059,
        1206477858,
        1239443753,
        1543208500,
        1441952575,
        2144161806,
        1908694277,
        1675577880,
        1842759443,
        3610369226,
        3644379585,
        3408119516,
        3307916247,
        4011190502,
        3776767469,
        4077384432,
        4245618683,
        2809771154,
        2842737049,
        3144396420,
        3043140495,
        2673705150,
        2438237621,
        2203032232,
        2370213795
    ]);
    _mixCol = new Uint8Array(256).map((e1, t)=>t < 128 ? t << 1 : t << 1 ^ 27);
    constructor(){
        this.buffer = new Uint8Array(16), this.bufferPosition = 0;
    }
    _expandKey(e1) {
        unreachable$1("Cannot call `_expandKey` on the base class");
    }
    _decrypt(e1, t) {
        let i, n, a;
        const s = new Uint8Array(16);
        s.set(e1);
        for(let e1 = 0, i = this._keySize; e1 < 16; ++e1, ++i)s[e1] ^= t[i];
        for(let e1 = this._cyclesOfRepetition - 1; e1 >= 1; --e1){
            i = s[13], s[13] = s[9], s[9] = s[5], s[5] = s[1], s[1] = i, i = s[14], n = s[10], s[14] = s[6], s[10] = s[2], s[6] = i, s[2] = n, i = s[15], n = s[11], a = s[7], s[15] = s[3], s[11] = i, s[7] = n, s[3] = a;
            for(let e1 = 0; e1 < 16; ++e1)s[e1] = this._inv_s[s[e1]];
            for(let i = 0, n = 16 * e1; i < 16; ++i, ++n)s[i] ^= t[n];
            for(let e1 = 0; e1 < 16; e1 += 4){
                const t = this._mix[s[e1]], n = this._mix[s[e1 + 1]], a = this._mix[s[e1 + 2]], r = this._mix[s[e1 + 3]];
                i = t ^ n >>> 8 ^ n << 24 ^ a >>> 16 ^ a << 16 ^ r >>> 24 ^ r << 8, s[e1] = i >>> 24 & 255, s[e1 + 1] = i >> 16 & 255, s[e1 + 2] = i >> 8 & 255, s[e1 + 3] = 255 & i;
            }
        }
        i = s[13], s[13] = s[9], s[9] = s[5], s[5] = s[1], s[1] = i, i = s[14], n = s[10], s[14] = s[6], s[10] = s[2], s[6] = i, s[2] = n, i = s[15], n = s[11], a = s[7], s[15] = s[3], s[11] = i, s[7] = n, s[3] = a;
        for(let e1 = 0; e1 < 16; ++e1)s[e1] = this._inv_s[s[e1]], s[e1] ^= t[e1];
        return s;
    }
    _encrypt(e1, t) {
        const i = this._s;
        let n, a, s;
        const r = new Uint8Array(16);
        r.set(e1);
        for(let e1 = 0; e1 < 16; ++e1)r[e1] ^= t[e1];
        for(let e1 = 1; e1 < this._cyclesOfRepetition; e1++){
            for(let e1 = 0; e1 < 16; ++e1)r[e1] = i[r[e1]];
            s = r[1], r[1] = r[5], r[5] = r[9], r[9] = r[13], r[13] = s, s = r[2], a = r[6], r[2] = r[10], r[6] = r[14], r[10] = s, r[14] = a, s = r[3], a = r[7], n = r[11], r[3] = r[15], r[7] = s, r[11] = a, r[15] = n;
            for(let e1 = 0; e1 < 16; e1 += 4){
                const t = r[e1], i = r[e1 + 1], a = r[e1 + 2], s = r[e1 + 3];
                n = t ^ i ^ a ^ s, r[e1] ^= n ^ this._mixCol[t ^ i], r[e1 + 1] ^= n ^ this._mixCol[i ^ a], r[e1 + 2] ^= n ^ this._mixCol[a ^ s], r[e1 + 3] ^= n ^ this._mixCol[s ^ t];
            }
            for(let i = 0, n = 16 * e1; i < 16; ++i, ++n)r[i] ^= t[n];
        }
        for(let e1 = 0; e1 < 16; ++e1)r[e1] = i[r[e1]];
        s = r[1], r[1] = r[5], r[5] = r[9], r[9] = r[13], r[13] = s, s = r[2], a = r[6], r[2] = r[10], r[6] = r[14], r[10] = s, r[14] = a, s = r[3], a = r[7], n = r[11], r[3] = r[15], r[7] = s, r[11] = a, r[15] = n;
        for(let e1 = 0, i = this._keySize; e1 < 16; ++e1, ++i)r[e1] ^= t[i];
        return r;
    }
    _decryptBlock2(e1, t) {
        const i = e1.length;
        let n = this.buffer, a = this.bufferPosition;
        const s = [];
        let r = this.iv;
        for(let t = 0; t < i; ++t){
            if (n[a] = e1[t], ++a, a < 16) continue;
            const i = this._decrypt(n, this._key);
            for(let e1 = 0; e1 < 16; ++e1)i[e1] ^= r[e1];
            r = n, s.push(i), n = new Uint8Array(16), a = 0;
        }
        if (this.buffer = n, this.bufferLength = a, this.iv = r, 0 === s.length) return new Uint8Array(0);
        let o = 16 * s.length;
        if (t) {
            const e1 = s.at(-1);
            let t = e1[15];
            if (t <= 16) {
                for(let i = 15, n = 16 - t; i >= n; --i)if (e1[i] !== t) {
                    t = 0;
                    break;
                }
                o -= t, s[s.length - 1] = e1.subarray(0, 16 - t);
            }
        }
        const l = new Uint8Array(o);
        for(let e1 = 0, t = 0, i = s.length; e1 < i; ++e1, t += 16)l.set(s[e1], t);
        return l;
    }
    decryptBlock(e1, t, i = null) {
        const n = e1.length, a = this.buffer;
        let s = this.bufferPosition;
        if (i) this.iv = i;
        else {
            for(let t = 0; s < 16 && t < n; ++t, ++s)a[s] = e1[t];
            if (s < 16) return this.bufferLength = s, new Uint8Array(0);
            this.iv = a, e1 = e1.subarray(16);
        }
        return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(e1, t);
    }
    encrypt(e1, t) {
        const i = e1.length;
        let n = this.buffer, a = this.bufferPosition;
        const s = [];
        t ||= new Uint8Array(16);
        for(let r = 0; r < i; ++r){
            if (n[a] = e1[r], ++a, a < 16) continue;
            for(let e1 = 0; e1 < 16; ++e1)n[e1] ^= t[e1];
            const i = this._encrypt(n, this._key);
            t = i, s.push(i), n = new Uint8Array(16), a = 0;
        }
        if (this.buffer = n, this.bufferLength = a, this.iv = t, 0 === s.length) return new Uint8Array(0);
        const r = 16 * s.length, o = new Uint8Array(r);
        for(let e1 = 0, t = 0, i = s.length; e1 < i; ++e1, t += 16)o.set(s[e1], t);
        return o;
    }
}
class AES128Cipher extends AESBaseCipher {
    _rcon = new Uint8Array([
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141
    ]);
    constructor(e1){
        super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._key = this._expandKey(e1);
    }
    _expandKey(e1) {
        const t = this._s, i = this._rcon, n = new Uint8Array(176);
        n.set(e1);
        for(let e1 = 16, a = 1; e1 < 176; ++a){
            let s = n[e1 - 3], r = n[e1 - 2], o = n[e1 - 1], l = n[e1 - 4];
            s = t[s], r = t[r], o = t[o], l = t[l], s ^= i[a];
            for(let t = 0; t < 4; ++t)n[e1] = s ^= n[e1 - 16], e1++, n[e1] = r ^= n[e1 - 16], e1++, n[e1] = o ^= n[e1 - 16], e1++, n[e1] = l ^= n[e1 - 16], e1++;
        }
        return n;
    }
}
class AES256Cipher extends AESBaseCipher {
    constructor(e1){
        super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(e1);
    }
    _expandKey(e1) {
        const t = this._s, i = new Uint8Array(240);
        i.set(e1);
        let n, a, s, r, o = 1;
        for(let e1 = 32, l = 1; e1 < 240; ++l){
            e1 % 32 == 16 ? (n = t[n], a = t[a], s = t[s], r = t[r]) : e1 % 32 == 0 && (n = i[e1 - 3], a = i[e1 - 2], s = i[e1 - 1], r = i[e1 - 4], n = t[n], a = t[a], s = t[s], r = t[r], n ^= o, (o <<= 1) >= 256 && (o = 255 & (27 ^ o)));
            for(let t = 0; t < 4; ++t)i[e1] = n ^= i[e1 - 32], e1++, i[e1] = a ^= i[e1 - 32], e1++, i[e1] = s ^= i[e1 - 32], e1++, i[e1] = r ^= i[e1 - 32], e1++;
        }
        return i;
    }
}
class PDFBase {
    _hash(e1, t, i) {
        unreachable$1("Abstract method `_hash` called");
    }
    checkOwnerPassword(e1, t, i, n) {
        const a = new Uint8Array(e1.length + 56);
        a.set(e1, 0), a.set(t, e1.length), a.set(i, e1.length + t.length);
        return isArrayEqual(this._hash(e1, a, i), n);
    }
    checkUserPassword(e1, t, i) {
        const n = new Uint8Array(e1.length + 8);
        n.set(e1, 0), n.set(t, e1.length);
        return isArrayEqual(this._hash(e1, n, []), i);
    }
    getOwnerKey(e1, t, i, n) {
        const a = new Uint8Array(e1.length + 56);
        a.set(e1, 0), a.set(t, e1.length), a.set(i, e1.length + t.length);
        const s = this._hash(e1, a, i);
        return new AES256Cipher(s).decryptBlock(n, !1, new Uint8Array(16));
    }
    getUserKey(e1, t, i) {
        const n = new Uint8Array(e1.length + 8);
        n.set(e1, 0), n.set(t, e1.length);
        const a = this._hash(e1, n, []);
        return new AES256Cipher(a).decryptBlock(i, !1, new Uint8Array(16));
    }
}
class PDF17 extends PDFBase {
    _hash(e1, t, i) {
        return calculateSHA256(t, 0, t.length);
    }
}
class PDF20 extends PDFBase {
    _hash(e1, t, i) {
        let n = calculateSHA256(t, 0, t.length).subarray(0, 32), a = [
            0
        ], s = 0;
        for(; s < 64 || a.at(-1) > s - 32;){
            const t = e1.length + n.length + i.length, r = new Uint8Array(t);
            let o = 0;
            r.set(e1, o), o += e1.length, r.set(n, o), o += n.length, r.set(i, o);
            const l = new Uint8Array(64 * t);
            for(let e1 = 0, i = 0; e1 < 64; e1++, i += t)l.set(r, i);
            a = new AES128Cipher(n.subarray(0, 16)).encrypt(l, n.subarray(16, 32));
            const c = Math.sumPrecise(a.slice(0, 16)) % 3;
            0 === c ? n = calculateSHA256(a, 0, a.length) : 1 === c ? n = calculateSHA384(a, 0, a.length) : 2 === c && (n = calculateSHA512(a, 0, a.length)), s++;
        }
        return n.subarray(0, 32);
    }
}
class CipherTransform {
    constructor(e1, t){
        this.StringCipherConstructor = e1, this.StreamCipherConstructor = t;
    }
    createStream(e1, t) {
        const i = new this.StreamCipherConstructor;
        return new DecryptStream(e1, t, function(e1, t) {
            return i.decryptBlock(e1, t);
        });
    }
    decryptString(e1) {
        const t = new this.StringCipherConstructor;
        let i = stringToBytes$1(e1);
        return i = t.decryptBlock(i, !0), bytesToString$1(i);
    }
    encryptString(e1) {
        const t = new this.StringCipherConstructor;
        if (t instanceof AESBaseCipher) {
            const i = 16 - e1.length % 16;
            e1 += String.fromCharCode(i).repeat(i);
            const n = new Uint8Array(16);
            crypto.getRandomValues(n);
            let a = stringToBytes$1(e1);
            a = t.encrypt(a, n);
            const s = new Uint8Array(16 + a.length);
            return s.set(n), s.set(a, 16), bytesToString$1(s);
        }
        let i = stringToBytes$1(e1);
        return i = t.encrypt(i), bytesToString$1(i);
    }
}
class CipherTransformFactory {
    static get _defaultPasswordBytes() {
        return shadow$1(this, "_defaultPasswordBytes", new Uint8Array([
            40,
            191,
            78,
            94,
            78,
            117,
            138,
            65,
            100,
            0,
            78,
            86,
            255,
            250,
            1,
            8,
            46,
            46,
            0,
            182,
            208,
            104,
            62,
            128,
            47,
            12,
            169,
            254,
            100,
            83,
            105,
            122
        ]));
    }
    #Ue(e1, t, i, n, a, s, r, o, l, c, h, d) {
        if (t) {
            const e1 = Math.min(127, t.length);
            t = t.subarray(0, e1);
        } else t = [];
        const u = 6 === e1 ? new PDF20 : new PDF17;
        return u.checkUserPassword(t, o, r) ? u.getUserKey(t, l, h) : t.length && u.checkOwnerPassword(t, n, s, i) ? u.getOwnerKey(t, a, s, c) : null;
    }
    #je(e1, t, i, n, a, s, r, o) {
        const l = 40 + i.length + e1.length, c = new Uint8Array(l);
        let h, d, u = 0;
        if (t) for(d = Math.min(32, t.length); u < d; ++u)c[u] = t[u];
        for(h = 0; u < 32;)c[u++] = CipherTransformFactory._defaultPasswordBytes[h++];
        c.set(i, u), u += i.length, c[u++] = 255 & a, c[u++] = a >> 8 & 255, c[u++] = a >> 16 & 255, c[u++] = a >>> 24 & 255, c.set(e1, u), u += e1.length, s >= 4 && !o && (c.fill(255, u, u + 4), u += 4);
        let g = calculateMD5(c, 0, u);
        const f = r >> 3;
        if (s >= 3) for(h = 0; h < 50; ++h)g = calculateMD5(g, 0, f);
        const p = g.subarray(0, f);
        let m, b;
        if (s >= 3) {
            u = 0, c.set(CipherTransformFactory._defaultPasswordBytes, u), u += 32, c.set(e1, u), u += e1.length, m = new ARCFourCipher(p), b = m.encryptBlock(calculateMD5(c, 0, u)), d = p.length;
            const t = new Uint8Array(d);
            for(h = 1; h <= 19; ++h){
                for(let e1 = 0; e1 < d; ++e1)t[e1] = p[e1] ^ h;
                m = new ARCFourCipher(t), b = m.encryptBlock(b);
            }
        } else m = new ARCFourCipher(p), b = m.encryptBlock(CipherTransformFactory._defaultPasswordBytes);
        return b.every((e1, t)=>n[t] === e1) ? p : null;
    }
    #$e(e1, t, i, n) {
        const a = new Uint8Array(32);
        let s = 0;
        const r = Math.min(32, e1.length);
        for(; s < r; ++s)a[s] = e1[s];
        let o = 0;
        for(; s < 32;)a[s++] = CipherTransformFactory._defaultPasswordBytes[o++];
        let l = calculateMD5(a, 0, s);
        const c = n >> 3;
        if (i >= 3) for(o = 0; o < 50; ++o)l = calculateMD5(l, 0, l.length);
        let h, d;
        if (i >= 3) {
            d = t;
            const e1 = new Uint8Array(c);
            for(o = 19; o >= 0; o--){
                for(let t = 0; t < c; ++t)e1[t] = l[t] ^ o;
                h = new ARCFourCipher(e1), d = h.encryptBlock(d);
            }
        } else h = new ARCFourCipher(l.subarray(0, c)), d = h.encryptBlock(t);
        return d;
    }
    #He(e1, t, i, n = !1) {
        const a = i.length, s = new Uint8Array(a + 9);
        s.set(i);
        let r = a;
        s[r++] = 255 & e1, s[r++] = e1 >> 8 & 255, s[r++] = e1 >> 16 & 255, s[r++] = 255 & t, s[r++] = t >> 8 & 255, n && (s[r++] = 115, s[r++] = 65, s[r++] = 108, s[r++] = 84);
        return calculateMD5(s, 0, r).subarray(0, Math.min(a + 5, 16));
    }
    #Xe(e1, t, i, n, a) {
        if (!(t instanceof Name)) throw new ti("Invalid crypt filter name.");
        const s = this, r = e1.get(t.name), o = r?.get("CFM");
        if (!o || "None" === o.name) return function() {
            return new NullCipher;
        };
        if ("V2" === o.name) return function() {
            return new ARCFourCipher(s.#He(i, n, a, !1));
        };
        if ("AESV2" === o.name) return function() {
            return new AES128Cipher(s.#He(i, n, a, !0));
        };
        if ("AESV3" === o.name) return function() {
            return new AES256Cipher(a);
        };
        throw new ti("Unknown crypto method");
    }
    constructor(e1, t, i){
        const n = e1.get("Filter");
        if (!isName(n, "Standard")) throw new ti("unknown encryption method");
        this.filterName = n.name, this.dict = e1;
        const a = e1.get("V");
        if (!Number.isInteger(a) || 1 !== a && 2 !== a && 4 !== a && 5 !== a) throw new ti("unsupported encryption algorithm");
        this.algorithm = a;
        let s = e1.get("Length");
        if (!s) if (a <= 3) s = 40;
        else {
            const t = e1.get("CF"), i = e1.get("StmF");
            if (t instanceof Dict && i instanceof Name) {
                t.suppressEncryption = !0;
                const e1 = t.get(i.name);
                s = e1?.get("Length") || 128, s < 40 && (s <<= 3);
            }
        }
        if (!Number.isInteger(s) || s < 40 || s % 8 != 0) throw new ti("invalid key length");
        const r = stringToBytes$1(e1.get("O")), o = stringToBytes$1(e1.get("U")), l = r.subarray(0, 32), c = o.subarray(0, 32), h = e1.get("P"), d = e1.get("R"), u = (4 === a || 5 === a) && !1 !== e1.get("EncryptMetadata");
        this.encryptMetadata = u;
        const g = stringToBytes$1(t);
        let f, p;
        if (i) {
            if (6 === d) try {
                i = utf8StringToString(i);
            } catch  {
                warn$1("CipherTransformFactory: Unable to convert UTF8 encoded password.");
            }
            f = stringToBytes$1(i);
        }
        if (5 !== a) p = this.#je(g, f, l, c, h, d, s, u);
        else {
            const t = r.subarray(32, 40), i = r.subarray(40, 48), n = o.subarray(0, 48), a = o.subarray(32, 40), s = o.subarray(40, 48), h = stringToBytes$1(e1.get("OE")), u = stringToBytes$1(e1.get("UE")), g = stringToBytes$1(e1.get("Perms"));
            p = this.#Ue(d, f, l, t, i, n, c, a, s, h, u, g);
        }
        if (!p) {
            if (!i) throw new Jt("No password given", Gt);
            const e1 = this.#$e(f, l, d, s);
            p = this.#je(g, e1, l, c, h, d, s, u);
        }
        if (!p) throw new Jt("Incorrect Password", Vt);
        if (4 === a && p.length < 16 ? (this.encryptionKey = new Uint8Array(16), this.encryptionKey.set(p)) : this.encryptionKey = p, a >= 4) {
            const t = e1.get("CF");
            t instanceof Dict && (t.suppressEncryption = !0), this.cf = t, this.stmf = e1.get("StmF") || Name.get("Identity"), this.strf = e1.get("StrF") || Name.get("Identity"), this.eff = e1.get("EFF") || this.stmf;
        }
    }
    createCipherTransform(e1, t) {
        if (4 === this.algorithm || 5 === this.algorithm) return new CipherTransform(this.#Xe(this.cf, this.strf, e1, t, this.encryptionKey), this.#Xe(this.cf, this.stmf, e1, t, this.encryptionKey));
        const i = this.#He(e1, t, this.encryptionKey, !1), cipherConstructor = function() {
            return new ARCFourCipher(i);
        };
        return new CipherTransform(cipherConstructor, cipherConstructor);
    }
}
class XRef {
    constructor(e1, t){
        this.stream = e1, this.pdfManager = t, this.entries = [], this._xrefStms = new Set, this._cacheMap = new Map, this._pendingRefs = new RefSet, this._newPersistentRefNum = null, this._newTemporaryRefNum = null, this._persistentRefsCache = null;
    }
    getNewPersistentRef(e1) {
        null === this._newPersistentRefNum && (this._newPersistentRefNum = this.entries.length || 1);
        const t = this._newPersistentRefNum++;
        return this._cacheMap.set(t, e1), Ref.get(t, 0);
    }
    getNewTemporaryRef() {
        if (null === this._newTemporaryRefNum && (this._newTemporaryRefNum = this.entries.length || 1, this._newPersistentRefNum)) {
            this._persistentRefsCache = new Map;
            for(let e1 = this._newTemporaryRefNum; e1 < this._newPersistentRefNum; e1++)this._persistentRefsCache.set(e1, this._cacheMap.get(e1)), this._cacheMap.delete(e1);
        }
        return Ref.get(this._newTemporaryRefNum++, 0);
    }
    resetNewTemporaryRef() {
        if (this._newTemporaryRefNum = null, this._persistentRefsCache) for (const [e1, t] of this._persistentRefsCache)this._cacheMap.set(e1, t);
        this._persistentRefsCache = null;
    }
    setStartXRef(e1) {
        this.startXRefQueue = [
            e1
        ];
    }
    parse(e1 = !1) {
        let t, i, n;
        e1 ? (warn$1("Indexing all PDF objects"), t = this.indexObjects()) : t = this.readXRef(), t.assignXref(this), this.trailer = t;
        try {
            i = t.get("Encrypt");
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn$1(`XRef.parse - Invalid "Encrypt" reference: "${e1}".`);
        }
        if (i instanceof Dict) {
            const e1 = t.get("ID"), n = e1?.length ? e1[0] : "";
            i.suppressEncryption = !0, this.encrypt = new CipherTransformFactory(i, n, this.pdfManager.password);
        }
        try {
            n = t.get("Root");
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn$1(`XRef.parse - Invalid "Root" reference: "${e1}".`);
        }
        if (n instanceof Dict) try {
            if (n.get("Pages") instanceof Dict) return void (this.root = n);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn$1(`XRef.parse - Invalid "Pages" reference: "${e1}".`);
        }
        if (!e1) throw new XRefParseException;
        throw new Qt("Invalid Root reference.");
    }
    processXRefTable(e1) {
        "tableState" in this || (this.tableState = {
            entryNum: 0,
            streamPos: e1.lexer.stream.pos,
            parserBuf1: e1.buf1,
            parserBuf2: e1.buf2
        });
        if (!isCmd(this.readXRefTable(e1), "trailer")) throw new ti("Invalid XRef table: could not find trailer dictionary");
        let t = e1.getObj();
        if (t instanceof Dict || !t.dict || (t = t.dict), !(t instanceof Dict)) throw new ti("Invalid XRef table: could not parse trailer dictionary");
        return delete this.tableState, t;
    }
    readXRefTable(e1) {
        const t = e1.lexer.stream, i = this.tableState;
        let n;
        for(t.pos = i.streamPos, e1.buf1 = i.parserBuf1, e1.buf2 = i.parserBuf2;;){
            if (!("firstEntryNum" in i) || !("entryCount" in i)) {
                if (isCmd(n = e1.getObj(), "trailer")) break;
                i.firstEntryNum = n, i.entryCount = e1.getObj();
            }
            let a = i.firstEntryNum;
            const s = i.entryCount;
            if (!Number.isInteger(a) || !Number.isInteger(s)) throw new ti("Invalid XRef table: wrong types in subsection header");
            for(let n = i.entryNum; n < s; n++){
                i.streamPos = t.pos, i.entryNum = n, i.parserBuf1 = e1.buf1, i.parserBuf2 = e1.buf2;
                const r = {};
                r.offset = e1.getObj(), r.gen = e1.getObj();
                const o = e1.getObj();
                if (o instanceof Cmd) switch(o.cmd){
                    case "f":
                        r.free = !0;
                        break;
                    case "n":
                        r.uncompressed = !0;
                }
                if (!Number.isInteger(r.offset) || !Number.isInteger(r.gen) || !r.free && !r.uncompressed) throw new ti(`Invalid entry in XRef subsection: ${a}, ${s}`);
                0 === n && r.free && 1 === a && (a = 0), this.entries[n + a] || (this.entries[n + a] = r);
            }
            i.entryNum = 0, i.streamPos = t.pos, i.parserBuf1 = e1.buf1, i.parserBuf2 = e1.buf2, delete i.firstEntryNum, delete i.entryCount;
        }
        if (this.entries[0] && !this.entries[0].free) throw new ti("Invalid XRef table: unexpected first object");
        return n;
    }
    processXRefStream(e1) {
        if (!("streamState" in this)) {
            const { dict: t, pos: i } = e1, n = t.get("W"), a = t.get("Index") || [
                0,
                t.get("Size")
            ];
            this.streamState = {
                entryRanges: a,
                byteWidths: n,
                entryNum: 0,
                streamPos: i
            };
        }
        return this.readXRefStream(e1), delete this.streamState, e1.dict;
    }
    readXRefStream(e1) {
        const t = this.streamState;
        e1.pos = t.streamPos;
        const [i, n, a] = t.byteWidths, s = t.entryRanges;
        for(; s.length > 0;){
            const [r, o] = s;
            if (!Number.isInteger(r) || !Number.isInteger(o)) throw new ti(`Invalid XRef range fields: ${r}, ${o}`);
            if (!Number.isInteger(i) || !Number.isInteger(n) || !Number.isInteger(a)) throw new ti(`Invalid XRef entry fields length: ${r}, ${o}`);
            for(let s = t.entryNum; s < o; ++s){
                t.entryNum = s, t.streamPos = e1.pos;
                let o = 0, l = 0, c = 0;
                for(let t = 0; t < i; ++t){
                    const t = e1.getByte();
                    if (-1 === t) throw new ti("Invalid XRef byteWidths 'type'.");
                    o = o << 8 | t;
                }
                0 === i && (o = 1);
                for(let t = 0; t < n; ++t){
                    const t = e1.getByte();
                    if (-1 === t) throw new ti("Invalid XRef byteWidths 'offset'.");
                    l = l << 8 | t;
                }
                for(let t = 0; t < a; ++t){
                    const t = e1.getByte();
                    if (-1 === t) throw new ti("Invalid XRef byteWidths 'generation'.");
                    c = c << 8 | t;
                }
                const h = {};
                switch(h.offset = l, h.gen = c, o){
                    case 0:
                        h.free = !0;
                        break;
                    case 1:
                        h.uncompressed = !0;
                        break;
                    case 2:
                        break;
                    default:
                        throw new ti(`Invalid XRef entry type: ${o}`);
                }
                this.entries[r + s] || (this.entries[r + s] = h);
            }
            t.entryNum = 0, t.streamPos = e1.pos, s.splice(0, 2);
        }
    }
    indexObjects() {
        function readToken(e1, t) {
            let i = "", n = e1[t];
            for(; 10 !== n && 13 !== n && 60 !== n && !(++t >= e1.length);)i += String.fromCharCode(n), n = e1[t];
            return i;
        }
        function skipUntil(e1, t, i) {
            const n = i.length, a = e1.length;
            let s = 0;
            for(; t < a;){
                let a = 0;
                for(; a < n && e1[t + a] === i[a];)++a;
                if (a >= n) break;
                t++, s++;
            }
            return s;
        }
        const e1 = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, t = /\b(startxref|\d+\s+\d+\s+obj)\b/g, i = /^(\d+)\s+(\d+)\s+obj\b/, n = new Uint8Array([
            116,
            114,
            97,
            105,
            108,
            101,
            114
        ]), a = new Uint8Array([
            115,
            116,
            97,
            114,
            116,
            120,
            114,
            101,
            102
        ]), s = new Uint8Array([
            47,
            88,
            82,
            101,
            102
        ]);
        this.entries.length = 0, this._cacheMap.clear();
        const r = this.stream;
        r.pos = 0;
        const o = r.getBytes(), l = bytesToString$1(o), c = o.length;
        let h = r.start;
        const d = [], u = [];
        for(; h < c;){
            let g = o[h];
            if (9 === g || 10 === g || 13 === g || 32 === g) {
                ++h;
                continue;
            }
            if (37 === g) {
                do {
                    if (++h, h >= c) break;
                    g = o[h];
                }while (10 !== g && 13 !== g)
                continue;
            }
            const f = readToken(o, h);
            let p;
            if (f.startsWith("xref") && (4 === f.length || /\s/.test(f[4]))) h += skipUntil(o, h, n), d.push(h), h += skipUntil(o, h, a);
            else if (p = i.exec(f)) {
                const t = 0 | p[1], i = 0 | p[2], n = h + f.length;
                let a, d = !1;
                if (this.entries[t]) {
                    if (this.entries[t].gen === i) try {
                        new Parser({
                            lexer: new Lexer(r.makeSubStream(n))
                        }).getObj(), d = !0;
                    } catch (e1) {
                        e1 instanceof ParserEOFException ? warn$1(`indexObjects -- checking object (${f}): "${e1}".`) : d = !0;
                    }
                } else d = !0;
                d && (this.entries[t] = {
                    offset: h - r.start,
                    gen: i,
                    uncompressed: !0
                }), e1.lastIndex = n;
                const g = e1.exec(l);
                if (g) {
                    a = e1.lastIndex + 1 - h, "endobj" !== g[1] && (warn$1(`indexObjects: Found "${g[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`), a -= g[1].length + 1);
                } else a = c - h;
                const m = o.subarray(h, h + a), b = skipUntil(m, 0, s);
                b < a && m[b + 5] < 64 && (u.push(h - r.start), this._xrefStms.add(h - r.start)), h += a;
            } else if (f.startsWith("trailer") && (7 === f.length || /\s/.test(f[7]))) {
                d.push(h);
                const e1 = h + f.length;
                let i;
                t.lastIndex = e1;
                const n = t.exec(l);
                if (n) {
                    i = t.lastIndex + 1 - h, "startxref" !== n[1] && (warn$1(`indexObjects: Found "${n[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`), i -= n[1].length + 1);
                } else i = c - h;
                h += i;
            } else h += f.length + 1;
        }
        for (const e1 of u)this.startXRefQueue.push(e1), this.readXRef(!0);
        const g = [];
        let f, p, m = !1;
        for (const e1 of d){
            r.pos = e1;
            const t = new Parser({
                lexer: new Lexer(r),
                xref: this,
                allowStreams: !0,
                recoveryMode: !0
            });
            if (!isCmd(t.getObj(), "trailer")) continue;
            const i = t.getObj();
            i instanceof Dict && (g.push(i), i.has("Encrypt") && (m = !0));
        }
        for (const e1 of [
            ...g,
            "genFallback",
            ...g
        ]){
            if ("genFallback" === e1) {
                if (!p) break;
                this._generationFallback = !0;
                continue;
            }
            let t = !1;
            try {
                const i = e1.get("Root");
                if (!(i instanceof Dict)) continue;
                const n = i.get("Pages");
                if (!(n instanceof Dict)) continue;
                const a = n.get("Count");
                Number.isInteger(a) && (t = !0);
            } catch (e1) {
                p = e1;
                continue;
            }
            if (t && (!m || e1.has("Encrypt")) && e1.has("ID")) return e1;
            f = e1;
        }
        if (f) return f;
        if (this.topDict) return this.topDict;
        if (!g.length) for(const e1 in this.entries){
            if (!Object.hasOwn(this.entries, e1)) continue;
            const t = this.entries[e1], i = Ref.get(parseInt(e1), t.gen);
            let n;
            try {
                n = this.fetch(i);
            } catch  {
                continue;
            }
            if (n instanceof BaseStream && (n = n.dict), n instanceof Dict && n.has("Root")) return n;
        }
        throw new Qt("Invalid PDF structure.");
    }
    readXRef(e1 = !1) {
        const t = this.stream, i = new Set;
        for(; this.startXRefQueue.length;){
            try {
                const e1 = this.startXRefQueue[0];
                if (i.has(e1)) {
                    warn$1("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
                    continue;
                }
                i.add(e1), t.pos = e1 + t.start;
                const n = new Parser({
                    lexer: new Lexer(t),
                    xref: this,
                    allowStreams: !0
                });
                let a, s = n.getObj();
                if (isCmd(s, "xref")) a = this.processXRefTable(n), this.topDict || (this.topDict = a), s = a.get("XRefStm"), Number.isInteger(s) && !this._xrefStms.has(s) && (this._xrefStms.add(s), this.startXRefQueue.push(s));
                else {
                    if (!Number.isInteger(s)) throw new ti("Invalid XRef stream header");
                    if (!(Number.isInteger(n.getObj()) && isCmd(n.getObj(), "obj") && (s = n.getObj()) instanceof BaseStream)) throw new ti("Invalid XRef stream");
                    if (a = this.processXRefStream(s), this.topDict || (this.topDict = a), !a) throw new ti("Failed to read XRef stream");
                }
                s = a.get("Prev"), Number.isInteger(s) ? this.startXRefQueue.push(s) : s instanceof Ref && this.startXRefQueue.push(s.num);
            } catch (e1) {
                if (e1 instanceof MissingDataException) throw e1;
                info$1("(while reading XRef): " + e1);
            }
            this.startXRefQueue.shift();
        }
        if (this.topDict) return this.topDict;
        if (!e1) throw new XRefParseException;
    }
    getEntry(e1) {
        const t = this.entries[e1];
        return t && !t.free && t.offset ? t : null;
    }
    fetchIfRef(e1, t = !1) {
        return e1 instanceof Ref ? this.fetch(e1, t) : e1;
    }
    fetch(e1, t = !1) {
        if (!(e1 instanceof Ref)) throw new Error("ref object is not a reference");
        const i = e1.num, n = this._cacheMap.get(i);
        if (void 0 !== n) return n instanceof Dict && !n.objId && (n.objId = e1.toString()), n;
        let a = this.getEntry(i);
        if (null === a) return a;
        if (this._pendingRefs.has(e1)) return this._pendingRefs.remove(e1), warn$1(`Ignoring circular reference: ${e1}.`), li;
        this._pendingRefs.put(e1);
        try {
            a = a.uncompressed ? this.fetchUncompressed(e1, a, t) : this.fetchCompressed(e1, a, t), this._pendingRefs.remove(e1);
        } catch (t) {
            throw this._pendingRefs.remove(e1), t;
        }
        return a instanceof Dict ? a.objId = e1.toString() : a instanceof BaseStream && (a.dict.objId = e1.toString()), a;
    }
    fetchUncompressed(e1, t, i = !1) {
        const n = e1.gen;
        let a = e1.num;
        if (t.gen !== n) {
            const s = `Inconsistent generation in XRef: ${e1}`;
            if (this._generationFallback && t.gen < n) return warn$1(s), this.fetchUncompressed(Ref.get(a, t.gen), t, i);
            throw new XRefEntryException(s);
        }
        const s = this.stream.makeSubStream(t.offset + this.stream.start), r = new Parser({
            lexer: new Lexer(s),
            xref: this,
            allowStreams: !0
        }), o = r.getObj(), l = r.getObj(), c = r.getObj();
        if (o !== a || l !== n || !(c instanceof Cmd)) throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e1}`);
        if ("obj" !== c.cmd) {
            if (c.cmd.startsWith("obj") && (a = parseInt(c.cmd.substring(3), 10), !Number.isNaN(a))) return a;
            throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e1}`);
        }
        return (t = this.encrypt && !i ? r.getObj(this.encrypt.createCipherTransform(a, n)) : r.getObj()) instanceof BaseStream || this._cacheMap.set(a, t), t;
    }
    fetchCompressed(e1, t, i = !1) {
        const n = t.offset, a = this.fetch(Ref.get(n, 0));
        if (!(a instanceof BaseStream)) throw new ti("bad ObjStm stream");
        const s = a.dict.get("First"), r = a.dict.get("N");
        if (!Number.isInteger(s) || !Number.isInteger(r)) throw new ti("invalid first and n parameters for ObjStm stream");
        let o = new Parser({
            lexer: new Lexer(a),
            xref: this,
            allowStreams: !0
        });
        const l = new Array(r), c = new Array(r);
        for(let e1 = 0; e1 < r; ++e1){
            const t = o.getObj();
            if (!Number.isInteger(t)) throw new ti(`invalid object number in the ObjStm stream: ${t}`);
            const i = o.getObj();
            if (!Number.isInteger(i)) throw new ti(`invalid object offset in the ObjStm stream: ${i}`);
            l[e1] = t;
            const a = this.getEntry(t);
            a?.offset === n && a.gen !== e1 && (a.gen = e1), c[e1] = i;
        }
        const h = (a.start || 0) + s, d = new Array(r);
        for(let e1 = 0; e1 < r; ++e1){
            const t = e1 < r - 1 ? c[e1 + 1] - c[e1] : void 0;
            if (t < 0) throw new ti("Invalid offset in the ObjStm stream.");
            o = new Parser({
                lexer: new Lexer(a.makeSubStream(h + c[e1], t, a.dict)),
                xref: this,
                allowStreams: !0
            });
            const i = o.getObj();
            if (d[e1] = i, i instanceof BaseStream) continue;
            const s = l[e1], u = this.entries[s];
            u && u.offset === n && u.gen === e1 && this._cacheMap.set(s, i);
        }
        if (void 0 === (t = d[t.gen])) throw new XRefEntryException(`Bad (compressed) XRef entry: ${e1}`);
        return t;
    }
    async fetchIfRefAsync(e1, t) {
        return e1 instanceof Ref ? this.fetchAsync(e1, t) : e1;
    }
    async fetchAsync(e1, t) {
        try {
            return this.fetch(e1, t);
        } catch (i) {
            if (!(i instanceof MissingDataException)) throw i;
            return await this.pdfManager.requestRange(i.begin, i.end), this.fetchAsync(e1, t);
        }
    }
    getCatalogObj() {
        return this.root;
    }
}
const ul = [
    0,
    0,
    612,
    792
];
class Page {
    #qe = !1;
    #ze = null;
    constructor({ pdfManager: e1, xref: t, pageIndex: i, pageDict: n, ref: a, globalIdFactory: s, fontCache: r, builtInCMapCache: o, standardFontDataCache: l, globalColorSpaceCache: c, globalImageCache: h, systemFontCache: d, nonBlendModesSet: u, xfaFactory: g }){
        this.pdfManager = e1, this.pageIndex = i, this.pageDict = n, this.xref = t, this.ref = a, this.fontCache = r, this.builtInCMapCache = o, this.standardFontDataCache = l, this.globalColorSpaceCache = c, this.globalImageCache = h, this.systemFontCache = d, this.nonBlendModesSet = u, this.evaluatorOptions = e1.evaluatorOptions, this.xfaFactory = g;
        const f = {
            obj: 0
        };
        this._localIdFactory = class extends s {
            static createObjId() {
                return `p${i}_${++f.obj}`;
            }
            static getPageObjId() {
                return `p${a.toString()}`;
            }
        };
    }
    #We(e1) {
        return new PartialEvaluator({
            xref: this.xref,
            handler: e1,
            pageIndex: this.pageIndex,
            idFactory: this._localIdFactory,
            fontCache: this.fontCache,
            builtInCMapCache: this.builtInCMapCache,
            standardFontDataCache: this.standardFontDataCache,
            globalColorSpaceCache: this.globalColorSpaceCache,
            globalImageCache: this.globalImageCache,
            systemFontCache: this.systemFontCache,
            options: this.evaluatorOptions
        });
    }
    #Ge(e1, t = !1) {
        const i = getInheritableProperty({
            dict: this.pageDict,
            key: e1,
            getArray: t,
            stopWhenFound: !1
        });
        return Array.isArray(i) ? 1 !== i.length && i[0] instanceof Dict ? Dict.merge({
            xref: this.xref,
            dictArray: i
        }) : i[0] : i;
    }
    get content() {
        return this.pageDict.getArray("Contents");
    }
    get resources() {
        const e1 = this.#Ge("Resources");
        return shadow$1(this, "resources", e1 instanceof Dict ? e1 : Dict.empty);
    }
    #Ve(e1) {
        if (this.xfaData) return this.xfaData.bbox;
        const t = lookupNormalRect(this.#Ge(e1, !0), null);
        if (t) {
            if (t[2] - t[0] > 0 && t[3] - t[1] > 0) return t;
            warn$1(`Empty, or invalid, /${e1} entry.`);
        }
        return null;
    }
    get mediaBox() {
        return shadow$1(this, "mediaBox", this.#Ve("MediaBox") || ul);
    }
    get cropBox() {
        return shadow$1(this, "cropBox", this.#Ve("CropBox") || this.mediaBox);
    }
    get userUnit() {
        const e1 = this.pageDict.get("UserUnit");
        return shadow$1(this, "userUnit", "number" == typeof e1 && e1 > 0 ? e1 : 1);
    }
    get view() {
        const { cropBox: e1, mediaBox: t } = this;
        if (e1 !== t && !isArrayEqual(e1, t)) {
            const i = ai.intersect(e1, t);
            if (i && i[2] - i[0] > 0 && i[3] - i[1] > 0) return shadow$1(this, "view", i);
            warn$1("Empty /CropBox and /MediaBox intersection.");
        }
        return shadow$1(this, "view", t);
    }
    get rotate() {
        let e1 = this.#Ge("Rotate") || 0;
        return e1 % 90 != 0 ? e1 = 0 : e1 >= 360 ? e1 %= 360 : e1 < 0 && (e1 = (e1 % 360 + 360) % 360), shadow$1(this, "rotate", e1);
    }
    #Ke(e1, t) {
        if (!this.evaluatorOptions.ignoreErrors) throw e1;
        warn$1(`getContentStream - ignoring sub-stream (${t}): "${e1}".`);
    }
    async getContentStream() {
        const e1 = await this.pdfManager.ensure(this, "content");
        return e1 instanceof BaseStream ? e1 : Array.isArray(e1) ? new StreamsSequenceStream(e1, this.#Ke.bind(this)) : new NullStream;
    }
    get xfaData() {
        return shadow$1(this, "xfaData", this.xfaFactory ? {
            bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
        } : null);
    }
    async #Ye(e1, t, i) {
        const n = [];
        for (const a of e1)if (a.id) {
            const e1 = Ref.fromString(a.id);
            if (!e1) {
                warn$1(`A non-linked annotation cannot be modified: ${a.id}`);
                continue;
            }
            if (a.deleted) {
                if (t.put(e1, e1), a.popupRef) {
                    const e1 = Ref.fromString(a.popupRef);
                    e1 && t.put(e1, e1);
                }
                continue;
            }
            if (a.popup?.deleted) {
                const e1 = Ref.fromString(a.popupRef);
                e1 && t.put(e1, e1);
            }
            i?.put(e1), a.ref = e1, n.push(this.xref.fetchAsync(e1).then((e1)=>{
                e1 instanceof Dict && (a.oldAnnotation = e1.clone());
            }, ()=>{
                warn$1(`Cannot fetch \`oldAnnotation\` for: ${e1}.`);
            })), delete a.id;
        }
        await Promise.all(n);
    }
    async saveNewAnnotations(e1, t, i, n, a) {
        if (this.xfaFactory) throw new Error("XFA: Cannot save new annotations.");
        const s = this.#We(e1), r = new RefSetCache, o = new RefSet;
        await this.#Ye(i, r, o);
        const l = this.pageDict, c = this.annotations.filter((e1)=>!(e1 instanceof Ref && r.has(e1))), h = await AnnotationFactory.saveNewAnnotations(s, t, i, n, a);
        for (const { ref: e1 } of h.annotations)e1 instanceof Ref && !o.has(e1) && c.push(e1);
        const d = l.clone();
        d.set("Annots", c), a.put(this.ref, {
            data: d
        });
        for (const e1 of r)a.put(e1, {
            data: null
        });
    }
    async save(e1, t, i, n) {
        const a = this.#We(e1), s = await this._parsedAnnotations, r = [];
        for (const e1 of s)r.push(e1.save(a, t, i, n).catch(function(e1) {
            return warn$1(`save - ignoring annotation data during "${t.name}" task: "${e1}".`), null;
        }));
        return Promise.all(r);
    }
    async loadResources(e1) {
        await (this.#ze ??= this.pdfManager.ensure(this, "resources")), await ObjectLoader.load(this.resources, e1, this.xref);
    }
    async #Je(e1, t) {
        const i = e1?.get("Resources");
        return i instanceof Dict && i.size ? (await ObjectLoader.load(i, t, this.xref), Dict.merge({
            xref: this.xref,
            dictArray: [
                i,
                this.resources
            ],
            mergeSubDicts: !0
        })) : this.resources;
    }
    async getOperatorList({ handler: e1, sink: t, task: i, intent: n, cacheKey: a, annotationStorage: l = null, modifiedIds: u = null }) {
        const f = this.getContentStream(), p = this.loadResources(mi), m = this.#We(e1), b = this.xfaFactory ? null : getNewAnnotationsMap(l), y = b?.get(this.pageIndex);
        let w = Promise.resolve(null), x = null;
        if (y) {
            const e1 = this.pdfManager.ensureDoc("annotationGlobals");
            let t;
            const n = new Set;
            for (const { bitmapId: e1, bitmap: t } of y)!e1 || t || n.has(e1) || n.add(e1);
            const { isOffscreenCanvasSupported: a } = this.evaluatorOptions;
            if (n.size > 0) {
                const e1 = y.slice();
                for (const [t, i] of l)t.startsWith(g) && i.bitmap && n.has(i.bitmapId) && e1.push(i);
                t = AnnotationFactory.generateImages(e1, this.xref, a);
            } else t = AnnotationFactory.generateImages(y, this.xref, a);
            x = new RefSet, w = Promise.all([
                e1,
                this.#Ye(y, x, null)
            ]).then(([e1])=>e1 ? AnnotationFactory.printNewAnnotations(e1, m, i, y, t) : null);
        }
        const S = Promise.all([
            f,
            p
        ]).then(async ([s])=>{
            const r = await this.#Je(s.dict, mi), o = new OperatorList(n, t);
            return e1.send("StartRenderPage", {
                transparency: m.hasBlendModes(r, this.nonBlendModesSet),
                pageIndex: this.pageIndex,
                cacheKey: a
            }), await m.getOperatorList({
                stream: s,
                task: i,
                resources: r,
                operatorList: o
            }), o;
        });
        let [v, C, k] = await Promise.all([
            S,
            this._parsedAnnotations,
            w
        ]);
        if (k) {
            C = C.filter((e1)=>!(e1.ref && x.has(e1.ref)));
            for(let e1 = 0, t = k.length; e1 < t; e1++){
                const i = k[e1];
                if (i.refToReplace) {
                    const n = C.findIndex((e1)=>e1.ref && isRefsEqual(e1.ref, i.refToReplace));
                    n >= 0 && (C.splice(n, 1, i), k.splice(e1--, 1), t--);
                }
            }
            C = C.concat(k);
        }
        if (0 === C.length || n & h) return v.flush(!0), {
            length: v.totalLength
        };
        const T = !!(n & c), F = !!(n & d), E = !!(n & s), M = !!(n & r), D = !!(n & o), O = [];
        for (const e1 of C)(E || M && e1.mustBeViewed(l, T) && e1.mustBeViewedWhenEditing(F, u) || D && e1.mustBePrinted(l)) && O.push(e1.getOperatorList(m, i, n, l).catch(function(e1) {
            return warn$1(`getOperatorList - ignoring annotation data during "${i.name}" task: "${e1}".`), {
                opList: null,
                separateForm: !1,
                separateCanvas: !1
            };
        }));
        const _ = await Promise.all(O);
        let R = !1, N = !1;
        for (const { opList: e1, separateForm: t, separateCanvas: i } of _)v.addOpList(e1), R ||= t, N ||= i;
        return v.flush(!0, {
            form: R,
            canvas: N
        }), {
            length: v.totalLength
        };
    }
    async extractTextContent({ handler: e1, task: t, includeMarkedContent: i, disableNormalization: n, sink: a, intersector: s = null }) {
        const r = this.getContentStream(), o = this.loadResources(bi), l = this.pdfManager.ensureCatalog("lang"), [c, , h] = await Promise.all([
            r,
            o,
            l
        ]), d = await this.#Je(c.dict, bi);
        return this.#We(e1).getTextContent({
            stream: c,
            task: t,
            resources: d,
            includeMarkedContent: i,
            disableNormalization: n,
            sink: a,
            viewBox: this.view,
            lang: h,
            intersector: s
        });
    }
    async getStructTree() {
        const e1 = await this.pdfManager.ensureCatalog("structTreeRoot");
        if (!e1) return null;
        await this._parsedAnnotations;
        try {
            const t = await this.pdfManager.ensure(this, "_parseStructTree", [
                e1
            ]);
            return await this.pdfManager.ensure(t, "serializable");
        } catch (e1) {
            return warn$1(`getStructTree: "${e1}".`), null;
        }
    }
    _parseStructTree(e1) {
        const t = new StructTreePage(e1, this.pageDict);
        return t.parse(this.ref), t;
    }
    async getAnnotationsData(e1, t, i) {
        const n = await this._parsedAnnotations;
        if (0 === n.length) return n;
        const a = [], l = [];
        let c;
        const h = !!(i & s), d = !!(i & r), u = !!(i & o), g = [];
        for (const i of n){
            const n = h || d && i.viewable;
            (n || u && i.printable) && a.push(i.data), i.hasTextContent && n ? (c ??= this.#We(e1), l.push(i.extractTextContent(c, t, [
                -1 / 0,
                -1 / 0,
                1 / 0,
                1 / 0
            ]).catch(function(e1) {
                warn$1(`getAnnotationsData - ignoring textContent during "${t.name}" task: "${e1}".`);
            }))) : i.overlaysTextContent && n && g.push(i);
        }
        if (g.length > 0) {
            const i = new Intersector(g);
            l.push(this.extractTextContent({
                handler: e1,
                task: t,
                includeMarkedContent: !1,
                disableNormalization: !1,
                sink: null,
                viewBox: this.view,
                lang: null,
                intersector: i
            }).then(()=>{
                i.setText();
            }));
        }
        return await Promise.all(l), a;
    }
    get annotations() {
        const e1 = this.#Ge("Annots");
        return shadow$1(this, "annotations", Array.isArray(e1) ? e1 : []);
    }
    get _parsedAnnotations() {
        const e1 = this.pdfManager.ensure(this, "annotations").then(async (e1)=>{
            if (0 === e1.length) return e1;
            const [t, i] = await Promise.all([
                this.pdfManager.ensureDoc("annotationGlobals"),
                this.pdfManager.ensureDoc("fieldObjects")
            ]);
            if (!t) return [];
            const n = i?.orphanFields, a = [];
            for (const i of e1)a.push(AnnotationFactory.create(this.xref, i, t, this._localIdFactory, !1, n, null, this.ref).catch(function(e1) {
                return warn$1(`_parsedAnnotations: "${e1}".`), null;
            }));
            const s = [];
            let r, o;
            for (const e1 of (await Promise.all(a)))e1 && (e1 instanceof WidgetAnnotation ? (o ||= []).push(e1) : e1 instanceof PopupAnnotation ? (r ||= []).push(e1) : s.push(e1));
            return o && s.push(...o), r && s.push(...r), s;
        });
        return this.#qe = !0, shadow$1(this, "_parsedAnnotations", e1);
    }
    get jsActions() {
        return shadow$1(this, "jsActions", collectActions(this.xref, this.pageDict, ne));
    }
    async collectAnnotationsByType(e1, t, i, n, a) {
        const { pageIndex: s } = this;
        if (this.#qe) {
            const e1 = await this._parsedAnnotations;
            for (const { data: t } of e1)i && !i.has(t.annotationType) || (t.pageIndex = s, n.push(Promise.resolve(t)));
            return;
        }
        const r = await this.pdfManager.ensure(this, "annotations");
        for (const o of r)n.push(AnnotationFactory.create(this.xref, o, a, this._localIdFactory, !1, null, i, this.ref).then(async (i)=>{
            if (!i) return null;
            if (i.data.pageIndex = s, i.hasTextContent && i.viewable) {
                const n = this.#We(e1);
                await i.extractTextContent(n, t, [
                    -1 / 0,
                    -1 / 0,
                    1 / 0,
                    1 / 0
                ]);
            }
            return i.data;
        }).catch(function(e1) {
            return warn$1(`collectAnnotationsByType: "${e1}".`), null;
        }));
    }
}
const gl = new Uint8Array([
    37,
    80,
    68,
    70,
    45
]), fl = new Uint8Array([
    115,
    116,
    97,
    114,
    116,
    120,
    114,
    101,
    102
]), pl = new Uint8Array([
    101,
    110,
    100,
    111,
    98,
    106
]);
function find(e1, t, i = 1024, n = !1) {
    const a = t.length, s = e1.peekBytes(i), r = s.length - a;
    if (r <= 0) return !1;
    if (n) {
        const i = a - 1;
        let n = s.length - 1;
        for(; n >= i;){
            let r = 0;
            for(; r < a && s[n - r] === t[i - r];)r++;
            if (r >= a) return e1.pos += n - i, !0;
            n--;
        }
    } else {
        let i = 0;
        for(; i <= r;){
            let n = 0;
            for(; n < a && s[i + n] === t[n];)n++;
            if (n >= a) return e1.pos += i, !0;
            i++;
        }
    }
    return !1;
}
class PDFDocument {
    #Ze = new Map;
    #Qe = null;
    constructor(e1, t){
        if (t.length <= 0) throw new Qt("The PDF file is empty, i.e. its size is zero bytes.");
        this.pdfManager = e1, this.stream = t, this.xref = new XRef(t, e1);
        const i = {
            font: 0
        };
        this._globalIdFactory = class {
            static getDocId() {
                return `g_${e1.docId}`;
            }
            static createFontId() {
                return "f" + ++i.font;
            }
            static createObjId() {
                unreachable$1("Abstract method `createObjId` called.");
            }
            static getPageObjId() {
                unreachable$1("Abstract method `getPageObjId` called.");
            }
        };
    }
    parse(e1) {
        this.xref.parse(e1), this.catalog = new Catalog(this.pdfManager, this.xref);
    }
    get linearization() {
        let e1 = null;
        try {
            e1 = Linearization.create(this.stream);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info$1(e1);
        }
        return shadow$1(this, "linearization", e1);
    }
    get startXRef() {
        const e1 = this.stream;
        let t = 0;
        if (this.linearization) {
            if (e1.reset(), find(e1, pl)) {
                e1.skip(6);
                let i = e1.peekByte();
                for(; isWhiteSpace(i);)e1.pos++, i = e1.peekByte();
                t = e1.pos - e1.start;
            }
        } else {
            const i = 1024, n = fl.length;
            let a = !1, s = e1.end;
            for(; !a && s > 0;)s -= i - n, s < 0 && (s = 0), e1.pos = s, a = find(e1, fl, i, !0);
            if (a) {
                let i;
                e1.skip(9);
                do {
                    i = e1.getByte();
                }while (isWhiteSpace(i))
                let n = "";
                for(; i >= 32 && i <= 57;)n += String.fromCharCode(i), i = e1.getByte();
                t = parseInt(n, 10), isNaN(t) && (t = 0);
            }
        }
        return shadow$1(this, "startXRef", t);
    }
    checkHeader() {
        const e1 = this.stream;
        if (e1.reset(), !find(e1, gl)) return;
        e1.moveStart(), e1.skip(gl.length);
        let t, i = "";
        for(; (t = e1.getByte()) > 32 && i.length < 7;)i += String.fromCharCode(t);
        gi.test(i) ? this.#Qe = i : warn$1(`Invalid PDF header version: ${i}`);
    }
    parseStartXRef() {
        this.xref.setStartXRef(this.startXRef);
    }
    get numPages() {
        let e1 = 0;
        return e1 = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages, shadow$1(this, "numPages", e1);
    }
    #et(e1, t = 0) {
        return !!Array.isArray(e1) && e1.every((e1)=>{
            if (!((e1 = this.xref.fetchIfRef(e1)) instanceof Dict)) return !1;
            if (e1.has("Kids")) return ++t > 10 ? (warn$1("#hasOnlyDocumentSignatures: maximum recursion depth reached"), !1) : this.#et(e1.get("Kids"), t);
            const i = isName(e1.get("FT"), "Sig"), n = e1.get("Rect"), a = Array.isArray(n) && n.every((e1)=>0 === e1);
            return i && a;
        });
    }
    #tt(e1, t, i = new RefSet) {
        if (Array.isArray(e1)) for (let n of e1){
            if (n instanceof Ref) {
                if (i.has(n)) continue;
                i.put(n);
            }
            if (n = this.xref.fetchIfRef(n), !(n instanceof Dict)) continue;
            if (n.has("Kids")) {
                this.#tt(n.get("Kids"), t, i);
                continue;
            }
            if (!isName(n.get("FT"), "Sig")) continue;
            const e1 = n.get("V");
            if (!(e1 instanceof Dict)) continue;
            const a = e1.get("SubFilter");
            a instanceof Name && t.add(a.name);
        }
    }
    get _xfaStreams() {
        const { acroForm: e1 } = this.catalog;
        if (!e1) return null;
        const t = e1.get("XFA"), i = new Map([
            "xdp:xdp",
            "template",
            "datasets",
            "config",
            "connectionSet",
            "localeSet",
            "stylesheet",
            "/xdp:xdp"
        ].map((e1)=>[
                e1,
                null
            ]));
        if (t instanceof BaseStream && !t.isEmpty) return i.set("xdp:xdp", t), i;
        if (!Array.isArray(t) || 0 === t.length) return null;
        for(let e1 = 0, n = t.length; e1 < n; e1 += 2){
            let a;
            if (a = 0 === e1 ? "xdp:xdp" : e1 === n - 2 ? "/xdp:xdp" : t[e1], !i.has(a)) continue;
            const s = this.xref.fetchIfRef(t[e1 + 1]);
            s instanceof BaseStream && !s.isEmpty && i.set(a, s);
        }
        return i;
    }
    get xfaDatasets() {
        const e1 = this._xfaStreams;
        if (!e1) return shadow$1(this, "xfaDatasets", null);
        for (const t of [
            "datasets",
            "xdp:xdp"
        ]){
            const i = e1.get(t);
            if (i) try {
                const e1 = stringToUTF8String$1(i.getString());
                return shadow$1(this, "xfaDatasets", new DatasetReader({
                    [t]: e1
                }));
            } catch  {
                warn$1("XFA - Invalid utf-8 string.");
                break;
            }
        }
        return shadow$1(this, "xfaDatasets", null);
    }
    get xfaData() {
        const e1 = this._xfaStreams;
        if (!e1) return null;
        const t = Object.create(null);
        for (const [i, n] of e1)if (n) try {
            t[i] = stringToUTF8String$1(n.getString());
        } catch  {
            return warn$1("XFA - Invalid utf-8 string."), null;
        }
        return t;
    }
    get xfaFactory() {
        let e1;
        return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e1 = this.xfaData), shadow$1(this, "xfaFactory", e1 ? new XFAFactory(e1) : null);
    }
    get isPureXfa() {
        return !!this.xfaFactory && this.xfaFactory.isValid();
    }
    get htmlForXfa() {
        return this.xfaFactory ? this.xfaFactory.getPages() : null;
    }
    async #it() {
        const e1 = await this.pdfManager.ensureCatalog("xfaImages");
        e1 && this.xfaFactory.setImages(e1);
    }
    async #nt(e1, t) {
        const i = await this.pdfManager.ensureCatalog("acroForm");
        if (!i) return;
        const n = await i.getAsync("DR");
        if (!(n instanceof Dict)) return;
        await ObjectLoader.load(n, [
            "Font"
        ], this.xref);
        const a = n.get("Font");
        if (!(a instanceof Dict)) return;
        const s = Object.assign(Object.create(null), this.pdfManager.evaluatorOptions, {
            useSystemFonts: !1
        }), { builtInCMapCache: r, fontCache: o, standardFontDataCache: l } = this.catalog, c = new PartialEvaluator({
            xref: this.xref,
            handler: e1,
            pageIndex: -1,
            idFactory: this._globalIdFactory,
            fontCache: o,
            builtInCMapCache: r,
            standardFontDataCache: l,
            options: s
        }), h = new OperatorList, d = [], u = {
            get font () {
                return d.at(-1);
            },
            set font (e){
                d.push(e);
            },
            clone () {
                return this;
            }
        }, parseFont = (e1, i, a)=>c.handleSetFont(n, [
                Name.get(e1),
                1
            ], null, h, t, u, i, a).catch((e1)=>(warn$1(`loadXfaFonts: "${e1}".`), null)), g = [];
        for (const [e1, t] of a){
            const i = t.get("FontDescriptor");
            if (!(i instanceof Dict)) continue;
            let n = i.get("FontFamily");
            n = n.replaceAll(/[ ]+(\d)/g, "$1");
            const a = {
                fontFamily: n,
                fontWeight: i.get("FontWeight"),
                italicAngle: -i.get("ItalicAngle")
            };
            validateCSSFont(a) && g.push(parseFont(e1, null, a));
        }
        await Promise.all(g);
        const f = this.xfaFactory.setFonts(d);
        if (!f) return;
        s.ignoreErrors = !0, g.length = 0, d.length = 0;
        const p = new Set;
        for (const e1 of f)getXfaFontName(`${e1}-Regular`) || p.add(e1);
        p.size && f.push("PdfJS-Fallback");
        for (const e1 of f)if (!p.has(e1)) for (const t of [
            {
                name: "Regular",
                fontWeight: 400,
                italicAngle: 0
            },
            {
                name: "Bold",
                fontWeight: 700,
                italicAngle: 0
            },
            {
                name: "Italic",
                fontWeight: 400,
                italicAngle: 12
            },
            {
                name: "BoldItalic",
                fontWeight: 700,
                italicAngle: 12
            }
        ]){
            const i = `${e1}-${t.name}`;
            g.push(parseFont(i, getXfaFontDict(i), {
                fontFamily: e1,
                fontWeight: t.fontWeight,
                italicAngle: t.italicAngle
            }));
        }
        await Promise.all(g), this.xfaFactory.appendFonts(d, p);
    }
    loadXfaResources(e1, t) {
        return Promise.all([
            this.#nt(e1, t).catch(()=>{}),
            this.#it()
        ]);
    }
    serializeXfaData(e1) {
        return this.xfaFactory ? this.xfaFactory.serializeData(e1) : null;
    }
    get version() {
        return this.catalog.version || this.#Qe;
    }
    get formInfo() {
        const e1 = {
            hasFields: !1,
            hasAcroForm: !1,
            hasXfa: !1,
            hasSignatures: !1
        }, { acroForm: t } = this.catalog;
        if (!t) return shadow$1(this, "formInfo", e1);
        try {
            const i = t.get("Fields"), n = Array.isArray(i) && i.length > 0;
            e1.hasFields = n;
            const a = t.get("XFA");
            e1.hasXfa = Array.isArray(a) && a.length > 0 || a instanceof BaseStream && !a.isEmpty;
            const s = !!(1 & t.get("SigFlags")), r = s && this.#et(i);
            e1.hasAcroForm = n && !r, e1.hasSignatures = s;
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn$1(`Cannot fetch form information: "${e1}".`);
        }
        return shadow$1(this, "formInfo", e1);
    }
    get documentInfo() {
        const { catalog: e1, formInfo: t, xref: i } = this, n = {
            PDFFormatVersion: this.version,
            Language: e1.lang,
            EncryptFilterName: i.encrypt?.filterName ?? null,
            IsLinearized: !!this.linearization,
            IsAcroFormPresent: t.hasAcroForm,
            IsXFAPresent: t.hasXfa,
            IsCollectionPresent: !!e1.collection,
            IsSignaturesPresent: t.hasSignatures
        };
        let a;
        try {
            a = i.trailer.get("Info");
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info$1("The document information dictionary is invalid.");
        }
        if (!(a instanceof Dict)) return shadow$1(this, "documentInfo", n);
        for (const [e1, t] of a){
            switch(e1){
                case "Title":
                case "Author":
                case "Subject":
                case "Keywords":
                case "Creator":
                case "Producer":
                case "CreationDate":
                case "ModDate":
                    if ("string" == typeof t) {
                        n[e1] = stringToPDFString(t);
                        continue;
                    }
                    break;
                case "Trapped":
                    if (t instanceof Name) {
                        n[e1] = t;
                        continue;
                    }
                    break;
                default:
                    let i;
                    switch(typeof t){
                        case "string":
                            i = stringToPDFString(t);
                            break;
                        case "number":
                        case "boolean":
                            i = t;
                            break;
                        default:
                            t instanceof Name && (i = t);
                    }
                    if (void 0 === i) {
                        warn$1(`Bad value, for custom key "${e1}", in Info: ${t}.`);
                        continue;
                    }
                    n.Custom ??= Object.create(null), n.Custom[e1] = i;
                    continue;
            }
            warn$1(`Bad value, for key "${e1}", in Info: ${t}.`);
        }
        return shadow$1(this, "documentInfo", n);
    }
    get fingerprints() {
        const e1 = "\0".repeat(16);
        function validate(t) {
            return "string" == typeof t && 16 === t.length && t !== e1;
        }
        const t = this.xref.trailer.get("ID");
        let i, n;
        return Array.isArray(t) && validate(t[0]) ? (i = stringToBytes$1(t[0]), t[1] !== t[0] && validate(t[1]) && (n = stringToBytes$1(t[1]))) : i = calculateMD5(this.stream.getByteRange(0, 1024), 0, 1024), shadow$1(this, "fingerprints", [
            toHexUtil(i),
            n ? toHexUtil(n) : null
        ]);
    }
    async #at(e1) {
        const { catalog: t, linearization: i, xref: n } = this, a = Ref.get(i.objectNumberFirst, 0);
        try {
            const e1 = await n.fetchAsync(a);
            if (e1 instanceof Dict) {
                let i = e1.getRaw("Type");
                if (i instanceof Ref && (i = await n.fetchAsync(i)), isName(i, "Page") || !e1.has("Type") && !e1.has("Kids") && e1.has("Contents")) return t.pageKidsCountCache.has(a) || t.pageKidsCountCache.put(a, 1), t.pageIndexCache.has(a) || t.pageIndexCache.put(a, 0), [
                    e1,
                    a
                ];
            }
            throw new ti("The Linearization dictionary doesn't point to a valid Page dictionary.");
        } catch (i) {
            return warn$1(`_getLinearizationPage: "${i.message}".`), t.getPageDict(e1);
        }
    }
    getPage(e1) {
        const t = this.#Ze.get(e1);
        if (t) return t;
        const { catalog: i, linearization: n, xfaFactory: a } = this;
        let s;
        return s = a ? Promise.resolve([
            Dict.empty,
            null
        ]) : n?.pageFirst === e1 ? this.#at(e1) : i.getPageDict(e1), s = s.then(([t, n])=>new Page({
                pdfManager: this.pdfManager,
                xref: this.xref,
                pageIndex: e1,
                pageDict: t,
                ref: n,
                globalIdFactory: this._globalIdFactory,
                fontCache: i.fontCache,
                builtInCMapCache: i.builtInCMapCache,
                standardFontDataCache: i.standardFontDataCache,
                globalColorSpaceCache: i.globalColorSpaceCache,
                globalImageCache: i.globalImageCache,
                systemFontCache: i.systemFontCache,
                nonBlendModesSet: i.nonBlendModesSet,
                xfaFactory: a
            })), this.#Ze.set(e1, s), s;
    }
    async checkFirstPage(e1 = !1) {
        if (!e1) try {
            await this.getPage(0);
        } catch (e1) {
            if (e1 instanceof XRefEntryException) throw this.#Ze.delete(0), await this.cleanup(), new XRefParseException;
        }
    }
    async checkLastPage(e1 = !1) {
        const { catalog: t, pdfManager: i } = this;
        let n;
        t.setActualNumPages();
        try {
            if (await Promise.all([
                i.ensureDoc("xfaFactory"),
                i.ensureDoc("linearization"),
                i.ensureCatalog("numPages")
            ]), this.xfaFactory) return;
            if (n = this.linearization ? this.linearization.numPages : t.numPages, !Number.isInteger(n)) throw new ti("Page count is not an integer.");
            if (n <= 1) return;
            await this.getPage(n - 1);
        } catch (a) {
            if (this.#Ze.delete(n - 1), await this.cleanup(), a instanceof XRefEntryException && !e1) throw new XRefParseException;
            let s;
            warn$1(`checkLastPage - invalid /Pages tree /Count: ${n}.`);
            try {
                s = await t.getAllPageDicts(e1);
            } catch (i) {
                if (i instanceof XRefEntryException && !e1) throw new XRefParseException;
                return void t.setActualNumPages(1);
            }
            for (const [e1, [n, a]] of s){
                let s;
                n instanceof Error ? (s = Promise.reject(n), s.catch(()=>{})) : s = Promise.resolve(new Page({
                    pdfManager: i,
                    xref: this.xref,
                    pageIndex: e1,
                    pageDict: n,
                    ref: a,
                    globalIdFactory: this._globalIdFactory,
                    fontCache: t.fontCache,
                    builtInCMapCache: t.builtInCMapCache,
                    standardFontDataCache: t.standardFontDataCache,
                    globalColorSpaceCache: this.globalColorSpaceCache,
                    globalImageCache: t.globalImageCache,
                    systemFontCache: t.systemFontCache,
                    nonBlendModesSet: t.nonBlendModesSet,
                    xfaFactory: null
                })), this.#Ze.set(e1, s);
            }
            t.setActualNumPages(s.size);
        }
    }
    async fontFallback(e1, t) {
        const { catalog: i, pdfManager: n } = this;
        for (const a of (await Promise.all(i.fontCache)))if (a.loadedName === e1) return void a.fallback(t, n.evaluatorOptions);
    }
    async cleanup(e1 = !1) {
        return this.catalog ? this.catalog.cleanup(e1) : clearGlobalCaches();
    }
    async #st(e1, t, i, n, a, s, r) {
        const { xref: o } = this;
        if (!(i instanceof Ref) || s.has(i)) return;
        s.put(i);
        const l = await o.fetchAsync(i);
        if (!(l instanceof Dict)) return;
        let c = await l.getAsync("Subtype");
        if (c = c instanceof Name ? c.name : null, "Link" === c) return;
        if (l.has("T")) {
            const t = stringToPDFString(await l.getAsync("T"));
            e1 = "" === e1 ? t : `${e1}.${t}`;
        } else {
            let i = l;
            for(;;){
                if (i = i.getRaw("Parent") || t, i instanceof Ref) {
                    if (s.has(i)) break;
                    i = await o.fetchAsync(i);
                }
                if (!(i instanceof Dict)) break;
                if (i.has("T")) {
                    const t = stringToPDFString(await i.getAsync("T"));
                    e1 = "" === e1 ? t : `${e1}.${t}`;
                    break;
                }
            }
        }
        if (t && !l.has("Parent") && isName(l.get("Subtype"), "Widget") && r.put(i, t), n.has(e1) || n.set(e1, []), n.get(e1).push(AnnotationFactory.create(o, i, a, null, !0, r, null, null).then((e1)=>e1?.getFieldObject()).catch(function(e1) {
            return warn$1(`#collectFieldObjects: "${e1}".`), null;
        })), !l.has("Kids")) return;
        const h = await l.getAsync("Kids");
        if (Array.isArray(h)) for (const t of h)await this.#st(e1, i, t, n, a, s, r);
    }
    get fieldObjects() {
        return shadow$1(this, "fieldObjects", this.pdfManager.ensureDoc("formInfo").then(async (e1)=>{
            if (!e1.hasFields) return null;
            const t = await this.annotationGlobals;
            if (!t) return null;
            const { acroForm: i } = t, n = new RefSet, a = Object.create(null), s = new Map, r = new RefSetCache;
            for (const e1 of i.get("Fields"))await this.#st("", null, e1, s, t, n, r);
            const o = [];
            for (const [e1, t] of s)o.push(Promise.all(t).then((t)=>{
                (t = t.filter((e1)=>!!e1)).length > 0 && (a[e1] = t);
            }));
            return await Promise.all(o), {
                allFields: objectSize(a) > 0 ? a : null,
                orphanFields: r
            };
        }));
    }
    get hasJSActions() {
        return shadow$1(this, "hasJSActions", this.pdfManager.ensureDoc("_parseHasJSActions"));
    }
    async _parseHasJSActions() {
        const [e1, t] = await Promise.all([
            this.pdfManager.ensureCatalog("jsActions"),
            this.pdfManager.ensureDoc("fieldObjects")
        ]);
        return !!e1 || !!t?.allFields && Object.values(t.allFields).some((e1)=>e1.some((e1)=>null !== e1.actions));
    }
    get calculationOrderIds() {
        const e1 = this.catalog.acroForm?.get("CO");
        if (!Array.isArray(e1) || 0 === e1.length) return shadow$1(this, "calculationOrderIds", null);
        const t = [];
        for (const i of e1)i instanceof Ref && t.push(i.toString());
        return shadow$1(this, "calculationOrderIds", t.length ? t : null);
    }
    get annotationGlobals() {
        return shadow$1(this, "annotationGlobals", AnnotationFactory.createGlobals(this.pdfManager));
    }
}
class BasePdfManager {
    constructor({ docBaseUrl: e1, docId: t, enableXfa: i, evaluatorOptions: n, handler: a, password: s }){
        this._docBaseUrl = function(e1) {
            if (e1) {
                const t = createValidAbsoluteUrl$1(e1);
                if (t) return t.href;
                warn$1(`Invalid absolute docBaseUrl: "${e1}".`);
            }
            return null;
        }(e1), this._docId = t, this._password = s, this.enableXfa = i, n.isOffscreenCanvasSupported &&= FeatureTest.isOffscreenCanvasSupported, n.isImageDecoderSupported &&= FeatureTest.isImageDecoderSupported, this.evaluatorOptions = Object.freeze(n), ImageResizer.setOptions(n), JpegStream.setOptions(n), OperatorList.setOptions(n);
        const r = {
            ...n,
            handler: a
        };
        JpxImage.setOptions(r), IccColorSpace.setOptions(r), CmykICCBasedCS.setOptions(r);
    }
    get docId() {
        return this._docId;
    }
    get password() {
        return this._password;
    }
    get docBaseUrl() {
        return this._docBaseUrl;
    }
    ensureDoc(e1, t) {
        return this.ensure(this.pdfDocument, e1, t);
    }
    ensureXRef(e1, t) {
        return this.ensure(this.pdfDocument.xref, e1, t);
    }
    ensureCatalog(e1, t) {
        return this.ensure(this.pdfDocument.catalog, e1, t);
    }
    getPage(e1) {
        return this.pdfDocument.getPage(e1);
    }
    fontFallback(e1, t) {
        return this.pdfDocument.fontFallback(e1, t);
    }
    cleanup(e1 = !1) {
        return this.pdfDocument.cleanup(e1);
    }
    async ensure(e1, t, i) {
        unreachable$1("Abstract method `ensure` called");
    }
    requestRange(e1, t) {
        unreachable$1("Abstract method `requestRange` called");
    }
    requestLoadedStream(e1 = !1) {
        unreachable$1("Abstract method `requestLoadedStream` called");
    }
    sendProgressiveData(e1) {
        unreachable$1("Abstract method `sendProgressiveData` called");
    }
    updatePassword(e1) {
        this._password = e1;
    }
    terminate(e1) {
        unreachable$1("Abstract method `terminate` called");
    }
}
class LocalPdfManager extends BasePdfManager {
    constructor(e1){
        super(e1);
        const t = new Stream(e1.source);
        this.pdfDocument = new PDFDocument(this, t), this._loadedStreamPromise = Promise.resolve(t);
    }
    async ensure(e1, t, i) {
        const n = e1[t];
        return "function" == typeof n ? n.apply(e1, i) : n;
    }
    requestRange(e1, t) {
        return Promise.resolve();
    }
    requestLoadedStream(e1 = !1) {
        return this._loadedStreamPromise;
    }
    terminate(e1) {}
}
class NetworkPdfManager extends BasePdfManager {
    constructor(e1){
        super(e1), this.streamManager = new ChunkedStreamManager(e1.source, {
            msgHandler: e1.handler,
            length: e1.length,
            disableAutoFetch: e1.disableAutoFetch,
            rangeChunkSize: e1.rangeChunkSize
        }), this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());
    }
    async ensure(e1, t, i) {
        try {
            const n = e1[t];
            return "function" == typeof n ? n.apply(e1, i) : n;
        } catch (n) {
            if (!(n instanceof MissingDataException)) throw n;
            return await this.requestRange(n.begin, n.end), this.ensure(e1, t, i);
        }
    }
    requestRange(e1, t) {
        return this.streamManager.requestRange(e1, t);
    }
    requestLoadedStream(e1 = !1) {
        return this.streamManager.requestAllChunks(e1);
    }
    sendProgressiveData(e1) {
        this.streamManager.onReceiveData({
            chunk: e1
        });
    }
    terminate(e1) {
        this.streamManager.abort(e1);
    }
}
const ml = 1, bl = 2, yl = 1, wl = 2, Al = 3, xl = 4, Sl = 5, vl = 6, Cl = 7, kl = 8;
function onFn$1() {}
function wrapReason$1(e1) {
    if (e1 instanceof ii || e1 instanceof Qt || e1 instanceof Jt || e1 instanceof ei || e1 instanceof Zt) return e1;
    switch(e1 instanceof Error || "object" == typeof e1 && null !== e1 || unreachable$1('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), e1.name){
        case "AbortException":
            return new ii(e1.message);
        case "InvalidPDFException":
            return new Qt(e1.message);
        case "PasswordException":
            return new Jt(e1.message, e1.code);
        case "ResponseException":
            return new ei(e1.message, e1.status, e1.missing);
        case "UnknownErrorException":
            return new Zt(e1.message, e1.details);
    }
    return new Zt(e1.message, e1.toString());
}
let Tl = class {
    #rt = new AbortController;
    constructor(e1, t, i){
        this.sourceName = e1, this.targetName = t, this.comObj = i, this.callbackId = 1, this.streamId = 1, this.streamSinks = Object.create(null), this.streamControllers = Object.create(null), this.callbackCapabilities = Object.create(null), this.actionHandler = Object.create(null), i.addEventListener("message", this.#ot.bind(this), {
            signal: this.#rt.signal
        });
    }
    #ot({ data: e1 }) {
        if (e1.targetName !== this.sourceName) return;
        if (e1.stream) return void this.#lt(e1);
        if (e1.callback) {
            const t = e1.callbackId, i = this.callbackCapabilities[t];
            if (!i) throw new Error(`Cannot resolve callback ${t}`);
            if (delete this.callbackCapabilities[t], e1.callback === ml) i.resolve(e1.data);
            else {
                if (e1.callback !== bl) throw new Error("Unexpected callback case");
                i.reject(wrapReason$1(e1.reason));
            }
            return;
        }
        const t = this.actionHandler[e1.action];
        if (!t) throw new Error(`Unknown action from worker: ${e1.action}`);
        if (e1.callbackId) {
            const i = this.sourceName, n = e1.sourceName, a = this.comObj;
            return void Promise.try(t, e1.data).then(function(t) {
                a.postMessage({
                    sourceName: i,
                    targetName: n,
                    callback: ml,
                    callbackId: e1.callbackId,
                    data: t
                });
            }, function(t) {
                a.postMessage({
                    sourceName: i,
                    targetName: n,
                    callback: bl,
                    callbackId: e1.callbackId,
                    reason: wrapReason$1(t)
                });
            });
        }
        e1.streamId ? this.#ct(e1) : t(e1.data);
    }
    on(e1, t) {
        const i = this.actionHandler;
        if (i[e1]) throw new Error(`There is already an actionName called "${e1}"`);
        i[e1] = t;
    }
    send(e1, t, i) {
        this.comObj.postMessage({
            sourceName: this.sourceName,
            targetName: this.targetName,
            action: e1,
            data: t
        }, i);
    }
    sendWithPromise(e1, t, i) {
        const n = this.callbackId++, a = Promise.withResolvers();
        this.callbackCapabilities[n] = a;
        try {
            this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: e1,
                callbackId: n,
                data: t
            }, i);
        } catch (e1) {
            a.reject(e1);
        }
        return a.promise;
    }
    sendWithStream(e1, t, i, n) {
        const a = this.streamId++, s = this.sourceName, r = this.targetName, o = this.comObj;
        return new ReadableStream({
            start: (i)=>{
                const l = Promise.withResolvers();
                return this.streamControllers[a] = {
                    controller: i,
                    startCall: l,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                }, o.postMessage({
                    sourceName: s,
                    targetName: r,
                    action: e1,
                    streamId: a,
                    data: t,
                    desiredSize: i.desiredSize
                }, n), l.promise;
            },
            pull: (e1)=>{
                const t = Promise.withResolvers();
                return this.streamControllers[a].pullCall = t, o.postMessage({
                    sourceName: s,
                    targetName: r,
                    stream: vl,
                    streamId: a,
                    desiredSize: e1.desiredSize
                }), t.promise;
            },
            cancel: (e1)=>{
                assert$1(e1 instanceof Error, "cancel must have a valid reason");
                const t = Promise.withResolvers();
                return this.streamControllers[a].cancelCall = t, this.streamControllers[a].isClosed = !0, o.postMessage({
                    sourceName: s,
                    targetName: r,
                    stream: yl,
                    streamId: a,
                    reason: wrapReason$1(e1)
                }), t.promise;
            }
        }, i);
    }
    #ct(e1) {
        const t = e1.streamId, i = this.sourceName, n = e1.sourceName, a = this.comObj, s = this, r = this.actionHandler[e1.action], o = {
            enqueue (e1, s = 1, r) {
                if (this.isCancelled) return;
                const o = this.desiredSize;
                this.desiredSize -= s, o > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), a.postMessage({
                    sourceName: i,
                    targetName: n,
                    stream: xl,
                    streamId: t,
                    chunk: e1
                }, r);
            },
            close () {
                this.isCancelled || (this.isCancelled = !0, a.postMessage({
                    sourceName: i,
                    targetName: n,
                    stream: Al,
                    streamId: t
                }), delete s.streamSinks[t]);
            },
            error (e1) {
                assert$1(e1 instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = !0, a.postMessage({
                    sourceName: i,
                    targetName: n,
                    stream: Sl,
                    streamId: t,
                    reason: wrapReason$1(e1)
                }));
            },
            sinkCapability: Promise.withResolvers(),
            onPull: null,
            onCancel: null,
            isCancelled: !1,
            desiredSize: e1.desiredSize,
            ready: null
        };
        o.sinkCapability.resolve(), o.ready = o.sinkCapability.promise, this.streamSinks[t] = o, Promise.try(r, e1.data, o).then(function() {
            a.postMessage({
                sourceName: i,
                targetName: n,
                stream: kl,
                streamId: t,
                success: !0
            });
        }, function(e1) {
            a.postMessage({
                sourceName: i,
                targetName: n,
                stream: kl,
                streamId: t,
                reason: wrapReason$1(e1)
            });
        });
    }
    #lt(e1) {
        const t = e1.streamId, i = this.sourceName, n = e1.sourceName, a = this.comObj, s = this.streamControllers[t], r = this.streamSinks[t];
        switch(e1.stream){
            case kl:
                e1.success ? s.startCall.resolve() : s.startCall.reject(wrapReason$1(e1.reason));
                break;
            case Cl:
                e1.success ? s.pullCall.resolve() : s.pullCall.reject(wrapReason$1(e1.reason));
                break;
            case vl:
                if (!r) {
                    a.postMessage({
                        sourceName: i,
                        targetName: n,
                        stream: Cl,
                        streamId: t,
                        success: !0
                    });
                    break;
                }
                r.desiredSize <= 0 && e1.desiredSize > 0 && r.sinkCapability.resolve(), r.desiredSize = e1.desiredSize, Promise.try(r.onPull || onFn$1).then(function() {
                    a.postMessage({
                        sourceName: i,
                        targetName: n,
                        stream: Cl,
                        streamId: t,
                        success: !0
                    });
                }, function(e1) {
                    a.postMessage({
                        sourceName: i,
                        targetName: n,
                        stream: Cl,
                        streamId: t,
                        reason: wrapReason$1(e1)
                    });
                });
                break;
            case xl:
                if (assert$1(s, "enqueue should have stream controller"), s.isClosed) break;
                s.controller.enqueue(e1.chunk);
                break;
            case Al:
                if (assert$1(s, "close should have stream controller"), s.isClosed) break;
                s.isClosed = !0, s.controller.close(), this.#ht(s, t);
                break;
            case Sl:
                assert$1(s, "error should have stream controller"), s.controller.error(wrapReason$1(e1.reason)), this.#ht(s, t);
                break;
            case wl:
                e1.success ? s.cancelCall.resolve() : s.cancelCall.reject(wrapReason$1(e1.reason)), this.#ht(s, t);
                break;
            case yl:
                if (!r) break;
                const o = wrapReason$1(e1.reason);
                Promise.try(r.onCancel || onFn$1, o).then(function() {
                    a.postMessage({
                        sourceName: i,
                        targetName: n,
                        stream: wl,
                        streamId: t,
                        success: !0
                    });
                }, function(e1) {
                    a.postMessage({
                        sourceName: i,
                        targetName: n,
                        stream: wl,
                        streamId: t,
                        reason: wrapReason$1(e1)
                    });
                }), r.sinkCapability.reject(o), r.isCancelled = !0, delete this.streamSinks[t];
                break;
            default:
                throw new Error("Unexpected stream case");
        }
    }
    async #ht(e1, t) {
        await Promise.allSettled([
            e1.startCall?.promise,
            e1.pullCall?.promise,
            e1.cancelCall?.promise
        ]), delete this.streamControllers[t];
    }
    destroy() {
        this.#rt?.abort(), this.#rt = null;
    }
};
async function writeObject(e1, t, i, { encrypt: n = null }) {
    const a = n?.createCipherTransform(e1.num, e1.gen);
    i.push(`${e1.num} ${e1.gen} obj\n`), t instanceof Dict ? await writeDict(t, i, a) : t instanceof BaseStream ? await writeStream(t, i, a) : (Array.isArray(t) || ArrayBuffer.isView(t)) && await writeArray(t, i, a), i.push("\nendobj\n");
}
async function writeDict(e1, t, i) {
    t.push("<<");
    for (const n of e1.getKeys())t.push(` /${escapePDFName(n)} `), await writeValue(e1.getRaw(n), t, i);
    t.push(">>");
}
async function writeStream(e1, t, i) {
    let n = e1.getBytes();
    const { dict: a } = e1, [s, r] = await Promise.all([
        a.getAsync("Filter"),
        a.getAsync("DecodeParms")
    ]), o = isName(Array.isArray(s) ? await a.xref.fetchIfRefAsync(s[0]) : s, "FlateDecode");
    if (n.length >= 256 || o) try {
        const e1 = new CompressionStream("deflate"), t = e1.writable.getWriter();
        await t.ready, t.write(n).then(async ()=>{
            await t.ready, await t.close();
        }).catch(()=>{});
        const i = await new Response(e1.readable).arrayBuffer();
        let l, c;
        n = new Uint8Array(i), s ? o || (l = Array.isArray(s) ? [
            Name.get("FlateDecode"),
            ...s
        ] : [
            Name.get("FlateDecode"),
            s
        ], r && (c = Array.isArray(r) ? [
            null,
            ...r
        ] : [
            null,
            r
        ])) : l = Name.get("FlateDecode"), l && a.set("Filter", l), c && a.set("DecodeParms", c);
    } catch (e1) {
        info$1(`writeStream - cannot compress data: "${e1}".`);
    }
    let l = bytesToString$1(n);
    i && (l = i.encryptString(l)), a.set("Length", l.length), await writeDict(a, t, i), t.push(" stream\n", l, "\nendstream");
}
async function writeArray(e1, t, i) {
    t.push("[");
    let n = !0;
    for (const a of e1)n ? n = !1 : t.push(" "), await writeValue(a, t, i);
    t.push("]");
}
async function writeValue(e1, t, i) {
    e1 instanceof Name ? t.push(`/${escapePDFName(e1.name)}`) : e1 instanceof Ref ? t.push(`${e1.num} ${e1.gen} R`) : Array.isArray(e1) || ArrayBuffer.isView(e1) ? await writeArray(e1, t, i) : "string" == typeof e1 ? (i && (e1 = i.encryptString(e1)), t.push(`(${escapeString(e1)})`)) : "number" == typeof e1 ? t.push(numberToString(e1)) : "boolean" == typeof e1 ? t.push(e1.toString()) : e1 instanceof Dict ? await writeDict(e1, t, i) : e1 instanceof BaseStream ? await writeStream(e1, t, i) : null === e1 ? t.push("null") : warn$1(`Unhandled value in writer: ${typeof e1}, please file a bug.`);
}
function writeInt(e1, t, i, n) {
    for(let a = t + i - 1; a > i - 1; a--)n[a] = 255 & e1, e1 >>= 8;
    return i + t;
}
function writeString(e1, t, i) {
    const n = e1.length;
    for(let a = 0; a < n; a++)i[t + a] = 255 & e1.charCodeAt(a);
    return t + n;
}
function updateXFA({ xfaData: e1, xfaDatasetsRef: t, changes: i, xref: n }) {
    if (null === e1) {
        e1 = function(e1, t) {
            const i = new SimpleXMLParser({
                hasAttributes: !0
            }).parseFromString(e1);
            for (const { xfa: e1 } of t){
                if (!e1) continue;
                const { path: t, value: n } = e1;
                if (!t) continue;
                const a = parseXFAPath(t);
                let s = i.documentElement.searchNode(a, 0);
                !s && a.length > 1 && (s = i.documentElement.searchNode([
                    a.at(-1)
                ], 0)), s ? s.childNodes = Array.isArray(n) ? n.map((e1)=>new SimpleDOMNode("value", e1)) : [
                    new SimpleDOMNode("#text", n)
                ] : warn$1(`Node not found for path: ${t}`);
            }
            const n = [];
            return i.documentElement.dump(n), n.join("");
        }(n.fetchIfRef(t).getString(), i);
    }
    const a = new StringStream(e1);
    a.dict = new Dict(n), a.dict.setIfName("Type", "EmbeddedFile"), i.put(t, {
        data: a
    });
}
function getIndexes(e1) {
    const t = [];
    for (const { ref: i } of e1)i.num === t.at(-2) + t.at(-1) ? t[t.length - 1] += 1 : t.push(i.num, 1);
    return t;
}
function computeIDs(e1, t, i) {
    if (Array.isArray(t.fileIds) && t.fileIds.length > 0) {
        const n = function(e1, t) {
            const i = Math.floor(Date.now() / 1e3), n = t.filename || "", a = [
                i.toString(),
                n,
                e1.toString(),
                ...t.infoMap.values()
            ], s = Math.sumPrecise(a.map((e1)=>e1.length)), r = new Uint8Array(s);
            let o = 0;
            for (const e1 of a)o = writeString(e1, o, r);
            return bytesToString$1(calculateMD5(r, 0, r.length));
        }(e1, t);
        i.set("ID", [
            t.fileIds[0],
            n
        ]);
    }
}
async function incrementalUpdate({ originalData: e1, xrefInfo: t, changes: i, xref: n = null, hasXfa: a = !1, xfaDatasetsRef: s = null, hasXfaDatasetsEntry: r = !1, needAppearances: o, acroFormRef: l = null, acroForm: c = null, xfaData: h = null, useXrefStream: d = !1 }) {
    await async function({ xref: e1, acroForm: t, acroFormRef: i, hasXfa: n, hasXfaDatasetsEntry: a, xfaDatasetsRef: s, needAppearances: r, changes: o }) {
        if (!n || a || s || warn$1("XFA - Cannot save it"), !r && (!n || !s || a)) return;
        const l = t.clone();
        if (n && !a) {
            const e1 = t.get("XFA").slice();
            e1.splice(2, 0, "datasets"), e1.splice(3, 0, s), l.set("XFA", e1);
        }
        r && l.set("NeedAppearances", !0), o.put(i, {
            data: l
        });
    }({
        xref: n,
        acroForm: c,
        acroFormRef: l,
        hasXfa: a,
        hasXfaDatasetsEntry: r,
        xfaDatasetsRef: s,
        needAppearances: o,
        changes: i
    }), a && updateXFA({
        xfaData: h,
        xfaDatasetsRef: s,
        changes: i,
        xref: n
    });
    const u = function(e1, t, i) {
        const n = new Dict(null);
        n.set("Prev", e1.startXRef);
        const a = e1.newRef;
        return i ? (t.put(a, {
            data: ""
        }), n.set("Size", a.num + 1), n.setIfName("Type", "XRef")) : n.set("Size", a.num), null !== e1.rootRef && n.set("Root", e1.rootRef), null !== e1.infoRef && n.set("Info", e1.infoRef), null !== e1.encryptRef && n.set("Encrypt", e1.encryptRef), n;
    }(t, i, d), g = [], f = await async function(e1, t, i = []) {
        const n = [];
        for (const [a, { data: s }] of e1.items())null !== s && "string" != typeof s ? (await writeObject(a, s, i, t), n.push({
            ref: a,
            data: i.join("")
        }), i.length = 0) : n.push({
            ref: a,
            data: s
        });
        return n.sort((e1, t)=>e1.ref.num - t.ref.num);
    }(i, n, g);
    let p = e1.length;
    const m = e1.at(-1);
    10 !== m && 13 !== m && (g.push("\n"), p += 1);
    for (const { data: e1 } of f)null !== e1 && g.push(e1);
    await (d ? async function(e1, t, i, n, a) {
        const s = [];
        let r = 0, o = 0;
        for (const { ref: e1, data: n } of i){
            let i;
            r = Math.max(r, t), null !== n ? (i = Math.min(e1.gen, 65535), s.push([
                1,
                t,
                i
            ]), t += n.length) : (i = Math.min(e1.gen + 1, 65535), s.push([
                0,
                0,
                i
            ])), o = Math.max(o, i);
        }
        n.set("Index", getIndexes(i));
        const l = [
            1,
            getSizeInBytes(r),
            getSizeInBytes(o)
        ];
        n.set("W", l), computeIDs(t, e1, n);
        const c = Math.sumPrecise(l), h = new Uint8Array(c * s.length), d = new Stream(h);
        d.dict = n;
        let u = 0;
        for (const [e1, t, i] of s)u = writeInt(e1, l[0], u, h), u = writeInt(t, l[1], u, h), u = writeInt(i, l[2], u, h);
        await writeObject(e1.newRef, d, a, {}), a.push("startxref\n", t.toString(), "\n%%EOF\n");
    }(t, p, f, u, g) : async function(e1, t, i, n, a) {
        a.push("xref\n");
        const s = getIndexes(i);
        let r = 0;
        for (const { ref: e1, data: n } of i)e1.num === s[r] && (a.push(`${s[r]} ${s[r + 1]}\n`), r += 2), null !== n ? (a.push(`${t.toString().padStart(10, "0")} ${Math.min(e1.gen, 65535).toString().padStart(5, "0")} n\r\n`), t += n.length) : a.push(`0000000000 ${Math.min(e1.gen + 1, 65535).toString().padStart(5, "0")} f\r\n`);
        computeIDs(t, e1, n), a.push("trailer\n"), await writeDict(n, a), a.push("\nstartxref\n", t.toString(), "\n%%EOF\n");
    }(t, p, f, u, g));
    const b = e1.length + Math.sumPrecise(g.map((e1)=>e1.length)), y = new Uint8Array(b);
    y.set(e1);
    let w = e1.length;
    for (const e1 of g)w = writeString(e1, w, y);
    return y;
}
class PDFWorkerStream {
    constructor(e1){
        this._msgHandler = e1, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    getFullReader() {
        return assert$1(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler), this._fullRequestReader;
    }
    getRangeReader(e1, t) {
        const i = new PDFWorkerStreamRangeReader(e1, t, this._msgHandler);
        return this._rangeRequestReaders.push(i), i;
    }
    cancelAllRequests(e1) {
        this._fullRequestReader?.cancel(e1);
        for (const t of this._rangeRequestReaders.slice(0))t.cancel(e1);
    }
}
class PDFWorkerStreamReader {
    constructor(e1){
        this._msgHandler = e1, this.onProgress = null, this._contentLength = null, this._isRangeSupported = !1, this._isStreamingSupported = !1;
        const t = this._msgHandler.sendWithStream("GetReader");
        this._reader = t.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((e1)=>{
            this._isStreamingSupported = e1.isStreamingSupported, this._isRangeSupported = e1.isRangeSupported, this._contentLength = e1.contentLength;
        });
    }
    get headersReady() {
        return this._headersReady;
    }
    get contentLength() {
        return this._contentLength;
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    get isRangeSupported() {
        return this._isRangeSupported;
    }
    async read() {
        const { value: e1, done: t } = await this._reader.read();
        return t ? {
            value: void 0,
            done: !0
        } : {
            value: e1.buffer,
            done: !1
        };
    }
    cancel(e1) {
        this._reader.cancel(e1);
    }
}
class PDFWorkerStreamRangeReader {
    constructor(e1, t, i){
        this._msgHandler = i, this.onProgress = null;
        const n = this._msgHandler.sendWithStream("GetRangeReader", {
            begin: e1,
            end: t
        });
        this._reader = n.getReader();
    }
    get isStreamingSupported() {
        return !1;
    }
    async read() {
        const { value: e1, done: t } = await this._reader.read();
        return t ? {
            value: void 0,
            done: !0
        } : {
            value: e1.buffer,
            done: !1
        };
    }
    cancel(e1) {
        this._reader.cancel(e1);
    }
}
class WorkerTask {
    constructor(e1){
        this.name = e1, this.terminated = !1, this._capability = Promise.withResolvers();
    }
    get finished() {
        return this._capability.promise;
    }
    finish() {
        this._capability.resolve();
    }
    terminate() {
        this.terminated = !0;
    }
    ensureNotTerminated() {
        if (this.terminated) throw new Error("Worker task was terminated");
    }
}
class WorkerMessageHandler {
    static{
        "undefined" == ("TURBOPACK compile-time value", "undefined") && !e1 && "undefined" != typeof self && "function" == typeof self.postMessage && "onmessage" in self && this.initializeFromPort(self);
    }
    static setup(e1, t) {
        let i = !1;
        e1.on("test", (t)=>{
            i || (i = !0, e1.send("test", t instanceof Uint8Array));
        }), e1.on("configure", (e1)=>{
            var t;
            t = e1.verbosity, Number.isInteger(t) && (Kt = t);
        }), e1.on("GetDocRequest", (e1)=>this.createDocumentHandler(e1, t));
    }
    static createDocumentHandler(e1, t) {
        let i, n = !1, a = null;
        const s = new Set, r = Kt, { docId: o, apiVersion: l } = e1, c = "5.4.296";
        if (l !== c) throw new Error(`The API version "${l}" does not match the Worker version "${c}".`);
        const buildMsg = (e1, t)=>`The \`${e1}.prototype\` contains unexpected enumerable property "${t}", thus breaking e.g. \`for...in\` iteration of ${e1}s.`;
        for(const e1 in {})throw new Error(buildMsg("Object", e1));
        for(const e1 in [])throw new Error(buildMsg("Array", e1));
        const h = o + "_worker";
        let d = new Tl(h, o, t);
        function ensureNotTerminated() {
            if (n) throw new Error("Worker was terminated");
        }
        function startWorkerTask(e1) {
            s.add(e1);
        }
        function finishWorkerTask(e1) {
            e1.finish(), s.delete(e1);
        }
        async function loadDocument(e1) {
            await i.ensureDoc("checkHeader"), await i.ensureDoc("parseStartXRef"), await i.ensureDoc("parse", [
                e1
            ]), await i.ensureDoc("checkFirstPage", [
                e1
            ]), await i.ensureDoc("checkLastPage", [
                e1
            ]);
            const t = await i.ensureDoc("isPureXfa");
            if (t) {
                const e1 = new WorkerTask("loadXfaResources");
                startWorkerTask(e1), await i.ensureDoc("loadXfaResources", [
                    d,
                    e1
                ]), finishWorkerTask(e1);
            }
            const [n, a] = await Promise.all([
                i.ensureDoc("numPages"),
                i.ensureDoc("fingerprints")
            ]);
            return {
                numPages: n,
                fingerprints: a,
                htmlForXfa: t ? await i.ensureDoc("htmlForXfa") : null
            };
        }
        function setupDoc(e1) {
            function onSuccess(e1) {
                ensureNotTerminated(), d.send("GetDoc", {
                    pdfInfo: e1
                });
            }
            function onFailure(e1) {
                if (ensureNotTerminated(), e1 instanceof Jt) {
                    const t = new WorkerTask(`PasswordException: response ${e1.code}`);
                    startWorkerTask(t), d.sendWithPromise("PasswordRequest", e1).then(function({ password: e1 }) {
                        finishWorkerTask(t), i.updatePassword(e1), pdfManagerReady();
                    }).catch(function() {
                        finishWorkerTask(t), d.send("DocException", e1);
                    });
                } else d.send("DocException", wrapReason$1(e1));
            }
            function pdfManagerReady() {
                ensureNotTerminated(), loadDocument(!1).then(onSuccess, function(e1) {
                    ensureNotTerminated(), e1 instanceof XRefParseException ? i.requestLoadedStream().then(function() {
                        ensureNotTerminated(), loadDocument(!0).then(onSuccess, onFailure);
                    }) : onFailure(e1);
                });
            }
            ensureNotTerminated(), (async function({ data: e1, password: t, disableAutoFetch: i, rangeChunkSize: n, length: s, docBaseUrl: r, enableXfa: l, evaluatorOptions: c }) {
                const h = {
                    source: null,
                    disableAutoFetch: i,
                    docBaseUrl: r,
                    docId: o,
                    enableXfa: l,
                    evaluatorOptions: c,
                    handler: d,
                    length: s,
                    password: t,
                    rangeChunkSize: n
                };
                if (e1) return h.source = e1, new LocalPdfManager(h);
                const u = new PDFWorkerStream(d), g = u.getFullReader(), f = Promise.withResolvers();
                let p, m = [], b = 0;
                return g.headersReady.then(function() {
                    if (g.isRangeSupported) {
                        h.source = u, h.length = g.contentLength, h.disableAutoFetch ||= g.isStreamingSupported, p = new NetworkPdfManager(h);
                        for (const e1 of m)p.sendProgressiveData(e1);
                        m = [], f.resolve(p), a = null;
                    }
                }).catch(function(e1) {
                    f.reject(e1), a = null;
                }), new Promise(function(e1, t) {
                    const readChunk = function({ value: e1, done: i }) {
                        try {
                            if (ensureNotTerminated(), i) {
                                if (!p) {
                                    const e1 = arrayBuffersToBytes(m);
                                    m = [], s && e1.length !== s && warn$1("reported HTTP length is different from actual"), h.source = e1, p = new LocalPdfManager(h), f.resolve(p);
                                }
                                return void (a = null);
                            }
                            b += e1.byteLength, g.isStreamingSupported || d.send("DocProgress", {
                                loaded: b,
                                total: Math.max(b, g.contentLength || 0)
                            }), p ? p.sendProgressiveData(e1) : m.push(e1), g.read().then(readChunk, t);
                        } catch (e1) {
                            t(e1);
                        }
                    };
                    g.read().then(readChunk, t);
                }).catch(function(e1) {
                    f.reject(e1), a = null;
                }), a = (e1)=>{
                    u.cancelAllRequests(e1);
                }, f.promise;
            })(e1).then(function(e1) {
                if (n) throw e1.terminate(new ii("Worker was terminated.")), new Error("Worker was terminated");
                i = e1, i.requestLoadedStream(!0).then((e1)=>{
                    d.send("DataLoaded", {
                        length: e1.bytes.byteLength
                    });
                });
            }).then(pdfManagerReady, onFailure);
        }
        return d.on("GetPage", function(e1) {
            return i.getPage(e1.pageIndex).then(function(e1) {
                return Promise.all([
                    i.ensure(e1, "rotate"),
                    i.ensure(e1, "ref"),
                    i.ensure(e1, "userUnit"),
                    i.ensure(e1, "view")
                ]).then(function([e1, t, i, n]) {
                    return {
                        rotate: e1,
                        ref: t,
                        refStr: t?.toString() ?? null,
                        userUnit: i,
                        view: n
                    };
                });
            });
        }), d.on("GetPageIndex", function(e1) {
            const t = Ref.get(e1.num, e1.gen);
            return i.ensureCatalog("getPageIndex", [
                t
            ]);
        }), d.on("GetDestinations", function(e1) {
            return i.ensureCatalog("destinations");
        }), d.on("GetDestination", function(e1) {
            return i.ensureCatalog("getDestination", [
                e1.id
            ]);
        }), d.on("GetPageLabels", function(e1) {
            return i.ensureCatalog("pageLabels");
        }), d.on("GetPageLayout", function(e1) {
            return i.ensureCatalog("pageLayout");
        }), d.on("GetPageMode", function(e1) {
            return i.ensureCatalog("pageMode");
        }), d.on("GetViewerPreferences", function(e1) {
            return i.ensureCatalog("viewerPreferences");
        }), d.on("GetOpenAction", function(e1) {
            return i.ensureCatalog("openAction");
        }), d.on("GetAttachments", function(e1) {
            return i.ensureCatalog("attachments");
        }), d.on("GetDocJSActions", function(e1) {
            return i.ensureCatalog("jsActions");
        }), d.on("GetPageJSActions", function({ pageIndex: e1 }) {
            return i.getPage(e1).then((e1)=>i.ensure(e1, "jsActions"));
        }), d.on("GetAnnotationsByType", async function({ types: e1, pageIndexesToSkip: t }) {
            const [n, a] = await Promise.all([
                i.ensureDoc("numPages"),
                i.ensureDoc("annotationGlobals")
            ]);
            if (!a) return null;
            const s = [], r = [];
            let o = null;
            try {
                for(let l = 0, c = n; l < c; l++)t?.has(l) || (o || (o = new WorkerTask("GetAnnotationsByType"), startWorkerTask(o)), s.push(i.getPage(l).then(async (t)=>t && t.collectAnnotationsByType(d, o, e1, r, a) || [])));
                await Promise.all(s);
                return (await Promise.all(r)).filter((e1)=>!!e1);
            } finally{
                o && finishWorkerTask(o);
            }
        }), d.on("GetOutline", function(e1) {
            return i.ensureCatalog("documentOutline");
        }), d.on("GetOptionalContentConfig", function(e1) {
            return i.ensureCatalog("optionalContentConfig");
        }), d.on("GetPermissions", function(e1) {
            return i.ensureCatalog("permissions");
        }), d.on("GetMetadata", function(e1) {
            return Promise.all([
                i.ensureDoc("documentInfo"),
                i.ensureCatalog("metadata")
            ]);
        }), d.on("GetMarkInfo", function(e1) {
            return i.ensureCatalog("markInfo");
        }), d.on("GetData", function(e1) {
            return i.requestLoadedStream().then((e1)=>e1.bytes);
        }), d.on("GetAnnotations", function({ pageIndex: e1, intent: t }) {
            return i.getPage(e1).then(function(i) {
                const n = new WorkerTask(`GetAnnotations: page ${e1}`);
                return startWorkerTask(n), i.getAnnotationsData(d, n, t).then((e1)=>(finishWorkerTask(n), e1), (e1)=>{
                    throw finishWorkerTask(n), e1;
                });
            });
        }), d.on("GetFieldObjects", function(e1) {
            return i.ensureDoc("fieldObjects").then((e1)=>e1?.allFields || null);
        }), d.on("HasJSActions", function(e1) {
            return i.ensureDoc("hasJSActions");
        }), d.on("GetCalculationOrderIds", function(e1) {
            return i.ensureDoc("calculationOrderIds");
        }), d.on("SaveDocument", async function({ isPureXfa: e1, numPages: t, annotationStorage: n, filename: a }) {
            const s = [
                i.requestLoadedStream(),
                i.ensureCatalog("acroForm"),
                i.ensureCatalog("acroFormRef"),
                i.ensureDoc("startXRef"),
                i.ensureDoc("xref"),
                i.ensureCatalog("structTreeRoot")
            ], r = new RefSetCache, o = [], l = e1 ? null : getNewAnnotationsMap(n), [c, h, u, g, f, p] = await Promise.all(s), m = f.trailer.getRaw("Root") || null;
            let b;
            if (l) {
                p ? await p.canUpdateStructTree({
                    pdfManager: i,
                    newAnnotationsByPage: l
                }) && (b = p) : await StructTreeRoot.canCreateStructureTree({
                    catalogRef: m,
                    pdfManager: i,
                    newAnnotationsByPage: l
                }) && (b = null);
                const e1 = AnnotationFactory.generateImages(n.values(), f, i.evaluatorOptions.isOffscreenCanvasSupported), t = void 0 === b ? o : [];
                for (const [n, a] of l)t.push(i.getPage(n).then((t)=>{
                    const i = new WorkerTask(`Save (editor): page ${n}`);
                    return startWorkerTask(i), t.saveNewAnnotations(d, i, a, e1, r).finally(function() {
                        finishWorkerTask(i);
                    });
                }));
                null === b ? o.push(Promise.all(t).then(async ()=>{
                    await StructTreeRoot.createStructureTree({
                        newAnnotationsByPage: l,
                        xref: f,
                        catalogRef: m,
                        pdfManager: i,
                        changes: r
                    });
                })) : b && o.push(Promise.all(t).then(async ()=>{
                    await b.updateStructureTree({
                        newAnnotationsByPage: l,
                        pdfManager: i,
                        changes: r
                    });
                }));
            }
            if (e1) o.push(i.ensureDoc("serializeXfaData", [
                n
            ]));
            else for(let e1 = 0; e1 < t; e1++)o.push(i.getPage(e1).then(function(t) {
                const i = new WorkerTask(`Save: page ${e1}`);
                return startWorkerTask(i), t.save(d, i, n, r).finally(function() {
                    finishWorkerTask(i);
                });
            }));
            const y = await Promise.all(o);
            let w = null;
            if (e1) {
                if (w = y[0], !w) return c.bytes;
            } else if (0 === r.size) return c.bytes;
            const x = u && h instanceof Dict && r.values().some((e1)=>e1.needAppearances), S = h instanceof Dict && h.get("XFA") || null;
            let v = null, C = !1;
            if (Array.isArray(S)) {
                for(let e1 = 0, t = S.length; e1 < t; e1 += 2)"datasets" === S[e1] && (v = S[e1 + 1], C = !0);
                null === v && (v = f.getNewTemporaryRef());
            } else S && warn$1("Unsupported XFA type.");
            let k = Object.create(null);
            if (f.trailer) {
                const e1 = new Map, t = f.trailer.get("Info") || null;
                if (t instanceof Dict) for (const [i, n] of t)"string" == typeof n && e1.set(i, stringToPDFString(n));
                k = {
                    rootRef: m,
                    encryptRef: f.trailer.getRaw("Encrypt") || null,
                    newRef: f.getNewTemporaryRef(),
                    infoRef: f.trailer.getRaw("Info") || null,
                    infoMap: e1,
                    fileIds: f.trailer.get("ID") || null,
                    startXRef: g,
                    filename: a
                };
            }
            return incrementalUpdate({
                originalData: c.bytes,
                xrefInfo: k,
                changes: r,
                xref: f,
                hasXfa: !!S,
                xfaDatasetsRef: v,
                hasXfaDatasetsEntry: C,
                needAppearances: x,
                acroFormRef: u,
                acroForm: h,
                xfaData: w,
                useXrefStream: isDict(f.topDict, "XRef")
            }).finally(()=>{
                f.resetNewTemporaryRef();
            });
        }), d.on("GetOperatorList", function(e1, t) {
            const n = e1.pageIndex;
            i.getPage(n).then(function(i) {
                const a = new WorkerTask(`GetOperatorList: page ${n}`);
                startWorkerTask(a);
                const s = r >= se ? Date.now() : 0;
                i.getOperatorList({
                    handler: d,
                    sink: t,
                    task: a,
                    intent: e1.intent,
                    cacheKey: e1.cacheKey,
                    annotationStorage: e1.annotationStorage,
                    modifiedIds: e1.modifiedIds
                }).then(function(e1) {
                    finishWorkerTask(a), s && info$1(`page=${n + 1} - getOperatorList: time=${Date.now() - s}ms, len=${e1.length}`), t.close();
                }, function(e1) {
                    finishWorkerTask(a), a.terminated || t.error(e1);
                });
            });
        }), d.on("GetTextContent", function(e1, t) {
            const { pageIndex: n, includeMarkedContent: a, disableNormalization: s } = e1;
            i.getPage(n).then(function(e1) {
                const i = new WorkerTask("GetTextContent: page " + n);
                startWorkerTask(i);
                const o = r >= se ? Date.now() : 0;
                e1.extractTextContent({
                    handler: d,
                    task: i,
                    sink: t,
                    includeMarkedContent: a,
                    disableNormalization: s
                }).then(function() {
                    finishWorkerTask(i), o && info$1(`page=${n + 1} - getTextContent: time=` + (Date.now() - o) + "ms"), t.close();
                }, function(e1) {
                    finishWorkerTask(i), i.terminated || t.error(e1);
                });
            });
        }), d.on("GetStructTree", function(e1) {
            return i.getPage(e1.pageIndex).then((e1)=>i.ensure(e1, "getStructTree"));
        }), d.on("FontFallback", function(e1) {
            return i.fontFallback(e1.id, d);
        }), d.on("Cleanup", function(e1) {
            return i.cleanup(!0);
        }), d.on("Terminate", function(e1) {
            n = !0;
            const t = [];
            if (i) {
                i.terminate(new ii("Worker was terminated."));
                const e1 = i.cleanup();
                t.push(e1), i = null;
            } else clearGlobalCaches();
            a?.(new ii("Worker was terminated."));
            for (const e1 of s)t.push(e1.finished), e1.terminate();
            return Promise.all(t).then(function() {
                d.destroy(), d = null;
            });
        }), d.on("Ready", function(t) {
            setupDoc(e1), e1 = null;
        }), h;
    }
    static initializeFromPort(e1) {
        const t = new Tl("worker", "main", e1);
        this.setup(t, e1), t.send("ready", null);
    }
}
globalThis.pdfjsWorker = {
    WorkerMessageHandler: WorkerMessageHandler
};
const Fl = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type), Il = [
    .001,
    0,
    0,
    .001,
    0,
    0
], El = 1.35, Ml = 1, Dl = 2, _l = 4, Pl = 16, Rl = 32, Bl = 64, Nl = 128, Ll = 256, jl = {
    DISABLE: 0,
    ENABLE: 1,
    ENABLE_FORMS: 2,
    ENABLE_STORAGE: 3
}, $l = "pdfjs_internal_editor_", Hl = {
    DISABLE: -1,
    NONE: 0,
    FREETEXT: 3,
    HIGHLIGHT: 9,
    STAMP: 13,
    INK: 15,
    POPUP: 16,
    SIGNATURE: 101,
    COMMENT: 102
}, Xl = {
    RESIZE: 1,
    CREATE: 2,
    FREETEXT_SIZE: 11,
    FREETEXT_COLOR: 12,
    FREETEXT_OPACITY: 13,
    INK_COLOR: 21,
    INK_THICKNESS: 22,
    INK_OPACITY: 23,
    HIGHLIGHT_COLOR: 31,
    HIGHLIGHT_THICKNESS: 32,
    HIGHLIGHT_FREE: 33,
    HIGHLIGHT_SHOW_ALL: 34,
    DRAW_STEP: 41
}, ql = {
    PRINT: 4,
    MODIFY_CONTENTS: 8,
    COPY: 16,
    MODIFY_ANNOTATIONS: 32,
    FILL_INTERACTIVE_FORMS: 256,
    COPY_FOR_ACCESSIBILITY: 512,
    ASSEMBLE: 1024,
    PRINT_HIGH_QUALITY: 2048
}, zl = 0, Wl = 1, Gl = 2, Vl = 3, Kl = 3, Yl = 4, Jl = {
    GRAYSCALE_1BPP: 1,
    RGB_24BPP: 2,
    RGBA_32BPP: 3
}, Zl = {
    TEXT: 1,
    LINK: 2,
    FREETEXT: 3,
    LINE: 4,
    SQUARE: 5,
    CIRCLE: 6,
    POLYGON: 7,
    POLYLINE: 8,
    HIGHLIGHT: 9,
    UNDERLINE: 10,
    SQUIGGLY: 11,
    STRIKEOUT: 12,
    STAMP: 13,
    CARET: 14,
    INK: 15,
    POPUP: 16,
    FILEATTACHMENT: 17,
    SOUND: 18,
    MOVIE: 19,
    WIDGET: 20,
    SCREEN: 21,
    PRINTERMARK: 22,
    TRAPNET: 23,
    WATERMARK: 24,
    THREED: 25,
    REDACT: 26
}, Ql = 1, ec = 2, tc = 3, ic = 4, nc = 5, ac = {
    ERRORS: 0,
    WARNINGS: 1,
    INFOS: 5
}, sc = {
    dependency: 1,
    setLineWidth: 2,
    setLineCap: 3,
    setLineJoin: 4,
    setMiterLimit: 5,
    setDash: 6,
    setRenderingIntent: 7,
    setFlatness: 8,
    setGState: 9,
    save: 10,
    restore: 11,
    transform: 12,
    moveTo: 13,
    lineTo: 14,
    curveTo: 15,
    curveTo2: 16,
    curveTo3: 17,
    closePath: 18,
    rectangle: 19,
    stroke: 20,
    closeStroke: 21,
    fill: 22,
    eoFill: 23,
    fillStroke: 24,
    eoFillStroke: 25,
    closeFillStroke: 26,
    closeEOFillStroke: 27,
    endPath: 28,
    clip: 29,
    eoClip: 30,
    beginText: 31,
    endText: 32,
    setCharSpacing: 33,
    setWordSpacing: 34,
    setHScale: 35,
    setLeading: 36,
    setFont: 37,
    setTextRenderingMode: 38,
    setTextRise: 39,
    moveText: 40,
    setLeadingMoveText: 41,
    setTextMatrix: 42,
    nextLine: 43,
    showText: 44,
    showSpacedText: 45,
    nextLineShowText: 46,
    nextLineSetSpacingShowText: 47,
    setCharWidth: 48,
    setCharWidthAndBounds: 49,
    setStrokeColorSpace: 50,
    setFillColorSpace: 51,
    setStrokeColor: 52,
    setStrokeColorN: 53,
    setFillColor: 54,
    setFillColorN: 55,
    setStrokeGray: 56,
    setFillGray: 57,
    setStrokeRGBColor: 58,
    setFillRGBColor: 59,
    setStrokeCMYKColor: 60,
    setFillCMYKColor: 61,
    shadingFill: 62,
    beginInlineImage: 63,
    beginImageData: 64,
    endInlineImage: 65,
    paintXObject: 66,
    markPoint: 67,
    markPointProps: 68,
    beginMarkedContent: 69,
    beginMarkedContentProps: 70,
    endMarkedContent: 71,
    beginCompat: 72,
    endCompat: 73,
    paintFormXObjectBegin: 74,
    paintFormXObjectEnd: 75,
    beginGroup: 76,
    endGroup: 77,
    beginAnnotation: 80,
    endAnnotation: 81,
    paintImageMaskXObject: 83,
    paintImageMaskXObjectGroup: 84,
    paintImageXObject: 85,
    paintInlineImageXObject: 86,
    paintInlineImageXObjectGroup: 87,
    paintImageXObjectRepeat: 88,
    paintImageMaskXObjectRepeat: 89,
    paintSolidColorImageMask: 90,
    constructPath: 91,
    setStrokeTransparent: 92,
    setFillTransparent: 93,
    rawFillPath: 94
}, rc = 0, oc = 1, lc = 2, cc = 3, hc = {
    NEED_PASSWORD: 1,
    INCORRECT_PASSWORD: 2
};
let dc = ac.WARNINGS;
function setVerbosityLevel(e1) {
    Number.isInteger(e1) && (dc = e1);
}
function getVerbosityLevel() {
    return dc;
}
function info(e1) {
    dc >= ac.INFOS && console.info(`Info: ${e1}`);
}
function warn(e1) {
    dc >= ac.WARNINGS && console.warn(`Warning: ${e1}`);
}
function unreachable(e1) {
    throw new Error(e1);
}
function assert(e1, t) {
    e1 || unreachable(t);
}
function createValidAbsoluteUrl(e1, t = null, i = null) {
    if (!e1) return null;
    if (i && "string" == typeof e1) {
        if (i.addDefaultProtocol && e1.startsWith("www.")) {
            const t = e1.match(/\./g);
            t?.length >= 2 && (e1 = `http://${e1}`);
        }
        if (i.tryConvertEncoding) try {
            e1 = decodeURIComponent(escape(e1));
        } catch  {}
    }
    const n = t ? URL.parse(e1, t) : URL.parse(e1);
    return function(e1) {
        switch(e1?.protocol){
            case "http:":
            case "https:":
            case "ftp:":
            case "mailto:":
            case "tel:":
                return !0;
            default:
                return !1;
        }
    }(n) ? n : null;
}
function updateUrlHash(e1, t, i = !1) {
    const n = URL.parse(e1);
    return n ? (n.hash = t, n.href) : i && createValidAbsoluteUrl(e1, "http://example.com") ? e1.split("#", 1)[0] + "" + (t ? `#${t}` : "") : "";
}
function shadow(e1, t, i, n = !1) {
    return Object.defineProperty(e1, t, {
        value: i,
        enumerable: !n,
        configurable: !0,
        writable: !1
    }), i;
}
const uc = function() {
    function BaseException(e1, t) {
        this.message = e1, this.name = t;
    }
    return BaseException.prototype = new Error, BaseException.constructor = BaseException, BaseException;
}();
class PasswordException extends uc {
    constructor(e1, t){
        super(e1, "PasswordException"), this.code = t;
    }
}
class UnknownErrorException extends uc {
    constructor(e1, t){
        super(e1, "UnknownErrorException"), this.details = t;
    }
}
class InvalidPDFException extends uc {
    constructor(e1){
        super(e1, "InvalidPDFException");
    }
}
class ResponseException extends uc {
    constructor(e1, t, i){
        super(e1, "ResponseException"), this.status = t, this.missing = i;
    }
}
class FormatError extends uc {
    constructor(e1){
        super(e1, "FormatError");
    }
}
class AbortException extends uc {
    constructor(e1){
        super(e1, "AbortException");
    }
}
function bytesToString(e1) {
    "object" == typeof e1 && void 0 !== e1?.length || unreachable("Invalid argument for bytesToString");
    const t = e1.length, i = 8192;
    if (t < i) return String.fromCharCode.apply(null, e1);
    const n = [];
    for(let a = 0; a < t; a += i){
        const s = Math.min(a + i, t), r = e1.subarray(a, s);
        n.push(String.fromCharCode.apply(null, r));
    }
    return n.join("");
}
function stringToBytes(e1) {
    "string" != typeof e1 && unreachable("Invalid argument for stringToBytes");
    const t = e1.length, i = new Uint8Array(t);
    for(let n = 0; n < t; ++n)i[n] = 255 & e1.charCodeAt(n);
    return i;
}
class util_FeatureTest {
    static get isLittleEndian() {
        return shadow(this, "isLittleEndian", function() {
            const e1 = new Uint8Array(4);
            return e1[0] = 1, 1 === new Uint32Array(e1.buffer, 0, 1)[0];
        }());
    }
    static get isEvalSupported() {
        return shadow(this, "isEvalSupported", function() {
            try {
                return new Function(""), !0;
            } catch  {
                return !1;
            }
        }());
    }
    static get isOffscreenCanvasSupported() {
        return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
    }
    static get isImageDecoderSupported() {
        return shadow(this, "isImageDecoderSupported", "undefined" != typeof ImageDecoder);
    }
    static get platform() {
        const { platform: e1, userAgent: t } = navigator;
        return shadow(this, "platform", {
            isAndroid: t.includes("Android"),
            isLinux: e1.includes("Linux"),
            isMac: e1.includes("Mac"),
            isWindows: e1.includes("Win"),
            isFirefox: t.includes("Firefox")
        });
    }
    static get isCSSRoundSupported() {
        return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
    }
}
const gc = Array.from(Array(256).keys(), (e1)=>e1.toString(16).padStart(2, "0"));
class Util {
    static makeHexColor(e1, t, i) {
        return `#${gc[e1]}${gc[t]}${gc[i]}`;
    }
    static domMatrixToTransform(e1) {
        return [
            e1.a,
            e1.b,
            e1.c,
            e1.d,
            e1.e,
            e1.f
        ];
    }
    static scaleMinMax(e1, t) {
        let i;
        e1[0] ? (e1[0] < 0 && (i = t[0], t[0] = t[2], t[2] = i), t[0] *= e1[0], t[2] *= e1[0], e1[3] < 0 && (i = t[1], t[1] = t[3], t[3] = i), t[1] *= e1[3], t[3] *= e1[3]) : (i = t[0], t[0] = t[1], t[1] = i, i = t[2], t[2] = t[3], t[3] = i, e1[1] < 0 && (i = t[1], t[1] = t[3], t[3] = i), t[1] *= e1[1], t[3] *= e1[1], e1[2] < 0 && (i = t[0], t[0] = t[2], t[2] = i), t[0] *= e1[2], t[2] *= e1[2]), t[0] += e1[4], t[1] += e1[5], t[2] += e1[4], t[3] += e1[5];
    }
    static transform(e1, t) {
        return [
            e1[0] * t[0] + e1[2] * t[1],
            e1[1] * t[0] + e1[3] * t[1],
            e1[0] * t[2] + e1[2] * t[3],
            e1[1] * t[2] + e1[3] * t[3],
            e1[0] * t[4] + e1[2] * t[5] + e1[4],
            e1[1] * t[4] + e1[3] * t[5] + e1[5]
        ];
    }
    static multiplyByDOMMatrix(e1, t) {
        return [
            e1[0] * t.a + e1[2] * t.b,
            e1[1] * t.a + e1[3] * t.b,
            e1[0] * t.c + e1[2] * t.d,
            e1[1] * t.c + e1[3] * t.d,
            e1[0] * t.e + e1[2] * t.f + e1[4],
            e1[1] * t.e + e1[3] * t.f + e1[5]
        ];
    }
    static applyTransform(e1, t, i = 0) {
        const n = e1[i], a = e1[i + 1];
        e1[i] = n * t[0] + a * t[2] + t[4], e1[i + 1] = n * t[1] + a * t[3] + t[5];
    }
    static applyTransformToBezier(e1, t, i = 0) {
        const n = t[0], a = t[1], s = t[2], r = t[3], o = t[4], l = t[5];
        for(let t = 0; t < 6; t += 2){
            const c = e1[i + t], h = e1[i + t + 1];
            e1[i + t] = c * n + h * s + o, e1[i + t + 1] = c * a + h * r + l;
        }
    }
    static applyInverseTransform(e1, t) {
        const i = e1[0], n = e1[1], a = t[0] * t[3] - t[1] * t[2];
        e1[0] = (i * t[3] - n * t[2] + t[2] * t[5] - t[4] * t[3]) / a, e1[1] = (-i * t[1] + n * t[0] + t[4] * t[1] - t[5] * t[0]) / a;
    }
    static axialAlignedBoundingBox(e1, t, i) {
        const n = t[0], a = t[1], s = t[2], r = t[3], o = t[4], l = t[5], c = e1[0], h = e1[1], d = e1[2], u = e1[3];
        let g = n * c + o, f = g, p = n * d + o, m = p, b = r * h + l, y = b, w = r * u + l, x = w;
        if (0 !== a || 0 !== s) {
            const e1 = a * c, t = a * d, i = s * h, n = s * u;
            g += i, m += i, p += n, f += n, b += e1, x += e1, w += t, y += t;
        }
        i[0] = Math.min(i[0], g, p, f, m), i[1] = Math.min(i[1], b, w, y, x), i[2] = Math.max(i[2], g, p, f, m), i[3] = Math.max(i[3], b, w, y, x);
    }
    static inverseTransform(e1) {
        const t = e1[0] * e1[3] - e1[1] * e1[2];
        return [
            e1[3] / t,
            -e1[1] / t,
            -e1[2] / t,
            e1[0] / t,
            (e1[2] * e1[5] - e1[4] * e1[3]) / t,
            (e1[4] * e1[1] - e1[5] * e1[0]) / t
        ];
    }
    static singularValueDecompose2dScale(e1, t) {
        const i = e1[0], n = e1[1], a = e1[2], s = e1[3], r = i ** 2 + n ** 2, o = i * a + n * s, l = a ** 2 + s ** 2, c = (r + l) / 2, h = Math.sqrt(c ** 2 - (r * l - o ** 2));
        t[0] = Math.sqrt(c + h || 1), t[1] = Math.sqrt(c - h || 1);
    }
    static normalizeRect(e1) {
        const t = e1.slice(0);
        return e1[0] > e1[2] && (t[0] = e1[2], t[2] = e1[0]), e1[1] > e1[3] && (t[1] = e1[3], t[3] = e1[1]), t;
    }
    static intersect(e1, t) {
        const i = Math.max(Math.min(e1[0], e1[2]), Math.min(t[0], t[2])), n = Math.min(Math.max(e1[0], e1[2]), Math.max(t[0], t[2]));
        if (i > n) return null;
        const a = Math.max(Math.min(e1[1], e1[3]), Math.min(t[1], t[3])), s = Math.min(Math.max(e1[1], e1[3]), Math.max(t[1], t[3]));
        return a > s ? null : [
            i,
            a,
            n,
            s
        ];
    }
    static pointBoundingBox(e1, t, i) {
        i[0] = Math.min(i[0], e1), i[1] = Math.min(i[1], t), i[2] = Math.max(i[2], e1), i[3] = Math.max(i[3], t);
    }
    static rectBoundingBox(e1, t, i, n, a) {
        a[0] = Math.min(a[0], e1, i), a[1] = Math.min(a[1], t, n), a[2] = Math.max(a[2], e1, i), a[3] = Math.max(a[3], t, n);
    }
    static #e(e1, t, i, n, a, s, r, o, l, c) {
        if (l <= 0 || l >= 1) return;
        const h = 1 - l, d = l * l, u = d * l, g = h * (h * (h * e1 + 3 * l * t) + 3 * d * i) + u * n, f = h * (h * (h * a + 3 * l * s) + 3 * d * r) + u * o;
        c[0] = Math.min(c[0], g), c[1] = Math.min(c[1], f), c[2] = Math.max(c[2], g), c[3] = Math.max(c[3], f);
    }
    static #t(e1, t, i, n, a, s, r, o, l, c, h, d) {
        if (Math.abs(l) < 1e-12) return void (Math.abs(c) >= 1e-12 && this.#e(e1, t, i, n, a, s, r, o, -h / c, d));
        const u = c ** 2 - 4 * h * l;
        if (u < 0) return;
        const g = Math.sqrt(u), f = 2 * l;
        this.#e(e1, t, i, n, a, s, r, o, (-c + g) / f, d), this.#e(e1, t, i, n, a, s, r, o, (-c - g) / f, d);
    }
    static bezierBoundingBox(e1, t, i, n, a, s, r, o, l) {
        l[0] = Math.min(l[0], e1, r), l[1] = Math.min(l[1], t, o), l[2] = Math.max(l[2], e1, r), l[3] = Math.max(l[3], t, o), this.#t(e1, i, a, r, t, n, s, o, 3 * (3 * (i - a) - e1 + r), 6 * (e1 - 2 * i + a), 3 * (i - e1), l), this.#t(e1, i, a, r, t, n, s, o, 3 * (3 * (n - s) - t + o), 6 * (t - 2 * n + s), 3 * (n - t), l);
    }
}
let fc = null, pc = null;
function normalizeUnicode(e1) {
    return fc || (fc = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, pc = new Map([
        [
            "ï¬",
            "Å¿t"
        ]
    ])), e1.replaceAll(fc, (e1, t, i)=>t ? t.normalize("NFKC") : pc.get(i));
}
function getUuid() {
    if ("function" == typeof crypto.randomUUID) return crypto.randomUUID();
    const e1 = new Uint8Array(32);
    return crypto.getRandomValues(e1), bytesToString(e1);
}
const mc = "pdfjs_internal_id_";
function MathClamp(e1, t, i) {
    return Math.min(Math.max(e1, t), i);
}
function toBase64Util(e1) {
    return Uint8Array.prototype.toBase64 ? e1.toBase64() : btoa(bytesToString(e1));
}
"function" != typeof Promise.try && (Promise.try = function(e1, ...t) {
    return new Promise((i)=>{
        i(e1(...t));
    });
}), "function" != typeof Math.sumPrecise && (Math.sumPrecise = function(e1) {
    return e1.reduce((e1, t)=>e1 + t, 0);
});
class XfaText {
    static textContent(e1) {
        const t = [], i = {
            items: t,
            styles: Object.create(null)
        };
        return function walk(e1) {
            if (!e1) return;
            let i = null;
            const n = e1.name;
            if ("#text" === n) i = e1.value;
            else {
                if (!XfaText.shouldBuildText(n)) return;
                e1?.attributes?.textContent ? i = e1.attributes.textContent : e1.value && (i = e1.value);
            }
            if (null !== i && t.push({
                str: i
            }), e1.children) for (const t of e1.children)walk(t);
        }(e1), i;
    }
    static shouldBuildText(e1) {
        return !("textarea" === e1 || "input" === e1 || "option" === e1 || "select" === e1);
    }
}
class XfaLayer {
    static setupStorage(e1, t, i, n, a) {
        const s = n.getValue(t, {
            value: null
        });
        switch(i.name){
            case "textarea":
                if (null !== s.value && (e1.textContent = s.value), "print" === a) break;
                e1.addEventListener("input", (e1)=>{
                    n.setValue(t, {
                        value: e1.target.value
                    });
                });
                break;
            case "input":
                if ("radio" === i.attributes.type || "checkbox" === i.attributes.type) {
                    if (s.value === i.attributes.xfaOn ? e1.setAttribute("checked", !0) : s.value === i.attributes.xfaOff && e1.removeAttribute("checked"), "print" === a) break;
                    e1.addEventListener("change", (e1)=>{
                        n.setValue(t, {
                            value: e1.target.checked ? e1.target.getAttribute("xfaOn") : e1.target.getAttribute("xfaOff")
                        });
                    });
                } else {
                    if (null !== s.value && e1.setAttribute("value", s.value), "print" === a) break;
                    e1.addEventListener("input", (e1)=>{
                        n.setValue(t, {
                            value: e1.target.value
                        });
                    });
                }
                break;
            case "select":
                if (null !== s.value) {
                    e1.setAttribute("value", s.value);
                    for (const e1 of i.children)e1.attributes.value === s.value ? e1.attributes.selected = !0 : e1.attributes.hasOwnProperty("selected") && delete e1.attributes.selected;
                }
                e1.addEventListener("input", (e1)=>{
                    const i = e1.target.options, a = -1 === i.selectedIndex ? "" : i[i.selectedIndex].value;
                    n.setValue(t, {
                        value: a
                    });
                });
        }
    }
    static setAttributes({ html: e1, element: t, storage: i = null, intent: n, linkService: a }) {
        const { attributes: s } = t, r = e1 instanceof HTMLAnchorElement;
        "radio" === s.type && (s.name = `${s.name}-${n}`);
        for (const [t, i] of Object.entries(s))if (null != i) switch(t){
            case "class":
                i.length && e1.setAttribute(t, i.join(" "));
                break;
            case "dataId":
                break;
            case "id":
                e1.setAttribute("data-element-id", i);
                break;
            case "style":
                Object.assign(e1.style, i);
                break;
            case "textContent":
                e1.textContent = i;
                break;
            default:
                (!r || "href" !== t && "newWindow" !== t) && e1.setAttribute(t, i);
        }
        r && a.addLinkAttributes(e1, s.href, s.newWindow), i && s.dataId && this.setupStorage(e1, s.dataId, t, i);
    }
    static render(e1) {
        const t = e1.annotationStorage, i = e1.linkService, n = e1.xfaHtml, a = e1.intent || "display", s = document.createElement(n.name);
        n.attributes && this.setAttributes({
            html: s,
            element: n,
            intent: a,
            linkService: i
        });
        const r = "richText" !== a, o = e1.div;
        if (o.append(s), e1.viewport) {
            const t = `matrix(${e1.viewport.transform.join(",")})`;
            o.style.transform = t;
        }
        r && o.setAttribute("class", "xfaLayer xfaFont");
        const l = [];
        if (0 === n.children.length) {
            if (n.value) {
                const e1 = document.createTextNode(n.value);
                s.append(e1), r && XfaText.shouldBuildText(n.name) && l.push(e1);
            }
            return {
                textDivs: l
            };
        }
        const c = [
            [
                n,
                -1,
                s
            ]
        ];
        for(; c.length > 0;){
            const [e1, n, s] = c.at(-1);
            if (n + 1 === e1.children.length) {
                c.pop();
                continue;
            }
            const o = e1.children[++c.at(-1)[1]];
            if (null === o) continue;
            const { name: h } = o;
            if ("#text" === h) {
                const e1 = document.createTextNode(o.value);
                l.push(e1), s.append(e1);
                continue;
            }
            const d = o?.attributes?.xmlns ? document.createElementNS(o.attributes.xmlns, h) : document.createElement(h);
            if (s.append(d), o.attributes && this.setAttributes({
                html: d,
                element: o,
                storage: t,
                intent: a,
                linkService: i
            }), o.children?.length > 0) c.push([
                o,
                -1,
                d
            ]);
            else if (o.value) {
                const e1 = document.createTextNode(o.value);
                r && XfaText.shouldBuildText(h) && l.push(e1), d.append(e1);
            }
        }
        for (const e1 of o.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))e1.setAttribute("readOnly", !0);
        return {
            textDivs: l
        };
    }
    static update(e1) {
        const t = `matrix(${e1.viewport.transform.join(",")})`;
        e1.div.style.transform = t, e1.div.hidden = !1;
    }
}
const bc = "http://www.w3.org/2000/svg";
class PixelsPerInch {
    static CSS = 96;
    static PDF = 72;
    static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
}
async function fetchData(e1, t = "text") {
    if (isValidFetchUrl(e1, document.baseURI)) {
        const i = await fetch(e1);
        if (!i.ok) throw new Error(i.statusText);
        switch(t){
            case "arraybuffer":
                return i.arrayBuffer();
            case "blob":
                return i.blob();
            case "json":
                return i.json();
        }
        return i.text();
    }
    return new Promise((i, n)=>{
        const a = new XMLHttpRequest;
        a.open("GET", e1, !0), a.responseType = t, a.onreadystatechange = ()=>{
            if (a.readyState === XMLHttpRequest.DONE) if (200 !== a.status && 0 !== a.status) n(new Error(a.statusText));
            else {
                switch(t){
                    case "arraybuffer":
                    case "blob":
                    case "json":
                        return void i(a.response);
                }
                i(a.responseText);
            }
        }, a.send(null);
    });
}
class PageViewport {
    constructor({ viewBox: e1, userUnit: t, scale: i, rotation: n, offsetX: a = 0, offsetY: s = 0, dontFlip: r = !1 }){
        this.viewBox = e1, this.userUnit = t, this.scale = i, this.rotation = n, this.offsetX = a, this.offsetY = s, i *= t;
        const o = (e1[2] + e1[0]) / 2, l = (e1[3] + e1[1]) / 2;
        let c, h, d, u, g, f, p, m;
        switch((n %= 360) < 0 && (n += 360), n){
            case 180:
                c = -1, h = 0, d = 0, u = 1;
                break;
            case 90:
                c = 0, h = 1, d = 1, u = 0;
                break;
            case 270:
                c = 0, h = -1, d = -1, u = 0;
                break;
            case 0:
                c = 1, h = 0, d = 0, u = -1;
                break;
            default:
                throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
        }
        r && (d = -d, u = -u), 0 === c ? (g = Math.abs(l - e1[1]) * i + a, f = Math.abs(o - e1[0]) * i + s, p = (e1[3] - e1[1]) * i, m = (e1[2] - e1[0]) * i) : (g = Math.abs(o - e1[0]) * i + a, f = Math.abs(l - e1[1]) * i + s, p = (e1[2] - e1[0]) * i, m = (e1[3] - e1[1]) * i), this.transform = [
            c * i,
            h * i,
            d * i,
            u * i,
            g - c * i * o - d * i * l,
            f - h * i * o - u * i * l
        ], this.width = p, this.height = m;
    }
    get rawDims() {
        const e1 = this.viewBox;
        return shadow(this, "rawDims", {
            pageWidth: e1[2] - e1[0],
            pageHeight: e1[3] - e1[1],
            pageX: e1[0],
            pageY: e1[1]
        });
    }
    clone({ scale: e1 = this.scale, rotation: t = this.rotation, offsetX: i = this.offsetX, offsetY: n = this.offsetY, dontFlip: a = !1 } = {}) {
        return new PageViewport({
            viewBox: this.viewBox.slice(),
            userUnit: this.userUnit,
            scale: e1,
            rotation: t,
            offsetX: i,
            offsetY: n,
            dontFlip: a
        });
    }
    convertToViewportPoint(e1, t) {
        const i = [
            e1,
            t
        ];
        return Util.applyTransform(i, this.transform), i;
    }
    convertToViewportRectangle(e1) {
        const t = [
            e1[0],
            e1[1]
        ];
        Util.applyTransform(t, this.transform);
        const i = [
            e1[2],
            e1[3]
        ];
        return Util.applyTransform(i, this.transform), [
            t[0],
            t[1],
            i[0],
            i[1]
        ];
    }
    convertToPdfPoint(e1, t) {
        const i = [
            e1,
            t
        ];
        return Util.applyInverseTransform(i, this.transform), i;
    }
}
class RenderingCancelledException extends uc {
    constructor(e1, t = 0){
        super(e1, "RenderingCancelledException"), this.extraDelay = t;
    }
}
function isDataScheme(e1) {
    const t = e1.length;
    let i = 0;
    for(; i < t && "" === e1[i].trim();)i++;
    return "data:" === e1.substring(i, i + 5).toLowerCase();
}
function isPdfFile(e1) {
    return "string" == typeof e1 && /\.pdf$/i.test(e1);
}
function getFilenameFromUrl(e1) {
    return [e1] = e1.split(/[#?]/, 1), e1.substring(e1.lastIndexOf("/") + 1);
}
function getPdfFilenameFromUrl(e1, t = "document.pdf") {
    if ("string" != typeof e1) return t;
    if (isDataScheme(e1)) return warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), t;
    const i = ((e1)=>{
        try {
            return new URL(e1);
        } catch  {
            try {
                return new URL(decodeURIComponent(e1));
            } catch  {
                try {
                    return new URL(e1, "https://foo.bar");
                } catch  {
                    try {
                        return new URL(decodeURIComponent(e1), "https://foo.bar");
                    } catch  {
                        return null;
                    }
                }
            }
        }
    })(e1);
    if (!i) return t;
    const decode = (e1)=>{
        try {
            let t = decodeURIComponent(e1);
            return t.includes("/") ? (t = t.split("/").at(-1), t.test(/^\.pdf$/i) ? t : e1) : t;
        } catch  {
            return e1;
        }
    }, n = /\.pdf$/i, a = i.pathname.split("/").at(-1);
    if (n.test(a)) return decode(a);
    if (i.searchParams.size > 0) {
        const e1 = Array.from(i.searchParams.values()).reverse();
        for (const t of e1)if (n.test(t)) return decode(t);
        const t = Array.from(i.searchParams.keys()).reverse();
        for (const e1 of t)if (n.test(e1)) return decode(e1);
    }
    if (i.hash) {
        const e1 = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i.exec(i.hash);
        if (e1) return decode(e1[0]);
    }
    return t;
}
class StatTimer {
    started = Object.create(null);
    times = [];
    time(e1) {
        e1 in this.started && warn(`Timer is already running for ${e1}`), this.started[e1] = Date.now();
    }
    timeEnd(e1) {
        e1 in this.started || warn(`Timer has not been started for ${e1}`), this.times.push({
            name: e1,
            start: this.started[e1],
            end: Date.now()
        }), delete this.started[e1];
    }
    toString() {
        const e1 = [];
        let t = 0;
        for (const { name: e1 } of this.times)t = Math.max(e1.length, t);
        for (const { name: i, start: n, end: a } of this.times)e1.push(`${i.padEnd(t)} ${a - n}ms\n`);
        return e1.join("");
    }
}
function isValidFetchUrl(e1, t) {
    const i = t ? URL.parse(e1, t) : URL.parse(e1);
    return "http:" === i?.protocol || "https:" === i?.protocol;
}
function noContextMenu(e1) {
    e1.preventDefault();
}
function stopEvent(e1) {
    e1.preventDefault(), e1.stopPropagation();
}
class PDFDateString {
    static #dt;
    static toDateObject(e1) {
        if (e1 instanceof Date) return e1;
        if (!e1 || "string" != typeof e1) return null;
        this.#dt ||= new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
        const t = this.#dt.exec(e1);
        if (!t) return null;
        const i = parseInt(t[1], 10);
        let n = parseInt(t[2], 10);
        n = n >= 1 && n <= 12 ? n - 1 : 0;
        let a = parseInt(t[3], 10);
        a = a >= 1 && a <= 31 ? a : 1;
        let s = parseInt(t[4], 10);
        s = s >= 0 && s <= 23 ? s : 0;
        let r = parseInt(t[5], 10);
        r = r >= 0 && r <= 59 ? r : 0;
        let o = parseInt(t[6], 10);
        o = o >= 0 && o <= 59 ? o : 0;
        const l = t[7] || "Z";
        let c = parseInt(t[8], 10);
        c = c >= 0 && c <= 23 ? c : 0;
        let h = parseInt(t[9], 10) || 0;
        return h = h >= 0 && h <= 59 ? h : 0, "-" === l ? (s += c, r += h) : "+" === l && (s -= c, r -= h), new Date(Date.UTC(i, n, a, s, r, o));
    }
}
function getXfaPageViewport(e1, { scale: t = 1, rotation: i = 0 }) {
    const { width: n, height: a } = e1.attributes.style, s = [
        0,
        0,
        parseInt(n),
        parseInt(a)
    ];
    return new PageViewport({
        viewBox: s,
        userUnit: 1,
        scale: t,
        rotation: i
    });
}
function getRGB(e1) {
    if (e1.startsWith("#")) {
        const t = parseInt(e1.slice(1), 16);
        return [
            (16711680 & t) >> 16,
            (65280 & t) >> 8,
            255 & t
        ];
    }
    return e1.startsWith("rgb(") ? e1.slice(4, -1).split(",").map((e1)=>parseInt(e1)) : e1.startsWith("rgba(") ? e1.slice(5, -1).split(",").map((e1)=>parseInt(e1)).slice(0, 3) : (warn(`Not a valid color format: "${e1}"`), [
        0,
        0,
        0
    ]);
}
function getCurrentTransform(e1) {
    const { a: t, b: i, c: n, d: a, e: s, f: r } = e1.getTransform();
    return [
        t,
        i,
        n,
        a,
        s,
        r
    ];
}
function getCurrentTransformInverse(e1) {
    const { a: t, b: i, c: n, d: a, e: s, f: r } = e1.getTransform().invertSelf();
    return [
        t,
        i,
        n,
        a,
        s,
        r
    ];
}
function setLayerDimensions(e1, t, i = !1, n = !0) {
    if (t instanceof PageViewport) {
        const { pageWidth: n, pageHeight: a } = t.rawDims, { style: s } = e1, r = util_FeatureTest.isCSSRoundSupported, o = `var(--total-scale-factor) * ${n}px`, l = `var(--total-scale-factor) * ${a}px`, c = r ? `round(down, ${o}, var(--scale-round-x))` : `calc(${o})`, h = r ? `round(down, ${l}, var(--scale-round-y))` : `calc(${l})`;
        i && t.rotation % 180 != 0 ? (s.width = h, s.height = c) : (s.width = c, s.height = h);
    }
    n && e1.setAttribute("data-main-rotation", t.rotation);
}
class OutputScale {
    constructor(){
        const { pixelRatio: e1 } = OutputScale;
        this.sx = e1, this.sy = e1;
    }
    get scaled() {
        return 1 !== this.sx || 1 !== this.sy;
    }
    get symmetric() {
        return this.sx === this.sy;
    }
    limitCanvas(e1, t, i, n, a = -1) {
        let s = 1 / 0, r = 1 / 0, o = 1 / 0;
        (i = OutputScale.capPixels(i, a)) > 0 && (s = Math.sqrt(i / (e1 * t))), -1 !== n && (r = n / e1, o = n / t);
        const l = Math.min(s, r, o);
        return (this.sx > l || this.sy > l) && (this.sx = l, this.sy = l, !0);
    }
    static get pixelRatio() {
        return globalThis.devicePixelRatio || 1;
    }
    static capPixels(e1, t) {
        if (t >= 0) {
            const i = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + t / 100));
            return e1 > 0 ? Math.min(e1, i) : i;
        }
        return e1;
    }
}
const yc = [
    "image/apng",
    "image/avif",
    "image/bmp",
    "image/gif",
    "image/jpeg",
    "image/png",
    "image/svg+xml",
    "image/webp",
    "image/x-icon"
];
class ColorScheme {
    static get isDarkMode() {
        return shadow(this, "isDarkMode", !!window?.matchMedia?.("(prefers-color-scheme: dark)").matches);
    }
}
class CSSConstants {
    static get commentForegroundColor() {
        const e1 = document.createElement("span");
        e1.classList.add("comment", "sidebar");
        const { style: t } = e1;
        t.width = t.height = "0", t.display = "none", t.color = "var(--comment-fg-color)", document.body.append(e1);
        const { color: i } = window.getComputedStyle(e1);
        return e1.remove(), shadow(this, "commentForegroundColor", getRGB(i));
    }
}
function applyOpacity(e1, t, i, n) {
    const a = 255 * (1 - (n = Math.min(Math.max(n ?? 1, 0), 1)));
    return [
        e1 = Math.round(e1 * n + a),
        t = Math.round(t * n + a),
        i = Math.round(i * n + a)
    ];
}
function RGBToHSL(e1, t) {
    const i = e1[0] / 255, n = e1[1] / 255, a = e1[2] / 255, s = Math.max(i, n, a), r = Math.min(i, n, a), o = (s + r) / 2;
    if (s === r) t[0] = t[1] = 0;
    else {
        const e1 = s - r;
        switch(t[1] = o < .5 ? e1 / (s + r) : e1 / (2 - s - r), s){
            case i:
                t[0] = 60 * ((n - a) / e1 + (n < a ? 6 : 0));
                break;
            case n:
                t[0] = 60 * ((a - i) / e1 + 2);
                break;
            case a:
                t[0] = 60 * ((i - n) / e1 + 4);
        }
    }
    t[2] = o;
}
function HSLToRGB(e1, t) {
    const i = e1[0], n = e1[1], a = e1[2], s = (1 - Math.abs(2 * a - 1)) * n, r = s * (1 - Math.abs(i / 60 % 2 - 1)), o = a - s / 2;
    switch(Math.floor(i / 60)){
        case 0:
            t[0] = s + o, t[1] = r + o, t[2] = o;
            break;
        case 1:
            t[0] = r + o, t[1] = s + o, t[2] = o;
            break;
        case 2:
            t[0] = o, t[1] = s + o, t[2] = r + o;
            break;
        case 3:
            t[0] = o, t[1] = r + o, t[2] = s + o;
            break;
        case 4:
            t[0] = r + o, t[1] = o, t[2] = s + o;
            break;
        case 5:
        case 6:
            t[0] = s + o, t[1] = o, t[2] = r + o;
    }
}
function computeLuminance(e1) {
    return e1 <= .03928 ? e1 / 12.92 : ((e1 + .055) / 1.055) ** 2.4;
}
function contrastRatio(e1, t, i) {
    HSLToRGB(e1, i), i.map(computeLuminance);
    const n = .2126 * i[0] + .7152 * i[1] + .0722 * i[2];
    HSLToRGB(t, i), i.map(computeLuminance);
    const a = .2126 * i[0] + .7152 * i[1] + .0722 * i[2];
    return n > a ? (n + .05) / (a + .05) : (a + .05) / (n + .05);
}
const wc = new Map;
function findContrastColor(e1, t) {
    const i = e1[0] + 256 * e1[1] + 65536 * e1[2] + 16777216 * t[0] + 4294967296 * t[1] + 1099511627776 * t[2];
    let n = wc.get(i);
    if (n) return n;
    const a = new Float32Array(9), s = a.subarray(0, 3), r = a.subarray(3, 6);
    RGBToHSL(e1, r);
    const o = a.subarray(6, 9);
    RGBToHSL(t, o);
    const l = o[2] < .5, c = l ? 12 : 4.5;
    if (r[2] = l ? Math.sqrt(r[2]) : 1 - Math.sqrt(1 - r[2]), contrastRatio(r, o, s) < c) {
        let e1, t;
        l ? (e1 = r[2], t = 1) : (e1 = 0, t = r[2]);
        const i = .005;
        for(; t - e1 > i;){
            const i = r[2] = (e1 + t) / 2;
            l === contrastRatio(r, o, s) < c ? e1 = i : t = i;
        }
        r[2] = l ? t : e1;
    }
    return HSLToRGB(r, s), n = Util.makeHexColor(Math.round(255 * s[0]), Math.round(255 * s[1]), Math.round(255 * s[2])), wc.set(i, n), n;
}
function renderRichText({ html: e1, dir: t, className: i }, n) {
    const a = document.createDocumentFragment();
    if ("string" == typeof e1) {
        const i = document.createElement("p");
        i.dir = t || "auto";
        const n = e1.split(/(?:\r\n?|\n)/);
        for(let e1 = 0, t = n.length; e1 < t; ++e1){
            const a = n[e1];
            i.append(document.createTextNode(a)), e1 < t - 1 && i.append(document.createElement("br"));
        }
        a.append(i);
    } else XfaLayer.render({
        xfaHtml: e1,
        div: a,
        intent: "richText"
    });
    a.firstChild.classList.add("richText", i), n.append(a);
}
class EditorToolbar {
    #ut = null;
    #gt = null;
    #ft;
    #pt = null;
    #mt = null;
    #bt = null;
    #yt = null;
    #wt = null;
    static #At = null;
    constructor(e1){
        this.#ft = e1, EditorToolbar.#At ||= Object.freeze({
            freetext: "pdfjs-editor-remove-freetext-button",
            highlight: "pdfjs-editor-remove-highlight-button",
            ink: "pdfjs-editor-remove-ink-button",
            stamp: "pdfjs-editor-remove-stamp-button",
            signature: "pdfjs-editor-remove-signature-button"
        });
    }
    render() {
        const e1 = this.#ut = document.createElement("div");
        e1.classList.add("editToolbar", "hidden"), e1.setAttribute("role", "toolbar");
        const t = this.#ft._uiManager._signal;
        t instanceof AbortSignal && !t.aborted && (e1.addEventListener("contextmenu", noContextMenu, {
            signal: t
        }), e1.addEventListener("pointerdown", EditorToolbar.#xt, {
            signal: t
        }));
        const i = this.#pt = document.createElement("div");
        i.className = "buttons", e1.append(i);
        const n = this.#ft.toolbarPosition;
        if (n) {
            const { style: t } = e1, i = "ltr" === this.#ft._uiManager.direction ? 1 - n[0] : n[0];
            t.insetInlineEnd = 100 * i + "%", t.top = `calc(${100 * n[1]}% + var(--editor-toolbar-vert-offset))`;
        }
        return e1;
    }
    get div() {
        return this.#ut;
    }
    static #xt(e1) {
        e1.stopPropagation();
    }
    #St(e1) {
        this.#ft._focusEventsAllowed = !1, stopEvent(e1);
    }
    #vt(e1) {
        this.#ft._focusEventsAllowed = !0, stopEvent(e1);
    }
    #Ct(e1) {
        const t = this.#ft._uiManager._signal;
        return t instanceof AbortSignal && !t.aborted && (e1.addEventListener("focusin", this.#St.bind(this), {
            capture: !0,
            signal: t
        }), e1.addEventListener("focusout", this.#vt.bind(this), {
            capture: !0,
            signal: t
        }), e1.addEventListener("contextmenu", noContextMenu, {
            signal: t
        }), !0);
    }
    hide() {
        this.#ut.classList.add("hidden"), this.#gt?.hideDropdown();
    }
    show() {
        this.#ut.classList.remove("hidden"), this.#mt?.shown(), this.#bt?.shown();
    }
    addDeleteButton() {
        const { editorType: e1, _uiManager: t } = this.#ft, i = document.createElement("button");
        i.classList.add("basic", "deleteButton"), i.tabIndex = 0, i.setAttribute("data-l10n-id", EditorToolbar.#At[e1]), this.#Ct(i) && i.addEventListener("click", (e1)=>{
            t.delete();
        }, {
            signal: t._signal
        }), this.#pt.append(i);
    }
    get #kt() {
        const e1 = document.createElement("div");
        return e1.className = "divider", e1;
    }
    async addAltText(e1) {
        const t = await e1.render();
        this.#Ct(t), this.#pt.append(t, this.#kt), this.#mt = e1;
    }
    addComment(e1, t = null) {
        if (this.#bt) return;
        const i = e1.renderForToolbar();
        if (!i) return;
        this.#Ct(i);
        const n = this.#yt = this.#kt;
        t ? (this.#pt.insertBefore(i, t), this.#pt.insertBefore(n, t)) : this.#pt.append(i, n), this.#bt = e1, e1.toolbar = this;
    }
    addColorPicker(e1) {
        if (this.#gt) return;
        this.#gt = e1;
        const t = e1.renderButton();
        this.#Ct(t), this.#pt.append(t, this.#kt);
    }
    async addEditSignatureButton(e1) {
        const t = this.#wt = await e1.renderEditButton(this.#ft);
        this.#Ct(t), this.#pt.append(t, this.#kt);
    }
    removeButton(e1) {
        if ("comment" === e1) this.#bt?.removeToolbarCommentButton(), this.#bt = null, this.#yt?.remove(), this.#yt = null;
    }
    async addButton(e1, t) {
        switch(e1){
            case "colorPicker":
                this.addColorPicker(t);
                break;
            case "altText":
                await this.addAltText(t);
                break;
            case "editSignature":
                await this.addEditSignatureButton(t);
                break;
            case "delete":
                this.addDeleteButton();
                break;
            case "comment":
                this.addComment(t);
        }
    }
    async addButtonBefore(e1, t, i) {
        const n = this.#pt.querySelector(i);
        n && "comment" === e1 && this.addComment(t, n);
    }
    updateEditSignatureButton(e1) {
        this.#wt && (this.#wt.title = e1);
    }
    remove() {
        this.#ut.remove(), this.#gt?.destroy(), this.#gt = null;
    }
}
class FloatingToolbar {
    #pt = null;
    #ut = null;
    #Tt;
    constructor(e1){
        this.#Tt = e1;
    }
    #Ft() {
        const e1 = this.#ut = document.createElement("div");
        e1.className = "editToolbar", e1.setAttribute("role", "toolbar");
        const t = this.#Tt._signal;
        t instanceof AbortSignal && !t.aborted && e1.addEventListener("contextmenu", noContextMenu, {
            signal: t
        });
        const i = this.#pt = document.createElement("div");
        return i.className = "buttons", e1.append(i), this.#Tt.hasCommentManager() && this.#It("commentButton", "pdfjs-comment-floating-button", "pdfjs-comment-floating-button-label", ()=>{
            this.#Tt.commentSelection("floating_button");
        }), this.#It("highlightButton", "pdfjs-highlight-floating-button1", "pdfjs-highlight-floating-button-label", ()=>{
            this.#Tt.highlightSelection("floating_button");
        }), e1;
    }
    #Et(e1, t) {
        let i = 0, n = 0;
        for (const a of e1){
            const e1 = a.y + a.height;
            if (e1 < i) continue;
            const s = a.x + (t ? a.width : 0);
            e1 > i ? (n = s, i = e1) : t ? s > n && (n = s) : s < n && (n = s);
        }
        return [
            t ? 1 - n : n,
            i
        ];
    }
    show(e1, t, i) {
        const [n, a] = this.#Et(t, i), { style: s } = this.#ut ||= this.#Ft();
        e1.append(this.#ut), s.insetInlineEnd = 100 * n + "%", s.top = `calc(${100 * a}% + var(--editor-toolbar-vert-offset))`;
    }
    hide() {
        this.#ut.remove();
    }
    #It(e1, t, i, n) {
        const a = document.createElement("button");
        a.classList.add("basic", e1), a.tabIndex = 0, a.setAttribute("data-l10n-id", t);
        const s = document.createElement("span");
        a.append(s), s.className = "visuallyHidden", s.setAttribute("data-l10n-id", i);
        const r = this.#Tt._signal;
        r instanceof AbortSignal && !r.aborted && (a.addEventListener("contextmenu", noContextMenu, {
            signal: r
        }), a.addEventListener("click", n, {
            signal: r
        })), this.#pt.append(a);
    }
}
function bindEvents(e1, t, i) {
    for (const n of i)t.addEventListener(n, e1[n].bind(e1));
}
class IdManager {
    #Mt = 0;
    get id() {
        return `${$l}${this.#Mt++}`;
    }
}
class ImageManager {
    #Dt = getUuid();
    #Mt = 0;
    #Ot = null;
    static get _isSVGFittingCanvas() {
        const e1 = new OffscreenCanvas(1, 3).getContext("2d", {
            willReadFrequently: !0
        }), t = new Image;
        t.src = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>';
        return shadow(this, "_isSVGFittingCanvas", t.decode().then(()=>(e1.drawImage(t, 0, 0, 1, 1, 0, 0, 1, 3), 0 === new Uint32Array(e1.getImageData(0, 0, 1, 1).data.buffer)[0])));
    }
    async #_t(e1, t) {
        this.#Ot ||= new Map;
        let i = this.#Ot.get(e1);
        if (null === i) return null;
        if (i?.bitmap) return i.refCounter += 1, i;
        try {
            let e1;
            if (i ||= {
                bitmap: null,
                id: `image_${this.#Dt}_${this.#Mt++}`,
                refCounter: 0,
                isSvg: !1
            }, "string" == typeof t ? (i.url = t, e1 = await fetchData(t, "blob")) : t instanceof File ? e1 = i.file = t : t instanceof Blob && (e1 = t), "image/svg+xml" === e1.type) {
                const t = ImageManager._isSVGFittingCanvas, n = new FileReader, a = new Image, s = new Promise((e1, s)=>{
                    a.onload = ()=>{
                        i.bitmap = a, i.isSvg = !0, e1();
                    }, n.onload = async ()=>{
                        const e1 = i.svgUrl = n.result;
                        a.src = await t ? `${e1}#svgView(preserveAspectRatio(none))` : e1;
                    }, a.onerror = n.onerror = s;
                });
                n.readAsDataURL(e1), await s;
            } else i.bitmap = await createImageBitmap(e1);
            i.refCounter = 1;
        } catch (e1) {
            warn(e1), i = null;
        }
        return this.#Ot.set(e1, i), i && this.#Ot.set(i.id, i), i;
    }
    async getFromFile(e1) {
        const { lastModified: t, name: i, size: n, type: a } = e1;
        return this.#_t(`${t}_${i}_${n}_${a}`, e1);
    }
    async getFromUrl(e1) {
        return this.#_t(e1, e1);
    }
    async getFromBlob(e1, t) {
        const i = await t;
        return this.#_t(e1, i);
    }
    async getFromId(e1) {
        this.#Ot ||= new Map;
        const t = this.#Ot.get(e1);
        if (!t) return null;
        if (t.bitmap) return t.refCounter += 1, t;
        if (t.file) return this.getFromFile(t.file);
        if (t.blobPromise) {
            const { blobPromise: e1 } = t;
            return delete t.blobPromise, this.getFromBlob(t.id, e1);
        }
        return this.getFromUrl(t.url);
    }
    getFromCanvas(e1, t) {
        this.#Ot ||= new Map;
        let i = this.#Ot.get(e1);
        if (i?.bitmap) return i.refCounter += 1, i;
        const n = new OffscreenCanvas(t.width, t.height);
        return n.getContext("2d").drawImage(t, 0, 0), i = {
            bitmap: n.transferToImageBitmap(),
            id: `image_${this.#Dt}_${this.#Mt++}`,
            refCounter: 1,
            isSvg: !1
        }, this.#Ot.set(e1, i), this.#Ot.set(i.id, i), i;
    }
    getSvgUrl(e1) {
        const t = this.#Ot.get(e1);
        return t?.isSvg ? t.svgUrl : null;
    }
    deleteId(e1) {
        this.#Ot ||= new Map;
        const t = this.#Ot.get(e1);
        if (!t) return;
        if (t.refCounter -= 1, 0 !== t.refCounter) return;
        const { bitmap: i } = t;
        if (!t.url && !t.file) {
            const e1 = new OffscreenCanvas(i.width, i.height);
            e1.getContext("bitmaprenderer").transferFromImageBitmap(i), t.blobPromise = e1.convertToBlob();
        }
        i.close?.(), t.bitmap = null;
    }
    isValidId(e1) {
        return e1.startsWith(`image_${this.#Dt}_`);
    }
}
class CommandManager {
    #Pt = [];
    #Rt = !1;
    #Bt;
    #Nt = -1;
    constructor(e1 = 128){
        this.#Bt = e1;
    }
    add({ cmd: e1, undo: t, post: i, mustExec: n, type: a = NaN, overwriteIfSameType: s = !1, keepUndo: r = !1 }) {
        if (n && e1(), this.#Rt) return;
        const o = {
            cmd: e1,
            undo: t,
            post: i,
            type: a
        };
        if (-1 === this.#Nt) return this.#Pt.length > 0 && (this.#Pt.length = 0), this.#Nt = 0, void this.#Pt.push(o);
        if (s && this.#Pt[this.#Nt].type === a) return r && (o.undo = this.#Pt[this.#Nt].undo), void (this.#Pt[this.#Nt] = o);
        const l = this.#Nt + 1;
        l === this.#Bt ? this.#Pt.splice(0, 1) : (this.#Nt = l, l < this.#Pt.length && this.#Pt.splice(l)), this.#Pt.push(o);
    }
    undo() {
        if (-1 === this.#Nt) return;
        this.#Rt = !0;
        const { undo: e1, post: t } = this.#Pt[this.#Nt];
        e1(), t?.(), this.#Rt = !1, this.#Nt -= 1;
    }
    redo() {
        if (this.#Nt < this.#Pt.length - 1) {
            this.#Nt += 1, this.#Rt = !0;
            const { cmd: e1, post: t } = this.#Pt[this.#Nt];
            e1(), t?.(), this.#Rt = !1;
        }
    }
    hasSomethingToUndo() {
        return -1 !== this.#Nt;
    }
    hasSomethingToRedo() {
        return this.#Nt < this.#Pt.length - 1;
    }
    cleanType(e1) {
        if (-1 !== this.#Nt) {
            for(let t = this.#Nt; t >= 0; t--)if (this.#Pt[t].type !== e1) return this.#Pt.splice(t + 1, this.#Nt - t), void (this.#Nt = t);
            this.#Pt.length = 0, this.#Nt = -1;
        }
    }
    destroy() {
        this.#Pt = null;
    }
}
class KeyboardManager {
    constructor(e1){
        this.buffer = [], this.callbacks = new Map, this.allKeys = new Set;
        const { isMac: t } = util_FeatureTest.platform;
        for (const [i, n, a = {}] of e1)for (const e1 of i){
            const i = e1.startsWith("mac+");
            t && i ? (this.callbacks.set(e1.slice(4), {
                callback: n,
                options: a
            }), this.allKeys.add(e1.split("+").at(-1))) : t || i || (this.callbacks.set(e1, {
                callback: n,
                options: a
            }), this.allKeys.add(e1.split("+").at(-1)));
        }
    }
    #Lt(e1) {
        e1.altKey && this.buffer.push("alt"), e1.ctrlKey && this.buffer.push("ctrl"), e1.metaKey && this.buffer.push("meta"), e1.shiftKey && this.buffer.push("shift"), this.buffer.push(e1.key);
        const t = this.buffer.join("+");
        return this.buffer.length = 0, t;
    }
    exec(e1, t) {
        if (!this.allKeys.has(t.key)) return;
        const i = this.callbacks.get(this.#Lt(t));
        if (!i) return;
        const { callback: n, options: { bubbles: a = !1, args: s = [], checker: r = null } } = i;
        r && !r(e1, t) || (n.bind(e1, ...s, t)(), a || stopEvent(t));
    }
}
class ColorManager {
    static _colorsMapping = new Map([
        [
            "CanvasText",
            [
                0,
                0,
                0
            ]
        ],
        [
            "Canvas",
            [
                255,
                255,
                255
            ]
        ]
    ]);
    get _colors() {
        const e1 = new Map([
            [
                "CanvasText",
                null
            ],
            [
                "Canvas",
                null
            ]
        ]);
        return function(e1) {
            const t = document.createElement("span");
            t.style.visibility = "hidden", t.style.colorScheme = "only light", document.body.append(t);
            for (const i of e1.keys()){
                t.style.color = i;
                const n = window.getComputedStyle(t).color;
                e1.set(i, getRGB(n));
            }
            t.remove();
        }(e1), shadow(this, "_colors", e1);
    }
    convert(e1) {
        const t = getRGB(e1);
        if (!window.matchMedia("(forced-colors: active)").matches) return t;
        for (const [e1, i] of this._colors)if (i.every((e1, i)=>e1 === t[i])) return ColorManager._colorsMapping.get(e1);
        return t;
    }
    getHexCode(e1) {
        const t = this._colors.get(e1);
        return t ? Util.makeHexColor(...t) : e1;
    }
}
class AnnotationEditorUIManager {
    #Ut = new AbortController;
    #jt = null;
    #$t = null;
    #Ht = new Map;
    #Xt = new Map;
    #qt = null;
    #zt = null;
    #Wt = null;
    #Gt = new CommandManager;
    #Vt = null;
    #Kt = null;
    #Yt = null;
    #Jt = 0;
    #Zt = new Set;
    #Qt = null;
    #ei = null;
    #ti = new Set;
    _editorUndoBar = null;
    #ii = !1;
    #ni = !1;
    #ai = !1;
    #si = null;
    #ri = null;
    #oi = null;
    #li = null;
    #ci = !1;
    #hi = null;
    #di = new IdManager;
    #ui = !1;
    #gi = !1;
    #fi = !1;
    #pi = null;
    #mi = null;
    #bi = null;
    #yi = null;
    #wi = null;
    #Ai = Hl.NONE;
    #xi = new Set;
    #Si = null;
    #vi = null;
    #Ci = null;
    #ki = null;
    #Ti = null;
    #Fi = {
        isEditing: !1,
        isEmpty: !0,
        hasSomethingToUndo: !1,
        hasSomethingToRedo: !1,
        hasSelectedEditor: !1,
        hasSelectedText: !1
    };
    #Ii = [
        0,
        0
    ];
    #Ei = null;
    #Mi = null;
    #Di = null;
    #Oi = null;
    #_i = null;
    static TRANSLATE_SMALL = 1;
    static TRANSLATE_BIG = 10;
    static get _keyboardManager() {
        const e1 = AnnotationEditorUIManager.prototype, arrowChecker = (e1)=>e1.#Mi.contains(document.activeElement) && "BUTTON" !== document.activeElement.tagName && e1.hasSomethingToControl(), textInputChecker = (e1, { target: t })=>{
            if (t instanceof HTMLInputElement) {
                const { type: e1 } = t;
                return "text" !== e1 && "number" !== e1;
            }
            return !0;
        }, t = this.TRANSLATE_SMALL, i = this.TRANSLATE_BIG;
        return shadow(this, "_keyboardManager", new KeyboardManager([
            [
                [
                    "ctrl+a",
                    "mac+meta+a"
                ],
                e1.selectAll,
                {
                    checker: textInputChecker
                }
            ],
            [
                [
                    "ctrl+z",
                    "mac+meta+z"
                ],
                e1.undo,
                {
                    checker: textInputChecker
                }
            ],
            [
                [
                    "ctrl+y",
                    "ctrl+shift+z",
                    "mac+meta+shift+z",
                    "ctrl+shift+Z",
                    "mac+meta+shift+Z"
                ],
                e1.redo,
                {
                    checker: textInputChecker
                }
            ],
            [
                [
                    "Backspace",
                    "alt+Backspace",
                    "ctrl+Backspace",
                    "shift+Backspace",
                    "mac+Backspace",
                    "mac+alt+Backspace",
                    "mac+ctrl+Backspace",
                    "Delete",
                    "ctrl+Delete",
                    "shift+Delete",
                    "mac+Delete"
                ],
                e1.delete,
                {
                    checker: textInputChecker
                }
            ],
            [
                [
                    "Enter",
                    "mac+Enter"
                ],
                e1.addNewEditorFromKeyboard,
                {
                    checker: (e1, { target: t })=>!(t instanceof HTMLButtonElement) && e1.#Mi.contains(t) && !e1.isEnterHandled
                }
            ],
            [
                [
                    " ",
                    "mac+ "
                ],
                e1.addNewEditorFromKeyboard,
                {
                    checker: (e1, { target: t })=>!(t instanceof HTMLButtonElement) && e1.#Mi.contains(document.activeElement)
                }
            ],
            [
                [
                    "Escape",
                    "mac+Escape"
                ],
                e1.unselectAll
            ],
            [
                [
                    "ArrowLeft",
                    "mac+ArrowLeft"
                ],
                e1.translateSelectedEditors,
                {
                    args: [
                        -t,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowLeft",
                    "mac+shift+ArrowLeft"
                ],
                e1.translateSelectedEditors,
                {
                    args: [
                        -i,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ArrowRight",
                    "mac+ArrowRight"
                ],
                e1.translateSelectedEditors,
                {
                    args: [
                        t,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowRight",
                    "mac+shift+ArrowRight"
                ],
                e1.translateSelectedEditors,
                {
                    args: [
                        i,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ArrowUp",
                    "mac+ArrowUp"
                ],
                e1.translateSelectedEditors,
                {
                    args: [
                        0,
                        -t
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowUp",
                    "mac+shift+ArrowUp"
                ],
                e1.translateSelectedEditors,
                {
                    args: [
                        0,
                        -i
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ArrowDown",
                    "mac+ArrowDown"
                ],
                e1.translateSelectedEditors,
                {
                    args: [
                        0,
                        t
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowDown",
                    "mac+shift+ArrowDown"
                ],
                e1.translateSelectedEditors,
                {
                    args: [
                        0,
                        i
                    ],
                    checker: arrowChecker
                }
            ]
        ]));
    }
    constructor(e1, t, i, n, a, s, r, o, l, c, h, d, u, g, f, p){
        const m = this._signal = this.#Ut.signal;
        this.#Mi = e1, this.#Di = t, this.#Oi = i, this.#qt = n, this.#Vt = a, this.#vi = s, this.#Ti = o, this._eventBus = r, r._on("editingaction", this.onEditingAction.bind(this), {
            signal: m
        }), r._on("pagechanging", this.onPageChanging.bind(this), {
            signal: m
        }), r._on("scalechanging", this.onScaleChanging.bind(this), {
            signal: m
        }), r._on("rotationchanging", this.onRotationChanging.bind(this), {
            signal: m
        }), r._on("setpreference", this.onSetPreference.bind(this), {
            signal: m
        }), r._on("switchannotationeditorparams", (e1)=>this.updateParams(e1.type, e1.value), {
            signal: m
        }), window.addEventListener("pointerdown", ()=>{
            this.#gi = !0;
        }, {
            capture: !0,
            signal: m
        }), window.addEventListener("pointerup", ()=>{
            this.#gi = !1;
        }, {
            capture: !0,
            signal: m
        }), this.#Pi(), this.#Ri(), this.#Bi(), this.#zt = o.annotationStorage, this.#si = o.filterFactory, this.#Ci = l, this.#li = c || null, this.#ii = h, this.#ni = d, this.#ai = u, this.#wi = g || null, this.viewParameters = {
            realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
            rotation: 0
        }, this.isShiftKeyDown = !1, this._editorUndoBar = f || null, this._supportsPinchToZoom = !1 !== p, a?.setSidebarUiManager(this);
    }
    destroy() {
        this.#_i?.resolve(), this.#_i = null, this.#Ut?.abort(), this.#Ut = null, this._signal = null;
        for (const e1 of this.#Xt.values())e1.destroy();
        this.#Xt.clear(), this.#Ht.clear(), this.#ti.clear(), this.#yi?.clear(), this.#jt = null, this.#xi.clear(), this.#Gt.destroy(), this.#qt?.destroy(), this.#Vt?.destroy(), this.#vi?.destroy(), this.#hi?.hide(), this.#hi = null, this.#bi?.destroy(), this.#bi = null, this.#$t = null, this.#ri && (clearTimeout(this.#ri), this.#ri = null), this.#Ei && (clearTimeout(this.#Ei), this.#Ei = null), this._editorUndoBar?.destroy(), this.#Ti = null;
    }
    combinedSignal(e1) {
        return AbortSignal.any([
            this._signal,
            e1.signal
        ]);
    }
    get mlManager() {
        return this.#wi;
    }
    get useNewAltTextFlow() {
        return this.#ni;
    }
    get useNewAltTextWhenAddingImage() {
        return this.#ai;
    }
    get hcmFilter() {
        return shadow(this, "hcmFilter", this.#Ci ? this.#si.addHCMFilter(this.#Ci.foreground, this.#Ci.background) : "none");
    }
    get direction() {
        return shadow(this, "direction", getComputedStyle(this.#Mi).direction);
    }
    get _highlightColors() {
        return shadow(this, "_highlightColors", this.#li ? new Map(this.#li.split(",").map((e1)=>((e1 = e1.split("=").map((e1)=>e1.trim()))[1] = e1[1].toUpperCase(), e1))) : null);
    }
    get highlightColors() {
        const { _highlightColors: e1 } = this;
        if (!e1) return shadow(this, "highlightColors", null);
        const t = new Map, i = !!this.#Ci;
        for (const [n, a] of e1){
            const e1 = n.endsWith("_HCM");
            i && e1 ? t.set(n.replace("_HCM", ""), a) : i || e1 || t.set(n, a);
        }
        return shadow(this, "highlightColors", t);
    }
    get highlightColorNames() {
        return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e1)=>e1.reverse())) : null);
    }
    getNonHCMColor(e1) {
        if (!this._highlightColors) return e1;
        const t = this.highlightColorNames.get(e1);
        return this._highlightColors.get(t) || e1;
    }
    getNonHCMColorName(e1) {
        return this.highlightColorNames.get(e1) || e1;
    }
    setCurrentDrawingSession(e1) {
        e1 ? (this.unselectAll(), this.disableUserSelect(!0)) : this.disableUserSelect(!1), this.#Yt = e1;
    }
    setMainHighlightColorPicker(e1) {
        this.#bi = e1;
    }
    editAltText(e1, t = !1) {
        this.#qt?.editAltText(this, e1, t);
    }
    hasCommentManager() {
        return !!this.#Vt;
    }
    editComment(e1, t, i, n) {
        this.#Vt?.showDialog(this, e1, t, i, n);
    }
    selectComment(e1, t) {
        const i = this.#Xt.get(e1), n = i?.getEditorByUID(t);
        n?.toggleComment(!0, !0);
    }
    updateComment(e1) {
        this.#Vt?.updateComment(e1.getData());
    }
    updatePopupColor(e1) {
        this.#Vt?.updatePopupColor(e1);
    }
    removeComment(e1) {
        this.#Vt?.removeComments([
            e1.uid
        ]);
    }
    toggleComment(e1, t, i = void 0) {
        this.#Vt?.toggleCommentPopup(e1, t, i);
    }
    makeCommentColor(e1, t) {
        return e1 && this.#Vt?.makeCommentColor(e1, t) || null;
    }
    getCommentDialogElement() {
        return this.#Vt?.dialogElement || null;
    }
    async waitForEditorsRendered(e1) {
        if (this.#Xt.has(e1 - 1)) return;
        const { resolve: t, promise: i } = Promise.withResolvers(), onEditorsRendered = (i)=>{
            i.pageNumber === e1 && (this._eventBus._off("editorsrendered", onEditorsRendered), t());
        };
        this._eventBus.on("editorsrendered", onEditorsRendered), await i;
    }
    getSignature(e1) {
        this.#vi?.getSignature({
            uiManager: this,
            editor: e1
        });
    }
    get signatureManager() {
        return this.#vi;
    }
    switchToMode(e1, t) {
        this._eventBus.on("annotationeditormodechanged", t, {
            once: !0,
            signal: this._signal
        }), this._eventBus.dispatch("showannotationeditorui", {
            source: this,
            mode: e1
        });
    }
    setPreference(e1, t) {
        this._eventBus.dispatch("setpreference", {
            source: this,
            name: e1,
            value: t
        });
    }
    onSetPreference({ name: e1, value: t }) {
        if ("enableNewAltTextWhenAddingImage" === e1) this.#ai = t;
    }
    onPageChanging({ pageNumber: e1 }) {
        this.#Jt = e1 - 1;
    }
    focusMainContainer() {
        this.#Mi.focus();
    }
    findParent(e1, t) {
        for (const i of this.#Xt.values()){
            const { x: n, y: a, width: s, height: r } = i.div.getBoundingClientRect();
            if (e1 >= n && e1 <= n + s && t >= a && t <= a + r) return i;
        }
        return null;
    }
    disableUserSelect(e1 = !1) {
        this.#Di.classList.toggle("noUserSelect", e1);
    }
    addShouldRescale(e1) {
        this.#ti.add(e1);
    }
    removeShouldRescale(e1) {
        this.#ti.delete(e1);
    }
    onScaleChanging({ scale: e1 }) {
        this.commitOrRemove(), this.viewParameters.realScale = e1 * PixelsPerInch.PDF_TO_CSS_UNITS;
        for (const e1 of this.#ti)e1.onScaleChanging();
        this.#Yt?.onScaleChanging();
    }
    onRotationChanging({ pagesRotation: e1 }) {
        this.commitOrRemove(), this.viewParameters.rotation = e1;
    }
    #Ni({ anchorNode: e1 }) {
        return e1.nodeType === Node.TEXT_NODE ? e1.parentElement : e1;
    }
    #Li(e1) {
        const { currentLayer: t } = this;
        if (t.hasTextLayer(e1)) return t;
        for (const t of this.#Xt.values())if (t.hasTextLayer(e1)) return t;
        return null;
    }
    highlightSelection(e1 = "", t = !1) {
        const i = document.getSelection();
        if (!i || i.isCollapsed) return;
        const { anchorNode: n, anchorOffset: a, focusNode: s, focusOffset: r } = i, o = i.toString(), l = this.#Ni(i).closest(".textLayer"), c = this.getSelectionBoxes(l);
        if (!c) return;
        i.empty();
        const h = this.#Li(l), d = this.#Ai === Hl.NONE, callback = ()=>{
            const i = h?.createAndAddNewEditor({
                x: 0,
                y: 0
            }, !1, {
                methodOfCreation: e1,
                boxes: c,
                anchorNode: n,
                anchorOffset: a,
                focusNode: s,
                focusOffset: r,
                text: o
            });
            d && this.showAllEditors("highlight", !0, !0), t && i?.editComment();
        };
        d ? this.switchToMode(Hl.HIGHLIGHT, callback) : callback();
    }
    commentSelection(e1 = "") {
        this.highlightSelection(e1, !0);
    }
    #Ui() {
        const e1 = document.getSelection();
        if (!e1 || e1.isCollapsed) return;
        const t = this.#Ni(e1).closest(".textLayer"), i = this.getSelectionBoxes(t);
        i && (this.#hi ||= new FloatingToolbar(this), this.#hi.show(t, i, "ltr" === this.direction));
    }
    getAndRemoveDataFromAnnotationStorage(e1) {
        if (!this.#zt) return null;
        const t = `${$l}${e1}`, i = this.#zt.getRawValue(t);
        return i && this.#zt.remove(t), i;
    }
    addToAnnotationStorage(e1) {
        e1.isEmpty() || !this.#zt || this.#zt.has(e1.id) || this.#zt.setValue(e1.id, e1);
    }
    a11yAlert(e1, t = null) {
        const i = this.#Oi;
        i && (i.setAttribute("data-l10n-id", e1), t ? i.setAttribute("data-l10n-args", JSON.stringify(t)) : i.removeAttribute("data-l10n-args"));
    }
    #ji() {
        const e1 = document.getSelection();
        if (!e1 || e1.isCollapsed) return void (this.#Si && (this.#hi?.hide(), this.#Si = null, this.#$i({
            hasSelectedText: !1
        })));
        const { anchorNode: t } = e1;
        if (t === this.#Si) return;
        const i = this.#Ni(e1).closest(".textLayer");
        if (i) {
            if (this.#hi?.hide(), this.#Si = t, this.#$i({
                hasSelectedText: !0
            }), (this.#Ai === Hl.HIGHLIGHT || this.#Ai === Hl.NONE) && (this.#Ai === Hl.HIGHLIGHT && this.showAllEditors("highlight", !0, !0), this.#ci = this.isShiftKeyDown, !this.isShiftKeyDown)) {
                const e1 = this.#Ai === Hl.HIGHLIGHT ? this.#Li(i) : null;
                if (e1?.toggleDrawing(), this.#gi) {
                    const t = new AbortController, i = this.combinedSignal(t), pointerup = (i)=>{
                        "pointerup" === i.type && 0 !== i.button || (t.abort(), e1?.toggleDrawing(!0), "pointerup" === i.type && this.#Hi("main_toolbar"));
                    };
                    window.addEventListener("pointerup", pointerup, {
                        signal: i
                    }), window.addEventListener("blur", pointerup, {
                        signal: i
                    });
                } else e1?.toggleDrawing(!0), this.#Hi("main_toolbar");
            }
        } else this.#Si && (this.#hi?.hide(), this.#Si = null, this.#$i({
            hasSelectedText: !1
        }));
    }
    #Hi(e1 = "") {
        this.#Ai === Hl.HIGHLIGHT ? this.highlightSelection(e1) : this.#ii && this.#Ui();
    }
    #Pi() {
        document.addEventListener("selectionchange", this.#ji.bind(this), {
            signal: this._signal
        });
    }
    #Xi() {
        if (this.#oi) return;
        this.#oi = new AbortController;
        const e1 = this.combinedSignal(this.#oi);
        window.addEventListener("focus", this.focus.bind(this), {
            signal: e1
        }), window.addEventListener("blur", this.blur.bind(this), {
            signal: e1
        });
    }
    #qi() {
        this.#oi?.abort(), this.#oi = null;
    }
    blur() {
        if (this.isShiftKeyDown = !1, this.#ci && (this.#ci = !1, this.#Hi("main_toolbar")), !this.hasSelection) return;
        const { activeElement: e1 } = document;
        for (const t of this.#xi)if (t.div.contains(e1)) {
            this.#mi = [
                t,
                e1
            ], t._focusEventsAllowed = !1;
            break;
        }
    }
    focus() {
        if (!this.#mi) return;
        const [e1, t] = this.#mi;
        this.#mi = null, t.addEventListener("focusin", ()=>{
            e1._focusEventsAllowed = !0;
        }, {
            once: !0,
            signal: this._signal
        }), t.focus();
    }
    #Bi() {
        if (this.#pi) return;
        this.#pi = new AbortController;
        const e1 = this.combinedSignal(this.#pi);
        window.addEventListener("keydown", this.keydown.bind(this), {
            signal: e1
        }), window.addEventListener("keyup", this.keyup.bind(this), {
            signal: e1
        });
    }
    #zi() {
        this.#pi?.abort(), this.#pi = null;
    }
    #Wi() {
        if (this.#Kt) return;
        this.#Kt = new AbortController;
        const e1 = this.combinedSignal(this.#Kt);
        document.addEventListener("copy", this.copy.bind(this), {
            signal: e1
        }), document.addEventListener("cut", this.cut.bind(this), {
            signal: e1
        }), document.addEventListener("paste", this.paste.bind(this), {
            signal: e1
        });
    }
    #Gi() {
        this.#Kt?.abort(), this.#Kt = null;
    }
    #Ri() {
        const e1 = this._signal;
        document.addEventListener("dragover", this.dragOver.bind(this), {
            signal: e1
        }), document.addEventListener("drop", this.drop.bind(this), {
            signal: e1
        });
    }
    addEditListeners() {
        this.#Bi(), this.#Wi();
    }
    removeEditListeners() {
        this.#zi(), this.#Gi();
    }
    dragOver(e1) {
        for (const { type: t } of e1.dataTransfer.items)for (const i of this.#ei)if (i.isHandlingMimeForPasting(t)) return e1.dataTransfer.dropEffect = "copy", void e1.preventDefault();
    }
    drop(e1) {
        for (const t of e1.dataTransfer.items)for (const i of this.#ei)if (i.isHandlingMimeForPasting(t.type)) return i.paste(t, this.currentLayer), void e1.preventDefault();
    }
    copy(e1) {
        if (e1.preventDefault(), this.#jt?.commitOrRemove(), !this.hasSelection) return;
        const t = [];
        for (const e1 of this.#xi){
            const i = e1.serialize(!0);
            i && t.push(i);
        }
        0 !== t.length && e1.clipboardData.setData("application/pdfjs", JSON.stringify(t));
    }
    cut(e1) {
        this.copy(e1), this.delete();
    }
    async paste(e1) {
        e1.preventDefault();
        const { clipboardData: t } = e1;
        for (const e1 of t.items)for (const t of this.#ei)if (t.isHandlingMimeForPasting(e1.type)) return void t.paste(e1, this.currentLayer);
        let i = t.getData("application/pdfjs");
        if (!i) return;
        try {
            i = JSON.parse(i);
        } catch (e1) {
            return void warn(`paste: "${e1.message}".`);
        }
        if (!Array.isArray(i)) return;
        this.unselectAll();
        const n = this.currentLayer;
        try {
            const e1 = [];
            for (const t of i){
                const i = await n.deserialize(t);
                if (!i) return;
                e1.push(i);
            }
            const cmd = ()=>{
                for (const t of e1)this.#Vi(t);
                this.#Ki(e1);
            }, undo = ()=>{
                for (const t of e1)t.remove();
            };
            this.addCommands({
                cmd: cmd,
                undo: undo,
                mustExec: !0
            });
        } catch (e1) {
            warn(`paste: "${e1.message}".`);
        }
    }
    keydown(e1) {
        this.isShiftKeyDown || "Shift" !== e1.key || (this.isShiftKeyDown = !0), this.#Ai === Hl.NONE || this.isEditorHandlingKeyboard || AnnotationEditorUIManager._keyboardManager.exec(this, e1);
    }
    keyup(e1) {
        this.isShiftKeyDown && "Shift" === e1.key && (this.isShiftKeyDown = !1, this.#ci && (this.#ci = !1, this.#Hi("main_toolbar")));
    }
    onEditingAction({ name: e1 }) {
        switch(e1){
            case "undo":
            case "redo":
            case "delete":
            case "selectAll":
                this[e1]();
                break;
            case "highlightSelection":
                this.highlightSelection("context_menu");
                break;
            case "commentSelection":
                this.commentSelection("context_menu");
        }
    }
    #$i(e1) {
        Object.entries(e1).some(([e1, t])=>this.#Fi[e1] !== t) && (this._eventBus.dispatch("annotationeditorstateschanged", {
            source: this,
            details: Object.assign(this.#Fi, e1)
        }), this.#Ai === Hl.HIGHLIGHT && !1 === e1.hasSelectedEditor && this.#Yi([
            [
                Xl.HIGHLIGHT_FREE,
                !0
            ]
        ]));
    }
    #Yi(e1) {
        this._eventBus.dispatch("annotationeditorparamschanged", {
            source: this,
            details: e1
        });
    }
    setEditingState(e1) {
        e1 ? (this.#Xi(), this.#Wi(), this.#$i({
            isEditing: this.#Ai !== Hl.NONE,
            isEmpty: this.#Ji(),
            hasSomethingToUndo: this.#Gt.hasSomethingToUndo(),
            hasSomethingToRedo: this.#Gt.hasSomethingToRedo(),
            hasSelectedEditor: !1
        })) : (this.#qi(), this.#Gi(), this.#$i({
            isEditing: !1
        }), this.disableUserSelect(!1));
    }
    registerEditorTypes(e1) {
        if (!this.#ei) {
            this.#ei = e1;
            for (const e1 of this.#ei)this.#Yi(e1.defaultPropertiesToUpdate);
        }
    }
    getId() {
        return this.#di.id;
    }
    get currentLayer() {
        return this.#Xt.get(this.#Jt);
    }
    getLayer(e1) {
        return this.#Xt.get(e1);
    }
    get currentPageIndex() {
        return this.#Jt;
    }
    addLayer(e1) {
        this.#Xt.set(e1.pageIndex, e1), this.#ui ? e1.enable() : e1.disable();
    }
    removeLayer(e1) {
        this.#Xt.delete(e1.pageIndex);
    }
    async updateMode(e1, t = null, i = !1, n = !1, a = !1) {
        if (this.#Ai !== e1 && (!this.#_i || (await this.#_i.promise, this.#_i))) {
            if (this.#_i = Promise.withResolvers(), this.#Yt?.commitOrRemove(), this.#Ai === Hl.POPUP && this.#Vt?.hideSidebar(), this.#Vt?.destroyPopup(), this.#Ai = e1, e1 === Hl.NONE) {
                this.setEditingState(!1), this.#Zi();
                for (const e1 of this.#Ht.values())e1.hideStandaloneCommentButton();
                return this._editorUndoBar?.hide(), this.toggleComment(null), void this.#_i.resolve();
            }
            for (const e1 of this.#Ht.values())e1.addStandaloneCommentButton();
            e1 === Hl.SIGNATURE && await this.#vi?.loadSignatures(), this.setEditingState(!0), await this.#Qi(), this.unselectAll();
            for (const t of this.#Xt.values())t.updateMode(e1);
            if (e1 === Hl.POPUP) {
                this.#$t ||= await this.#Ti.getAnnotationsByType(new Set(this.#ei.map((e1)=>e1._editorType)));
                const e1 = new Set, t = [];
                for (const i of this.#Ht.values()){
                    const { annotationElementId: n, hasComment: a, deleted: s } = i;
                    n && e1.add(n), a && !s && t.push(i.getData());
                }
                for (const i of this.#$t){
                    const { id: n, popupRef: a, contentsObj: s } = i;
                    a && s?.str && !e1.has(n) && !this.#Zt.has(n) && t.push(i);
                }
                this.#Vt?.showSidebar(t);
            }
            if (!t) return i && this.addNewEditorFromKeyboard(), void this.#_i.resolve();
            for (const e1 of this.#Ht.values())e1.uid === t ? (this.setSelected(e1), a ? e1.editComment() : n ? e1.enterInEditMode() : e1.focus()) : e1.unselect();
            this.#_i.resolve();
        }
    }
    addNewEditorFromKeyboard() {
        this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
    }
    updateToolbar(e1) {
        e1.mode !== this.#Ai && this._eventBus.dispatch("switchannotationeditormode", {
            source: this,
            ...e1
        });
    }
    updateParams(e1, t) {
        if (this.#ei) {
            switch(e1){
                case Xl.CREATE:
                    return void this.currentLayer.addNewEditor(t);
                case Xl.HIGHLIGHT_SHOW_ALL:
                    this._eventBus.dispatch("reporttelemetry", {
                        source: this,
                        details: {
                            type: "editing",
                            data: {
                                type: "highlight",
                                action: "toggle_visibility"
                            }
                        }
                    }), (this.#ki ||= new Map).set(e1, t), this.showAllEditors("highlight", t);
            }
            if (this.hasSelection) for (const i of this.#xi)i.updateParams(e1, t);
            else for (const i of this.#ei)i.updateDefaultParams(e1, t);
        }
    }
    showAllEditors(e1, t, i = !1) {
        for (const i of this.#Ht.values())i.editorType === e1 && i.show(t);
        (this.#ki?.get(Xl.HIGHLIGHT_SHOW_ALL) ?? !0) !== t && this.#Yi([
            [
                Xl.HIGHLIGHT_SHOW_ALL,
                t
            ]
        ]);
    }
    enableWaiting(e1 = !1) {
        if (this.#fi !== e1) {
            this.#fi = e1;
            for (const t of this.#Xt.values())e1 ? t.disableClick() : t.enableClick(), t.div.classList.toggle("waiting", e1);
        }
    }
    async #Qi() {
        if (!this.#ui) {
            this.#ui = !0;
            const e1 = [];
            for (const t of this.#Xt.values())e1.push(t.enable());
            await Promise.all(e1);
            for (const e1 of this.#Ht.values())e1.enable();
        }
    }
    #Zi() {
        if (this.unselectAll(), this.#ui) {
            this.#ui = !1;
            for (const e1 of this.#Xt.values())e1.disable();
            for (const e1 of this.#Ht.values())e1.disable();
        }
    }
    *getEditors(e1) {
        for (const t of this.#Ht.values())t.pageIndex === e1 && (yield t);
    }
    getEditor(e1) {
        return this.#Ht.get(e1);
    }
    addEditor(e1) {
        this.#Ht.set(e1.id, e1);
    }
    removeEditor(e1) {
        e1.div.contains(document.activeElement) && (this.#ri && clearTimeout(this.#ri), this.#ri = setTimeout(()=>{
            this.focusMainContainer(), this.#ri = null;
        }, 0)), this.#Ht.delete(e1.id), e1.annotationElementId && this.#yi?.delete(e1.annotationElementId), this.unselect(e1), e1.annotationElementId && this.#Zt.has(e1.annotationElementId) || this.#zt?.remove(e1.id);
    }
    addDeletedAnnotationElement(e1) {
        this.#Zt.add(e1.annotationElementId), this.addChangedExistingAnnotation(e1), e1.deleted = !0;
    }
    isDeletedAnnotationElement(e1) {
        return this.#Zt.has(e1);
    }
    removeDeletedAnnotationElement(e1) {
        this.#Zt.delete(e1.annotationElementId), this.removeChangedExistingAnnotation(e1), e1.deleted = !1;
    }
    #Vi(e1) {
        const t = this.#Xt.get(e1.pageIndex);
        t ? t.addOrRebuild(e1) : (this.addEditor(e1), this.addToAnnotationStorage(e1));
    }
    setActiveEditor(e1) {
        this.#jt !== e1 && (this.#jt = e1, e1 && this.#Yi(e1.propertiesToUpdate));
    }
    get #en() {
        let e1 = null;
        for (e1 of this.#xi);
        return e1;
    }
    updateUI(e1) {
        this.#en === e1 && this.#Yi(e1.propertiesToUpdate);
    }
    updateUIForDefaultProperties(e1) {
        this.#Yi(e1.defaultPropertiesToUpdate);
    }
    toggleSelected(e1) {
        if (this.#xi.has(e1)) return this.#xi.delete(e1), e1.unselect(), void this.#$i({
            hasSelectedEditor: this.hasSelection
        });
        this.#xi.add(e1), e1.select(), this.#Yi(e1.propertiesToUpdate), this.#$i({
            hasSelectedEditor: !0
        });
    }
    setSelected(e1) {
        this.updateToolbar({
            mode: e1.mode,
            editId: e1.id
        }), this.#Yt?.commitOrRemove();
        for (const t of this.#xi)t !== e1 && t.unselect();
        this.#xi.clear(), this.#xi.add(e1), e1.select(), this.#Yi(e1.propertiesToUpdate), this.#$i({
            hasSelectedEditor: !0
        });
    }
    isSelected(e1) {
        return this.#xi.has(e1);
    }
    get firstSelectedEditor() {
        return this.#xi.values().next().value;
    }
    unselect(e1) {
        e1.unselect(), this.#xi.delete(e1), this.#$i({
            hasSelectedEditor: this.hasSelection
        });
    }
    get hasSelection() {
        return 0 !== this.#xi.size;
    }
    get isEnterHandled() {
        return 1 === this.#xi.size && this.firstSelectedEditor.isEnterHandled;
    }
    undo() {
        this.#Gt.undo(), this.#$i({
            hasSomethingToUndo: this.#Gt.hasSomethingToUndo(),
            hasSomethingToRedo: !0,
            isEmpty: this.#Ji()
        }), this._editorUndoBar?.hide();
    }
    redo() {
        this.#Gt.redo(), this.#$i({
            hasSomethingToUndo: !0,
            hasSomethingToRedo: this.#Gt.hasSomethingToRedo(),
            isEmpty: this.#Ji()
        });
    }
    addCommands(e1) {
        this.#Gt.add(e1), this.#$i({
            hasSomethingToUndo: !0,
            hasSomethingToRedo: !1,
            isEmpty: this.#Ji()
        });
    }
    cleanUndoStack(e1) {
        this.#Gt.cleanType(e1);
    }
    #Ji() {
        if (0 === this.#Ht.size) return !0;
        if (1 === this.#Ht.size) for (const e1 of this.#Ht.values())return e1.isEmpty();
        return !1;
    }
    delete() {
        this.commitOrRemove();
        const e1 = this.currentLayer?.endDrawingSession(!0);
        if (!this.hasSelection && !e1) return;
        const t = e1 ? [
            e1
        ] : [
            ...this.#xi
        ], undo = ()=>{
            for (const e1 of t)this.#Vi(e1);
        };
        this.addCommands({
            cmd: ()=>{
                this._editorUndoBar?.show(undo, 1 === t.length ? t[0].editorType : t.length);
                for (const e1 of t)e1.remove();
            },
            undo: undo,
            mustExec: !0
        });
    }
    commitOrRemove() {
        this.#jt?.commitOrRemove();
    }
    hasSomethingToControl() {
        return this.#jt || this.hasSelection;
    }
    #Ki(e1) {
        for (const e1 of this.#xi)e1.unselect();
        this.#xi.clear();
        for (const t of e1)t.isEmpty() || (this.#xi.add(t), t.select());
        this.#$i({
            hasSelectedEditor: this.hasSelection
        });
    }
    selectAll() {
        for (const e1 of this.#xi)e1.commit();
        this.#Ki(this.#Ht.values());
    }
    unselectAll() {
        if ((!this.#jt || (this.#jt.commitOrRemove(), this.#Ai === Hl.NONE)) && !this.#Yt?.commitOrRemove() && this.hasSelection) {
            for (const e1 of this.#xi)e1.unselect();
            this.#xi.clear(), this.#$i({
                hasSelectedEditor: !1
            });
        }
    }
    translateSelectedEditors(e1, t, i = !1) {
        if (i || this.commitOrRemove(), !this.hasSelection) return;
        this.#Ii[0] += e1, this.#Ii[1] += t;
        const [n, a] = this.#Ii, s = [
            ...this.#xi
        ];
        this.#Ei && clearTimeout(this.#Ei), this.#Ei = setTimeout(()=>{
            this.#Ei = null, this.#Ii[0] = this.#Ii[1] = 0, this.addCommands({
                cmd: ()=>{
                    for (const e1 of s)this.#Ht.has(e1.id) && (e1.translateInPage(n, a), e1.translationDone());
                },
                undo: ()=>{
                    for (const e1 of s)this.#Ht.has(e1.id) && (e1.translateInPage(-n, -a), e1.translationDone());
                },
                mustExec: !1
            });
        }, 1e3);
        for (const i of s)i.translateInPage(e1, t), i.translationDone();
    }
    setUpDragSession() {
        if (this.hasSelection) {
            this.disableUserSelect(!0), this.#Qt = new Map;
            for (const e1 of this.#xi)this.#Qt.set(e1, {
                savedX: e1.x,
                savedY: e1.y,
                savedPageIndex: e1.pageIndex,
                newX: 0,
                newY: 0,
                newPageIndex: -1
            });
        }
    }
    endDragSession() {
        if (!this.#Qt) return !1;
        this.disableUserSelect(!1);
        const e1 = this.#Qt;
        this.#Qt = null;
        let t = !1;
        for (const [{ x: i, y: n, pageIndex: a }, s] of e1)s.newX = i, s.newY = n, s.newPageIndex = a, t ||= i !== s.savedX || n !== s.savedY || a !== s.savedPageIndex;
        if (!t) return !1;
        const move = (e1, t, i, n)=>{
            if (this.#Ht.has(e1.id)) {
                const a = this.#Xt.get(n);
                a ? e1._setParentAndPosition(a, t, i) : (e1.pageIndex = n, e1.x = t, e1.y = i);
            }
        };
        return this.addCommands({
            cmd: ()=>{
                for (const [t, { newX: i, newY: n, newPageIndex: a }] of e1)move(t, i, n, a);
            },
            undo: ()=>{
                for (const [t, { savedX: i, savedY: n, savedPageIndex: a }] of e1)move(t, i, n, a);
            },
            mustExec: !0
        }), !0;
    }
    dragSelectedEditors(e1, t) {
        if (this.#Qt) for (const i of this.#Qt.keys())i.drag(e1, t);
    }
    rebuild(e1) {
        if (null === e1.parent) {
            const t = this.getLayer(e1.pageIndex);
            t ? (t.changeParent(e1), t.addOrRebuild(e1)) : (this.addEditor(e1), this.addToAnnotationStorage(e1), e1.rebuild());
        } else e1.parent.addOrRebuild(e1);
    }
    get isEditorHandlingKeyboard() {
        return this.getActive()?.shouldGetKeyboardEvents() || 1 === this.#xi.size && this.firstSelectedEditor.shouldGetKeyboardEvents();
    }
    isActive(e1) {
        return this.#jt === e1;
    }
    getActive() {
        return this.#jt;
    }
    getMode() {
        return this.#Ai;
    }
    isEditingMode() {
        return this.#Ai !== Hl.NONE;
    }
    get imageManager() {
        return shadow(this, "imageManager", new ImageManager);
    }
    getSelectionBoxes(e1) {
        if (!e1) return null;
        const t = document.getSelection();
        for(let i = 0, n = t.rangeCount; i < n; i++)if (!e1.contains(t.getRangeAt(i).commonAncestorContainer)) return null;
        const { x: i, y: n, width: a, height: s } = e1.getBoundingClientRect();
        let r;
        switch(e1.getAttribute("data-main-rotation")){
            case "90":
                r = (e1, t, r, o)=>({
                        x: (t - n) / s,
                        y: 1 - (e1 + r - i) / a,
                        width: o / s,
                        height: r / a
                    });
                break;
            case "180":
                r = (e1, t, r, o)=>({
                        x: 1 - (e1 + r - i) / a,
                        y: 1 - (t + o - n) / s,
                        width: r / a,
                        height: o / s
                    });
                break;
            case "270":
                r = (e1, t, r, o)=>({
                        x: 1 - (t + o - n) / s,
                        y: (e1 - i) / a,
                        width: o / s,
                        height: r / a
                    });
                break;
            default:
                r = (e1, t, r, o)=>({
                        x: (e1 - i) / a,
                        y: (t - n) / s,
                        width: r / a,
                        height: o / s
                    });
        }
        const o = [];
        for(let e1 = 0, i = t.rangeCount; e1 < i; e1++){
            const i = t.getRangeAt(e1);
            if (!i.collapsed) for (const { x: e1, y: t, width: n, height: a } of i.getClientRects())0 !== n && 0 !== a && o.push(r(e1, t, n, a));
        }
        return 0 === o.length ? null : o;
    }
    addChangedExistingAnnotation({ annotationElementId: e1, id: t }) {
        (this.#Wt ||= new Map).set(e1, t);
    }
    removeChangedExistingAnnotation({ annotationElementId: e1 }) {
        this.#Wt?.delete(e1);
    }
    renderAnnotationElement(e1) {
        const t = this.#Wt?.get(e1.data.id);
        if (!t) return;
        const i = this.#zt.getRawValue(t);
        i && (this.#Ai !== Hl.NONE || i.hasBeenModified) && i.renderAnnotationElement(e1);
    }
    setMissingCanvas(e1, t, i) {
        const n = this.#yi?.get(e1);
        n && (n.setCanvas(t, i), this.#yi.delete(e1));
    }
    addMissingCanvas(e1, t) {
        (this.#yi ||= new Map).set(e1, t);
    }
}
class AltText {
    #mt = null;
    #tn = !1;
    #in = null;
    #nn = null;
    #an = null;
    #sn = null;
    #rn = !1;
    #on = null;
    #ft = null;
    #ln = null;
    #cn = null;
    #hn = !1;
    static #dn = null;
    static _l10n = null;
    constructor(e1){
        this.#ft = e1, this.#hn = e1._uiManager.useNewAltTextFlow, AltText.#dn ||= Object.freeze({
            added: "pdfjs-editor-new-alt-text-added-button",
            "added-label": "pdfjs-editor-new-alt-text-added-button-label",
            missing: "pdfjs-editor-new-alt-text-missing-button",
            "missing-label": "pdfjs-editor-new-alt-text-missing-button-label",
            review: "pdfjs-editor-new-alt-text-to-review-button",
            "review-label": "pdfjs-editor-new-alt-text-to-review-button-label"
        });
    }
    static initialize(e1) {
        AltText._l10n ??= e1;
    }
    async render() {
        const e1 = this.#in = document.createElement("button");
        e1.className = "altText", e1.tabIndex = "0";
        const t = this.#nn = document.createElement("span");
        e1.append(t), this.#hn ? (e1.classList.add("new"), e1.setAttribute("data-l10n-id", AltText.#dn.missing), t.setAttribute("data-l10n-id", AltText.#dn["missing-label"])) : (e1.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button"), t.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label"));
        const i = this.#ft._uiManager._signal;
        e1.addEventListener("contextmenu", noContextMenu, {
            signal: i
        }), e1.addEventListener("pointerdown", (e1)=>e1.stopPropagation(), {
            signal: i
        });
        const onClick = (e1)=>{
            e1.preventDefault(), this.#ft._uiManager.editAltText(this.#ft), this.#hn && this.#ft._reportTelemetry({
                action: "pdfjs.image.alt_text.image_status_label_clicked",
                data: {
                    label: this.#un
                }
            });
        };
        return e1.addEventListener("click", onClick, {
            capture: !0,
            signal: i
        }), e1.addEventListener("keydown", (t)=>{
            t.target === e1 && "Enter" === t.key && (this.#rn = !0, onClick(t));
        }, {
            signal: i
        }), await this.#gn(), e1;
    }
    get #un() {
        return (this.#mt ? "added" : null === this.#mt && this.guessedText && "review") || "missing";
    }
    finish() {
        this.#in && (this.#in.focus({
            focusVisible: this.#rn
        }), this.#rn = !1);
    }
    isEmpty() {
        return this.#hn ? null === this.#mt : !this.#mt && !this.#tn;
    }
    hasData() {
        return this.#hn ? null !== this.#mt || !!this.#ln : this.isEmpty();
    }
    get guessedText() {
        return this.#ln;
    }
    async setGuessedText(e1) {
        null === this.#mt && (this.#ln = e1, this.#cn = await AltText._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", {
            generatedAltText: e1
        }), this.#gn());
    }
    toggleAltTextBadge(e1 = !1) {
        if (!this.#hn || this.#mt) return this.#on?.remove(), void (this.#on = null);
        if (!this.#on) {
            const e1 = this.#on = document.createElement("div");
            e1.className = "noAltTextBadge", this.#ft.div.append(e1);
        }
        this.#on.classList.toggle("hidden", !e1);
    }
    serialize(e1) {
        let t = this.#mt;
        return e1 || this.#ln !== t || (t = this.#cn), {
            altText: t,
            decorative: this.#tn,
            guessedText: this.#ln,
            textWithDisclaimer: this.#cn
        };
    }
    get data() {
        return {
            altText: this.#mt,
            decorative: this.#tn
        };
    }
    set data({ altText: e1, decorative: t, guessedText: i, textWithDisclaimer: n, cancel: a = !1 }) {
        i && (this.#ln = i, this.#cn = n), this.#mt === e1 && this.#tn === t || (a || (this.#mt = e1, this.#tn = t), this.#gn());
    }
    toggle(e1 = !1) {
        this.#in && (!e1 && this.#sn && (clearTimeout(this.#sn), this.#sn = null), this.#in.disabled = !e1);
    }
    shown() {
        this.#ft._reportTelemetry({
            action: "pdfjs.image.alt_text.image_status_label_displayed",
            data: {
                label: this.#un
            }
        });
    }
    destroy() {
        this.#in?.remove(), this.#in = null, this.#nn = null, this.#an = null, this.#on?.remove(), this.#on = null;
    }
    async #gn() {
        const e1 = this.#in;
        if (!e1) return;
        if (this.#hn) {
            if (e1.classList.toggle("done", !!this.#mt), e1.setAttribute("data-l10n-id", AltText.#dn[this.#un]), this.#nn?.setAttribute("data-l10n-id", AltText.#dn[`${this.#un}-label`]), !this.#mt) return void this.#an?.remove();
        } else {
            if (!this.#mt && !this.#tn) return e1.classList.remove("done"), void this.#an?.remove();
            e1.classList.add("done"), e1.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
        }
        let t = this.#an;
        if (!t) {
            this.#an = t = document.createElement("span"), t.className = "tooltip", t.setAttribute("role", "tooltip"), t.id = `alt-text-tooltip-${this.#ft.id}`;
            const i = 100, n = this.#ft._uiManager._signal;
            n.addEventListener("abort", ()=>{
                clearTimeout(this.#sn), this.#sn = null;
            }, {
                once: !0
            }), e1.addEventListener("mouseenter", ()=>{
                this.#sn = setTimeout(()=>{
                    this.#sn = null, this.#an.classList.add("show"), this.#ft._reportTelemetry({
                        action: "alt_text_tooltip"
                    });
                }, i);
            }, {
                signal: n
            }), e1.addEventListener("mouseleave", ()=>{
                this.#sn && (clearTimeout(this.#sn), this.#sn = null), this.#an?.classList.remove("show");
            }, {
                signal: n
            });
        }
        this.#tn ? t.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip") : (t.removeAttribute("data-l10n-id"), t.textContent = this.#mt), t.parentNode || e1.append(t);
        const i = this.#ft.getElementForAltText();
        i?.setAttribute("aria-describedby", t.id);
    }
}
class Comment {
    #fn = null;
    #pn = null;
    #mn = !1;
    #ft = null;
    #bn = null;
    #yn = null;
    #_e = null;
    #wn = null;
    #An = !1;
    #xn = null;
    constructor(e1){
        this.#ft = e1;
    }
    renderForToolbar() {
        const e1 = this.#pn = document.createElement("button");
        return e1.className = "comment", this.#Ft(e1, !1);
    }
    renderForStandalone() {
        const e1 = this.#fn = document.createElement("button");
        e1.className = "annotationCommentButton";
        const t = this.#ft.commentButtonPosition;
        if (t) {
            const { style: i } = e1;
            i.insetInlineEnd = `calc(${100 * ("ltr" === this.#ft._uiManager.direction ? 1 - t[0] : t[0])}% - var(--comment-button-dim))`, i.top = `calc(${100 * t[1]}% - var(--comment-button-dim))`;
            const n = this.#ft.commentButtonColor;
            n && (i.backgroundColor = n);
        }
        return this.#Ft(e1, !0);
    }
    focusButton() {
        setTimeout(()=>{
            (this.#fn ?? this.#pn)?.focus();
        }, 0);
    }
    onUpdatedColor() {
        if (!this.#fn) return;
        const e1 = this.#ft.commentButtonColor;
        e1 && (this.#fn.style.backgroundColor = e1), this.#ft._uiManager.updatePopupColor(this.#ft);
    }
    get commentButtonWidth() {
        return (this.#fn?.getBoundingClientRect().width ?? 0) / this.#ft.parent.boundingClientRect.width;
    }
    get commentPopupPositionInLayer() {
        if (this.#xn) return this.#xn;
        if (!this.#fn) return null;
        const { x: e1, y: t, height: i } = this.#fn.getBoundingClientRect(), { x: n, y: a, width: s, height: r } = this.#ft.parent.boundingClientRect;
        return [
            (e1 - n) / s,
            (t + i - a) / r
        ];
    }
    set commentPopupPositionInLayer(e1) {
        this.#xn = e1;
    }
    hasDefaultPopupPosition() {
        return null === this.#xn;
    }
    removeStandaloneCommentButton() {
        this.#fn?.remove(), this.#fn = null;
    }
    removeToolbarCommentButton() {
        this.#pn?.remove(), this.#pn = null;
    }
    setCommentButtonStates({ selected: e1, hasPopup: t }) {
        this.#fn && (this.#fn.classList.toggle("selected", e1), this.#fn.ariaExpanded = t);
    }
    #Ft(e1, t) {
        if (!this.#ft._uiManager.hasCommentManager()) return null;
        e1.tabIndex = "0", e1.ariaHasPopup = "dialog", t ? (e1.ariaControls = "commentPopup", e1.setAttribute("data-l10n-id", "pdfjs-show-comment-button")) : (e1.ariaControlsElements = [
            this.#ft._uiManager.getCommentDialogElement()
        ], e1.setAttribute("data-l10n-id", "pdfjs-editor-edit-comment-button"));
        const i = this.#ft._uiManager._signal;
        if (!(i instanceof AbortSignal) || i.aborted) return e1;
        e1.addEventListener("contextmenu", noContextMenu, {
            signal: i
        }), t && (e1.addEventListener("focusin", (e1)=>{
            this.#ft._focusEventsAllowed = !1, stopEvent(e1);
        }, {
            capture: !0,
            signal: i
        }), e1.addEventListener("focusout", (e1)=>{
            this.#ft._focusEventsAllowed = !0, stopEvent(e1);
        }, {
            capture: !0,
            signal: i
        })), e1.addEventListener("pointerdown", (e1)=>e1.stopPropagation(), {
            signal: i
        });
        const onClick = (t)=>{
            t.preventDefault(), e1 === this.#pn ? this.edit() : this.#ft.toggleComment(!0);
        };
        return e1.addEventListener("click", onClick, {
            capture: !0,
            signal: i
        }), e1.addEventListener("keydown", (t)=>{
            t.target === e1 && "Enter" === t.key && (this.#mn = !0, onClick(t));
        }, {
            signal: i
        }), e1.addEventListener("pointerenter", ()=>{
            this.#ft.toggleComment(!1, !0);
        }, {
            signal: i
        }), e1.addEventListener("pointerleave", ()=>{
            this.#ft.toggleComment(!1, !1);
        }, {
            signal: i
        }), e1;
    }
    edit(e1) {
        const t = this.commentPopupPositionInLayer;
        let i, n;
        if (t) [i, n] = t;
        else {
            [i, n] = this.#ft.commentButtonPosition;
            const { width: e1, height: t, x: a, y: s } = this.#ft;
            i = a + i * e1, n = s + n * t;
        }
        const a = this.#ft.parent.boundingClientRect, { x: s, y: r, width: o, height: l } = a;
        this.#ft._uiManager.editComment(this.#ft, s + i * o, r + n * l, {
            ...e1,
            parentDimensions: a
        });
    }
    finish() {
        this.#pn && (this.#pn.focus({
            focusVisible: this.#mn
        }), this.#mn = !1);
    }
    isDeleted() {
        return this.#An || "" === this.#_e;
    }
    isEmpty() {
        return null === this.#_e;
    }
    hasBeenEdited() {
        return this.isDeleted() || this.#_e !== this.#bn;
    }
    serialize() {
        return this.data;
    }
    get data() {
        return {
            text: this.#_e,
            richText: this.#yn,
            date: this.#wn,
            deleted: this.isDeleted()
        };
    }
    set data(e1) {
        if (e1 !== this.#_e && (this.#yn = null), null === e1) return this.#_e = "", void (this.#An = !0);
        this.#_e = e1, this.#wn = new Date, this.#An = !1;
    }
    setInitialText(e1, t = null) {
        this.#bn = e1, this.data = e1, this.#wn = null, this.#yn = t;
    }
    shown() {}
    destroy() {
        this.#pn?.remove(), this.#pn = null, this.#fn?.remove(), this.#fn = null, this.#_e = "", this.#yn = null, this.#wn = null, this.#ft = null, this.#mn = !1, this.#An = !1;
    }
}
class TouchManager {
    #Mi;
    #Sn = !1;
    #vn = null;
    #Cn;
    #kn;
    #Tn;
    #Fn;
    #In = null;
    #En;
    #Mn = null;
    #Dn;
    #On = null;
    constructor({ container: e1, isPinchingDisabled: t = null, isPinchingStopped: i = null, onPinchStart: n = null, onPinching: a = null, onPinchEnd: s = null, signal: r }){
        this.#Mi = e1, this.#vn = i, this.#Cn = t, this.#kn = n, this.#Tn = a, this.#Fn = s, this.#Dn = new AbortController, this.#En = AbortSignal.any([
            r,
            this.#Dn.signal
        ]), e1.addEventListener("touchstart", this.#_n.bind(this), {
            passive: !1,
            signal: this.#En
        });
    }
    get MIN_TOUCH_DISTANCE_TO_PINCH() {
        return 35 / OutputScale.pixelRatio;
    }
    #_n(e1) {
        if (this.#Cn?.()) return;
        if (1 === e1.touches.length) {
            if (this.#In) return;
            const e1 = this.#In = new AbortController, t = AbortSignal.any([
                this.#En,
                e1.signal
            ]), i = this.#Mi, n = {
                capture: !0,
                signal: t,
                passive: !1
            }, cancelPointerDown = (e1)=>{
                "touch" === e1.pointerType && (this.#In?.abort(), this.#In = null);
            };
            return i.addEventListener("pointerdown", (e1)=>{
                "touch" === e1.pointerType && (stopEvent(e1), cancelPointerDown(e1));
            }, n), i.addEventListener("pointerup", cancelPointerDown, n), void i.addEventListener("pointercancel", cancelPointerDown, n);
        }
        if (!this.#On) {
            this.#On = new AbortController;
            const e1 = AbortSignal.any([
                this.#En,
                this.#On.signal
            ]), t = this.#Mi, i = {
                signal: e1,
                capture: !1,
                passive: !1
            };
            t.addEventListener("touchmove", this.#Pn.bind(this), i);
            const n = this.#Rn.bind(this);
            t.addEventListener("touchend", n, i), t.addEventListener("touchcancel", n, i), i.capture = !0, t.addEventListener("pointerdown", stopEvent, i), t.addEventListener("pointermove", stopEvent, i), t.addEventListener("pointercancel", stopEvent, i), t.addEventListener("pointerup", stopEvent, i), this.#kn?.();
        }
        if (stopEvent(e1), 2 !== e1.touches.length || this.#vn?.()) return void (this.#Mn = null);
        let [t, i] = e1.touches;
        t.identifier > i.identifier && ([t, i] = [
            i,
            t
        ]), this.#Mn = {
            touch0X: t.screenX,
            touch0Y: t.screenY,
            touch1X: i.screenX,
            touch1Y: i.screenY
        };
    }
    #Pn(e1) {
        if (!this.#Mn || 2 !== e1.touches.length) return;
        stopEvent(e1);
        let [t, i] = e1.touches;
        t.identifier > i.identifier && ([t, i] = [
            i,
            t
        ]);
        const { screenX: n, screenY: a } = t, { screenX: s, screenY: r } = i, o = this.#Mn, { touch0X: l, touch0Y: c, touch1X: h, touch1Y: d } = o, u = h - l, g = d - c, f = s - n, p = r - a, m = Math.hypot(f, p) || 1, b = Math.hypot(u, g) || 1;
        if (!this.#Sn && Math.abs(b - m) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) return;
        if (o.touch0X = n, o.touch0Y = a, o.touch1X = s, o.touch1Y = r, !this.#Sn) return void (this.#Sn = !0);
        const y = [
            (n + s) / 2,
            (a + r) / 2
        ];
        this.#Tn?.(y, b, m);
    }
    #Rn(e1) {
        e1.touches.length >= 2 || (this.#On && (this.#On.abort(), this.#On = null, this.#Fn?.()), this.#Mn && (stopEvent(e1), this.#Mn = null, this.#Sn = !1));
    }
    destroy() {
        this.#Dn?.abort(), this.#Dn = null, this.#In?.abort(), this.#In = null;
    }
}
class AnnotationEditor {
    #Bn = null;
    #Nn = null;
    #mt = null;
    #bt = null;
    #fn = null;
    #Ln = !1;
    #Un = null;
    #jn = "";
    #$n = null;
    #Hn = null;
    #Xn = null;
    #qn = null;
    #zn = null;
    #Wn = "";
    #Gn = !1;
    #Vn = null;
    #Kn = !1;
    #Yn = !1;
    #Jn = !1;
    #Zn = null;
    #Qn = 0;
    #ea = 0;
    #ta = null;
    #ia = null;
    isSelected = !1;
    _isCopy = !1;
    _editToolbar = null;
    _initialOptions = Object.create(null);
    _initialData = null;
    _isVisible = !0;
    _uiManager = null;
    _focusEventsAllowed = !0;
    static _l10n = null;
    static _l10nResizer = null;
    #na = !1;
    #aa = AnnotationEditor._zIndex++;
    static _borderLineWidth = -1;
    static _colorManager = new ColorManager;
    static _zIndex = 1;
    static _telemetryTimeout = 1e3;
    static get _resizerKeyboardManager() {
        const e1 = AnnotationEditor.prototype._resizeWithKeyboard, t = AnnotationEditorUIManager.TRANSLATE_SMALL, i = AnnotationEditorUIManager.TRANSLATE_BIG;
        return shadow(this, "_resizerKeyboardManager", new KeyboardManager([
            [
                [
                    "ArrowLeft",
                    "mac+ArrowLeft"
                ],
                e1,
                {
                    args: [
                        -t,
                        0
                    ]
                }
            ],
            [
                [
                    "ctrl+ArrowLeft",
                    "mac+shift+ArrowLeft"
                ],
                e1,
                {
                    args: [
                        -i,
                        0
                    ]
                }
            ],
            [
                [
                    "ArrowRight",
                    "mac+ArrowRight"
                ],
                e1,
                {
                    args: [
                        t,
                        0
                    ]
                }
            ],
            [
                [
                    "ctrl+ArrowRight",
                    "mac+shift+ArrowRight"
                ],
                e1,
                {
                    args: [
                        i,
                        0
                    ]
                }
            ],
            [
                [
                    "ArrowUp",
                    "mac+ArrowUp"
                ],
                e1,
                {
                    args: [
                        0,
                        -t
                    ]
                }
            ],
            [
                [
                    "ctrl+ArrowUp",
                    "mac+shift+ArrowUp"
                ],
                e1,
                {
                    args: [
                        0,
                        -i
                    ]
                }
            ],
            [
                [
                    "ArrowDown",
                    "mac+ArrowDown"
                ],
                e1,
                {
                    args: [
                        0,
                        t
                    ]
                }
            ],
            [
                [
                    "ctrl+ArrowDown",
                    "mac+shift+ArrowDown"
                ],
                e1,
                {
                    args: [
                        0,
                        i
                    ]
                }
            ],
            [
                [
                    "Escape",
                    "mac+Escape"
                ],
                AnnotationEditor.prototype._stopResizingWithKeyboard
            ]
        ]));
    }
    constructor(e1){
        this.parent = e1.parent, this.id = e1.id, this.width = this.height = null, this.pageIndex = e1.parent.pageIndex, this.name = e1.name, this.div = null, this._uiManager = e1.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = e1.isCentered, this._structTreeParentId = null, this.annotationElementId = e1.annotationElementId || null, this.creationDate = e1.creationDate || new Date, this.modificationDate = e1.modificationDate || null;
        const { rotation: t, rawDims: { pageWidth: i, pageHeight: n, pageX: a, pageY: s } } = this.parent.viewport;
        this.rotation = t, this.pageRotation = (360 + t - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [
            i,
            n
        ], this.pageTranslation = [
            a,
            s
        ];
        const [r, o] = this.parentDimensions;
        this.x = e1.x / r, this.y = e1.y / o, this.isAttachedToDOM = !1, this.deleted = !1;
    }
    get editorType() {
        return Object.getPrototypeOf(this).constructor._type;
    }
    get mode() {
        return Object.getPrototypeOf(this).constructor._editorType;
    }
    static get isDrawer() {
        return !1;
    }
    static get _defaultLineColor() {
        return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
    }
    static deleteAnnotationElement(e1) {
        const t = new FakeEditor({
            id: e1.parent.getNextId(),
            parent: e1.parent,
            uiManager: e1._uiManager
        });
        t.annotationElementId = e1.annotationElementId, t.deleted = !0, t._uiManager.addToAnnotationStorage(t);
    }
    static initialize(e1, t) {
        if (AnnotationEditor._l10n ??= e1, AnnotationEditor._l10nResizer ||= Object.freeze({
            topLeft: "pdfjs-editor-resizer-top-left",
            topMiddle: "pdfjs-editor-resizer-top-middle",
            topRight: "pdfjs-editor-resizer-top-right",
            middleRight: "pdfjs-editor-resizer-middle-right",
            bottomRight: "pdfjs-editor-resizer-bottom-right",
            bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
            bottomLeft: "pdfjs-editor-resizer-bottom-left",
            middleLeft: "pdfjs-editor-resizer-middle-left"
        }), -1 !== AnnotationEditor._borderLineWidth) return;
        const i = getComputedStyle(document.documentElement);
        AnnotationEditor._borderLineWidth = parseFloat(i.getPropertyValue("--outline-width")) || 0;
    }
    static updateDefaultParams(e1, t) {}
    static get defaultPropertiesToUpdate() {
        return [];
    }
    static isHandlingMimeForPasting(e1) {
        return !1;
    }
    static paste(e1, t) {
        unreachable("Not implemented");
    }
    get propertiesToUpdate() {
        return [];
    }
    get _isDraggable() {
        return this.#na;
    }
    set _isDraggable(e1) {
        this.#na = e1, this.div?.classList.toggle("draggable", e1);
    }
    get uid() {
        return this.annotationElementId || this.id;
    }
    get isEnterHandled() {
        return !0;
    }
    center() {
        const [e1, t] = this.pageDimensions;
        switch(this.parentRotation){
            case 90:
                this.x -= this.height * t / (2 * e1), this.y += this.width * e1 / (2 * t);
                break;
            case 180:
                this.x += this.width / 2, this.y += this.height / 2;
                break;
            case 270:
                this.x += this.height * t / (2 * e1), this.y -= this.width * e1 / (2 * t);
                break;
            default:
                this.x -= this.width / 2, this.y -= this.height / 2;
        }
        this.fixAndSetPosition();
    }
    addCommands(e1) {
        this._uiManager.addCommands(e1);
    }
    get currentLayer() {
        return this._uiManager.currentLayer;
    }
    setInBackground() {
        this.div.style.zIndex = 0;
    }
    setInForeground() {
        this.div.style.zIndex = this.#aa;
    }
    setParent(e1) {
        null !== e1 ? (this.pageIndex = e1.pageIndex, this.pageDimensions = e1.pageDimensions) : (this.#sa(), this.#qn?.remove(), this.#qn = null), this.parent = e1;
    }
    focusin(e1) {
        this._focusEventsAllowed && (this.#Gn ? this.#Gn = !1 : this.parent.setSelected(this));
    }
    focusout(e1) {
        if (!this._focusEventsAllowed) return;
        if (!this.isAttachedToDOM) return;
        const t = e1.relatedTarget;
        t?.closest(`#${this.id}`) || (e1.preventDefault(), this.parent?.isMultipleSelection || this.commitOrRemove());
    }
    commitOrRemove() {
        this.isEmpty() ? this.remove() : this.commit();
    }
    commit() {
        this.isInEditMode() && this.addToAnnotationStorage();
    }
    addToAnnotationStorage() {
        this._uiManager.addToAnnotationStorage(this);
    }
    setAt(e1, t, i, n) {
        const [a, s] = this.parentDimensions;
        [i, n] = this.screenToPageTranslation(i, n), this.x = (e1 + i) / a, this.y = (t + n) / s, this.fixAndSetPosition();
    }
    _moveAfterPaste(e1, t) {
        const [i, n] = this.parentDimensions;
        this.setAt(e1 * i, t * n, this.width * i, this.height * n), this._onTranslated();
    }
    #ra([e1, t], i, n) {
        [i, n] = this.screenToPageTranslation(i, n), this.x += i / e1, this.y += n / t, this._onTranslating(this.x, this.y), this.fixAndSetPosition();
    }
    translate(e1, t) {
        this.#ra(this.parentDimensions, e1, t);
    }
    translateInPage(e1, t) {
        this.#Vn ||= [
            this.x,
            this.y,
            this.width,
            this.height
        ], this.#ra(this.pageDimensions, e1, t), this.div.scrollIntoView({
            block: "nearest"
        });
    }
    translationDone() {
        this._onTranslated(this.x, this.y);
    }
    drag(e1, t) {
        this.#Vn ||= [
            this.x,
            this.y,
            this.width,
            this.height
        ];
        const { div: i, parentDimensions: [n, a] } = this;
        if (this.x += e1 / n, this.y += t / a, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
            const { x: e1, y: t } = this.div.getBoundingClientRect();
            this.parent.findNewParent(this, e1, t) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
        }
        let { x: s, y: r } = this;
        const [o, l] = this.getBaseTranslation();
        s += o, r += l;
        const { style: c } = i;
        c.left = `${(100 * s).toFixed(2)}%`, c.top = `${(100 * r).toFixed(2)}%`, this._onTranslating(s, r), i.scrollIntoView({
            block: "nearest"
        });
    }
    _onTranslating(e1, t) {}
    _onTranslated(e1, t) {}
    get _hasBeenMoved() {
        return !!this.#Vn && (this.#Vn[0] !== this.x || this.#Vn[1] !== this.y);
    }
    get _hasBeenResized() {
        return !!this.#Vn && (this.#Vn[2] !== this.width || this.#Vn[3] !== this.height);
    }
    getBaseTranslation() {
        const [e1, t] = this.parentDimensions, { _borderLineWidth: i } = AnnotationEditor, n = i / e1, a = i / t;
        switch(this.rotation){
            case 90:
                return [
                    -n,
                    a
                ];
            case 180:
                return [
                    n,
                    a
                ];
            case 270:
                return [
                    n,
                    -a
                ];
            default:
                return [
                    -n,
                    -a
                ];
        }
    }
    get _mustFixPosition() {
        return !0;
    }
    fixAndSetPosition(e1 = this.rotation) {
        const { div: { style: t }, pageDimensions: [i, n] } = this;
        let { x: a, y: s, width: r, height: o } = this;
        if (r *= i, o *= n, a *= i, s *= n, this._mustFixPosition) switch(e1){
            case 0:
                a = MathClamp(a, 0, i - r), s = MathClamp(s, 0, n - o);
                break;
            case 90:
                a = MathClamp(a, 0, i - o), s = MathClamp(s, r, n);
                break;
            case 180:
                a = MathClamp(a, r, i), s = MathClamp(s, o, n);
                break;
            case 270:
                a = MathClamp(a, o, i), s = MathClamp(s, 0, n - r);
        }
        this.x = a /= i, this.y = s /= n;
        const [l, c] = this.getBaseTranslation();
        a += l, s += c, t.left = `${(100 * a).toFixed(2)}%`, t.top = `${(100 * s).toFixed(2)}%`, this.moveInDOM();
    }
    static #oa(e1, t, i) {
        switch(i){
            case 90:
                return [
                    t,
                    -e1
                ];
            case 180:
                return [
                    -e1,
                    -t
                ];
            case 270:
                return [
                    -t,
                    e1
                ];
            default:
                return [
                    e1,
                    t
                ];
        }
    }
    screenToPageTranslation(e1, t) {
        return AnnotationEditor.#oa(e1, t, this.parentRotation);
    }
    pageTranslationToScreen(e1, t) {
        return AnnotationEditor.#oa(e1, t, 360 - this.parentRotation);
    }
    #la(e1) {
        switch(e1){
            case 90:
                {
                    const [e1, t] = this.pageDimensions;
                    return [
                        0,
                        -e1 / t,
                        t / e1,
                        0
                    ];
                }
            case 180:
                return [
                    -1,
                    0,
                    0,
                    -1
                ];
            case 270:
                {
                    const [e1, t] = this.pageDimensions;
                    return [
                        0,
                        e1 / t,
                        -t / e1,
                        0
                    ];
                }
            default:
                return [
                    1,
                    0,
                    0,
                    1
                ];
        }
    }
    get parentScale() {
        return this._uiManager.viewParameters.realScale;
    }
    get parentRotation() {
        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
    }
    get parentDimensions() {
        const { parentScale: e1, pageDimensions: [t, i] } = this;
        return [
            t * e1,
            i * e1
        ];
    }
    setDims() {
        const { div: { style: e1 }, width: t, height: i } = this;
        e1.width = `${(100 * t).toFixed(2)}%`, e1.height = `${(100 * i).toFixed(2)}%`;
    }
    getInitialTranslation() {
        return [
            0,
            0
        ];
    }
    #ca() {
        if (this.#$n) return;
        this.#$n = document.createElement("div"), this.#$n.classList.add("resizers");
        const e1 = this._willKeepAspectRatio ? [
            "topLeft",
            "topRight",
            "bottomRight",
            "bottomLeft"
        ] : [
            "topLeft",
            "topMiddle",
            "topRight",
            "middleRight",
            "bottomRight",
            "bottomMiddle",
            "bottomLeft",
            "middleLeft"
        ], t = this._uiManager._signal;
        for (const i of e1){
            const e1 = document.createElement("div");
            this.#$n.append(e1), e1.classList.add("resizer", i), e1.setAttribute("data-resizer-name", i), e1.addEventListener("pointerdown", this.#ha.bind(this, i), {
                signal: t
            }), e1.addEventListener("contextmenu", noContextMenu, {
                signal: t
            }), e1.tabIndex = -1;
        }
        this.div.prepend(this.#$n);
    }
    #ha(e1, t) {
        t.preventDefault();
        const { isMac: i } = util_FeatureTest.platform;
        if (0 !== t.button || t.ctrlKey && i) return;
        this.#mt?.toggle(!1);
        const n = this._isDraggable;
        this._isDraggable = !1, this.#Hn = [
            t.screenX,
            t.screenY
        ];
        const a = new AbortController, s = this._uiManager.combinedSignal(a);
        this.parent.togglePointerEvents(!1), window.addEventListener("pointermove", this.#da.bind(this, e1), {
            passive: !0,
            capture: !0,
            signal: s
        }), window.addEventListener("touchmove", stopEvent, {
            passive: !1,
            signal: s
        }), window.addEventListener("contextmenu", noContextMenu, {
            signal: s
        }), this.#Xn = {
            savedX: this.x,
            savedY: this.y,
            savedWidth: this.width,
            savedHeight: this.height
        };
        const r = this.parent.div.style.cursor, o = this.div.style.cursor;
        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(t.target).cursor;
        const pointerUpCallback = ()=>{
            a.abort(), this.parent.togglePointerEvents(!0), this.#mt?.toggle(!0), this._isDraggable = n, this.parent.div.style.cursor = r, this.div.style.cursor = o, this.#ua();
        };
        window.addEventListener("pointerup", pointerUpCallback, {
            signal: s
        }), window.addEventListener("blur", pointerUpCallback, {
            signal: s
        });
    }
    #ga(e1, t, i, n) {
        this.width = i, this.height = n, this.x = e1, this.y = t, this.setDims(), this.fixAndSetPosition(), this._onResized();
    }
    _onResized() {}
    #ua() {
        if (!this.#Xn) return;
        const { savedX: e1, savedY: t, savedWidth: i, savedHeight: n } = this.#Xn;
        this.#Xn = null;
        const a = this.x, s = this.y, r = this.width, o = this.height;
        a === e1 && s === t && r === i && o === n || this.addCommands({
            cmd: this.#ga.bind(this, a, s, r, o),
            undo: this.#ga.bind(this, e1, t, i, n),
            mustExec: !0
        });
    }
    static _round(e1) {
        return Math.round(1e4 * e1) / 1e4;
    }
    #da(e1, t) {
        const [i, n] = this.parentDimensions, a = this.x, s = this.y, r = this.width, o = this.height, l = AnnotationEditor.MIN_SIZE / i, c = AnnotationEditor.MIN_SIZE / n, h = this.#la(this.rotation), transf = (e1, t)=>[
                h[0] * e1 + h[2] * t,
                h[1] * e1 + h[3] * t
            ], d = this.#la(360 - this.rotation);
        let u, g, f = !1, p = !1;
        switch(e1){
            case "topLeft":
                f = !0, u = (e1, t)=>[
                        0,
                        0
                    ], g = (e1, t)=>[
                        e1,
                        t
                    ];
                break;
            case "topMiddle":
                u = (e1, t)=>[
                        e1 / 2,
                        0
                    ], g = (e1, t)=>[
                        e1 / 2,
                        t
                    ];
                break;
            case "topRight":
                f = !0, u = (e1, t)=>[
                        e1,
                        0
                    ], g = (e1, t)=>[
                        0,
                        t
                    ];
                break;
            case "middleRight":
                p = !0, u = (e1, t)=>[
                        e1,
                        t / 2
                    ], g = (e1, t)=>[
                        0,
                        t / 2
                    ];
                break;
            case "bottomRight":
                f = !0, u = (e1, t)=>[
                        e1,
                        t
                    ], g = (e1, t)=>[
                        0,
                        0
                    ];
                break;
            case "bottomMiddle":
                u = (e1, t)=>[
                        e1 / 2,
                        t
                    ], g = (e1, t)=>[
                        e1 / 2,
                        0
                    ];
                break;
            case "bottomLeft":
                f = !0, u = (e1, t)=>[
                        0,
                        t
                    ], g = (e1, t)=>[
                        e1,
                        0
                    ];
                break;
            case "middleLeft":
                p = !0, u = (e1, t)=>[
                        0,
                        t / 2
                    ], g = (e1, t)=>[
                        e1,
                        t / 2
                    ];
        }
        const m = u(r, o), b = g(r, o);
        let y = transf(...b);
        const w = AnnotationEditor._round(a + y[0]), x = AnnotationEditor._round(s + y[1]);
        let S, v, C = 1, k = 1;
        if (t.fromKeyboard) ({ deltaX: S, deltaY: v } = t);
        else {
            const { screenX: e1, screenY: i } = t, [n, a] = this.#Hn;
            [S, v] = this.screenToPageTranslation(e1 - n, i - a), this.#Hn[0] = e1, this.#Hn[1] = i;
        }
        var T, F;
        if ([S, v] = (T = S / i, F = v / n, [
            d[0] * T + d[2] * F,
            d[1] * T + d[3] * F
        ]), f) {
            const e1 = Math.hypot(r, o);
            C = k = Math.max(Math.min(Math.hypot(b[0] - m[0] - S, b[1] - m[1] - v) / e1, 1 / r, 1 / o), l / r, c / o);
        } else p ? C = MathClamp(Math.abs(b[0] - m[0] - S), l, 1) / r : k = MathClamp(Math.abs(b[1] - m[1] - v), c, 1) / o;
        const E = AnnotationEditor._round(r * C), M = AnnotationEditor._round(o * k);
        y = transf(...g(E, M));
        const D = w - y[0], O = x - y[1];
        this.#Vn ||= [
            this.x,
            this.y,
            this.width,
            this.height
        ], this.width = E, this.height = M, this.x = D, this.y = O, this.setDims(), this.fixAndSetPosition(), this._onResizing();
    }
    _onResizing() {}
    altTextFinish() {
        this.#mt?.finish();
    }
    get toolbarButtons() {
        return null;
    }
    async addEditToolbar() {
        if (this._editToolbar || this.#Yn) return this._editToolbar;
        this._editToolbar = new EditorToolbar(this), this.div.append(this._editToolbar.render());
        const { toolbarButtons: e1 } = this;
        if (e1) for (const [t, i] of e1)await this._editToolbar.addButton(t, i);
        return this.hasComment || this._editToolbar.addButton("comment", this.addCommentButton()), this._editToolbar.addButton("delete"), this._editToolbar;
    }
    addCommentButtonInToolbar() {
        this._editToolbar?.addButtonBefore("comment", this.addCommentButton(), ".deleteButton");
    }
    removeCommentButtonFromToolbar() {
        this._editToolbar?.removeButton("comment");
    }
    removeEditToolbar() {
        this._editToolbar?.remove(), this._editToolbar = null, this.#mt?.destroy();
    }
    addContainer(e1) {
        const t = this._editToolbar?.div;
        t ? t.before(e1) : this.div.append(e1);
    }
    getClientDimensions() {
        return this.div.getBoundingClientRect();
    }
    createAltText() {
        return this.#mt || (AltText.initialize(AnnotationEditor._l10n), this.#mt = new AltText(this), this.#Bn && (this.#mt.data = this.#Bn, this.#Bn = null)), this.#mt;
    }
    get altTextData() {
        return this.#mt?.data;
    }
    set altTextData(e1) {
        this.#mt && (this.#mt.data = e1);
    }
    get guessedAltText() {
        return this.#mt?.guessedText;
    }
    async setGuessedAltText(e1) {
        await this.#mt?.setGuessedText(e1);
    }
    serializeAltText(e1) {
        return this.#mt?.serialize(e1);
    }
    hasAltText() {
        return !!this.#mt && !this.#mt.isEmpty();
    }
    hasAltTextData() {
        return this.#mt?.hasData() ?? !1;
    }
    focusCommentButton() {
        this.#bt?.focusButton();
    }
    addCommentButton() {
        return this.#bt ||= new Comment(this);
    }
    addStandaloneCommentButton() {
        this.#fn ? this._uiManager.isEditingMode() && this.#fn.classList.remove("hidden") : this.hasComment && (this.#fn = this.#bt.renderForStandalone(), this.div.append(this.#fn));
    }
    removeStandaloneCommentButton() {
        this.#bt.removeStandaloneCommentButton(), this.#fn = null;
    }
    hideStandaloneCommentButton() {
        this.#fn?.classList.add("hidden");
    }
    get comment() {
        const { data: { richText: e1, text: t, date: i, deleted: n } } = this.#bt;
        return {
            text: t,
            richText: e1,
            date: i,
            deleted: n,
            color: this.getNonHCMColor(),
            opacity: this.opacity ?? 1
        };
    }
    set comment(e1) {
        this.#bt ||= new Comment(this), this.#bt.data = e1, this.hasComment ? (this.removeCommentButtonFromToolbar(), this.addStandaloneCommentButton(), this._uiManager.updateComment(this)) : (this.addCommentButtonInToolbar(), this.removeStandaloneCommentButton(), this._uiManager.removeComment(this));
    }
    setCommentData({ comment: e1, popupRef: t, richText: i }) {
        if (!t) return;
        if (this.#bt ||= new Comment(this), this.#bt.setInitialText(e1, i), !this.annotationElementId) return;
        const n = this._uiManager.getAndRemoveDataFromAnnotationStorage(this.annotationElementId);
        n && this.updateFromAnnotationLayer(n);
    }
    get hasEditedComment() {
        return this.#bt?.hasBeenEdited();
    }
    get hasDeletedComment() {
        return this.#bt?.isDeleted();
    }
    get hasComment() {
        return !!this.#bt && !this.#bt.isEmpty() && !this.#bt.isDeleted();
    }
    async editComment(e1) {
        this.#bt ||= new Comment(this), this.#bt.edit(e1);
    }
    toggleComment(e1, t = void 0) {
        this.hasComment && this._uiManager.toggleComment(this, e1, t);
    }
    setSelectedCommentButton(e1) {
        this.#bt.setSelectedButton(e1);
    }
    addComment(e1) {
        if (this.hasEditedComment) {
            const t = 180, i = 100, [, , , n] = e1.rect, [a] = this.pageDimensions, [s] = this.pageTranslation, r = s + a + 1, o = n - i, l = r + t;
            e1.popup = {
                contents: this.comment.text,
                deleted: this.comment.deleted,
                rect: [
                    r,
                    o,
                    l,
                    n
                ]
            };
        }
    }
    updateFromAnnotationLayer({ popup: { contents: e1, deleted: t } }) {
        this.#bt.data = t ? null : e1;
    }
    get parentBoundingClientRect() {
        return this.parent.boundingClientRect;
    }
    render() {
        const e1 = this.div = document.createElement("div");
        e1.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), e1.className = this.name, e1.setAttribute("id", this.id), e1.tabIndex = this.#Ln ? -1 : 0, e1.setAttribute("role", "application"), this.defaultL10nId && e1.setAttribute("data-l10n-id", this.defaultL10nId), this._isVisible || e1.classList.add("hidden"), this.setInForeground(), this.#fa();
        const [t, i] = this.parentDimensions;
        this.parentRotation % 180 != 0 && (e1.style.maxWidth = `${(100 * i / t).toFixed(2)}%`, e1.style.maxHeight = `${(100 * t / i).toFixed(2)}%`);
        const [n, a] = this.getInitialTranslation();
        return this.translate(n, a), bindEvents(this, e1, [
            "keydown",
            "pointerdown",
            "dblclick"
        ]), this.isResizable && this._uiManager._supportsPinchToZoom && (this.#ia ||= new TouchManager({
            container: e1,
            isPinchingDisabled: ()=>!this.isSelected,
            onPinchStart: this.#pa.bind(this),
            onPinching: this.#ma.bind(this),
            onPinchEnd: this.#ba.bind(this),
            signal: this._uiManager._signal
        })), this.addStandaloneCommentButton(), this._uiManager._editorUndoBar?.hide(), e1;
    }
    #pa() {
        this.#Xn = {
            savedX: this.x,
            savedY: this.y,
            savedWidth: this.width,
            savedHeight: this.height
        }, this.#mt?.toggle(!1), this.parent.togglePointerEvents(!1);
    }
    #ma(e1, t, i) {
        let n = i / t * .7 + 1 - .7;
        if (1 === n) return;
        const a = this.#la(this.rotation), transf = (e1, t)=>[
                a[0] * e1 + a[2] * t,
                a[1] * e1 + a[3] * t
            ], [s, r] = this.parentDimensions, o = this.x, l = this.y, c = this.width, h = this.height, d = AnnotationEditor.MIN_SIZE / s, u = AnnotationEditor.MIN_SIZE / r;
        n = Math.max(Math.min(n, 1 / c, 1 / h), d / c, u / h);
        const g = AnnotationEditor._round(c * n), f = AnnotationEditor._round(h * n);
        if (g === c && f === h) return;
        this.#Vn ||= [
            o,
            l,
            c,
            h
        ];
        const p = transf(c / 2, h / 2), m = AnnotationEditor._round(o + p[0]), b = AnnotationEditor._round(l + p[1]), y = transf(g / 2, f / 2);
        this.x = m - y[0], this.y = b - y[1], this.width = g, this.height = f, this.setDims(), this.fixAndSetPosition(), this._onResizing();
    }
    #ba() {
        this.#mt?.toggle(!0), this.parent.togglePointerEvents(!0), this.#ua();
    }
    pointerdown(e1) {
        const { isMac: t } = util_FeatureTest.platform;
        0 !== e1.button || e1.ctrlKey && t ? e1.preventDefault() : (this.#Gn = !0, this._isDraggable ? this.#ya(e1) : this.#wa(e1));
    }
    #wa(e1) {
        const { isMac: t } = util_FeatureTest.platform;
        e1.ctrlKey && !t || e1.shiftKey || e1.metaKey && t ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
    }
    #ya(e1) {
        const { isSelected: t } = this;
        this._uiManager.setUpDragSession();
        let i = !1;
        const n = new AbortController, a = this._uiManager.combinedSignal(n), s = {
            capture: !0,
            passive: !1,
            signal: a
        }, cancelDrag = (e1)=>{
            n.abort(), this.#Un = null, this.#Gn = !1, this._uiManager.endDragSession() || this.#wa(e1), i && this._onStopDragging();
        };
        t && (this.#Qn = e1.clientX, this.#ea = e1.clientY, this.#Un = e1.pointerId, this.#jn = e1.pointerType, window.addEventListener("pointermove", (e1)=>{
            i || (i = !0, this._uiManager.toggleComment(this, !0, !1), this._onStartDragging());
            const { clientX: t, clientY: n, pointerId: a } = e1;
            if (a !== this.#Un) return void stopEvent(e1);
            const [s, r] = this.screenToPageTranslation(t - this.#Qn, n - this.#ea);
            this.#Qn = t, this.#ea = n, this._uiManager.dragSelectedEditors(s, r);
        }, s), window.addEventListener("touchmove", stopEvent, s), window.addEventListener("pointerdown", (e1)=>{
            e1.pointerType === this.#jn && (this.#ia || e1.isPrimary) && cancelDrag(e1), stopEvent(e1);
        }, s));
        const pointerUpCallback = (e1)=>{
            this.#Un && this.#Un !== e1.pointerId ? stopEvent(e1) : cancelDrag(e1);
        };
        window.addEventListener("pointerup", pointerUpCallback, {
            signal: a
        }), window.addEventListener("blur", pointerUpCallback, {
            signal: a
        });
    }
    _onStartDragging() {}
    _onStopDragging() {}
    moveInDOM() {
        this.#Zn && clearTimeout(this.#Zn), this.#Zn = setTimeout(()=>{
            this.#Zn = null, this.parent?.moveEditorInDOM(this);
        }, 0);
    }
    _setParentAndPosition(e1, t, i) {
        e1.changeParent(this), this.x = t, this.y = i, this.fixAndSetPosition(), this._onTranslated();
    }
    getRect(e1, t, i = this.rotation) {
        const n = this.parentScale, [a, s] = this.pageDimensions, [r, o] = this.pageTranslation, l = e1 / n, c = t / n, h = this.x * a, d = this.y * s, u = this.width * a, g = this.height * s;
        switch(i){
            case 0:
                return [
                    h + l + r,
                    s - d - c - g + o,
                    h + l + u + r,
                    s - d - c + o
                ];
            case 90:
                return [
                    h + c + r,
                    s - d + l + o,
                    h + c + g + r,
                    s - d + l + u + o
                ];
            case 180:
                return [
                    h - l - u + r,
                    s - d + c + o,
                    h - l + r,
                    s - d + c + g + o
                ];
            case 270:
                return [
                    h - c - g + r,
                    s - d - l - u + o,
                    h - c + r,
                    s - d - l + o
                ];
            default:
                throw new Error("Invalid rotation");
        }
    }
    getRectInCurrentCoords(e1, t) {
        const [i, n, a, s] = e1, r = a - i, o = s - n;
        switch(this.rotation){
            case 0:
                return [
                    i,
                    t - s,
                    r,
                    o
                ];
            case 90:
                return [
                    i,
                    t - n,
                    o,
                    r
                ];
            case 180:
                return [
                    a,
                    t - n,
                    r,
                    o
                ];
            case 270:
                return [
                    a,
                    t - s,
                    o,
                    r
                ];
            default:
                throw new Error("Invalid rotation");
        }
    }
    getPDFRect() {
        return this.getRect(0, 0);
    }
    getNonHCMColor() {
        return this.color && AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
    }
    onUpdatedColor() {
        this.#bt?.onUpdatedColor();
    }
    getData() {
        const { comment: { text: e1, color: t, date: i, opacity: n, deleted: a, richText: s }, uid: r, pageIndex: o, creationDate: l, modificationDate: c } = this;
        return {
            id: r,
            pageIndex: o,
            rect: this.getPDFRect(),
            richText: s,
            contentsObj: {
                str: e1
            },
            creationDate: l,
            modificationDate: i || c,
            popupRef: !a,
            color: t,
            opacity: n
        };
    }
    onceAdded(e1) {}
    isEmpty() {
        return !1;
    }
    enableEditMode() {
        return !this.isInEditMode() && (this.parent.setEditingState(!1), this.#Yn = !0, !0);
    }
    disableEditMode() {
        return !!this.isInEditMode() && (this.parent.setEditingState(!0), this.#Yn = !1, !0);
    }
    isInEditMode() {
        return this.#Yn;
    }
    shouldGetKeyboardEvents() {
        return this.#Jn;
    }
    needsToBeRebuilt() {
        return this.div && !this.isAttachedToDOM;
    }
    get isOnScreen() {
        const { top: e1, left: t, bottom: i, right: n } = this.getClientDimensions(), { innerHeight: a, innerWidth: s } = window;
        return t < s && n > 0 && e1 < a && i > 0;
    }
    #fa() {
        if (this.#zn || !this.div) return;
        this.#zn = new AbortController;
        const e1 = this._uiManager.combinedSignal(this.#zn);
        this.div.addEventListener("focusin", this.focusin.bind(this), {
            signal: e1
        }), this.div.addEventListener("focusout", this.focusout.bind(this), {
            signal: e1
        });
    }
    rebuild() {
        this.#fa();
    }
    rotate(e1) {}
    resize() {}
    serializeDeleted() {
        return {
            id: this.annotationElementId,
            deleted: !0,
            pageIndex: this.pageIndex,
            popupRef: this._initialData?.popupRef || ""
        };
    }
    serialize(e1 = !1, t = null) {
        return {
            annotationType: this.mode,
            pageIndex: this.pageIndex,
            rect: this.getPDFRect(),
            rotation: this.rotation,
            structTreeParentId: this._structTreeParentId,
            popupRef: this._initialData?.popupRef || ""
        };
    }
    static async deserialize(e1, t, i) {
        const n = new this.prototype.constructor({
            parent: t,
            id: t.getNextId(),
            uiManager: i,
            annotationElementId: e1.annotationElementId,
            creationDate: e1.creationDate,
            modificationDate: e1.modificationDate
        });
        n.rotation = e1.rotation, n.#Bn = e1.accessibilityData, n._isCopy = e1.isCopy || !1;
        const [a, s] = n.pageDimensions, [r, o, l, c] = n.getRectInCurrentCoords(e1.rect, s);
        return n.x = r / a, n.y = o / s, n.width = l / a, n.height = c / s, n;
    }
    get hasBeenModified() {
        return !!this.annotationElementId && (this.deleted || null !== this.serialize());
    }
    remove() {
        if (this.#zn?.abort(), this.#zn = null, this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), this.#Zn && (clearTimeout(this.#Zn), this.#Zn = null), this.#sa(), this.removeEditToolbar(), this.#ta) {
            for (const e1 of this.#ta.values())clearTimeout(e1);
            this.#ta = null;
        }
        this.parent = null, this.#ia?.destroy(), this.#ia = null;
    }
    get isResizable() {
        return !1;
    }
    makeResizable() {
        this.isResizable && (this.#ca(), this.#$n.classList.remove("hidden"));
    }
    get toolbarPosition() {
        return null;
    }
    get commentButtonPosition() {
        return "ltr" === this._uiManager.direction ? [
            1,
            0
        ] : [
            0,
            0
        ];
    }
    get commentButtonPositionInPage() {
        const { commentButtonPosition: [e1, t] } = this, [i, n, a, s] = this.getPDFRect();
        return [
            AnnotationEditor._round(i + (a - i) * e1),
            AnnotationEditor._round(n + (s - n) * (1 - t))
        ];
    }
    get commentButtonColor() {
        return this._uiManager.makeCommentColor(this.getNonHCMColor(), this.opacity);
    }
    get commentPopupPosition() {
        return this.#bt.commentPopupPositionInLayer;
    }
    set commentPopupPosition(e1) {
        this.#bt.commentPopupPositionInLayer = e1;
    }
    hasDefaultPopupPosition() {
        return this.#bt.hasDefaultPopupPosition();
    }
    get commentButtonWidth() {
        return this.#bt.commentButtonWidth;
    }
    get elementBeforePopup() {
        return this.div;
    }
    setCommentButtonStates(e1) {
        this.#bt.setCommentButtonStates(e1);
    }
    keydown(e1) {
        if (!this.isResizable || e1.target !== this.div || "Enter" !== e1.key) return;
        this._uiManager.setSelected(this), this.#Xn = {
            savedX: this.x,
            savedY: this.y,
            savedWidth: this.width,
            savedHeight: this.height
        };
        const t = this.#$n.children;
        if (!this.#Nn) {
            this.#Nn = Array.from(t);
            const e1 = this.#Aa.bind(this), i = this.#xa.bind(this), n = this._uiManager._signal;
            for (const t of this.#Nn){
                const a = t.getAttribute("data-resizer-name");
                t.setAttribute("role", "spinbutton"), t.addEventListener("keydown", e1, {
                    signal: n
                }), t.addEventListener("blur", i, {
                    signal: n
                }), t.addEventListener("focus", this.#Sa.bind(this, a), {
                    signal: n
                }), t.setAttribute("data-l10n-id", AnnotationEditor._l10nResizer[a]);
            }
        }
        const i = this.#Nn[0];
        let n = 0;
        for (const e1 of t){
            if (e1 === i) break;
            n++;
        }
        const a = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#Nn.length / 4);
        if (a !== n) {
            if (a < n) for(let e1 = 0; e1 < n - a; e1++)this.#$n.append(this.#$n.firstChild);
            else if (a > n) for(let e1 = 0; e1 < a - n; e1++)this.#$n.firstChild.before(this.#$n.lastChild);
            let e1 = 0;
            for (const i of t){
                const t = this.#Nn[e1++].getAttribute("data-resizer-name");
                i.setAttribute("data-l10n-id", AnnotationEditor._l10nResizer[t]);
            }
        }
        this.#va(0), this.#Jn = !0, this.#$n.firstChild.focus({
            focusVisible: !0
        }), e1.preventDefault(), e1.stopImmediatePropagation();
    }
    #Aa(e1) {
        AnnotationEditor._resizerKeyboardManager.exec(this, e1);
    }
    #xa(e1) {
        this.#Jn && e1.relatedTarget?.parentNode !== this.#$n && this.#sa();
    }
    #Sa(e1) {
        this.#Wn = this.#Jn ? e1 : "";
    }
    #va(e1) {
        if (this.#Nn) for (const t of this.#Nn)t.tabIndex = e1;
    }
    _resizeWithKeyboard(e1, t) {
        this.#Jn && this.#da(this.#Wn, {
            deltaX: e1,
            deltaY: t,
            fromKeyboard: !0
        });
    }
    #sa() {
        this.#Jn = !1, this.#va(-1), this.#ua();
    }
    _stopResizingWithKeyboard() {
        this.#sa(), this.div.focus();
    }
    select() {
        this.isSelected && this._editToolbar ? this._editToolbar.show() : (this.isSelected = !0, this.makeResizable(), this.div?.classList.add("selectedEditor"), this._editToolbar ? (this._editToolbar?.show(), this.#mt?.toggleAltTextBadge(!1)) : this.addEditToolbar().then(()=>{
            this.div?.classList.contains("selectedEditor") && this._editToolbar?.show();
        }));
    }
    focus() {
        this.div && !this.div.contains(document.activeElement) && setTimeout(()=>this.div?.focus({
                preventScroll: !0
            }), 0);
    }
    unselect() {
        this.isSelected && (this.isSelected = !1, this.#$n?.classList.add("hidden"), this.div?.classList.remove("selectedEditor"), this.div?.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({
            preventScroll: !0
        }), this._editToolbar?.hide(), this.#mt?.toggleAltTextBadge(!0), this.hasComment && this._uiManager.toggleComment(this, !1, !1));
    }
    updateParams(e1, t) {}
    disableEditing() {}
    enableEditing() {}
    get canChangeContent() {
        return !1;
    }
    enterInEditMode() {
        this.canChangeContent && (this.enableEditMode(), this.div.focus());
    }
    dblclick(e1) {
        "BUTTON" !== e1.target.nodeName && (this.enterInEditMode(), this.parent.updateToolbar({
            mode: this.constructor._editorType,
            editId: this.id
        }));
    }
    getElementForAltText() {
        return this.div;
    }
    get contentDiv() {
        return this.div;
    }
    get isEditing() {
        return this.#Kn;
    }
    set isEditing(e1) {
        this.#Kn = e1, this.parent && (e1 ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
    }
    static get MIN_SIZE() {
        return 16;
    }
    static canCreateNewEmptyEditor() {
        return !0;
    }
    get telemetryInitialData() {
        return {
            action: "added"
        };
    }
    get telemetryFinalData() {
        return null;
    }
    _reportTelemetry(e1, t = !1) {
        if (t) {
            this.#ta ||= new Map;
            const { action: t } = e1;
            let i = this.#ta.get(t);
            return i && clearTimeout(i), i = setTimeout(()=>{
                this._reportTelemetry(e1), this.#ta.delete(t), 0 === this.#ta.size && (this.#ta = null);
            }, AnnotationEditor._telemetryTimeout), void this.#ta.set(t, i);
        }
        e1.type ||= this.editorType, this._uiManager._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
                type: "editing",
                data: e1
            }
        });
    }
    show(e1 = this._isVisible) {
        this.div.classList.toggle("hidden", !e1), this._isVisible = e1;
    }
    enable() {
        this.div && (this.div.tabIndex = 0), this.#Ln = !1;
    }
    disable() {
        this.div && (this.div.tabIndex = -1), this.#Ln = !0;
    }
    updateFakeAnnotationElement(e1) {
        if (this.#qn || this.deleted) return this.deleted ? (this.#qn.remove(), void (this.#qn = null)) : void ((this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized) && this.#qn.updateEdited({
            rect: this.getPDFRect(),
            popup: this.comment
        }));
        this.#qn = e1.addFakeAnnotation(this);
    }
    renderAnnotationElement(e1) {
        if (this.deleted) return e1.hide(), null;
        let t = e1.container.querySelector(".annotationContent");
        if (t) {
            if ("CANVAS" === t.nodeName) {
                const e1 = t;
                t = document.createElement("div"), t.classList.add("annotationContent", this.editorType), e1.before(t);
            }
        } else t = document.createElement("div"), t.classList.add("annotationContent", this.editorType), e1.container.prepend(t);
        return t;
    }
    resetAnnotationElement(e1) {
        const { firstChild: t } = e1.container;
        "DIV" === t?.nodeName && t.classList.contains("annotationContent") && t.remove();
    }
}
class FakeEditor extends AnnotationEditor {
    constructor(e1){
        super(e1), this.annotationElementId = e1.annotationElementId, this.deleted = !0;
    }
    serialize() {
        return this.serializeDeleted();
    }
}
const Ac = 3285377520, xc = 4294901760, Sc = 65535;
class MurmurHash3_64 {
    constructor(e1){
        this.h1 = e1 ? 4294967295 & e1 : Ac, this.h2 = e1 ? 4294967295 & e1 : Ac;
    }
    update(e1) {
        let t, i;
        if ("string" == typeof e1) {
            t = new Uint8Array(2 * e1.length), i = 0;
            for(let n = 0, a = e1.length; n < a; n++){
                const a = e1.charCodeAt(n);
                a <= 255 ? t[i++] = a : (t[i++] = a >>> 8, t[i++] = 255 & a);
            }
        } else {
            if (!ArrayBuffer.isView(e1)) throw new Error("Invalid data format, must be a string or TypedArray.");
            t = e1.slice(), i = t.byteLength;
        }
        const n = i >> 2, a = i - 4 * n, s = new Uint32Array(t.buffer, 0, n);
        let r = 0, o = 0, l = this.h1, c = this.h2;
        const h = 3432918353, d = 461845907, u = 11601, g = 13715;
        for(let e1 = 0; e1 < n; e1++)1 & e1 ? (r = s[e1], r = r * h & xc | r * u & Sc, r = r << 15 | r >>> 17, r = r * d & xc | r * g & Sc, l ^= r, l = l << 13 | l >>> 19, l = 5 * l + 3864292196) : (o = s[e1], o = o * h & xc | o * u & Sc, o = o << 15 | o >>> 17, o = o * d & xc | o * g & Sc, c ^= o, c = c << 13 | c >>> 19, c = 5 * c + 3864292196);
        switch(r = 0, a){
            case 3:
                r ^= t[4 * n + 2] << 16;
            case 2:
                r ^= t[4 * n + 1] << 8;
            case 1:
                r ^= t[4 * n], r = r * h & xc | r * u & Sc, r = r << 15 | r >>> 17, r = r * d & xc | r * g & Sc, 1 & n ? l ^= r : c ^= r;
        }
        this.h1 = l, this.h2 = c;
    }
    hexdigest() {
        let e1 = this.h1, t = this.h2;
        return e1 ^= t >>> 1, e1 = 3981806797 * e1 & xc | 36045 * e1 & Sc, t = 4283543511 * t & xc | (2950163797 * (t << 16 | e1 >>> 16) & xc) >>> 16, e1 ^= t >>> 1, e1 = 444984403 * e1 & xc | 60499 * e1 & Sc, t = 3301882366 * t & xc | (3120437893 * (t << 16 | e1 >>> 16) & xc) >>> 16, e1 ^= t >>> 1, (e1 >>> 0).toString(16).padStart(8, "0") + (t >>> 0).toString(16).padStart(8, "0");
    }
}
const vc = Object.freeze({
    map: null,
    hash: "",
    transfer: void 0
});
class AnnotationStorage {
    #Ca = !1;
    #ka = null;
    #Ta = null;
    #Fa = new Map;
    constructor(){
        this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
    }
    getValue(e1, t) {
        const i = this.#Fa.get(e1);
        return void 0 === i ? t : Object.assign(t, i);
    }
    getRawValue(e1) {
        return this.#Fa.get(e1);
    }
    remove(e1) {
        const t = this.#Fa.get(e1);
        if (void 0 !== t && (t instanceof AnnotationEditor && this.#Ta.delete(t.annotationElementId), this.#Fa.delete(e1), 0 === this.#Fa.size && this.resetModified(), "function" == typeof this.onAnnotationEditor)) {
            for (const e1 of this.#Fa.values())if (e1 instanceof AnnotationEditor) return;
            this.onAnnotationEditor(null);
        }
    }
    setValue(e1, t) {
        const i = this.#Fa.get(e1);
        let n = !1;
        if (void 0 !== i) for (const [e1, a] of Object.entries(t))i[e1] !== a && (n = !0, i[e1] = a);
        else n = !0, this.#Fa.set(e1, t);
        n && this.#Ia(), t instanceof AnnotationEditor && ((this.#Ta ||= new Map).set(t.annotationElementId, t), "function" == typeof this.onAnnotationEditor && this.onAnnotationEditor(t.constructor._type));
    }
    has(e1) {
        return this.#Fa.has(e1);
    }
    get size() {
        return this.#Fa.size;
    }
    #Ia() {
        this.#Ca || (this.#Ca = !0, "function" == typeof this.onSetModified && this.onSetModified());
    }
    resetModified() {
        this.#Ca && (this.#Ca = !1, "function" == typeof this.onResetModified && this.onResetModified());
    }
    get print() {
        return new PrintAnnotationStorage(this);
    }
    get serializable() {
        if (0 === this.#Fa.size) return vc;
        const e1 = new Map, t = new MurmurHash3_64, i = [], n = Object.create(null);
        let a = !1;
        for (const [i, s] of this.#Fa){
            const r = s instanceof AnnotationEditor ? s.serialize(!1, n) : s;
            r && (e1.set(i, r), t.update(`${i}:${JSON.stringify(r)}`), a ||= !!r.bitmap);
        }
        if (a) for (const t of e1.values())t.bitmap && i.push(t.bitmap);
        return e1.size > 0 ? {
            map: e1,
            hash: t.hexdigest(),
            transfer: i
        } : vc;
    }
    get editorStats() {
        let e1 = null;
        const t = new Map;
        let i = 0, n = 0;
        for (const a of this.#Fa.values()){
            if (!(a instanceof AnnotationEditor)) {
                a.popup && (a.popup.deleted ? n += 1 : i += 1);
                continue;
            }
            a.isCommentDeleted ? n += 1 : a.hasEditedComment && (i += 1);
            const s = a.telemetryFinalData;
            if (!s) continue;
            const { type: r } = s;
            t.has(r) || t.set(r, Object.getPrototypeOf(a).constructor), e1 ||= Object.create(null);
            const o = e1[r] ||= new Map;
            for (const [e1, t] of Object.entries(s)){
                if ("type" === e1) continue;
                let i = o.get(e1);
                i || (i = new Map, o.set(e1, i));
                const n = i.get(t) ?? 0;
                i.set(t, n + 1);
            }
        }
        if ((n > 0 || i > 0) && (e1 ||= Object.create(null), e1.comments = {
            deleted: n,
            edited: i
        }), !e1) return null;
        for (const [i, n] of t)e1[i] = n.computeTelemetryFinalData(e1[i]);
        return e1;
    }
    resetModifiedIds() {
        this.#ka = null;
    }
    updateEditor(e1, t) {
        const i = this.#Ta?.get(e1);
        return !!i && (i.updateFromAnnotationLayer(t), !0);
    }
    getEditor(e1) {
        return this.#Ta?.get(e1) || null;
    }
    get modifiedIds() {
        if (this.#ka) return this.#ka;
        const e1 = [];
        if (this.#Ta) for (const t of this.#Ta.values())t.serialize() && e1.push(t.annotationElementId);
        return this.#ka = {
            ids: new Set(e1),
            hash: e1.join(",")
        };
    }
    [Symbol.iterator]() {
        return this.#Fa.entries();
    }
}
class PrintAnnotationStorage extends AnnotationStorage {
    #Ea;
    constructor(e1){
        super();
        const { map: t, hash: i, transfer: n } = e1.serializable, a = structuredClone(t, n ? {
            transfer: n
        } : null);
        this.#Ea = {
            map: a,
            hash: i,
            transfer: n
        };
    }
    get print() {
        unreachable("Should not call PrintAnnotationStorage.print");
    }
    get serializable() {
        return this.#Ea;
    }
    get modifiedIds() {
        return shadow(this, "modifiedIds", {
            ids: new Set,
            hash: ""
        });
    }
}
class FontLoader {
    #Ma = new Set;
    constructor({ ownerDocument: e1 = globalThis.document, styleElement: t = null }){
        this._document = e1, this.nativeFontFaces = new Set, this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
    }
    addNativeFontFace(e1) {
        this.nativeFontFaces.add(e1), this._document.fonts.add(e1);
    }
    removeNativeFontFace(e1) {
        this.nativeFontFaces.delete(e1), this._document.fonts.delete(e1);
    }
    insertRule(e1) {
        this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
        const t = this.styleElement.sheet;
        t.insertRule(e1, t.cssRules.length);
    }
    clear() {
        for (const e1 of this.nativeFontFaces)this._document.fonts.delete(e1);
        this.nativeFontFaces.clear(), this.#Ma.clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
    }
    async loadSystemFont({ systemFontInfo: e1, disableFontFace: t, _inspectFont: i }) {
        if (e1 && !this.#Ma.has(e1.loadedName)) {
            if (assert(!t, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
                const { loadedName: t, src: n, style: a } = e1, s = new FontFace(t, n, a);
                this.addNativeFontFace(s);
                try {
                    await s.load(), this.#Ma.add(t), i?.(e1);
                } catch  {
                    warn(`Cannot load system font: ${e1.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(s);
                }
                return;
            }
            unreachable("Not implemented: loadSystemFont without the Font Loading API.");
        }
    }
    async bind(e1) {
        if (e1.attached || e1.missingFile && !e1.systemFontInfo) return;
        if (e1.attached = !0, e1.systemFontInfo) return void await this.loadSystemFont(e1);
        if (this.isFontLoadingAPISupported) {
            const t = e1.createNativeFontFace();
            if (t) {
                this.addNativeFontFace(t);
                try {
                    await t.loaded;
                } catch (i) {
                    throw warn(`Failed to load font '${t.family}': '${i}'.`), e1.disableFontFace = !0, i;
                }
            }
            return;
        }
        const t = e1.createFontFaceRule();
        if (t) {
            if (this.insertRule(t), this.isSyncFontLoadingSupported) return;
            await new Promise((t)=>{
                const i = this._queueLoadingCallback(t);
                this._prepareFontLoadEvent(e1, i);
            });
        }
    }
    get isFontLoadingAPISupported() {
        return shadow(this, "isFontLoadingAPISupported", !!this._document?.fonts);
    }
    get isSyncFontLoadingSupported() {
        return shadow(this, "isSyncFontLoadingSupported", Fl || util_FeatureTest.platform.isFirefox);
    }
    _queueLoadingCallback(e1) {
        const { loadingRequests: t } = this, i = {
            done: !1,
            complete: function() {
                for(assert(!i.done, "completeRequest() cannot be called twice."), i.done = !0; t.length > 0 && t[0].done;){
                    const e1 = t.shift();
                    setTimeout(e1.callback, 0);
                }
            },
            callback: e1
        };
        return t.push(i), i;
    }
    get _loadTestFont() {
        return shadow(this, "_loadTestFont", atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=="));
    }
    _prepareFontLoadEvent(e1, t) {
        function int32(e1, t) {
            return e1.charCodeAt(t) << 24 | e1.charCodeAt(t + 1) << 16 | e1.charCodeAt(t + 2) << 8 | 255 & e1.charCodeAt(t + 3);
        }
        function spliceString(e1, t, i, n) {
            return e1.substring(0, t) + n + e1.substring(t + i);
        }
        let i, n;
        const a = this._document.createElement("canvas");
        a.width = 1, a.height = 1;
        const s = a.getContext("2d");
        let r = 0;
        const o = `lt${Date.now()}${this.loadTestFontId++}`;
        let l = this._loadTestFont;
        l = spliceString(l, 976, o.length, o);
        const c = 1482184792;
        let h = int32(l, 16);
        for(i = 0, n = o.length - 3; i < n; i += 4)h = h - c + int32(o, i) | 0;
        var d;
        i < o.length && (h = h - c + int32(o + "XXX", i) | 0), l = spliceString(l, 16, 4, (d = h, String.fromCharCode(d >> 24 & 255, d >> 16 & 255, d >> 8 & 255, 255 & d)));
        const u = `@font-face {font-family:"${o}";src:${`url(data:font/opentype;base64,${btoa(l)});`}}`;
        this.insertRule(u);
        const g = this._document.createElement("div");
        g.style.visibility = "hidden", g.style.width = g.style.height = "10px", g.style.position = "absolute", g.style.top = g.style.left = "0px";
        for (const t of [
            e1.loadedName,
            o
        ]){
            const e1 = this._document.createElement("span");
            e1.textContent = "Hi", e1.style.fontFamily = t, g.append(e1);
        }
        this._document.body.append(g), function isFontReady(e1, t) {
            if (++r > 30) return warn("Load test font never loaded."), void t();
            s.font = "30px " + e1, s.fillText(".", 0, 20), s.getImageData(0, 0, 1, 1).data[3] > 0 ? t() : setTimeout(isFontReady.bind(null, e1, t));
        }(o, ()=>{
            g.remove(), t.complete();
        });
    }
}
class FontFaceObject {
    #Da;
    constructor(e1, t = null, i, n){
        this.compiledGlyphs = Object.create(null), this.#Da = e1, this._inspectFont = t, i && Object.assign(this, i), n && (this.charProcOperatorList = n);
    }
    createNativeFontFace() {
        if (!this.data || this.disableFontFace) return null;
        let e1;
        if (this.cssFontInfo) {
            const t = {
                weight: this.cssFontInfo.fontWeight
            };
            this.cssFontInfo.italicAngle && (t.style = `oblique ${this.cssFontInfo.italicAngle}deg`), e1 = new FontFace(this.cssFontInfo.fontFamily, this.data, t);
        } else e1 = new FontFace(this.loadedName, this.data, {});
        return this._inspectFont?.(this), e1;
    }
    createFontFaceRule() {
        if (!this.data || this.disableFontFace) return null;
        const e1 = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;
        let t;
        if (this.cssFontInfo) {
            let i = `font-weight: ${this.cssFontInfo.fontWeight};`;
            this.cssFontInfo.italicAngle && (i += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), t = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${i}src:${e1}}`;
        } else t = `@font-face {font-family:"${this.loadedName}";src:${e1}}`;
        return this._inspectFont?.(this, e1), t;
    }
    getPathGenerator(e1, t) {
        if (void 0 !== this.compiledGlyphs[t]) return this.compiledGlyphs[t];
        const i = this.loadedName + "_path_" + t;
        let n;
        try {
            n = e1.get(i);
        } catch (e1) {
            warn(`getPathGenerator - ignoring character: "${e1}".`);
        }
        const a = new Path2D(n || "");
        return this.fontExtraProperties || e1.delete(i), this.compiledGlyphs[t] = a;
    }
    get black() {
        return this.#Da.black;
    }
    get bold() {
        return this.#Da.bold;
    }
    get disableFontFace() {
        return this.#Da.disableFontFace ?? !1;
    }
    get fontExtraProperties() {
        return this.#Da.fontExtraProperties ?? !1;
    }
    get isInvalidPDFjsFont() {
        return this.#Da.isInvalidPDFjsFont;
    }
    get isType3Font() {
        return this.#Da.isType3Font;
    }
    get italic() {
        return this.#Da.italic;
    }
    get missingFile() {
        return this.#Da.missingFile;
    }
    get remeasure() {
        return this.#Da.remeasure;
    }
    get vertical() {
        return this.#Da.vertical;
    }
    get ascent() {
        return this.#Da.ascent;
    }
    get defaultWidth() {
        return this.#Da.defaultWidth;
    }
    get descent() {
        return this.#Da.descent;
    }
    get bbox() {
        return this.#Da.bbox;
    }
    get fontMatrix() {
        return this.#Da.fontMatrix;
    }
    get fallbackName() {
        return this.#Da.fallbackName;
    }
    get loadedName() {
        return this.#Da.loadedName;
    }
    get mimetype() {
        return this.#Da.mimetype;
    }
    get name() {
        return this.#Da.name;
    }
    get data() {
        return this.#Da.data;
    }
    clearData() {
        this.#Da.clearData();
    }
    get cssFontInfo() {
        return this.#Da.cssFontInfo;
    }
    get systemFontInfo() {
        return this.#Da.systemFontInfo;
    }
    get defaultVMetrics() {
        return this.#Da.defaultVMetrics;
    }
}
function getFactoryUrlProp(e1) {
    if ("string" != typeof e1) return null;
    if (e1.endsWith("/")) return e1;
    throw new Error(`Invalid factory url: "${e1}" must include trailing slash.`);
}
const isRefProxy = (e1)=>"object" == typeof e1 && Number.isInteger(e1?.num) && e1.num >= 0 && Number.isInteger(e1?.gen) && e1.gen >= 0, Cc = (function(e1, t, i) {
    if (!Array.isArray(i) || i.length < 2) return !1;
    const [n, a, ...s] = i;
    if (!e1(n) && !Number.isInteger(n)) return !1;
    if (!t(a)) return !1;
    const r = s.length;
    let o = !0;
    switch(a.name){
        case "XYZ":
            if (r < 2 || r > 3) return !1;
            break;
        case "Fit":
        case "FitB":
            return 0 === r;
        case "FitH":
        case "FitBH":
        case "FitV":
        case "FitBV":
            if (r > 1) return !1;
            break;
        case "FitR":
            if (4 !== r) return !1;
            o = !1;
            break;
        default:
            return !1;
    }
    for (const e1 of s)if (!("number" == typeof e1 || o && null === e1)) return !1;
    return !0;
}).bind(null, isRefProxy, (e1)=>"object" == typeof e1 && "string" == typeof e1?.name);
class LoopbackPort {
    #Oa = new Map;
    #_a = Promise.resolve();
    postMessage(e1, t) {
        const i = {
            data: structuredClone(e1, t ? {
                transfer: t
            } : null)
        };
        this.#_a.then(()=>{
            for (const [e1] of this.#Oa)e1.call(this, i);
        });
    }
    addEventListener(e1, t, i = null) {
        let n = null;
        if (i?.signal instanceof AbortSignal) {
            const { signal: a } = i;
            if (a.aborted) return void warn("LoopbackPort - cannot use an `aborted` signal.");
            const onAbort = ()=>this.removeEventListener(e1, t);
            n = ()=>a.removeEventListener("abort", onAbort), a.addEventListener("abort", onAbort);
        }
        this.#Oa.set(t, n);
    }
    removeEventListener(e1, t) {
        const i = this.#Oa.get(t);
        i?.(), this.#Oa.delete(t);
    }
    terminate() {
        for (const [, e1] of this.#Oa)e1?.();
        this.#Oa.clear();
    }
}
const kc = 1, Tc = 2, Fc = 1, Ic = 2, Ec = 3, Mc = 4, Dc = 5, Oc = 6, _c = 7, Pc = 8;
function onFn() {}
function wrapReason(e1) {
    if (e1 instanceof AbortException || e1 instanceof InvalidPDFException || e1 instanceof PasswordException || e1 instanceof ResponseException || e1 instanceof UnknownErrorException) return e1;
    switch(e1 instanceof Error || "object" == typeof e1 && null !== e1 || unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), e1.name){
        case "AbortException":
            return new AbortException(e1.message);
        case "InvalidPDFException":
            return new InvalidPDFException(e1.message);
        case "PasswordException":
            return new PasswordException(e1.message, e1.code);
        case "ResponseException":
            return new ResponseException(e1.message, e1.status, e1.missing);
        case "UnknownErrorException":
            return new UnknownErrorException(e1.message, e1.details);
    }
    return new UnknownErrorException(e1.message, e1.toString());
}
class MessageHandler {
    #rt = new AbortController;
    constructor(e1, t, i){
        this.sourceName = e1, this.targetName = t, this.comObj = i, this.callbackId = 1, this.streamId = 1, this.streamSinks = Object.create(null), this.streamControllers = Object.create(null), this.callbackCapabilities = Object.create(null), this.actionHandler = Object.create(null), i.addEventListener("message", this.#ot.bind(this), {
            signal: this.#rt.signal
        });
    }
    #ot({ data: e1 }) {
        if (e1.targetName !== this.sourceName) return;
        if (e1.stream) return void this.#lt(e1);
        if (e1.callback) {
            const t = e1.callbackId, i = this.callbackCapabilities[t];
            if (!i) throw new Error(`Cannot resolve callback ${t}`);
            if (delete this.callbackCapabilities[t], e1.callback === kc) i.resolve(e1.data);
            else {
                if (e1.callback !== Tc) throw new Error("Unexpected callback case");
                i.reject(wrapReason(e1.reason));
            }
            return;
        }
        const t = this.actionHandler[e1.action];
        if (!t) throw new Error(`Unknown action from worker: ${e1.action}`);
        if (e1.callbackId) {
            const i = this.sourceName, n = e1.sourceName, a = this.comObj;
            return void Promise.try(t, e1.data).then(function(t) {
                a.postMessage({
                    sourceName: i,
                    targetName: n,
                    callback: kc,
                    callbackId: e1.callbackId,
                    data: t
                });
            }, function(t) {
                a.postMessage({
                    sourceName: i,
                    targetName: n,
                    callback: Tc,
                    callbackId: e1.callbackId,
                    reason: wrapReason(t)
                });
            });
        }
        e1.streamId ? this.#ct(e1) : t(e1.data);
    }
    on(e1, t) {
        const i = this.actionHandler;
        if (i[e1]) throw new Error(`There is already an actionName called "${e1}"`);
        i[e1] = t;
    }
    send(e1, t, i) {
        this.comObj.postMessage({
            sourceName: this.sourceName,
            targetName: this.targetName,
            action: e1,
            data: t
        }, i);
    }
    sendWithPromise(e1, t, i) {
        const n = this.callbackId++, a = Promise.withResolvers();
        this.callbackCapabilities[n] = a;
        try {
            this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: e1,
                callbackId: n,
                data: t
            }, i);
        } catch (e1) {
            a.reject(e1);
        }
        return a.promise;
    }
    sendWithStream(e1, t, i, n) {
        const a = this.streamId++, s = this.sourceName, r = this.targetName, o = this.comObj;
        return new ReadableStream({
            start: (i)=>{
                const l = Promise.withResolvers();
                return this.streamControllers[a] = {
                    controller: i,
                    startCall: l,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                }, o.postMessage({
                    sourceName: s,
                    targetName: r,
                    action: e1,
                    streamId: a,
                    data: t,
                    desiredSize: i.desiredSize
                }, n), l.promise;
            },
            pull: (e1)=>{
                const t = Promise.withResolvers();
                return this.streamControllers[a].pullCall = t, o.postMessage({
                    sourceName: s,
                    targetName: r,
                    stream: Oc,
                    streamId: a,
                    desiredSize: e1.desiredSize
                }), t.promise;
            },
            cancel: (e1)=>{
                assert(e1 instanceof Error, "cancel must have a valid reason");
                const t = Promise.withResolvers();
                return this.streamControllers[a].cancelCall = t, this.streamControllers[a].isClosed = !0, o.postMessage({
                    sourceName: s,
                    targetName: r,
                    stream: Fc,
                    streamId: a,
                    reason: wrapReason(e1)
                }), t.promise;
            }
        }, i);
    }
    #ct(e1) {
        const t = e1.streamId, i = this.sourceName, n = e1.sourceName, a = this.comObj, s = this, r = this.actionHandler[e1.action], o = {
            enqueue (e1, s = 1, r) {
                if (this.isCancelled) return;
                const o = this.desiredSize;
                this.desiredSize -= s, o > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), a.postMessage({
                    sourceName: i,
                    targetName: n,
                    stream: Mc,
                    streamId: t,
                    chunk: e1
                }, r);
            },
            close () {
                this.isCancelled || (this.isCancelled = !0, a.postMessage({
                    sourceName: i,
                    targetName: n,
                    stream: Ec,
                    streamId: t
                }), delete s.streamSinks[t]);
            },
            error (e1) {
                assert(e1 instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = !0, a.postMessage({
                    sourceName: i,
                    targetName: n,
                    stream: Dc,
                    streamId: t,
                    reason: wrapReason(e1)
                }));
            },
            sinkCapability: Promise.withResolvers(),
            onPull: null,
            onCancel: null,
            isCancelled: !1,
            desiredSize: e1.desiredSize,
            ready: null
        };
        o.sinkCapability.resolve(), o.ready = o.sinkCapability.promise, this.streamSinks[t] = o, Promise.try(r, e1.data, o).then(function() {
            a.postMessage({
                sourceName: i,
                targetName: n,
                stream: Pc,
                streamId: t,
                success: !0
            });
        }, function(e1) {
            a.postMessage({
                sourceName: i,
                targetName: n,
                stream: Pc,
                streamId: t,
                reason: wrapReason(e1)
            });
        });
    }
    #lt(e1) {
        const t = e1.streamId, i = this.sourceName, n = e1.sourceName, a = this.comObj, s = this.streamControllers[t], r = this.streamSinks[t];
        switch(e1.stream){
            case Pc:
                e1.success ? s.startCall.resolve() : s.startCall.reject(wrapReason(e1.reason));
                break;
            case _c:
                e1.success ? s.pullCall.resolve() : s.pullCall.reject(wrapReason(e1.reason));
                break;
            case Oc:
                if (!r) {
                    a.postMessage({
                        sourceName: i,
                        targetName: n,
                        stream: _c,
                        streamId: t,
                        success: !0
                    });
                    break;
                }
                r.desiredSize <= 0 && e1.desiredSize > 0 && r.sinkCapability.resolve(), r.desiredSize = e1.desiredSize, Promise.try(r.onPull || onFn).then(function() {
                    a.postMessage({
                        sourceName: i,
                        targetName: n,
                        stream: _c,
                        streamId: t,
                        success: !0
                    });
                }, function(e1) {
                    a.postMessage({
                        sourceName: i,
                        targetName: n,
                        stream: _c,
                        streamId: t,
                        reason: wrapReason(e1)
                    });
                });
                break;
            case Mc:
                if (assert(s, "enqueue should have stream controller"), s.isClosed) break;
                s.controller.enqueue(e1.chunk);
                break;
            case Ec:
                if (assert(s, "close should have stream controller"), s.isClosed) break;
                s.isClosed = !0, s.controller.close(), this.#ht(s, t);
                break;
            case Dc:
                assert(s, "error should have stream controller"), s.controller.error(wrapReason(e1.reason)), this.#ht(s, t);
                break;
            case Ic:
                e1.success ? s.cancelCall.resolve() : s.cancelCall.reject(wrapReason(e1.reason)), this.#ht(s, t);
                break;
            case Fc:
                if (!r) break;
                const o = wrapReason(e1.reason);
                Promise.try(r.onCancel || onFn, o).then(function() {
                    a.postMessage({
                        sourceName: i,
                        targetName: n,
                        stream: Ic,
                        streamId: t,
                        success: !0
                    });
                }, function(e1) {
                    a.postMessage({
                        sourceName: i,
                        targetName: n,
                        stream: Ic,
                        streamId: t,
                        reason: wrapReason(e1)
                    });
                }), r.sinkCapability.reject(o), r.isCancelled = !0, delete this.streamSinks[t];
                break;
            default:
                throw new Error("Unexpected stream case");
        }
    }
    async #ht(e1, t) {
        await Promise.allSettled([
            e1.startCall?.promise,
            e1.pullCall?.promise,
            e1.cancelCall?.promise
        ]), delete this.streamControllers[t];
    }
    destroy() {
        this.#rt?.abort(), this.#rt = null;
    }
}
class BaseCanvasFactory {
    #Pa = !1;
    constructor({ enableHWA: e1 = !1 }){
        this.#Pa = e1;
    }
    create(e1, t) {
        if (e1 <= 0 || t <= 0) throw new Error("Invalid canvas size");
        const i = this._createCanvas(e1, t);
        return {
            canvas: i,
            context: i.getContext("2d", {
                willReadFrequently: !this.#Pa
            })
        };
    }
    reset(e1, t, i) {
        if (!e1.canvas) throw new Error("Canvas is not specified");
        if (t <= 0 || i <= 0) throw new Error("Invalid canvas size");
        e1.canvas.width = t, e1.canvas.height = i;
    }
    destroy(e1) {
        if (!e1.canvas) throw new Error("Canvas is not specified");
        e1.canvas.width = 0, e1.canvas.height = 0, e1.canvas = null, e1.context = null;
    }
    _createCanvas(e1, t) {
        unreachable("Abstract method `_createCanvas` called.");
    }
}
class DOMCanvasFactory extends BaseCanvasFactory {
    constructor({ ownerDocument: e1 = globalThis.document, enableHWA: t = !1 }){
        super({
            enableHWA: t
        }), this._document = e1;
    }
    _createCanvas(e1, t) {
        const i = this._document.createElement("canvas");
        return i.width = e1, i.height = t, i;
    }
}
class BaseCMapReaderFactory {
    constructor({ baseUrl: e1 = null, isCompressed: t = !0 }){
        this.baseUrl = e1, this.isCompressed = t;
    }
    async fetch({ name: e1 }) {
        if (!this.baseUrl) throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
        if (!e1) throw new Error("CMap name must be specified.");
        const t = this.baseUrl + e1 + (this.isCompressed ? ".bcmap" : "");
        return this._fetch(t).then((e1)=>({
                cMapData: e1,
                isCompressed: this.isCompressed
            })).catch((e1)=>{
            throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${t}`);
        });
    }
    async _fetch(e1) {
        unreachable("Abstract method `_fetch` called.");
    }
}
class DOMCMapReaderFactory extends BaseCMapReaderFactory {
    async _fetch(e1) {
        const t = await fetchData(e1, this.isCompressed ? "arraybuffer" : "text");
        return t instanceof ArrayBuffer ? new Uint8Array(t) : stringToBytes(t);
    }
}
class BaseFilterFactory {
    addFilter(e1) {
        return "none";
    }
    addHCMFilter(e1, t) {
        return "none";
    }
    addAlphaFilter(e1) {
        return "none";
    }
    addLuminosityFilter(e1) {
        return "none";
    }
    addHighlightHCMFilter(e1, t, i, n, a) {
        return "none";
    }
    destroy(e1 = !1) {}
}
class DOMFilterFactory extends BaseFilterFactory {
    #Ra;
    #Ba;
    #Na;
    #La;
    #Ua;
    #ja;
    #Mt = 0;
    constructor({ docId: e1, ownerDocument: t = globalThis.document }){
        super(), this.#La = e1, this.#Ua = t;
    }
    get #Ot() {
        return this.#Ba ||= new Map;
    }
    get #$a() {
        return this.#ja ||= new Map;
    }
    get #Ha() {
        if (!this.#Na) {
            const e1 = this.#Ua.createElement("div"), { style: t } = e1;
            t.visibility = "hidden", t.contain = "strict", t.width = t.height = 0, t.position = "absolute", t.top = t.left = 0, t.zIndex = -1;
            const i = this.#Ua.createElementNS(bc, "svg");
            i.setAttribute("width", 0), i.setAttribute("height", 0), this.#Na = this.#Ua.createElementNS(bc, "defs"), e1.append(i), i.append(this.#Na), this.#Ua.body.append(e1);
        }
        return this.#Na;
    }
    #Xa(e1) {
        if (1 === e1.length) {
            const t = e1[0], i = new Array(256);
            for(let e1 = 0; e1 < 256; e1++)i[e1] = t[e1] / 255;
            const n = i.join(",");
            return [
                n,
                n,
                n
            ];
        }
        const [t, i, n] = e1, a = new Array(256), s = new Array(256), r = new Array(256);
        for(let e1 = 0; e1 < 256; e1++)a[e1] = t[e1] / 255, s[e1] = i[e1] / 255, r[e1] = n[e1] / 255;
        return [
            a.join(","),
            s.join(","),
            r.join(",")
        ];
    }
    #qa(e1) {
        if (void 0 === this.#Ra) {
            this.#Ra = "";
            const e1 = this.#Ua.URL;
            e1 !== this.#Ua.baseURI && (isDataScheme(e1) ? warn('#createUrl: ignore "data:"-URL for performance reasons.') : this.#Ra = updateUrlHash(e1, ""));
        }
        return `url(${this.#Ra}#${e1})`;
    }
    addFilter(e1) {
        if (!e1) return "none";
        let t = this.#Ot.get(e1);
        if (t) return t;
        const [i, n, a] = this.#Xa(e1), s = 1 === e1.length ? i : `${i}${n}${a}`;
        if (t = this.#Ot.get(s), t) return this.#Ot.set(e1, t), t;
        const r = `g_${this.#La}_transfer_map_${this.#Mt++}`, o = this.#qa(r);
        this.#Ot.set(e1, o), this.#Ot.set(s, o);
        const l = this.#za(r);
        return this.#Wa(i, n, a, l), o;
    }
    addHCMFilter(e1, t) {
        const i = `${e1}-${t}`, n = "base";
        let a = this.#$a.get(n);
        if (a?.key === i) return a.url;
        if (a ? (a.filter?.remove(), a.key = i, a.url = "none", a.filter = null) : (a = {
            key: i,
            url: "none",
            filter: null
        }, this.#$a.set(n, a)), !e1 || !t) return a.url;
        const s = this.#Ga(e1);
        e1 = Util.makeHexColor(...s);
        const r = this.#Ga(t);
        if (t = Util.makeHexColor(...r), this.#Ha.style.color = "", "#000000" === e1 && "#ffffff" === t || e1 === t) return a.url;
        const o = new Array(256);
        for(let e1 = 0; e1 <= 255; e1++){
            const t = e1 / 255;
            o[e1] = t <= .03928 ? t / 12.92 : ((t + .055) / 1.055) ** 2.4;
        }
        const l = o.join(","), c = `g_${this.#La}_hcm_filter`, h = a.filter = this.#za(c);
        this.#Wa(l, l, l, h), this.#Va(h);
        const getSteps = (e1, t)=>{
            const i = s[e1] / 255, n = r[e1] / 255, a = new Array(t + 1);
            for(let e1 = 0; e1 <= t; e1++)a[e1] = i + e1 / t * (n - i);
            return a.join(",");
        };
        return this.#Wa(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), h), a.url = this.#qa(c), a.url;
    }
    addAlphaFilter(e1) {
        let t = this.#Ot.get(e1);
        if (t) return t;
        const [i] = this.#Xa([
            e1
        ]), n = `alpha_${i}`;
        if (t = this.#Ot.get(n), t) return this.#Ot.set(e1, t), t;
        const a = `g_${this.#La}_alpha_map_${this.#Mt++}`, s = this.#qa(a);
        this.#Ot.set(e1, s), this.#Ot.set(n, s);
        const r = this.#za(a);
        return this.#Ka(i, r), s;
    }
    addLuminosityFilter(e1) {
        let t, i, n = this.#Ot.get(e1 || "luminosity");
        if (n) return n;
        if (e1 ? ([t] = this.#Xa([
            e1
        ]), i = `luminosity_${t}`) : i = "luminosity", n = this.#Ot.get(i), n) return this.#Ot.set(e1, n), n;
        const a = `g_${this.#La}_luminosity_map_${this.#Mt++}`, s = this.#qa(a);
        this.#Ot.set(e1, s), this.#Ot.set(i, s);
        const r = this.#za(a);
        return this.#Ya(r), e1 && this.#Ka(t, r), s;
    }
    addHighlightHCMFilter(e1, t, i, n, a) {
        const s = `${t}-${i}-${n}-${a}`;
        let r = this.#$a.get(e1);
        if (r?.key === s) return r.url;
        if (r ? (r.filter?.remove(), r.key = s, r.url = "none", r.filter = null) : (r = {
            key: s,
            url: "none",
            filter: null
        }, this.#$a.set(e1, r)), !t || !i) return r.url;
        const [o, l] = [
            t,
            i
        ].map(this.#Ga.bind(this));
        let c = Math.round(.2126 * o[0] + .7152 * o[1] + .0722 * o[2]), h = Math.round(.2126 * l[0] + .7152 * l[1] + .0722 * l[2]), [d, u] = [
            n,
            a
        ].map(this.#Ga.bind(this));
        h < c && ([c, h, d, u] = [
            h,
            c,
            u,
            d
        ]), this.#Ha.style.color = "";
        const getSteps = (e1, t, i)=>{
            const n = new Array(256), a = (h - c) / i, s = e1 / 255, r = (t - e1) / (255 * i);
            let o = 0;
            for(let e1 = 0; e1 <= i; e1++){
                const t = Math.round(c + e1 * a), i = s + e1 * r;
                for(let e1 = o; e1 <= t; e1++)n[e1] = i;
                o = t + 1;
            }
            for(let e1 = o; e1 < 256; e1++)n[e1] = n[o - 1];
            return n.join(",");
        }, g = `g_${this.#La}_hcm_${e1}_filter`, f = r.filter = this.#za(g);
        return this.#Va(f), this.#Wa(getSteps(d[0], u[0], 5), getSteps(d[1], u[1], 5), getSteps(d[2], u[2], 5), f), r.url = this.#qa(g), r.url;
    }
    destroy(e1 = !1) {
        e1 && this.#ja?.size || (this.#Na?.parentNode.parentNode.remove(), this.#Na = null, this.#Ba?.clear(), this.#Ba = null, this.#ja?.clear(), this.#ja = null, this.#Mt = 0);
    }
    #Ya(e1) {
        const t = this.#Ua.createElementNS(bc, "feColorMatrix");
        t.setAttribute("type", "matrix"), t.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), e1.append(t);
    }
    #Va(e1) {
        const t = this.#Ua.createElementNS(bc, "feColorMatrix");
        t.setAttribute("type", "matrix"), t.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), e1.append(t);
    }
    #za(e1) {
        const t = this.#Ua.createElementNS(bc, "filter");
        return t.setAttribute("color-interpolation-filters", "sRGB"), t.setAttribute("id", e1), this.#Ha.append(t), t;
    }
    #Ja(e1, t, i) {
        const n = this.#Ua.createElementNS(bc, t);
        n.setAttribute("type", "discrete"), n.setAttribute("tableValues", i), e1.append(n);
    }
    #Wa(e1, t, i, n) {
        const a = this.#Ua.createElementNS(bc, "feComponentTransfer");
        n.append(a), this.#Ja(a, "feFuncR", e1), this.#Ja(a, "feFuncG", t), this.#Ja(a, "feFuncB", i);
    }
    #Ka(e1, t) {
        const i = this.#Ua.createElementNS(bc, "feComponentTransfer");
        t.append(i), this.#Ja(i, "feFuncA", e1);
    }
    #Ga(e1) {
        return this.#Ha.style.color = e1, getRGB(getComputedStyle(this.#Ha).getPropertyValue("color"));
    }
}
class BaseStandardFontDataFactory {
    constructor({ baseUrl: e1 = null }){
        this.baseUrl = e1;
    }
    async fetch({ filename: e1 }) {
        if (!this.baseUrl) throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
        if (!e1) throw new Error("Font filename must be specified.");
        const t = `${this.baseUrl}${e1}`;
        return this._fetch(t).catch((e1)=>{
            throw new Error(`Unable to load font data at: ${t}`);
        });
    }
    async _fetch(e1) {
        unreachable("Abstract method `_fetch` called.");
    }
}
class DOMStandardFontDataFactory extends BaseStandardFontDataFactory {
    async _fetch(e1) {
        const t = await fetchData(e1, "arraybuffer");
        return new Uint8Array(t);
    }
}
class BaseWasmFactory {
    constructor({ baseUrl: e1 = null }){
        this.baseUrl = e1;
    }
    async fetch({ filename: e1 }) {
        if (!this.baseUrl) throw new Error("Ensure that the `wasmUrl` API parameter is provided.");
        if (!e1) throw new Error("Wasm filename must be specified.");
        const t = `${this.baseUrl}${e1}`;
        return this._fetch(t).catch((e1)=>{
            throw new Error(`Unable to load wasm data at: ${t}`);
        });
    }
    async _fetch(e1) {
        unreachable("Abstract method `_fetch` called.");
    }
}
class DOMWasmFactory extends BaseWasmFactory {
    async _fetch(e1) {
        const t = await fetchData(e1, "arraybuffer");
        return new Uint8Array(t);
    }
}
async function node_utils_fetchData(e1) {
    const t = process.getBuiltinModule("fs"), i = await t.promises.readFile(e1);
    return new Uint8Array(i);
}
class NodeFilterFactory extends BaseFilterFactory {
}
class NodeCanvasFactory extends BaseCanvasFactory {
    _createCanvas(e1, t) {
        process.getBuiltinModule("module").createRequire(__TURBOPACK__import$2e$meta__.url);
        return new Proxy({}, {
            get: (e1, t)=>()=>{
                    throw new Error("@napi-rs/canvas is not available in this environment");
                }
        }).createCanvas(e1, t);
    }
}
class NodeCMapReaderFactory extends BaseCMapReaderFactory {
    async _fetch(e1) {
        return node_utils_fetchData(e1);
    }
}
class NodeStandardFontDataFactory extends BaseStandardFontDataFactory {
    async _fetch(e1) {
        return node_utils_fetchData(e1);
    }
}
class NodeWasmFactory extends BaseWasmFactory {
    async _fetch(e1) {
        return node_utils_fetchData(e1);
    }
}
const Rc = "__forcedDependency", { floor: Bc, ceil: Nc } = Math;
function expandBBox(e1, t, i, n, a, s) {
    e1[4 * t + 0] = Math.min(e1[4 * t + 0], i), e1[4 * t + 1] = Math.min(e1[4 * t + 1], n), e1[4 * t + 2] = Math.max(e1[4 * t + 2], a), e1[4 * t + 3] = Math.max(e1[4 * t + 3], s);
}
const Lc = new Uint32Array(new Uint8Array([
    255,
    255,
    0,
    0
]).buffer)[0];
class BBoxReader {
    #Za;
    #Qa;
    constructor(e1, t){
        this.#Za = e1, this.#Qa = t;
    }
    get length() {
        return this.#Za.length;
    }
    isEmpty(e1) {
        return this.#Za[e1] === Lc;
    }
    minX(e1) {
        return this.#Qa[4 * e1 + 0] / 256;
    }
    minY(e1) {
        return this.#Qa[4 * e1 + 1] / 256;
    }
    maxX(e1) {
        return (this.#Qa[4 * e1 + 2] + 1) / 256;
    }
    maxY(e1) {
        return (this.#Qa[4 * e1 + 3] + 1) / 256;
    }
}
const ensureDebugMetadata = (e1, t)=>{
    if (!e1) return;
    let i = e1.get(t);
    return i || (i = {
        dependencies: new Set,
        isRenderingOperation: !1
    }, e1.set(t, i)), i;
};
class CanvasDependencyTracker {
    #es = {
        __proto__: null
    };
    #ts = {
        __proto__: null,
        transform: [],
        moveText: [],
        sameLineText: [],
        [Rc]: []
    };
    #is = new Map;
    #ns = [];
    #as = [];
    #ss = [
        [
            1,
            0,
            0,
            1,
            0,
            0
        ]
    ];
    #rs = [
        -1 / 0,
        -1 / 0,
        1 / 0,
        1 / 0
    ];
    #os = new Float64Array([
        1 / 0,
        1 / 0,
        -1 / 0,
        -1 / 0
    ]);
    #ls = -1;
    #cs = new Set;
    #hs = new Map;
    #ds = new Map;
    #us;
    #gs;
    #fs;
    #Za;
    #ps;
    constructor(e1, t, i = !1){
        this.#us = e1.width, this.#gs = e1.height, this.#ms(t), i && (this.#ps = new Map);
    }
    growOperationsCount(e1) {
        e1 >= this.#Za.length && this.#ms(e1, this.#Za);
    }
    #ms(e1, t) {
        const i = new ArrayBuffer(4 * e1);
        this.#fs = new Uint8ClampedArray(i), this.#Za = new Uint32Array(i), t && t.length > 0 ? (this.#Za.set(t), this.#Za.fill(Lc, t.length)) : this.#Za.fill(Lc);
    }
    save(e1) {
        return this.#es = {
            __proto__: this.#es
        }, this.#ts = {
            __proto__: this.#ts,
            transform: {
                __proto__: this.#ts.transform
            },
            moveText: {
                __proto__: this.#ts.moveText
            },
            sameLineText: {
                __proto__: this.#ts.sameLineText
            },
            [Rc]: {
                __proto__: this.#ts[Rc]
            }
        }, this.#rs = {
            __proto__: this.#rs
        }, this.#ns.push(e1), this;
    }
    restore(e1) {
        const t = Object.getPrototypeOf(this.#es);
        if (null === t) return this;
        this.#es = t, this.#ts = Object.getPrototypeOf(this.#ts), this.#rs = Object.getPrototypeOf(this.#rs);
        const i = this.#ns.pop();
        return void 0 !== i && (ensureDebugMetadata(this.#ps, e1)?.dependencies.add(i), this.#Za[e1] = this.#Za[i]), this;
    }
    recordOpenMarker(e1) {
        return this.#ns.push(e1), this;
    }
    getOpenMarker() {
        return 0 === this.#ns.length ? null : this.#ns.at(-1);
    }
    recordCloseMarker(e1) {
        const t = this.#ns.pop();
        return void 0 !== t && (ensureDebugMetadata(this.#ps, e1)?.dependencies.add(t), this.#Za[e1] = this.#Za[t]), this;
    }
    beginMarkedContent(e1) {
        return this.#as.push(e1), this;
    }
    endMarkedContent(e1) {
        const t = this.#as.pop();
        return void 0 !== t && (ensureDebugMetadata(this.#ps, e1)?.dependencies.add(t), this.#Za[e1] = this.#Za[t]), this;
    }
    pushBaseTransform(e1) {
        return this.#ss.push(Util.multiplyByDOMMatrix(this.#ss.at(-1), e1.getTransform())), this;
    }
    popBaseTransform() {
        return this.#ss.length > 1 && this.#ss.pop(), this;
    }
    recordSimpleData(e1, t) {
        return this.#es[e1] = t, this;
    }
    recordIncrementalData(e1, t) {
        return this.#ts[e1].push(t), this;
    }
    resetIncrementalData(e1, t) {
        return this.#ts[e1].length = 0, this;
    }
    recordNamedData(e1, t) {
        return this.#is.set(e1, t), this;
    }
    recordSimpleDataFromNamed(e1, t, i) {
        this.#es[e1] = this.#is.get(t) ?? i;
    }
    recordFutureForcedDependency(e1, t) {
        return this.recordIncrementalData(Rc, t), this;
    }
    inheritSimpleDataAsFutureForcedDependencies(e1) {
        for (const t of e1)t in this.#es && this.recordFutureForcedDependency(t, this.#es[t]);
        return this;
    }
    inheritPendingDependenciesAsFutureForcedDependencies() {
        for (const e1 of this.#cs)this.recordFutureForcedDependency(Rc, e1);
        return this;
    }
    resetBBox(e1) {
        return this.#ls !== e1 && (this.#ls = e1, this.#os[0] = 1 / 0, this.#os[1] = 1 / 0, this.#os[2] = -1 / 0, this.#os[3] = -1 / 0), this;
    }
    recordClipBox(e1, t, i, n, a, s) {
        const r = Util.multiplyByDOMMatrix(this.#ss.at(-1), t.getTransform()), o = [
            1 / 0,
            1 / 0,
            -1 / 0,
            -1 / 0
        ];
        Util.axialAlignedBoundingBox([
            i,
            a,
            n,
            s
        ], r, o);
        const l = Util.intersect(this.#rs, o);
        return l ? (this.#rs[0] = l[0], this.#rs[1] = l[1], this.#rs[2] = l[2], this.#rs[3] = l[3]) : (this.#rs[0] = this.#rs[1] = 1 / 0, this.#rs[2] = this.#rs[3] = -1 / 0), this;
    }
    recordBBox(e1, t, i, n, a, s) {
        const r = this.#rs;
        if (r[0] === 1 / 0) return this;
        const o = Util.multiplyByDOMMatrix(this.#ss.at(-1), t.getTransform());
        if (r[0] === -1 / 0) return Util.axialAlignedBoundingBox([
            i,
            a,
            n,
            s
        ], o, this.#os), this;
        const l = [
            1 / 0,
            1 / 0,
            -1 / 0,
            -1 / 0
        ];
        return Util.axialAlignedBoundingBox([
            i,
            a,
            n,
            s
        ], o, l), this.#os[0] = Math.min(this.#os[0], Math.max(l[0], r[0])), this.#os[1] = Math.min(this.#os[1], Math.max(l[1], r[1])), this.#os[2] = Math.max(this.#os[2], Math.min(l[2], r[2])), this.#os[3] = Math.max(this.#os[3], Math.min(l[3], r[3])), this;
    }
    recordCharacterBBox(e1, t, i, n = 1, a = 0, s = 0, r) {
        const o = i.bbox;
        let l, c;
        if (o && (l = o[2] !== o[0] && o[3] !== o[1] && this.#ds.get(i), !1 !== l && (c = [
            0,
            0,
            0,
            0
        ], Util.axialAlignedBoundingBox(o, i.fontMatrix, c), 1 === n && 0 === a && 0 === s || Util.scaleMinMax([
            n,
            0,
            0,
            -n,
            a,
            s
        ], c), l))) return this.recordBBox(e1, t, c[0], c[2], c[1], c[3]);
        if (!r) return this.recordFullPageBBox(e1);
        const h = r();
        return o && c && void 0 === l && (l = c[0] <= a - h.actualBoundingBoxLeft && c[2] >= a + h.actualBoundingBoxRight && c[1] <= s - h.actualBoundingBoxAscent && c[3] >= s + h.actualBoundingBoxDescent, this.#ds.set(i, l), l) ? this.recordBBox(e1, t, c[0], c[2], c[1], c[3]) : this.recordBBox(e1, t, a - h.actualBoundingBoxLeft, a + h.actualBoundingBoxRight, s - h.actualBoundingBoxAscent, s + h.actualBoundingBoxDescent);
    }
    recordFullPageBBox(e1) {
        return this.#os[0] = Math.max(0, this.#rs[0]), this.#os[1] = Math.max(0, this.#rs[1]), this.#os[2] = Math.min(this.#us, this.#rs[2]), this.#os[3] = Math.min(this.#gs, this.#rs[3]), this;
    }
    getSimpleIndex(e1) {
        return this.#es[e1];
    }
    recordDependencies(e1, t) {
        const i = this.#cs, n = this.#es, a = this.#ts;
        for (const e1 of t)e1 in this.#es ? i.add(n[e1]) : e1 in a && a[e1].forEach(i.add, i);
        return this;
    }
    recordNamedDependency(e1, t) {
        return this.#is.has(t) && this.#cs.add(this.#is.get(t)), this;
    }
    recordOperation(e1, t = !1) {
        if (this.recordDependencies(e1, [
            Rc
        ]), this.#ps) {
            const t = ensureDebugMetadata(this.#ps, e1), { dependencies: i } = t;
            this.#cs.forEach(i.add, i), this.#ns.forEach(i.add, i), this.#as.forEach(i.add, i), i.delete(e1), t.isRenderingOperation = !0;
        }
        if (this.#ls === e1) {
            const i = Bc(256 * this.#os[0] / this.#us), n = Bc(256 * this.#os[1] / this.#gs), a = Nc(256 * this.#os[2] / this.#us), s = Nc(256 * this.#os[3] / this.#gs);
            expandBBox(this.#fs, e1, i, n, a, s);
            for (const t of this.#cs)t !== e1 && expandBBox(this.#fs, t, i, n, a, s);
            for (const t of this.#ns)t !== e1 && expandBBox(this.#fs, t, i, n, a, s);
            for (const t of this.#as)t !== e1 && expandBBox(this.#fs, t, i, n, a, s);
            t || (this.#cs.clear(), this.#ls = -1);
        }
        return this;
    }
    recordShowTextOperation(e1, t = !1) {
        const i = Array.from(this.#cs);
        this.recordOperation(e1, t), this.recordIncrementalData("sameLineText", e1);
        for (const e1 of i)this.recordIncrementalData("sameLineText", e1);
        return this;
    }
    bboxToClipBoxDropOperation(e1, t = !1) {
        return this.#ls === e1 && (this.#ls = -1, this.#rs[0] = Math.max(this.#rs[0], this.#os[0]), this.#rs[1] = Math.max(this.#rs[1], this.#os[1]), this.#rs[2] = Math.min(this.#rs[2], this.#os[2]), this.#rs[3] = Math.min(this.#rs[3], this.#os[3]), t || this.#cs.clear()), this;
    }
    _takePendingDependencies() {
        const e1 = this.#cs;
        return this.#cs = new Set, e1;
    }
    _extractOperation(e1) {
        const t = this.#hs.get(e1);
        return this.#hs.delete(e1), t;
    }
    _pushPendingDependencies(e1) {
        for (const t of e1)this.#cs.add(t);
    }
    take() {
        return this.#ds.clear(), new BBoxReader(this.#Za, this.#fs);
    }
    takeDebugMetadata() {
        return this.#ps;
    }
}
class CanvasNestedDependencyTracker {
    #bs;
    #ys;
    #ws;
    #As = 0;
    #xs = 0;
    constructor(e1, t, i){
        if (e1 instanceof CanvasNestedDependencyTracker && e1.#ws === !!i) return e1;
        this.#bs = e1, this.#ys = t, this.#ws = !!i;
    }
    growOperationsCount() {
        throw new Error("Unreachable");
    }
    save(e1) {
        return this.#xs++, this.#bs.save(this.#ys), this;
    }
    restore(e1) {
        return this.#xs > 0 && (this.#bs.restore(this.#ys), this.#xs--), this;
    }
    recordOpenMarker(e1) {
        return this.#As++, this;
    }
    getOpenMarker() {
        return this.#As > 0 ? this.#ys : this.#bs.getOpenMarker();
    }
    recordCloseMarker(e1) {
        return this.#As--, this;
    }
    beginMarkedContent(e1) {
        return this;
    }
    endMarkedContent(e1) {
        return this;
    }
    pushBaseTransform(e1) {
        return this.#bs.pushBaseTransform(e1), this;
    }
    popBaseTransform() {
        return this.#bs.popBaseTransform(), this;
    }
    recordSimpleData(e1, t) {
        return this.#bs.recordSimpleData(e1, this.#ys), this;
    }
    recordIncrementalData(e1, t) {
        return this.#bs.recordIncrementalData(e1, this.#ys), this;
    }
    resetIncrementalData(e1, t) {
        return this.#bs.resetIncrementalData(e1, this.#ys), this;
    }
    recordNamedData(e1, t) {
        return this;
    }
    recordSimpleDataFromNamed(e1, t, i) {
        return this.#bs.recordSimpleDataFromNamed(e1, t, this.#ys), this;
    }
    recordFutureForcedDependency(e1, t) {
        return this.#bs.recordFutureForcedDependency(e1, this.#ys), this;
    }
    inheritSimpleDataAsFutureForcedDependencies(e1) {
        return this.#bs.inheritSimpleDataAsFutureForcedDependencies(e1), this;
    }
    inheritPendingDependenciesAsFutureForcedDependencies() {
        return this.#bs.inheritPendingDependenciesAsFutureForcedDependencies(), this;
    }
    resetBBox(e1) {
        return this.#ws || this.#bs.resetBBox(this.#ys), this;
    }
    recordClipBox(e1, t, i, n, a, s) {
        return this.#ws || this.#bs.recordClipBox(this.#ys, t, i, n, a, s), this;
    }
    recordBBox(e1, t, i, n, a, s) {
        return this.#ws || this.#bs.recordBBox(this.#ys, t, i, n, a, s), this;
    }
    recordCharacterBBox(e1, t, i, n, a, s, r) {
        return this.#ws || this.#bs.recordCharacterBBox(this.#ys, t, i, n, a, s, r), this;
    }
    recordFullPageBBox(e1) {
        return this.#ws || this.#bs.recordFullPageBBox(this.#ys), this;
    }
    getSimpleIndex(e1) {
        return this.#bs.getSimpleIndex(e1);
    }
    recordDependencies(e1, t) {
        return this.#bs.recordDependencies(this.#ys, t), this;
    }
    recordNamedDependency(e1, t) {
        return this.#bs.recordNamedDependency(this.#ys, t), this;
    }
    recordOperation(e1) {
        return this.#bs.recordOperation(this.#ys, !0), this;
    }
    recordShowTextOperation(e1) {
        return this.#bs.recordShowTextOperation(this.#ys, !0), this;
    }
    bboxToClipBoxDropOperation(e1) {
        return this.#ws || this.#bs.bboxToClipBoxDropOperation(this.#ys, !0), this;
    }
    take() {
        throw new Error("Unreachable");
    }
    takeDebugMetadata() {
        throw new Error("Unreachable");
    }
}
const Uc = [
    "path",
    "transform",
    "filter",
    "strokeColor",
    "strokeAlpha",
    "lineWidth",
    "lineCap",
    "lineJoin",
    "miterLimit",
    "dash"
], jc = [
    "path",
    "transform",
    "filter",
    "fillColor",
    "fillAlpha",
    "globalCompositeOperation",
    "SMask"
], $c = [
    "transform",
    "SMask",
    "filter",
    "fillAlpha",
    "strokeAlpha",
    "globalCompositeOperation"
], Hc = [
    "filter",
    "fillColor",
    "fillAlpha"
], Xc = [
    "transform",
    "leading",
    "charSpacing",
    "wordSpacing",
    "hScale",
    "textRise",
    "moveText",
    "textMatrix",
    "font",
    "fontObj",
    "filter",
    "fillColor",
    "textRenderingMode",
    "SMask",
    "fillAlpha",
    "strokeAlpha",
    "globalCompositeOperation",
    "sameLineText"
], qc = [
    "transform"
], zc = [
    "transform",
    "fillColor"
], Wc = "Fill", Gc = "Stroke", Vc = "Shading";
function applyBoundingBox(e1, t) {
    if (!t) return;
    const i = t[2] - t[0], n = t[3] - t[1], a = new Path2D;
    a.rect(t[0], t[1], i, n), e1.clip(a);
}
class BaseShadingPattern {
    isModifyingCurrentTransform() {
        return !1;
    }
    getPattern() {
        unreachable("Abstract method `getPattern` called.");
    }
}
class RadialAxialShadingPattern extends BaseShadingPattern {
    constructor(e1){
        super(), this._type = e1[1], this._bbox = e1[2], this._colorStops = e1[3], this._p0 = e1[4], this._p1 = e1[5], this._r0 = e1[6], this._r1 = e1[7], this.matrix = null;
    }
    _createGradient(e1) {
        let t;
        "axial" === this._type ? t = e1.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : "radial" === this._type && (t = e1.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
        for (const e1 of this._colorStops)t.addColorStop(e1[0], e1[1]);
        return t;
    }
    getPattern(e1, t, i, n) {
        let a;
        if (n === Gc || n === Wc) {
            const s = t.current.getClippedPathBoundingBox(n, getCurrentTransform(e1)) || [
                0,
                0,
                0,
                0
            ], r = Math.ceil(s[2] - s[0]) || 1, o = Math.ceil(s[3] - s[1]) || 1, l = t.cachedCanvases.getCanvas("pattern", r, o), c = l.context;
            c.clearRect(0, 0, c.canvas.width, c.canvas.height), c.beginPath(), c.rect(0, 0, c.canvas.width, c.canvas.height), c.translate(-s[0], -s[1]), i = Util.transform(i, [
                1,
                0,
                0,
                1,
                s[0],
                s[1]
            ]), c.transform(...t.baseTransform), this.matrix && c.transform(...this.matrix), applyBoundingBox(c, this._bbox), c.fillStyle = this._createGradient(c), c.fill(), a = e1.createPattern(l.canvas, "no-repeat");
            const h = new DOMMatrix(i);
            a.setTransform(h);
        } else applyBoundingBox(e1, this._bbox), a = this._createGradient(e1);
        return a;
    }
}
function drawTriangle(e1, t, i, n, a, s, r, o) {
    const l = t.coords, c = t.colors, h = e1.data, d = 4 * e1.width;
    let u;
    l[i + 1] > l[n + 1] && (u = i, i = n, n = u, u = s, s = r, r = u), l[n + 1] > l[a + 1] && (u = n, n = a, a = u, u = r, r = o, o = u), l[i + 1] > l[n + 1] && (u = i, i = n, n = u, u = s, s = r, r = u);
    const g = (l[i] + t.offsetX) * t.scaleX, f = (l[i + 1] + t.offsetY) * t.scaleY, p = (l[n] + t.offsetX) * t.scaleX, m = (l[n + 1] + t.offsetY) * t.scaleY, b = (l[a] + t.offsetX) * t.scaleX, y = (l[a + 1] + t.offsetY) * t.scaleY;
    if (f >= y) return;
    const w = c[s], x = c[s + 1], S = c[s + 2], v = c[r], C = c[r + 1], k = c[r + 2], T = c[o], F = c[o + 1], E = c[o + 2], M = Math.round(f), D = Math.round(y);
    let O, _, R, N, L, U, j, $;
    for(let e1 = M; e1 <= D; e1++){
        if (e1 < m) {
            const t = e1 < f ? 0 : (f - e1) / (f - m);
            O = g - (g - p) * t, _ = w - (w - v) * t, R = x - (x - C) * t, N = S - (S - k) * t;
        } else {
            let t;
            t = e1 > y ? 1 : m === y ? 0 : (m - e1) / (m - y), O = p - (p - b) * t, _ = v - (v - T) * t, R = C - (C - F) * t, N = k - (k - E) * t;
        }
        let t;
        t = e1 < f ? 0 : e1 > y ? 1 : (f - e1) / (f - y), L = g - (g - b) * t, U = w - (w - T) * t, j = x - (x - F) * t, $ = S - (S - E) * t;
        const i = Math.round(Math.min(O, L)), n = Math.round(Math.max(O, L));
        let a = d * e1 + 4 * i;
        for(let e1 = i; e1 <= n; e1++)t = (O - e1) / (O - L), t < 0 ? t = 0 : t > 1 && (t = 1), h[a++] = _ - (_ - U) * t | 0, h[a++] = R - (R - j) * t | 0, h[a++] = N - (N - $) * t | 0, h[a++] = 255;
    }
}
function drawFigure(e1, t, i) {
    const n = t.coords, a = t.colors;
    let s, r;
    switch(t.type){
        case "lattice":
            const o = t.verticesPerRow, l = Math.floor(n.length / o) - 1, c = o - 1;
            for(s = 0; s < l; s++){
                let t = s * o;
                for(let s = 0; s < c; s++, t++)drawTriangle(e1, i, n[t], n[t + 1], n[t + o], a[t], a[t + 1], a[t + o]), drawTriangle(e1, i, n[t + o + 1], n[t + 1], n[t + o], a[t + o + 1], a[t + 1], a[t + o]);
            }
            break;
        case "triangles":
            for(s = 0, r = n.length; s < r; s += 3)drawTriangle(e1, i, n[s], n[s + 1], n[s + 2], a[s], a[s + 1], a[s + 2]);
            break;
        default:
            throw new Error("illegal figure");
    }
}
class MeshShadingPattern extends BaseShadingPattern {
    constructor(e1){
        super(), this._coords = e1[2], this._colors = e1[3], this._figures = e1[4], this._bounds = e1[5], this._bbox = e1[6], this._background = e1[7], this.matrix = null;
    }
    _createMeshCanvas(e1, t, i) {
        const n = Math.floor(this._bounds[0]), a = Math.floor(this._bounds[1]), s = Math.ceil(this._bounds[2]) - n, r = Math.ceil(this._bounds[3]) - a, o = Math.min(Math.ceil(Math.abs(s * e1[0] * 1.1)), 3e3), l = Math.min(Math.ceil(Math.abs(r * e1[1] * 1.1)), 3e3), c = s / o, h = r / l, d = {
            coords: this._coords,
            colors: this._colors,
            offsetX: -n,
            offsetY: -a,
            scaleX: 1 / c,
            scaleY: 1 / h
        }, u = o + 4, g = l + 4, f = i.getCanvas("mesh", u, g), p = f.context, m = p.createImageData(o, l);
        if (t) {
            const e1 = m.data;
            for(let i = 0, n = e1.length; i < n; i += 4)e1[i] = t[0], e1[i + 1] = t[1], e1[i + 2] = t[2], e1[i + 3] = 255;
        }
        for (const e1 of this._figures)drawFigure(m, e1, d);
        p.putImageData(m, 2, 2);
        return {
            canvas: f.canvas,
            offsetX: n - 2 * c,
            offsetY: a - 2 * h,
            scaleX: c,
            scaleY: h
        };
    }
    isModifyingCurrentTransform() {
        return !0;
    }
    getPattern(e1, t, i, n) {
        applyBoundingBox(e1, this._bbox);
        const a = new Float32Array(2);
        if (n === Vc) Util.singularValueDecompose2dScale(getCurrentTransform(e1), a);
        else if (this.matrix) {
            Util.singularValueDecompose2dScale(this.matrix, a);
            const [e1, i] = a;
            Util.singularValueDecompose2dScale(t.baseTransform, a), a[0] *= e1, a[1] *= i;
        } else Util.singularValueDecompose2dScale(t.baseTransform, a);
        const s = this._createMeshCanvas(a, n === Vc ? null : this._background, t.cachedCanvases);
        return n !== Vc && (e1.setTransform(...t.baseTransform), this.matrix && e1.transform(...this.matrix)), e1.translate(s.offsetX, s.offsetY), e1.scale(s.scaleX, s.scaleY), e1.createPattern(s.canvas, "no-repeat");
    }
}
class DummyShadingPattern extends BaseShadingPattern {
    getPattern() {
        return "hotpink";
    }
}
const Kc = 1, Yc = 2;
class TilingPattern {
    static MAX_PATTERN_SIZE = 3e3;
    constructor(e1, t, i, n){
        this.color = e1[1], this.operatorList = e1[2], this.matrix = e1[3], this.bbox = e1[4], this.xstep = e1[5], this.ystep = e1[6], this.paintType = e1[7], this.tilingType = e1[8], this.ctx = t, this.canvasGraphicsFactory = i, this.baseTransform = n;
    }
    createPatternCanvas(e1, t) {
        const { bbox: i, operatorList: n, paintType: a, tilingType: s, color: r, canvasGraphicsFactory: o } = this;
        let { xstep: l, ystep: c } = this;
        l = Math.abs(l), c = Math.abs(c), info("TilingType: " + s);
        const h = i[0], d = i[1], u = i[2], g = i[3], f = u - h, p = g - d, m = new Float32Array(2);
        Util.singularValueDecompose2dScale(this.matrix, m);
        const [b, y] = m;
        Util.singularValueDecompose2dScale(this.baseTransform, m);
        const w = b * m[0], x = y * m[1];
        let S = f, v = p, C = !1, k = !1;
        const T = Math.ceil(l * w), F = Math.ceil(c * x);
        T >= Math.ceil(f * w) ? S = l : C = !0, F >= Math.ceil(p * x) ? v = c : k = !0;
        const E = this.getSizeAndScale(S, this.ctx.canvas.width, w), M = this.getSizeAndScale(v, this.ctx.canvas.height, x), D = e1.cachedCanvases.getCanvas("pattern", E.size, M.size), O = D.context, _ = o.createCanvasGraphics(O, t);
        if (_.groupLevel = e1.groupLevel, this.setFillAndStrokeStyleToContext(_, a, r), O.translate(-E.scale * h, -M.scale * d), _.transform(0, E.scale, 0, 0, M.scale, 0, 0), O.save(), _.dependencyTracker?.save(), this.clipBbox(_, h, d, u, g), _.baseTransform = getCurrentTransform(_.ctx), _.executeOperatorList(n), _.endDrawing(), _.dependencyTracker?.restore(), O.restore(), C || k) {
            const t = D.canvas;
            C && (S = l), k && (v = c);
            const i = this.getSizeAndScale(S, this.ctx.canvas.width, w), n = this.getSizeAndScale(v, this.ctx.canvas.height, x), a = i.size, s = n.size, r = e1.cachedCanvases.getCanvas("pattern-workaround", a, s), o = r.context, u = C ? Math.floor(f / l) : 0, g = k ? Math.floor(p / c) : 0;
            for(let e1 = 0; e1 <= u; e1++)for(let i = 0; i <= g; i++)o.drawImage(t, a * e1, s * i, a, s, 0, 0, a, s);
            return {
                canvas: r.canvas,
                scaleX: i.scale,
                scaleY: n.scale,
                offsetX: h,
                offsetY: d
            };
        }
        return {
            canvas: D.canvas,
            scaleX: E.scale,
            scaleY: M.scale,
            offsetX: h,
            offsetY: d
        };
    }
    getSizeAndScale(e1, t, i) {
        const n = Math.max(TilingPattern.MAX_PATTERN_SIZE, t);
        let a = Math.ceil(e1 * i);
        return a >= n ? a = n : i = a / e1, {
            scale: i,
            size: a
        };
    }
    clipBbox(e1, t, i, n, a) {
        const s = n - t, r = a - i;
        e1.ctx.rect(t, i, s, r), Util.axialAlignedBoundingBox([
            t,
            i,
            n,
            a
        ], getCurrentTransform(e1.ctx), e1.current.minMax), e1.clip(), e1.endPath();
    }
    setFillAndStrokeStyleToContext(e1, t, i) {
        const n = e1.ctx, a = e1.current;
        switch(t){
            case Kc:
                const { fillStyle: e2, strokeStyle: s } = this.ctx;
                n.fillStyle = a.fillColor = e2, n.strokeStyle = a.strokeColor = s;
                break;
            case Yc:
                n.fillStyle = n.strokeStyle = i, a.fillColor = a.strokeColor = i;
                break;
            default:
                throw new FormatError(`Unsupported paint type: ${t}`);
        }
    }
    isModifyingCurrentTransform() {
        return !1;
    }
    getPattern(e1, t, i, n, a) {
        let s = i;
        n !== Vc && (s = Util.transform(s, t.baseTransform), this.matrix && (s = Util.transform(s, this.matrix)));
        const r = this.createPatternCanvas(t, a);
        let o = new DOMMatrix(s);
        o = o.translate(r.offsetX, r.offsetY), o = o.scale(1 / r.scaleX, 1 / r.scaleY);
        const l = e1.createPattern(r.canvas, "repeat");
        return l.setTransform(o), l;
    }
}
function convertBlackAndWhiteToRGBA({ src: e1, srcPos: t = 0, dest: i, width: n, height: a, nonBlackColor: s = 4294967295, inverseDecode: r = !1 }) {
    const o = util_FeatureTest.isLittleEndian ? 4278190080 : 255, [l, c] = r ? [
        s,
        o
    ] : [
        o,
        s
    ], h = n >> 3, d = 7 & n, u = e1.length;
    i = new Uint32Array(i.buffer);
    let g = 0;
    for(let n = 0; n < a; n++){
        for(const n = t + h; t < n; t++){
            const n = t < u ? e1[t] : 255;
            i[g++] = 128 & n ? c : l, i[g++] = 64 & n ? c : l, i[g++] = 32 & n ? c : l, i[g++] = 16 & n ? c : l, i[g++] = 8 & n ? c : l, i[g++] = 4 & n ? c : l, i[g++] = 2 & n ? c : l, i[g++] = 1 & n ? c : l;
        }
        if (0 === d) continue;
        const n = t < u ? e1[t++] : 255;
        for(let e1 = 0; e1 < d; e1++)i[g++] = n & 1 << 7 - e1 ? c : l;
    }
    return {
        srcPos: t,
        destPos: g
    };
}
const Jc = 16, Zc = new DOMMatrix, Qc = new Float32Array(2), eh = new Float32Array([
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
]);
class CachedCanvases {
    constructor(e1){
        this.canvasFactory = e1, this.cache = Object.create(null);
    }
    getCanvas(e1, t, i) {
        let n;
        return void 0 !== this.cache[e1] ? (n = this.cache[e1], this.canvasFactory.reset(n, t, i)) : (n = this.canvasFactory.create(t, i), this.cache[e1] = n), n;
    }
    delete(e1) {
        delete this.cache[e1];
    }
    clear() {
        for(const e1 in this.cache){
            const t = this.cache[e1];
            this.canvasFactory.destroy(t), delete this.cache[e1];
        }
    }
}
function drawImageAtIntegerCoords(e1, t, i, n, a, s, r, o, l, c) {
    const [h, d, u, g, f, p] = getCurrentTransform(e1);
    if (0 === d && 0 === u) {
        const m = r * h + f, b = Math.round(m), y = o * g + p, w = Math.round(y), x = (r + l) * h + f, S = Math.abs(Math.round(x) - b) || 1, v = (o + c) * g + p, C = Math.abs(Math.round(v) - w) || 1;
        return e1.setTransform(Math.sign(h), 0, 0, Math.sign(g), b, w), e1.drawImage(t, i, n, a, s, 0, 0, S, C), e1.setTransform(h, d, u, g, f, p), [
            S,
            C
        ];
    }
    if (0 === h && 0 === g) {
        const m = o * u + f, b = Math.round(m), y = r * d + p, w = Math.round(y), x = (o + c) * u + f, S = Math.abs(Math.round(x) - b) || 1, v = (r + l) * d + p, C = Math.abs(Math.round(v) - w) || 1;
        return e1.setTransform(0, Math.sign(d), Math.sign(u), 0, b, w), e1.drawImage(t, i, n, a, s, 0, 0, C, S), e1.setTransform(h, d, u, g, f, p), [
            C,
            S
        ];
    }
    e1.drawImage(t, i, n, a, s, r, o, l, c);
    return [
        Math.hypot(h, d) * l,
        Math.hypot(u, g) * c
    ];
}
class CanvasExtraState {
    alphaIsShape = !1;
    fontSize = 0;
    fontSizeScale = 1;
    textMatrix = null;
    textMatrixScale = 1;
    fontMatrix = Il;
    leading = 0;
    x = 0;
    y = 0;
    lineX = 0;
    lineY = 0;
    charSpacing = 0;
    wordSpacing = 0;
    textHScale = 1;
    textRenderingMode = zl;
    textRise = 0;
    fillColor = "#000000";
    strokeColor = "#000000";
    patternFill = !1;
    patternStroke = !1;
    fillAlpha = 1;
    strokeAlpha = 1;
    lineWidth = 1;
    activeSMask = null;
    transferMaps = "none";
    constructor(e1, t, i){
        i?.(this), this.clipBox = new Float32Array([
            0,
            0,
            e1,
            t
        ]), this.minMax = eh.slice();
    }
    clone() {
        const e1 = Object.create(this);
        return e1.clipBox = this.clipBox.slice(), e1.minMax = this.minMax.slice(), e1;
    }
    getPathBoundingBox(e1 = Wc, t = null) {
        const i = this.minMax.slice();
        if (e1 === Gc) {
            t || unreachable("Stroke bounding box must include transform."), Util.singularValueDecompose2dScale(t, Qc);
            const e1 = Qc[0] * this.lineWidth / 2, n = Qc[1] * this.lineWidth / 2;
            i[0] -= e1, i[1] -= n, i[2] += e1, i[3] += n;
        }
        return i;
    }
    updateClipFromPath() {
        const e1 = Util.intersect(this.clipBox, this.getPathBoundingBox());
        this.startNewPathAndClipBox(e1 || [
            0,
            0,
            0,
            0
        ]);
    }
    isEmptyClip() {
        return this.minMax[0] === 1 / 0;
    }
    startNewPathAndClipBox(e1) {
        this.clipBox.set(e1, 0), this.minMax.set(eh, 0);
    }
    getClippedPathBoundingBox(e1 = Wc, t = null) {
        return Util.intersect(this.clipBox, this.getPathBoundingBox(e1, t));
    }
}
function putBinaryImageData(e1, t) {
    if (t instanceof ImageData) return void e1.putImageData(t, 0, 0);
    const i = t.height, n = t.width, a = i % Jc, s = (i - a) / Jc, r = 0 === a ? s : s + 1, o = e1.createImageData(n, Jc);
    let l, c = 0;
    const h = t.data, d = o.data;
    let u, g, f, p;
    if (t.kind === Jl.GRAYSCALE_1BPP) {
        const t = h.byteLength, i = new Uint32Array(d.buffer, 0, d.byteLength >> 2), p = i.length, m = n + 7 >> 3, b = 4294967295, y = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
        for(u = 0; u < r; u++){
            for(f = u < s ? Jc : a, l = 0, g = 0; g < f; g++){
                const e1 = t - c;
                let a = 0;
                const s = e1 > m ? n : 8 * e1 - 7, r = -8 & s;
                let o = 0, d = 0;
                for(; a < r; a += 8)d = h[c++], i[l++] = 128 & d ? b : y, i[l++] = 64 & d ? b : y, i[l++] = 32 & d ? b : y, i[l++] = 16 & d ? b : y, i[l++] = 8 & d ? b : y, i[l++] = 4 & d ? b : y, i[l++] = 2 & d ? b : y, i[l++] = 1 & d ? b : y;
                for(; a < s; a++)0 === o && (d = h[c++], o = 128), i[l++] = d & o ? b : y, o >>= 1;
            }
            for(; l < p;)i[l++] = 0;
            e1.putImageData(o, 0, u * Jc);
        }
    } else if (t.kind === Jl.RGBA_32BPP) {
        for(g = 0, p = n * Jc * 4, u = 0; u < s; u++)d.set(h.subarray(c, c + p)), c += p, e1.putImageData(o, 0, g), g += Jc;
        u < r && (p = n * a * 4, d.set(h.subarray(c, c + p)), e1.putImageData(o, 0, g));
    } else {
        if (t.kind !== Jl.RGB_24BPP) throw new Error(`bad image kind: ${t.kind}`);
        for(f = Jc, p = n * f, u = 0; u < r; u++){
            for(u >= s && (f = a, p = n * f), l = 0, g = p; g--;)d[l++] = h[c++], d[l++] = h[c++], d[l++] = h[c++], d[l++] = 255;
            e1.putImageData(o, 0, u * Jc);
        }
    }
}
function putBinaryImageMask(e1, t) {
    if (t.bitmap) return void e1.drawImage(t.bitmap, 0, 0);
    const i = t.height, n = t.width, a = i % Jc, s = (i - a) / Jc, r = 0 === a ? s : s + 1, o = e1.createImageData(n, Jc);
    let l = 0;
    const c = t.data, h = o.data;
    for(let t = 0; t < r; t++){
        const i = t < s ? Jc : a;
        ({ srcPos: l } = convertBlackAndWhiteToRGBA({
            src: c,
            srcPos: l,
            dest: h,
            width: n,
            height: i,
            nonBlackColor: 0
        })), e1.putImageData(o, 0, t * Jc);
    }
}
function copyCtxState(e1, t) {
    const i = [
        "strokeStyle",
        "fillStyle",
        "fillRule",
        "globalAlpha",
        "lineWidth",
        "lineCap",
        "lineJoin",
        "miterLimit",
        "globalCompositeOperation",
        "font",
        "filter"
    ];
    for (const n of i)void 0 !== e1[n] && (t[n] = e1[n]);
    void 0 !== e1.setLineDash && (t.setLineDash(e1.getLineDash()), t.lineDashOffset = e1.lineDashOffset);
}
function resetCtxToDefault(e1) {
    e1.strokeStyle = e1.fillStyle = "#000000", e1.fillRule = "nonzero", e1.globalAlpha = 1, e1.lineWidth = 1, e1.lineCap = "butt", e1.lineJoin = "miter", e1.miterLimit = 10, e1.globalCompositeOperation = "source-over", e1.font = "10px sans-serif", void 0 !== e1.setLineDash && (e1.setLineDash([]), e1.lineDashOffset = 0);
    const { filter: t } = e1;
    "none" !== t && "" !== t && (e1.filter = "none");
}
function getImageSmoothingEnabled(e1, t) {
    if (t) return !0;
    Util.singularValueDecompose2dScale(e1, Qc);
    const i = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);
    return Qc[0] <= i && Qc[1] <= i;
}
const th = [
    "butt",
    "round",
    "square"
], ih = [
    "miter",
    "round",
    "bevel"
], nh = {}, ah = {};
class CanvasGraphics {
    constructor(e1, t, i, n, a, { optionalContentConfig: s, markedContentStack: r = null }, o, l, c){
        this.ctx = e1, this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = t, this.objs = i, this.canvasFactory = n, this.filterFactory = a, this.groupStack = [], this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = r || [], this.optionalContentConfig = s, this.cachedCanvases = new CachedCanvases(this.canvasFactory), this.cachedPatterns = new Map, this.annotationCanvasMap = o, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = l, this._cachedScaleForStroking = [
            -1,
            0
        ], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = new Map, this.dependencyTracker = c ?? null;
    }
    getObject(e1, t, i = null) {
        return "string" == typeof t ? (this.dependencyTracker?.recordNamedDependency(e1, t), t.startsWith("g_") ? this.commonObjs.get(t) : this.objs.get(t)) : i;
    }
    beginDrawing({ transform: e1, viewport: t, transparency: i = !1, background: n = null }) {
        const a = this.ctx.canvas.width, s = this.ctx.canvas.height, r = this.ctx.fillStyle;
        if (this.ctx.fillStyle = n || "#ffffff", this.ctx.fillRect(0, 0, a, s), this.ctx.fillStyle = r, i) {
            const e1 = this.cachedCanvases.getCanvas("transparent", a, s);
            this.compositeCtx = this.ctx, this.transparentCanvas = e1.canvas, this.ctx = e1.context, this.ctx.save(), this.ctx.transform(...getCurrentTransform(this.compositeCtx));
        }
        this.ctx.save(), resetCtxToDefault(this.ctx), e1 && (this.ctx.transform(...e1), this.outputScaleX = e1[0], this.outputScaleY = e1[0]), this.ctx.transform(...t.transform), this.viewportScale = t.scale, this.baseTransform = getCurrentTransform(this.ctx);
    }
    executeOperatorList(e1, t, i, n, a) {
        const s = e1.argsArray, r = e1.fnArray;
        let o = t || 0;
        const l = s.length;
        if (l === o) return o;
        const c = l - o > 10 && "function" == typeof i, h = c ? Date.now() + 15 : 0;
        let d = 0;
        const u = this.commonObjs, g = this.objs;
        let f, p;
        for(;;){
            if (void 0 !== n && o === n.nextBreakPoint) return n.breakIt(o, i), o;
            if (!a || a(o)) if (f = r[o], p = s[o] ?? null, f !== sc.dependency) null === p ? this[f](o) : this[f](o, ...p);
            else for (const e1 of p){
                this.dependencyTracker?.recordNamedData(e1, o);
                const t = e1.startsWith("g_") ? u : g;
                if (!t.has(e1)) return t.get(e1, i), o;
            }
            if (o++, o === l) return o;
            if (c && ++d > 10) {
                if (Date.now() > h) return i(), o;
                d = 0;
            }
        }
    }
    #Ss() {
        for(; this.stateStack.length || this.inSMaskMode;)this.restore();
        this.current.activeSMask = null, this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
    }
    endDrawing() {
        this.#Ss(), this.cachedCanvases.clear(), this.cachedPatterns.clear();
        for (const e1 of this._cachedBitmapsMap.values()){
            for (const t of e1.values())"undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement && (t.width = t.height = 0);
            e1.clear();
        }
        this._cachedBitmapsMap.clear(), this.#vs();
    }
    #vs() {
        if (this.pageColors) {
            const e1 = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
            if ("none" !== e1) {
                const t = this.ctx.filter;
                this.ctx.filter = e1, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = t;
            }
        }
    }
    _scaleImage(e1, t) {
        const i = e1.width ?? e1.displayWidth, n = e1.height ?? e1.displayHeight;
        let a, s, r = Math.max(Math.hypot(t[0], t[1]), 1), o = Math.max(Math.hypot(t[2], t[3]), 1), l = i, c = n, h = "prescale1";
        for(; r > 2 && l > 1 || o > 2 && c > 1;){
            let t = l, i = c;
            r > 2 && l > 1 && (t = l >= 16384 ? Math.floor(l / 2) - 1 || 1 : Math.ceil(l / 2), r /= l / t), o > 2 && c > 1 && (i = c >= 16384 ? Math.floor(c / 2) - 1 || 1 : Math.ceil(c) / 2, o /= c / i), a = this.cachedCanvases.getCanvas(h, t, i), s = a.context, s.clearRect(0, 0, t, i), s.drawImage(e1, 0, 0, l, c, 0, 0, t, i), e1 = a.canvas, l = t, c = i, h = "prescale1" === h ? "prescale2" : "prescale1";
        }
        return {
            img: e1,
            paintWidth: l,
            paintHeight: c
        };
    }
    _createMaskCanvas(e1, t) {
        const i = this.ctx, { width: n, height: a } = t, s = this.current.fillColor, r = this.current.patternFill, o = getCurrentTransform(i);
        let l, c, h, d;
        if ((t.bitmap || t.data) && t.count > 1) {
            const i = t.bitmap || t.data.buffer;
            c = JSON.stringify(r ? o : [
                o.slice(0, 4),
                s
            ]), l = this._cachedBitmapsMap.get(i), l || (l = new Map, this._cachedBitmapsMap.set(i, l));
            const n = l.get(c);
            if (n && !r) {
                const t = Math.round(Math.min(o[0], o[2]) + o[4]), i = Math.round(Math.min(o[1], o[3]) + o[5]);
                return this.dependencyTracker?.recordDependencies(e1, zc), {
                    canvas: n,
                    offsetX: t,
                    offsetY: i
                };
            }
            h = n;
        }
        h || (d = this.cachedCanvases.getCanvas("maskCanvas", n, a), putBinaryImageMask(d.context, t));
        let u = Util.transform(o, [
            1 / n,
            0,
            0,
            -1 / a,
            0,
            0
        ]);
        u = Util.transform(u, [
            1,
            0,
            0,
            1,
            0,
            -a
        ]);
        const g = eh.slice();
        Util.axialAlignedBoundingBox([
            0,
            0,
            n,
            a
        ], u, g);
        const [f, p, m, b] = g, y = Math.round(m - f) || 1, w = Math.round(b - p) || 1, x = this.cachedCanvases.getCanvas("fillCanvas", y, w), S = x.context, v = f, C = p;
        S.translate(-v, -C), S.transform(...u), h || (h = this._scaleImage(d.canvas, getCurrentTransformInverse(S)), h = h.img, l && r && l.set(c, h)), S.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(S), t.interpolate), drawImageAtIntegerCoords(S, h, 0, 0, h.width, h.height, 0, 0, n, a), S.globalCompositeOperation = "source-in";
        const k = Util.transform(getCurrentTransformInverse(S), [
            1,
            0,
            0,
            1,
            -v,
            -C
        ]);
        return S.fillStyle = r ? s.getPattern(i, this, k, Wc, e1) : s, S.fillRect(0, 0, n, a), l && !r && (this.cachedCanvases.delete("fillCanvas"), l.set(c, x.canvas)), this.dependencyTracker?.recordDependencies(e1, zc), {
            canvas: x.canvas,
            offsetX: Math.round(v),
            offsetY: Math.round(C)
        };
    }
    setLineWidth(e1, t) {
        this.dependencyTracker?.recordSimpleData("lineWidth", e1), t !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = t, this.ctx.lineWidth = t;
    }
    setLineCap(e1, t) {
        this.dependencyTracker?.recordSimpleData("lineCap", e1), this.ctx.lineCap = th[t];
    }
    setLineJoin(e1, t) {
        this.dependencyTracker?.recordSimpleData("lineJoin", e1), this.ctx.lineJoin = ih[t];
    }
    setMiterLimit(e1, t) {
        this.dependencyTracker?.recordSimpleData("miterLimit", e1), this.ctx.miterLimit = t;
    }
    setDash(e1, t, i) {
        this.dependencyTracker?.recordSimpleData("dash", e1);
        const n = this.ctx;
        void 0 !== n.setLineDash && (n.setLineDash(t), n.lineDashOffset = i);
    }
    setRenderingIntent(e1, t) {}
    setFlatness(e1, t) {}
    setGState(e1, t) {
        for (const [i, n] of t)switch(i){
            case "LW":
                this.setLineWidth(e1, n);
                break;
            case "LC":
                this.setLineCap(e1, n);
                break;
            case "LJ":
                this.setLineJoin(e1, n);
                break;
            case "ML":
                this.setMiterLimit(e1, n);
                break;
            case "D":
                this.setDash(e1, n[0], n[1]);
                break;
            case "RI":
                this.setRenderingIntent(e1, n);
                break;
            case "FL":
                this.setFlatness(e1, n);
                break;
            case "Font":
                this.setFont(e1, n[0], n[1]);
                break;
            case "CA":
                this.dependencyTracker?.recordSimpleData("strokeAlpha", e1), this.current.strokeAlpha = n;
                break;
            case "ca":
                this.dependencyTracker?.recordSimpleData("fillAlpha", e1), this.ctx.globalAlpha = this.current.fillAlpha = n;
                break;
            case "BM":
                this.dependencyTracker?.recordSimpleData("globalCompositeOperation", e1), this.ctx.globalCompositeOperation = n;
                break;
            case "SMask":
                this.dependencyTracker?.recordSimpleData("SMask", e1), this.current.activeSMask = n ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                break;
            case "TR":
                this.dependencyTracker?.recordSimpleData("filter", e1), this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(n);
        }
    }
    get inSMaskMode() {
        return !!this.suspendedCtx;
    }
    checkSMaskState() {
        const e1 = this.inSMaskMode;
        this.current.activeSMask && !e1 ? this.beginSMaskMode() : !this.current.activeSMask && e1 && this.endSMaskMode();
    }
    beginSMaskMode(e1) {
        if (this.inSMaskMode) throw new Error("beginSMaskMode called while already in smask mode");
        const t = this.ctx.canvas.width, i = this.ctx.canvas.height, n = "smaskGroupAt" + this.groupLevel, a = this.cachedCanvases.getCanvas(n, t, i);
        this.suspendedCtx = this.ctx;
        const s = this.ctx = a.context;
        s.setTransform(this.suspendedCtx.getTransform()), copyCtxState(this.suspendedCtx, s), function(e1, t) {
            if (e1._removeMirroring) throw new Error("Context is already forwarding operations.");
            e1.__originalSave = e1.save, e1.__originalRestore = e1.restore, e1.__originalRotate = e1.rotate, e1.__originalScale = e1.scale, e1.__originalTranslate = e1.translate, e1.__originalTransform = e1.transform, e1.__originalSetTransform = e1.setTransform, e1.__originalResetTransform = e1.resetTransform, e1.__originalClip = e1.clip, e1.__originalMoveTo = e1.moveTo, e1.__originalLineTo = e1.lineTo, e1.__originalBezierCurveTo = e1.bezierCurveTo, e1.__originalRect = e1.rect, e1.__originalClosePath = e1.closePath, e1.__originalBeginPath = e1.beginPath, e1._removeMirroring = ()=>{
                e1.save = e1.__originalSave, e1.restore = e1.__originalRestore, e1.rotate = e1.__originalRotate, e1.scale = e1.__originalScale, e1.translate = e1.__originalTranslate, e1.transform = e1.__originalTransform, e1.setTransform = e1.__originalSetTransform, e1.resetTransform = e1.__originalResetTransform, e1.clip = e1.__originalClip, e1.moveTo = e1.__originalMoveTo, e1.lineTo = e1.__originalLineTo, e1.bezierCurveTo = e1.__originalBezierCurveTo, e1.rect = e1.__originalRect, e1.closePath = e1.__originalClosePath, e1.beginPath = e1.__originalBeginPath, delete e1._removeMirroring;
            }, e1.save = function() {
                t.save(), this.__originalSave();
            }, e1.restore = function() {
                t.restore(), this.__originalRestore();
            }, e1.translate = function(e1, i) {
                t.translate(e1, i), this.__originalTranslate(e1, i);
            }, e1.scale = function(e1, i) {
                t.scale(e1, i), this.__originalScale(e1, i);
            }, e1.transform = function(e1, i, n, a, s, r) {
                t.transform(e1, i, n, a, s, r), this.__originalTransform(e1, i, n, a, s, r);
            }, e1.setTransform = function(e1, i, n, a, s, r) {
                t.setTransform(e1, i, n, a, s, r), this.__originalSetTransform(e1, i, n, a, s, r);
            }, e1.resetTransform = function() {
                t.resetTransform(), this.__originalResetTransform();
            }, e1.rotate = function(e1) {
                t.rotate(e1), this.__originalRotate(e1);
            }, e1.clip = function(e1) {
                t.clip(e1), this.__originalClip(e1);
            }, e1.moveTo = function(e1, i) {
                t.moveTo(e1, i), this.__originalMoveTo(e1, i);
            }, e1.lineTo = function(e1, i) {
                t.lineTo(e1, i), this.__originalLineTo(e1, i);
            }, e1.bezierCurveTo = function(e1, i, n, a, s, r) {
                t.bezierCurveTo(e1, i, n, a, s, r), this.__originalBezierCurveTo(e1, i, n, a, s, r);
            }, e1.rect = function(e1, i, n, a) {
                t.rect(e1, i, n, a), this.__originalRect(e1, i, n, a);
            }, e1.closePath = function() {
                t.closePath(), this.__originalClosePath();
            }, e1.beginPath = function() {
                t.beginPath(), this.__originalBeginPath();
            };
        }(s, this.suspendedCtx), this.setGState(e1, [
            [
                "BM",
                "source-over"
            ]
        ]);
    }
    endSMaskMode() {
        if (!this.inSMaskMode) throw new Error("endSMaskMode called while not in smask mode");
        this.ctx._removeMirroring(), copyCtxState(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
    }
    compose(e1) {
        if (!this.current.activeSMask) return;
        e1 ? (e1[0] = Math.floor(e1[0]), e1[1] = Math.floor(e1[1]), e1[2] = Math.ceil(e1[2]), e1[3] = Math.ceil(e1[3])) : e1 = [
            0,
            0,
            this.ctx.canvas.width,
            this.ctx.canvas.height
        ];
        const t = this.current.activeSMask, i = this.suspendedCtx;
        this.composeSMask(i, t, this.ctx, e1), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
    }
    composeSMask(e1, t, i, n) {
        const a = n[0], s = n[1], r = n[2] - a, o = n[3] - s;
        0 !== r && 0 !== o && (this.genericComposeSMask(t.context, i, r, o, t.subtype, t.backdrop, t.transferMap, a, s, t.offsetX, t.offsetY), e1.save(), e1.globalAlpha = 1, e1.globalCompositeOperation = "source-over", e1.setTransform(1, 0, 0, 1, 0, 0), e1.drawImage(i.canvas, 0, 0), e1.restore());
    }
    genericComposeSMask(e1, t, i, n, a, s, r, o, l, c, h) {
        let d = e1.canvas, u = o - c, g = l - h;
        if (s) if (u < 0 || g < 0 || u + i > d.width || g + n > d.height) {
            const e1 = this.cachedCanvases.getCanvas("maskExtension", i, n), t = e1.context;
            t.drawImage(d, -u, -g), t.globalCompositeOperation = "destination-atop", t.fillStyle = s, t.fillRect(0, 0, i, n), t.globalCompositeOperation = "source-over", d = e1.canvas, u = g = 0;
        } else {
            e1.save(), e1.globalAlpha = 1, e1.setTransform(1, 0, 0, 1, 0, 0);
            const t = new Path2D;
            t.rect(u, g, i, n), e1.clip(t), e1.globalCompositeOperation = "destination-atop", e1.fillStyle = s, e1.fillRect(u, g, i, n), e1.restore();
        }
        t.save(), t.globalAlpha = 1, t.setTransform(1, 0, 0, 1, 0, 0), "Alpha" === a && r ? t.filter = this.filterFactory.addAlphaFilter(r) : "Luminosity" === a && (t.filter = this.filterFactory.addLuminosityFilter(r));
        const f = new Path2D;
        f.rect(o, l, i, n), t.clip(f), t.globalCompositeOperation = "destination-in", t.drawImage(d, u, g, i, n, o, l, i, n), t.restore();
    }
    save(e1) {
        this.inSMaskMode && copyCtxState(this.ctx, this.suspendedCtx), this.ctx.save();
        const t = this.current;
        this.stateStack.push(t), this.current = t.clone(), this.dependencyTracker?.save(e1);
    }
    restore(e1) {
        this.dependencyTracker?.restore(e1), 0 !== this.stateStack.length ? (this.current = this.stateStack.pop(), this.ctx.restore(), this.inSMaskMode && copyCtxState(this.suspendedCtx, this.ctx), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null) : this.inSMaskMode && this.endSMaskMode();
    }
    transform(e1, t, i, n, a, s, r) {
        this.dependencyTracker?.recordIncrementalData("transform", e1), this.ctx.transform(t, i, n, a, s, r), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
    }
    constructPath(e1, t, i, n) {
        let [a] = i;
        if (!n) return a ||= i[0] = new Path2D, void this[t](e1, a);
        if (null !== this.dependencyTracker) {
            const i = t === sc.stroke ? this.current.lineWidth / 2 : 0;
            this.dependencyTracker.resetBBox(e1).recordBBox(e1, this.ctx, n[0] - i, n[2] + i, n[1] - i, n[3] + i).recordDependencies(e1, [
                "transform"
            ]);
        }
        if (!(a instanceof Path2D)) {
            const e1 = i[0] = new Path2D;
            for(let t = 0, i = a.length; t < i;)switch(a[t++]){
                case rc:
                    e1.moveTo(a[t++], a[t++]);
                    break;
                case oc:
                    e1.lineTo(a[t++], a[t++]);
                    break;
                case lc:
                    e1.bezierCurveTo(a[t++], a[t++], a[t++], a[t++], a[t++], a[t++]);
                    break;
                case cc:
                    e1.closePath();
                    break;
                default:
                    warn(`Unrecognized drawing path operator: ${a[t - 1]}`);
            }
            a = e1;
        }
        Util.axialAlignedBoundingBox(n, getCurrentTransform(this.ctx), this.current.minMax), this[t](e1, a), this._pathStartIdx = e1;
    }
    closePath(e1) {
        this.ctx.closePath();
    }
    stroke(e1, t, i = !0) {
        const n = this.ctx, a = this.current.strokeColor;
        if (n.globalAlpha = this.current.strokeAlpha, this.contentVisible) if ("object" == typeof a && a?.getPattern) {
            const i = a.isModifyingCurrentTransform() ? n.getTransform() : null;
            if (n.save(), n.strokeStyle = a.getPattern(n, this, getCurrentTransformInverse(n), Gc, e1), i) {
                const e1 = new Path2D;
                e1.addPath(t, n.getTransform().invertSelf().multiplySelf(i)), t = e1;
            }
            this.rescaleAndStroke(t, !1), n.restore();
        } else this.rescaleAndStroke(t, !0);
        this.dependencyTracker?.recordDependencies(e1, Uc), i && this.consumePath(e1, t, this.current.getClippedPathBoundingBox(Gc, getCurrentTransform(this.ctx))), n.globalAlpha = this.current.fillAlpha;
    }
    closeStroke(e1, t) {
        this.stroke(e1, t);
    }
    fill(e1, t, i = !0) {
        const n = this.ctx, a = this.current.fillColor;
        let s = !1;
        if (this.current.patternFill) {
            const i = a.isModifyingCurrentTransform() ? n.getTransform() : null;
            if (this.dependencyTracker?.save(e1), n.save(), n.fillStyle = a.getPattern(n, this, getCurrentTransformInverse(n), Wc, e1), i) {
                const e1 = new Path2D;
                e1.addPath(t, n.getTransform().invertSelf().multiplySelf(i)), t = e1;
            }
            s = !0;
        }
        const r = this.current.getClippedPathBoundingBox();
        this.contentVisible && null !== r && (this.pendingEOFill ? (n.fill(t, "evenodd"), this.pendingEOFill = !1) : n.fill(t)), this.dependencyTracker?.recordDependencies(e1, jc), s && (n.restore(), this.dependencyTracker?.restore(e1)), i && this.consumePath(e1, t, r);
    }
    eoFill(e1, t) {
        this.pendingEOFill = !0, this.fill(e1, t);
    }
    fillStroke(e1, t) {
        this.fill(e1, t, !1), this.stroke(e1, t, !1), this.consumePath(e1, t);
    }
    eoFillStroke(e1, t) {
        this.pendingEOFill = !0, this.fillStroke(e1, t);
    }
    closeFillStroke(e1, t) {
        this.fillStroke(e1, t);
    }
    closeEOFillStroke(e1, t) {
        this.pendingEOFill = !0, this.fillStroke(e1, t);
    }
    endPath(e1, t) {
        this.consumePath(e1, t);
    }
    rawFillPath(e1, t) {
        this.ctx.fill(t), this.dependencyTracker?.recordDependencies(e1, Hc).recordOperation(e1);
    }
    clip(e1) {
        this.dependencyTracker?.recordFutureForcedDependency("clipMode", e1), this.pendingClip = nh;
    }
    eoClip(e1) {
        this.dependencyTracker?.recordFutureForcedDependency("clipMode", e1), this.pendingClip = ah;
    }
    beginText(e1) {
        this.current.textMatrix = null, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0, this.dependencyTracker?.recordOpenMarker(e1).resetIncrementalData("sameLineText").resetIncrementalData("moveText", e1);
    }
    endText(e1) {
        const t = this.pendingTextPaths, i = this.ctx;
        if (this.dependencyTracker) {
            const { dependencyTracker: i } = this;
            void 0 !== t && i.recordFutureForcedDependency("textClip", i.getOpenMarker()).recordFutureForcedDependency("textClip", e1), i.recordCloseMarker(e1);
        }
        if (void 0 !== t) {
            const e1 = new Path2D, n = i.getTransform().invertSelf();
            for (const { transform: i, x: a, y: s, fontSize: r, path: o } of t)o && e1.addPath(o, new DOMMatrix(i).preMultiplySelf(n).translate(a, s).scale(r, -r));
            i.clip(e1);
        }
        delete this.pendingTextPaths;
    }
    setCharSpacing(e1, t) {
        this.dependencyTracker?.recordSimpleData("charSpacing", e1), this.current.charSpacing = t;
    }
    setWordSpacing(e1, t) {
        this.dependencyTracker?.recordSimpleData("wordSpacing", e1), this.current.wordSpacing = t;
    }
    setHScale(e1, t) {
        this.dependencyTracker?.recordSimpleData("hScale", e1), this.current.textHScale = t / 100;
    }
    setLeading(e1, t) {
        this.dependencyTracker?.recordSimpleData("leading", e1), this.current.leading = -t;
    }
    setFont(e1, t, i) {
        this.dependencyTracker?.recordSimpleData("font", e1).recordSimpleDataFromNamed("fontObj", t, e1);
        const n = this.commonObjs.get(t), a = this.current;
        if (!n) throw new Error(`Can't find font for ${t}`);
        if (a.fontMatrix = n.fontMatrix || Il, 0 !== a.fontMatrix[0] && 0 !== a.fontMatrix[3] || warn("Invalid font matrix for font " + t), i < 0 ? (i = -i, a.fontDirection = -1) : a.fontDirection = 1, this.current.font = n, this.current.fontSize = i, n.isType3Font) return;
        const s = n.loadedName || "sans-serif", r = n.systemFontInfo?.css || `"${s}", ${n.fallbackName}`;
        let o = "normal";
        n.black ? o = "900" : n.bold && (o = "bold");
        const l = n.italic ? "italic" : "normal";
        let c = i;
        i < 16 ? c = 16 : i > 100 && (c = 100), this.current.fontSizeScale = i / c, this.ctx.font = `${l} ${o} ${c}px ${r}`;
    }
    setTextRenderingMode(e1, t) {
        this.dependencyTracker?.recordSimpleData("textRenderingMode", e1), this.current.textRenderingMode = t;
    }
    setTextRise(e1, t) {
        this.dependencyTracker?.recordSimpleData("textRise", e1), this.current.textRise = t;
    }
    moveText(e1, t, i) {
        this.dependencyTracker?.resetIncrementalData("sameLineText").recordIncrementalData("moveText", e1), this.current.x = this.current.lineX += t, this.current.y = this.current.lineY += i;
    }
    setLeadingMoveText(e1, t, i) {
        this.setLeading(e1, -i), this.moveText(e1, t, i);
    }
    setTextMatrix(e1, t) {
        this.dependencyTracker?.recordSimpleData("textMatrix", e1);
        const { current: i } = this;
        i.textMatrix = t, i.textMatrixScale = Math.hypot(t[0], t[1]), i.x = i.lineX = 0, i.y = i.lineY = 0;
    }
    nextLine(e1) {
        this.moveText(e1, 0, this.current.leading), this.dependencyTracker?.recordIncrementalData("moveText", this.dependencyTracker.getSimpleIndex("leading") ?? e1);
    }
    #Cs(e1, t, i) {
        const n = new Path2D;
        return n.addPath(e1, new DOMMatrix(i).invertSelf().multiplySelf(t)), n;
    }
    paintChar(e1, t, i, n, a, s) {
        const r = this.ctx, o = this.current, l = o.font, c = o.textRenderingMode, h = o.fontSize / o.fontSizeScale, d = c & Kl, u = !!(c & Yl), g = o.patternFill && !l.missingFile, f = o.patternStroke && !l.missingFile;
        let p;
        if ((l.disableFontFace || u || g || f) && !l.missingFile && (p = l.getPathGenerator(this.commonObjs, t)), p && (l.disableFontFace || g || f)) {
            let t;
            if (r.save(), r.translate(i, n), r.scale(h, -h), this.dependencyTracker?.recordCharacterBBox(e1, r, l), d === zl || d === Gl) if (a) {
                t = r.getTransform(), r.setTransform(...a);
                const e1 = this.#Cs(p, t, a);
                r.fill(e1);
            } else r.fill(p);
            if (d === Wl || d === Gl) if (s) {
                t ||= r.getTransform(), r.setTransform(...s);
                const { a: e1, b: i, c: n, d: a } = t, o = Util.inverseTransform(s), l = Util.transform([
                    e1,
                    i,
                    n,
                    a,
                    0,
                    0
                ], o);
                Util.singularValueDecompose2dScale(l, Qc), r.lineWidth *= Math.max(Qc[0], Qc[1]) / h, r.stroke(this.#Cs(p, t, s));
            } else r.lineWidth /= h, r.stroke(p);
            r.restore();
        } else d !== zl && d !== Gl || (r.fillText(t, i, n), this.dependencyTracker?.recordCharacterBBox(e1, r, l, h, i, n, ()=>r.measureText(t))), d !== Wl && d !== Gl || (this.dependencyTracker && this.dependencyTracker?.recordCharacterBBox(e1, r, l, h, i, n, ()=>r.measureText(t)).recordDependencies(e1, Uc), r.strokeText(t, i, n));
        if (u) {
            (this.pendingTextPaths ||= []).push({
                transform: getCurrentTransform(r),
                x: i,
                y: n,
                fontSize: h,
                path: p
            }), this.dependencyTracker?.recordCharacterBBox(e1, r, l, h, i, n);
        }
    }
    get isFontSubpixelAAEnabled() {
        const { context: e1 } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
        e1.scale(1.5, 1), e1.fillText("I", 0, 10);
        const t = e1.getImageData(0, 0, 10, 10).data;
        let i = !1;
        for(let e1 = 3; e1 < t.length; e1 += 4)if (t[e1] > 0 && t[e1] < 255) {
            i = !0;
            break;
        }
        return shadow(this, "isFontSubpixelAAEnabled", i);
    }
    showText(e1, t) {
        this.dependencyTracker && (this.dependencyTracker.recordDependencies(e1, Xc).resetBBox(e1), this.current.textRenderingMode & Yl && this.dependencyTracker.recordFutureForcedDependency("textClip", e1).inheritPendingDependenciesAsFutureForcedDependencies());
        const i = this.current, n = i.font;
        if (n.isType3Font) return this.showType3Text(e1, t), void this.dependencyTracker?.recordShowTextOperation(e1);
        const a = i.fontSize;
        if (0 === a) return void this.dependencyTracker?.recordOperation(e1);
        const s = this.ctx, r = i.fontSizeScale, o = i.charSpacing, l = i.wordSpacing, c = i.fontDirection, h = i.textHScale * c, d = t.length, u = n.vertical, g = u ? 1 : -1, f = n.defaultVMetrics, p = a * i.fontMatrix[0], m = i.textRenderingMode === zl && !n.disableFontFace && !i.patternFill;
        let b, y;
        if (s.save(), i.textMatrix && s.transform(...i.textMatrix), s.translate(i.x, i.y + i.textRise), c > 0 ? s.scale(h, -1) : s.scale(h, 1), i.patternFill) {
            s.save();
            const t = i.fillColor.getPattern(s, this, getCurrentTransformInverse(s), Wc, e1);
            b = getCurrentTransform(s), s.restore(), s.fillStyle = t;
        }
        if (i.patternStroke) {
            s.save();
            const t = i.strokeColor.getPattern(s, this, getCurrentTransformInverse(s), Gc, e1);
            y = getCurrentTransform(s), s.restore(), s.strokeStyle = t;
        }
        let w = i.lineWidth;
        const x = i.textMatrixScale;
        if (0 === x || 0 === w) {
            const e1 = i.textRenderingMode & Kl;
            e1 !== Wl && e1 !== Gl || (w = this.getSinglePixelWidth());
        } else w /= x;
        if (1 !== r && (s.scale(r, r), w /= r), s.lineWidth = w, n.isInvalidPDFjsFont) {
            const n = [];
            let a = 0;
            for (const e1 of t)n.push(e1.unicode), a += e1.width;
            const r = n.join("");
            if (s.fillText(r, 0, 0), null !== this.dependencyTracker) {
                const t = s.measureText(r);
                this.dependencyTracker.recordBBox(e1, this.ctx, -t.actualBoundingBoxLeft, t.actualBoundingBoxRight, -t.actualBoundingBoxAscent, t.actualBoundingBoxDescent).recordShowTextOperation(e1);
            }
            return i.x += a * p * h, s.restore(), void this.compose();
        }
        let S, v = 0;
        for(S = 0; S < d; ++S){
            const i = t[S];
            if ("number" == typeof i) {
                v += g * i * a / 1e3;
                continue;
            }
            let h = !1;
            const d = (i.isSpace ? l : 0) + o, w = i.fontChar, x = i.accent;
            let C, k, T, F = i.width;
            if (u) {
                const e1 = i.vmetric || f, t = -(i.vmetric ? e1[1] : .5 * F) * p, n = e1[2] * p;
                F = e1 ? -e1[0] : F, C = t / r, k = (v + n) / r;
            } else C = v / r, k = 0;
            if (n.remeasure && F > 0) {
                T = s.measureText(w);
                const e1 = 1e3 * T.width / a * r;
                if (F < e1 && this.isFontSubpixelAAEnabled) {
                    const t = F / e1;
                    h = !0, s.save(), s.scale(t, 1), C /= t;
                } else F !== e1 && (C += (F - e1) / 2e3 * a / r);
            }
            if (this.contentVisible && (i.isInFont || n.missingFile)) {
                if (m && !x) s.fillText(w, C, k), this.dependencyTracker?.recordCharacterBBox(e1, s, T ? {
                    bbox: null
                } : n, a / r, C, k, ()=>T ?? s.measureText(w));
                else if (this.paintChar(e1, w, C, k, b, y), x) {
                    const t = C + a * x.offset.x / r, i = k - a * x.offset.y / r;
                    this.paintChar(e1, x.fontChar, t, i, b, y);
                }
            }
            v += u ? F * p - d * c : F * p + d * c, h && s.restore();
        }
        u ? i.y -= v : i.x += v * h, s.restore(), this.compose(), this.dependencyTracker?.recordShowTextOperation(e1);
    }
    showType3Text(e1, t) {
        const i = this.ctx, n = this.current, a = n.font, s = n.fontSize, r = n.fontDirection, o = a.vertical ? 1 : -1, l = n.charSpacing, c = n.wordSpacing, h = n.textHScale * r, d = n.fontMatrix || Il, u = t.length;
        let g, f, p, m;
        if (n.textRenderingMode === Vl || 0 === s) return;
        this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, i.save(), n.textMatrix && i.transform(...n.textMatrix), i.translate(n.x, n.y + n.textRise), i.scale(h, r);
        const b = this.dependencyTracker;
        for(this.dependencyTracker = b ? new CanvasNestedDependencyTracker(b, e1) : null, g = 0; g < u; ++g){
            if (f = t[g], "number" == typeof f) {
                m = o * f * s / 1e3, this.ctx.translate(m, 0), n.x += m * h;
                continue;
            }
            const e1 = (f.isSpace ? c : 0) + l, r = a.charProcOperatorList[f.operatorListId];
            r ? this.contentVisible && (this.save(), i.scale(s, s), i.transform(...d), this.executeOperatorList(r), this.restore()) : warn(`Type3 character "${f.operatorListId}" is not available.`);
            const u = [
                f.width,
                0
            ];
            Util.applyTransform(u, d), p = u[0] * s + e1, i.translate(p, 0), n.x += p * h;
        }
        i.restore(), b && (this.dependencyTracker = b);
    }
    setCharWidth(e1, t, i) {}
    setCharWidthAndBounds(e1, t, i, n, a, s, r) {
        const o = new Path2D;
        o.rect(n, a, s - n, r - a), this.ctx.clip(o), this.dependencyTracker?.recordBBox(e1, this.ctx, n, s, a, r).recordClipBox(e1, this.ctx, n, s, a, r), this.endPath(e1);
    }
    getColorN_Pattern(e1, t) {
        let i;
        if ("TilingPattern" === t[0]) {
            const e1 = this.baseTransform || getCurrentTransform(this.ctx), n = {
                createCanvasGraphics: (e1, t)=>new CanvasGraphics(e1, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                        optionalContentConfig: this.optionalContentConfig,
                        markedContentStack: this.markedContentStack
                    }, void 0, void 0, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, t, !0) : null)
            };
            i = new TilingPattern(t, this.ctx, n, e1);
        } else i = this._getPattern(e1, t[1], t[2]);
        return i;
    }
    setStrokeColorN(e1, ...t) {
        this.dependencyTracker?.recordSimpleData("strokeColor", e1), this.current.strokeColor = this.getColorN_Pattern(e1, t), this.current.patternStroke = !0;
    }
    setFillColorN(e1, ...t) {
        this.dependencyTracker?.recordSimpleData("fillColor", e1), this.current.fillColor = this.getColorN_Pattern(e1, t), this.current.patternFill = !0;
    }
    setStrokeRGBColor(e1, t) {
        this.dependencyTracker?.recordSimpleData("strokeColor", e1), this.ctx.strokeStyle = this.current.strokeColor = t, this.current.patternStroke = !1;
    }
    setStrokeTransparent(e1) {
        this.dependencyTracker?.recordSimpleData("strokeColor", e1), this.ctx.strokeStyle = this.current.strokeColor = "transparent", this.current.patternStroke = !1;
    }
    setFillRGBColor(e1, t) {
        this.dependencyTracker?.recordSimpleData("fillColor", e1), this.ctx.fillStyle = this.current.fillColor = t, this.current.patternFill = !1;
    }
    setFillTransparent(e1) {
        this.dependencyTracker?.recordSimpleData("fillColor", e1), this.ctx.fillStyle = this.current.fillColor = "transparent", this.current.patternFill = !1;
    }
    _getPattern(e1, t, i = null) {
        let n;
        return this.cachedPatterns.has(t) ? n = this.cachedPatterns.get(t) : (n = function(e1) {
            switch(e1[0]){
                case "RadialAxial":
                    return new RadialAxialShadingPattern(e1);
                case "Mesh":
                    return new MeshShadingPattern(e1);
                case "Dummy":
                    return new DummyShadingPattern;
            }
            throw new Error(`Unknown IR type: ${e1[0]}`);
        }(this.getObject(e1, t)), this.cachedPatterns.set(t, n)), i && (n.matrix = i), n;
    }
    shadingFill(e1, t) {
        if (!this.contentVisible) return;
        const i = this.ctx;
        this.save(e1);
        const n = this._getPattern(e1, t);
        i.fillStyle = n.getPattern(i, this, getCurrentTransformInverse(i), Vc, e1);
        const a = getCurrentTransformInverse(i);
        if ("TURBOPACK compile-time truthy", 1) {
            const { width: e1, height: t } = i.canvas, n = eh.slice();
            Util.axialAlignedBoundingBox([
                0,
                0,
                e1,
                t
            ], a, n);
            const [s, r, o, l] = n;
            this.ctx.fillRect(s, r, o - s, l - r);
        } else //TURBOPACK unreachable
        ;
        this.dependencyTracker?.resetBBox(e1).recordFullPageBBox(e1).recordDependencies(e1, qc).recordDependencies(e1, jc).recordOperation(e1), this.compose(this.current.getClippedPathBoundingBox()), this.restore(e1);
    }
    beginInlineImage() {
        unreachable("Should not call beginInlineImage");
    }
    beginImageData() {
        unreachable("Should not call beginImageData");
    }
    paintFormXObjectBegin(e1, t, i) {
        if (this.contentVisible && (this.save(e1), this.baseTransformStack.push(this.baseTransform), t && this.transform(e1, ...t), this.baseTransform = getCurrentTransform(this.ctx), i)) {
            Util.axialAlignedBoundingBox(i, this.baseTransform, this.current.minMax);
            const [t, n, a, s] = i, r = new Path2D;
            r.rect(t, n, a - t, s - n), this.ctx.clip(r), this.dependencyTracker?.recordClipBox(e1, this.ctx, t, a, n, s), this.endPath(e1);
        }
    }
    paintFormXObjectEnd(e1) {
        this.contentVisible && (this.restore(e1), this.baseTransform = this.baseTransformStack.pop());
    }
    beginGroup(e1, t) {
        if (!this.contentVisible) return;
        this.save(e1), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
        const i = this.ctx;
        t.isolated || info("TODO: Support non-isolated groups."), t.knockout && warn("Knockout groups not supported.");
        const n = getCurrentTransform(i);
        if (t.matrix && i.transform(...t.matrix), !t.bbox) throw new Error("Bounding box is required.");
        let a = eh.slice();
        Util.axialAlignedBoundingBox(t.bbox, getCurrentTransform(i), a);
        const s = [
            0,
            0,
            i.canvas.width,
            i.canvas.height
        ];
        a = Util.intersect(a, s) || [
            0,
            0,
            0,
            0
        ];
        const r = Math.floor(a[0]), o = Math.floor(a[1]), l = Math.max(Math.ceil(a[2]) - r, 1), c = Math.max(Math.ceil(a[3]) - o, 1);
        this.current.startNewPathAndClipBox([
            0,
            0,
            l,
            c
        ]);
        let h = "groupAt" + this.groupLevel;
        t.smask && (h += "_smask_" + this.smaskCounter++ % 2);
        const d = this.cachedCanvases.getCanvas(h, l, c), u = d.context;
        u.translate(-r, -o), u.transform(...n);
        let g = new Path2D;
        const [f, p, m, b] = t.bbox;
        if (g.rect(f, p, m - f, b - p), t.matrix) {
            const e1 = new Path2D;
            e1.addPath(g, new DOMMatrix(t.matrix)), g = e1;
        }
        u.clip(g), t.smask && this.smaskStack.push({
            canvas: d.canvas,
            context: u,
            offsetX: r,
            offsetY: o,
            subtype: t.smask.subtype,
            backdrop: t.smask.backdrop,
            transferMap: t.smask.transferMap || null,
            startTransformInverse: null
        }), t.smask && !this.dependencyTracker || (i.setTransform(1, 0, 0, 1, 0, 0), i.translate(r, o), i.save()), copyCtxState(i, u), this.ctx = u, this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies([
            "fillAlpha",
            "strokeAlpha",
            "globalCompositeOperation"
        ]).pushBaseTransform(i), this.setGState(e1, [
            [
                "BM",
                "source-over"
            ],
            [
                "ca",
                1
            ],
            [
                "CA",
                1
            ]
        ]), this.groupStack.push(i), this.groupLevel++;
    }
    endGroup(e1, t) {
        if (!this.contentVisible) return;
        this.groupLevel--;
        const i = this.ctx, n = this.groupStack.pop();
        if (this.ctx = n, this.ctx.imageSmoothingEnabled = !1, this.dependencyTracker?.popBaseTransform(), t.smask) this.tempSMask = this.smaskStack.pop(), this.restore(e1), this.dependencyTracker && this.ctx.restore();
        else {
            this.ctx.restore();
            const t = getCurrentTransform(this.ctx);
            this.restore(e1), this.ctx.save(), this.ctx.setTransform(...t);
            const n = eh.slice();
            Util.axialAlignedBoundingBox([
                0,
                0,
                i.canvas.width,
                i.canvas.height
            ], t, n), this.ctx.drawImage(i.canvas, 0, 0), this.ctx.restore(), this.compose(n);
        }
    }
    beginAnnotation(e1, t, i, n, a, s) {
        if (this.#Ss(), resetCtxToDefault(this.ctx), this.ctx.save(), this.save(e1), this.baseTransform && this.ctx.setTransform(...this.baseTransform), i) {
            const a = i[2] - i[0], r = i[3] - i[1];
            if (s && this.annotationCanvasMap) {
                (n = n.slice())[4] -= i[0], n[5] -= i[1], (i = i.slice())[0] = i[1] = 0, i[2] = a, i[3] = r, Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), Qc);
                const { viewportScale: e1 } = this, s = Math.ceil(a * this.outputScaleX * e1), o = Math.ceil(r * this.outputScaleY * e1);
                this.annotationCanvas = this.canvasFactory.create(s, o);
                const { canvas: l, context: c } = this.annotationCanvas;
                this.annotationCanvasMap.set(t, l), this.annotationCanvas.savedCtx = this.ctx, this.ctx = c, this.ctx.save(), this.ctx.setTransform(Qc[0], 0, 0, -Qc[1], 0, r * Qc[1]), resetCtxToDefault(this.ctx);
            } else {
                resetCtxToDefault(this.ctx), this.endPath(e1);
                const t = new Path2D;
                t.rect(i[0], i[1], a, r), this.ctx.clip(t);
            }
        }
        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(e1, ...n), this.transform(e1, ...a);
    }
    endAnnotation(e1) {
        this.annotationCanvas && (this.ctx.restore(), this.#vs(), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
    }
    paintImageMaskXObject(e1, t) {
        if (!this.contentVisible) return;
        const i = t.count;
        (t = this.getObject(e1, t.data, t)).count = i;
        const n = this.ctx, a = this._createMaskCanvas(e1, t), s = a.canvas;
        n.save(), n.setTransform(1, 0, 0, 1, 0, 0), n.drawImage(s, a.offsetX, a.offsetY), this.dependencyTracker?.resetBBox(e1).recordBBox(e1, this.ctx, a.offsetX, a.offsetX + s.width, a.offsetY, a.offsetY + s.height).recordOperation(e1), n.restore(), this.compose();
    }
    paintImageMaskXObjectRepeat(e1, t, i, n = 0, a = 0, s, r) {
        if (!this.contentVisible) return;
        t = this.getObject(e1, t.data, t);
        const o = this.ctx;
        o.save();
        const l = getCurrentTransform(o);
        o.transform(i, n, a, s, 0, 0);
        const c = this._createMaskCanvas(e1, t);
        o.setTransform(1, 0, 0, 1, c.offsetX - l[4], c.offsetY - l[5]), this.dependencyTracker?.resetBBox(e1);
        for(let t = 0, h = r.length; t < h; t += 2){
            const h = Util.transform(l, [
                i,
                n,
                a,
                s,
                r[t],
                r[t + 1]
            ]);
            o.drawImage(c.canvas, h[4], h[5]), this.dependencyTracker?.recordBBox(e1, this.ctx, h[4], h[4] + c.canvas.width, h[5], h[5] + c.canvas.height);
        }
        o.restore(), this.compose(), this.dependencyTracker?.recordOperation(e1);
    }
    paintImageMaskXObjectGroup(e1, t) {
        if (!this.contentVisible) return;
        const i = this.ctx, n = this.current.fillColor, a = this.current.patternFill;
        this.dependencyTracker?.resetBBox(e1).recordDependencies(e1, zc);
        for (const s of t){
            const { data: t, width: r, height: o, transform: l } = s, c = this.cachedCanvases.getCanvas("maskCanvas", r, o), h = c.context;
            h.save();
            putBinaryImageMask(h, this.getObject(e1, t, s)), h.globalCompositeOperation = "source-in", h.fillStyle = a ? n.getPattern(h, this, getCurrentTransformInverse(i), Wc, e1) : n, h.fillRect(0, 0, r, o), h.restore(), i.save(), i.transform(...l), i.scale(1, -1), drawImageAtIntegerCoords(i, c.canvas, 0, 0, r, o, 0, -1, 1, 1), this.dependencyTracker?.recordBBox(e1, i, 0, r, 0, o), i.restore();
        }
        this.compose(), this.dependencyTracker?.recordOperation(e1);
    }
    paintImageXObject(e1, t) {
        if (!this.contentVisible) return;
        const i = this.getObject(e1, t);
        i ? this.paintInlineImageXObject(e1, i) : warn("Dependent image isn't ready yet");
    }
    paintImageXObjectRepeat(e1, t, i, n, a) {
        if (!this.contentVisible) return;
        const s = this.getObject(e1, t);
        if (!s) return void warn("Dependent image isn't ready yet");
        const r = s.width, o = s.height, l = [];
        for(let e1 = 0, t = a.length; e1 < t; e1 += 2)l.push({
            transform: [
                i,
                0,
                0,
                n,
                a[e1],
                a[e1 + 1]
            ],
            x: 0,
            y: 0,
            w: r,
            h: o
        });
        this.paintInlineImageXObjectGroup(e1, s, l);
    }
    applyTransferMapsToCanvas(e1) {
        return "none" !== this.current.transferMaps && (e1.filter = this.current.transferMaps, e1.drawImage(e1.canvas, 0, 0), e1.filter = "none"), e1.canvas;
    }
    applyTransferMapsToBitmap(e1) {
        if ("none" === this.current.transferMaps) return e1.bitmap;
        const { bitmap: t, width: i, height: n } = e1, a = this.cachedCanvases.getCanvas("inlineImage", i, n), s = a.context;
        return s.filter = this.current.transferMaps, s.drawImage(t, 0, 0), s.filter = "none", a.canvas;
    }
    paintInlineImageXObject(e1, t) {
        if (!this.contentVisible) return;
        const i = t.width, n = t.height, a = this.ctx;
        this.save(e1);
        const { filter: s } = a;
        let r;
        if ("none" !== s && "" !== s && (a.filter = "none"), a.scale(1 / i, -1 / n), t.bitmap) r = this.applyTransferMapsToBitmap(t);
        else if ("function" == typeof HTMLElement && t instanceof HTMLElement || !t.data) r = t;
        else {
            const e1 = this.cachedCanvases.getCanvas("inlineImage", i, n).context;
            putBinaryImageData(e1, t), r = this.applyTransferMapsToCanvas(e1);
        }
        const o = this._scaleImage(r, getCurrentTransformInverse(a));
        a.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(a), t.interpolate), this.dependencyTracker?.resetBBox(e1).recordBBox(e1, a, 0, i, -n, 0).recordDependencies(e1, $c).recordOperation(e1), drawImageAtIntegerCoords(a, o.img, 0, 0, o.paintWidth, o.paintHeight, 0, -n, i, n), this.compose(), this.restore(e1);
    }
    paintInlineImageXObjectGroup(e1, t, i) {
        if (!this.contentVisible) return;
        const n = this.ctx;
        let a;
        if (t.bitmap) a = t.bitmap;
        else {
            const e1 = t.width, i = t.height, n = this.cachedCanvases.getCanvas("inlineImage", e1, i).context;
            putBinaryImageData(n, t), a = this.applyTransferMapsToCanvas(n);
        }
        this.dependencyTracker?.resetBBox(e1);
        for (const t of i)n.save(), n.transform(...t.transform), n.scale(1, -1), drawImageAtIntegerCoords(n, a, t.x, t.y, t.w, t.h, 0, -1, 1, 1), this.dependencyTracker?.recordBBox(e1, n, 0, 1, -1, 0), n.restore();
        this.dependencyTracker?.recordOperation(e1), this.compose();
    }
    paintSolidColorImageMask(e1) {
        this.contentVisible && (this.dependencyTracker?.resetBBox(e1).recordBBox(e1, this.ctx, 0, 1, 0, 1).recordDependencies(e1, jc).recordOperation(e1), this.ctx.fillRect(0, 0, 1, 1), this.compose());
    }
    markPoint(e1, t) {}
    markPointProps(e1, t, i) {}
    beginMarkedContent(e1, t) {
        this.dependencyTracker?.beginMarkedContent(e1), this.markedContentStack.push({
            visible: !0
        });
    }
    beginMarkedContentProps(e1, t, i) {
        this.dependencyTracker?.beginMarkedContent(e1), "OC" === t ? this.markedContentStack.push({
            visible: this.optionalContentConfig.isVisible(i)
        }) : this.markedContentStack.push({
            visible: !0
        }), this.contentVisible = this.isContentVisible();
    }
    endMarkedContent(e1) {
        this.dependencyTracker?.endMarkedContent(e1), this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
    }
    beginCompat(e1) {}
    endCompat(e1) {}
    consumePath(e1, t, i) {
        const n = this.current.isEmptyClip();
        this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(i);
        const a = this.ctx;
        this.pendingClip ? (n || (this.pendingClip === ah ? a.clip(t, "evenodd") : a.clip(t)), this.pendingClip = null, this.dependencyTracker?.bboxToClipBoxDropOperation(e1).recordFutureForcedDependency("clipPath", e1)) : this.dependencyTracker?.recordOperation(e1), this.current.startNewPathAndClipBox(this.current.clipBox);
    }
    getSinglePixelWidth() {
        if (!this._cachedGetSinglePixelWidth) {
            const e1 = getCurrentTransform(this.ctx);
            if (0 === e1[1] && 0 === e1[2]) this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(e1[0]), Math.abs(e1[3]));
            else {
                const t = Math.abs(e1[0] * e1[3] - e1[2] * e1[1]), i = Math.hypot(e1[0], e1[2]), n = Math.hypot(e1[1], e1[3]);
                this._cachedGetSinglePixelWidth = Math.max(i, n) / t;
            }
        }
        return this._cachedGetSinglePixelWidth;
    }
    getScaleForStroking() {
        if (-1 === this._cachedScaleForStroking[0]) {
            const { lineWidth: e1 } = this.current, { a: t, b: i, c: n, d: a } = this.ctx.getTransform();
            let s, r;
            if (0 === i && 0 === n) {
                const i = Math.abs(t), n = Math.abs(a);
                if (i === n) if (0 === e1) s = r = 1 / i;
                else {
                    const t = i * e1;
                    s = r = t < 1 ? 1 / t : 1;
                }
                else if (0 === e1) s = 1 / i, r = 1 / n;
                else {
                    const t = i * e1, a = n * e1;
                    s = t < 1 ? 1 / t : 1, r = a < 1 ? 1 / a : 1;
                }
            } else {
                const o = Math.abs(t * a - i * n), l = Math.hypot(t, i), c = Math.hypot(n, a);
                if (0 === e1) s = c / o, r = l / o;
                else {
                    const t = e1 * o;
                    s = c > t ? c / t : 1, r = l > t ? l / t : 1;
                }
            }
            this._cachedScaleForStroking[0] = s, this._cachedScaleForStroking[1] = r;
        }
        return this._cachedScaleForStroking;
    }
    rescaleAndStroke(e1, t) {
        const { ctx: i, current: { lineWidth: n } } = this, [a, s] = this.getScaleForStroking();
        if (a === s) return i.lineWidth = (n || 1) * a, void i.stroke(e1);
        const r = i.getLineDash();
        t && i.save(), i.scale(a, s), Zc.a = 1 / a, Zc.d = 1 / s;
        const o = new Path2D;
        if (o.addPath(e1, Zc), r.length > 0) {
            const e1 = Math.max(a, s);
            i.setLineDash(r.map((t)=>t / e1)), i.lineDashOffset /= e1;
        }
        i.lineWidth = n || 1, i.stroke(o), t && i.restore();
    }
    isContentVisible() {
        for(let e1 = this.markedContentStack.length - 1; e1 >= 0; e1--)if (!this.markedContentStack[e1].visible) return !1;
        return !0;
    }
}
for(const e1 in sc)void 0 !== CanvasGraphics.prototype[e1] && (CanvasGraphics.prototype[sc[e1]] = CanvasGraphics.prototype[e1]);
class CssFontInfo {
    #R;
    #W;
    #G;
    static strings = [
        "fontFamily",
        "fontWeight",
        "italicAngle"
    ];
    static write(e1) {
        const t = new TextEncoder, i = {};
        let n = 0;
        for (const a of CssFontInfo.strings){
            const s = t.encode(e1[a]);
            i[a] = s, n += 4 + s.length;
        }
        const a = new ArrayBuffer(n), s = new Uint8Array(a), r = new DataView(a);
        let o = 0;
        for (const e1 of CssFontInfo.strings){
            const t = i[e1], n = t.length;
            r.setUint32(o, n), s.set(t, o + 4), o += 4 + n;
        }
        return assert(o === a.byteLength, "CssFontInfo.write: Buffer overflow"), a;
    }
    constructor(e1){
        this.#R = e1, this.#W = new DataView(this.#R), this.#G = new TextDecoder;
    }
    #V(e1) {
        assert(e1 < CssFontInfo.strings.length, "Invalid string index");
        let t = 0;
        for(let i = 0; i < e1; i++)t += this.#W.getUint32(t) + 4;
        const i = this.#W.getUint32(t);
        return this.#G.decode(new Uint8Array(this.#R, t + 4, i));
    }
    get fontFamily() {
        return this.#V(0);
    }
    get fontWeight() {
        return this.#V(1);
    }
    get italicAngle() {
        return this.#V(2);
    }
}
class SystemFontInfo {
    #R;
    #W;
    #G;
    static strings = [
        "css",
        "loadedName",
        "baseFontName",
        "src"
    ];
    static write(e1) {
        const t = new TextEncoder, i = {};
        let n = 0;
        for (const a of SystemFontInfo.strings){
            const s = t.encode(e1[a]);
            i[a] = s, n += 4 + s.length;
        }
        n += 4;
        let a, s, r = 1 + n;
        e1.style && (a = t.encode(e1.style.style), s = t.encode(e1.style.weight), r += 4 + a.length + 4 + s.length);
        const o = new ArrayBuffer(r), l = new Uint8Array(o), c = new DataView(o);
        let h = 0;
        c.setUint8(h++, e1.guessFallback ? 1 : 0), c.setUint32(h, 0), h += 4, n = 0;
        for (const e1 of SystemFontInfo.strings){
            const t = i[e1], a = t.length;
            n += 4 + a, c.setUint32(h, a), l.set(t, h + 4), h += 4 + a;
        }
        return c.setUint32(h - n - 4, n), e1.style && (c.setUint32(h, a.length), l.set(a, h + 4), h += 4 + a.length, c.setUint32(h, s.length), l.set(s, h + 4), h += 4 + s.length), assert(h <= o.byteLength, "SubstitionInfo.write: Buffer overflow"), o.transferToFixedLength(h);
    }
    constructor(e1){
        this.#R = e1, this.#W = new DataView(this.#R), this.#G = new TextDecoder;
    }
    get guessFallback() {
        return 0 !== this.#W.getUint8(0);
    }
    #V(e1) {
        assert(e1 < SystemFontInfo.strings.length, "Invalid string index");
        let t = 5;
        for(let i = 0; i < e1; i++)t += this.#W.getUint32(t) + 4;
        const i = this.#W.getUint32(t);
        return this.#G.decode(new Uint8Array(this.#R, t + 4, i));
    }
    get css() {
        return this.#V(0);
    }
    get loadedName() {
        return this.#V(1);
    }
    get baseFontName() {
        return this.#V(2);
    }
    get src() {
        return this.#V(3);
    }
    get style() {
        let e1 = 1;
        e1 += 4 + this.#W.getUint32(e1);
        const t = this.#W.getUint32(e1), i = this.#G.decode(new Uint8Array(this.#R, e1 + 4, t));
        e1 += 4 + t;
        const n = this.#W.getUint32(e1);
        return {
            style: i,
            weight: this.#G.decode(new Uint8Array(this.#R, e1 + 4, n))
        };
    }
}
class FontInfo {
    static bools = [
        "black",
        "bold",
        "disableFontFace",
        "fontExtraProperties",
        "isInvalidPDFjsFont",
        "isType3Font",
        "italic",
        "missingFile",
        "remeasure",
        "vertical"
    ];
    static numbers = [
        "ascent",
        "defaultWidth",
        "descent"
    ];
    static strings = [
        "fallbackName",
        "loadedName",
        "mimetype",
        "name"
    ];
    static #K = Math.ceil(2 * this.bools.length / 8);
    static #Y = this.#K + 8 * this.numbers.length;
    static #J = this.#Y + 1 + 8;
    static #Z = this.#J + 1 + 48;
    static #Q = this.#Z + 1 + 6;
    #R;
    #G;
    #W;
    constructor({ data: e1, extra: t }){
        this.#R = e1, this.#G = new TextDecoder, this.#W = new DataView(this.#R), t && Object.assign(this, t);
    }
    #ee(e1) {
        assert(e1 < FontInfo.bools.length, "Invalid boolean index");
        const t = Math.floor(e1 / 4), i = 2 * e1 % 8, n = this.#W.getUint8(t) >> i & 3;
        return 0 === n ? void 0 : 2 === n;
    }
    get black() {
        return this.#ee(0);
    }
    get bold() {
        return this.#ee(1);
    }
    get disableFontFace() {
        return this.#ee(2);
    }
    get fontExtraProperties() {
        return this.#ee(3);
    }
    get isInvalidPDFjsFont() {
        return this.#ee(4);
    }
    get isType3Font() {
        return this.#ee(5);
    }
    get italic() {
        return this.#ee(6);
    }
    get missingFile() {
        return this.#ee(7);
    }
    get remeasure() {
        return this.#ee(8);
    }
    get vertical() {
        return this.#ee(9);
    }
    #te(e1) {
        return assert(e1 < FontInfo.numbers.length, "Invalid number index"), this.#W.getFloat64(FontInfo.#K + 8 * e1);
    }
    get ascent() {
        return this.#te(0);
    }
    get defaultWidth() {
        return this.#te(1);
    }
    get descent() {
        return this.#te(2);
    }
    get bbox() {
        let e1 = FontInfo.#Y;
        if (0 === this.#W.getUint8(e1)) return;
        e1 += 1;
        const t = [];
        for(let i = 0; i < 4; i++)t.push(this.#W.getInt16(e1, !0)), e1 += 2;
        return t;
    }
    get fontMatrix() {
        let e1 = FontInfo.#J;
        if (0 === this.#W.getUint8(e1)) return;
        e1 += 1;
        const t = [];
        for(let i = 0; i < 6; i++)t.push(this.#W.getFloat64(e1, !0)), e1 += 8;
        return t;
    }
    get defaultVMetrics() {
        let e1 = FontInfo.#Z;
        if (0 === this.#W.getUint8(e1)) return;
        e1 += 1;
        const t = [];
        for(let i = 0; i < 3; i++)t.push(this.#W.getInt16(e1, !0)), e1 += 2;
        return t;
    }
    #V(e1) {
        assert(e1 < FontInfo.strings.length, "Invalid string index");
        let t = FontInfo.#Q + 4;
        for(let i = 0; i < e1; i++)t += this.#W.getUint32(t) + 4;
        const i = this.#W.getUint32(t), n = new Uint8Array(i);
        return n.set(new Uint8Array(this.#R, t + 4, i)), this.#G.decode(n);
    }
    get fallbackName() {
        return this.#V(0);
    }
    get loadedName() {
        return this.#V(1);
    }
    get mimetype() {
        return this.#V(2);
    }
    get name() {
        return this.#V(3);
    }
    get data() {
        let e1 = FontInfo.#Q;
        e1 += 4 + this.#W.getUint32(e1);
        e1 += 4 + this.#W.getUint32(e1);
        e1 += 4 + this.#W.getUint32(e1);
        const t = this.#W.getUint32(e1);
        if (0 !== t) return new Uint8Array(this.#R, e1 + 4, t);
    }
    clearData() {
        let e1 = FontInfo.#Q;
        e1 += 4 + this.#W.getUint32(e1);
        e1 += 4 + this.#W.getUint32(e1);
        e1 += 4 + this.#W.getUint32(e1);
        const t = this.#W.getUint32(e1);
        new Uint8Array(this.#R, e1 + 4, t).fill(0), this.#W.setUint32(e1, 0);
    }
    get cssFontInfo() {
        let e1 = FontInfo.#Q;
        e1 += 4 + this.#W.getUint32(e1);
        e1 += 4 + this.#W.getUint32(e1);
        const t = this.#W.getUint32(e1);
        if (0 === t) return null;
        const i = new Uint8Array(t);
        return i.set(new Uint8Array(this.#R, e1 + 4, t)), new CssFontInfo(i.buffer);
    }
    get systemFontInfo() {
        let e1 = FontInfo.#Q;
        e1 += 4 + this.#W.getUint32(e1);
        const t = this.#W.getUint32(e1);
        if (0 === t) return null;
        const i = new Uint8Array(t);
        return i.set(new Uint8Array(this.#R, e1 + 4, t)), new SystemFontInfo(i.buffer);
    }
    static write(e1) {
        const t = e1.systemFontInfo ? SystemFontInfo.write(e1.systemFontInfo) : null, i = e1.cssFontInfo ? CssFontInfo.write(e1.cssFontInfo) : null, n = new TextEncoder, a = {};
        let s = 0;
        for (const t of FontInfo.strings)a[t] = n.encode(e1[t]), s += 4 + a[t].length;
        const r = FontInfo.#Q + 4 + s + 4 + (t ? t.byteLength : 0) + 4 + (i ? i.byteLength : 0) + 4 + (e1.data ? e1.data.length : 0), o = new ArrayBuffer(r), l = new Uint8Array(o), c = new DataView(o);
        let h = 0;
        const d = FontInfo.bools.length;
        let u = 0, g = 0;
        for(let t = 0; t < d; t++){
            const i = e1[FontInfo.bools[t]];
            u |= (void 0 === i ? 0 : i ? 2 : 1) << g, g += 2, 8 !== g && t !== d - 1 || (c.setUint8(h++, u), u = 0, g = 0);
        }
        assert(h === FontInfo.#K, "FontInfo.write: Boolean properties offset mismatch");
        for (const t of FontInfo.numbers)c.setFloat64(h, e1[t]), h += 8;
        if (assert(h === FontInfo.#Y, "FontInfo.write: Number properties offset mismatch"), e1.bbox) {
            c.setUint8(h++, 4);
            for (const t of e1.bbox)c.setInt16(h, t, !0), h += 2;
        } else c.setUint8(h++, 0), h += 8;
        if (assert(h === FontInfo.#J, "FontInfo.write: BBox properties offset mismatch"), e1.fontMatrix) {
            c.setUint8(h++, 6);
            for (const t of e1.fontMatrix)c.setFloat64(h, t, !0), h += 8;
        } else c.setUint8(h++, 0), h += 48;
        if (assert(h === FontInfo.#Z, "FontInfo.write: FontMatrix properties offset mismatch"), e1.defaultVMetrics) {
            c.setUint8(h++, 1);
            for (const t of e1.defaultVMetrics)c.setInt16(h, t, !0), h += 2;
        } else c.setUint8(h++, 0), h += 6;
        assert(h === FontInfo.#Q, "FontInfo.write: DefaultVMetrics properties offset mismatch"), c.setUint32(FontInfo.#Q, 0), h += 4;
        for (const e1 of FontInfo.strings){
            const t = a[e1], i = t.length;
            c.setUint32(h, i), l.set(t, h + 4), h += 4 + i;
        }
        if (c.setUint32(FontInfo.#Q, h - FontInfo.#Q - 4), t) {
            const e1 = t.byteLength;
            c.setUint32(h, e1), assert(h + 4 + e1 <= o.byteLength, "FontInfo.write: Buffer overflow at systemFontInfo"), l.set(new Uint8Array(t), h + 4), h += 4 + e1;
        } else c.setUint32(h, 0), h += 4;
        if (i) {
            const e1 = i.byteLength;
            c.setUint32(h, e1), assert(h + 4 + e1 <= o.byteLength, "FontInfo.write: Buffer overflow at cssFontInfo"), l.set(new Uint8Array(i), h + 4), h += 4 + e1;
        } else c.setUint32(h, 0), h += 4;
        return void 0 === e1.data ? (c.setUint32(h, 0), h += 4) : (c.setUint32(h, e1.data.length), l.set(e1.data, h + 4), h += 4 + e1.data.length), assert(h <= o.byteLength, "FontInfo.write: Buffer overflow"), o.transferToFixedLength(h);
    }
}
class GlobalWorkerOptions {
    static #ks = null;
    static #Ts = "";
    static get workerPort() {
        return this.#ks;
    }
    static set workerPort(e1) {
        if (!("undefined" != typeof Worker && e1 instanceof Worker) && null !== e1) throw new Error("Invalid `workerPort` type.");
        this.#ks = e1;
    }
    static get workerSrc() {
        return this.#Ts;
    }
    static set workerSrc(e1) {
        if ("string" != typeof e1) throw new Error("Invalid `workerSrc` type.");
        this.#Ts = e1;
    }
}
class Metadata {
    #Fs;
    #Is;
    constructor({ parsedData: e1, rawData: t }){
        this.#Fs = e1, this.#Is = t;
    }
    getRaw() {
        return this.#Is;
    }
    get(e1) {
        return this.#Fs.get(e1) ?? null;
    }
    [Symbol.iterator]() {
        return this.#Fs.entries();
    }
}
const sh = Symbol("INTERNAL");
class OptionalContentGroup {
    #Es = !1;
    #Ms = !1;
    #Ds = !1;
    #Os = !0;
    constructor(e1, { name: t, intent: i, usage: n, rbGroups: a }){
        this.#Es = !!(e1 & Dl), this.#Ms = !!(e1 & _l), this.name = t, this.intent = i, this.usage = n, this.rbGroups = a;
    }
    get visible() {
        if (this.#Ds) return this.#Os;
        if (!this.#Os) return !1;
        const { print: e1, view: t } = this.usage;
        return this.#Es ? "OFF" !== t?.viewState : !this.#Ms || "OFF" !== e1?.printState;
    }
    _setVisible(e1, t, i = !1) {
        e1 !== sh && unreachable("Internal method `_setVisible` called."), this.#Ds = i, this.#Os = t;
    }
}
class OptionalContentConfig {
    #_s = null;
    #Ps = new Map;
    #Rs = null;
    #Bs = null;
    constructor(e1, t = Dl){
        if (this.renderingIntent = t, this.name = null, this.creator = null, null !== e1) {
            this.name = e1.name, this.creator = e1.creator, this.#Bs = e1.order;
            for (const i of e1.groups)this.#Ps.set(i.id, new OptionalContentGroup(t, i));
            if ("OFF" === e1.baseState) for (const e1 of this.#Ps.values())e1._setVisible(sh, !1);
            for (const t of e1.on)this.#Ps.get(t)._setVisible(sh, !0);
            for (const t of e1.off)this.#Ps.get(t)._setVisible(sh, !1);
            this.#Rs = this.getHash();
        }
    }
    #Ns(e1) {
        const t = e1.length;
        if (t < 2) return !0;
        const i = e1[0];
        for(let n = 1; n < t; n++){
            const t = e1[n];
            let a;
            if (Array.isArray(t)) a = this.#Ns(t);
            else {
                if (!this.#Ps.has(t)) return warn(`Optional content group not found: ${t}`), !0;
                a = this.#Ps.get(t).visible;
            }
            switch(i){
                case "And":
                    if (!a) return !1;
                    break;
                case "Or":
                    if (a) return !0;
                    break;
                case "Not":
                    return !a;
                default:
                    return !0;
            }
        }
        return "And" === i;
    }
    isVisible(e1) {
        if (0 === this.#Ps.size) return !0;
        if (!e1) return info("Optional content group not defined."), !0;
        if ("OCG" === e1.type) return this.#Ps.has(e1.id) ? this.#Ps.get(e1.id).visible : (warn(`Optional content group not found: ${e1.id}`), !0);
        if ("OCMD" === e1.type) {
            if (e1.expression) return this.#Ns(e1.expression);
            if (!e1.policy || "AnyOn" === e1.policy) {
                for (const t of e1.ids){
                    if (!this.#Ps.has(t)) return warn(`Optional content group not found: ${t}`), !0;
                    if (this.#Ps.get(t).visible) return !0;
                }
                return !1;
            }
            if ("AllOn" === e1.policy) {
                for (const t of e1.ids){
                    if (!this.#Ps.has(t)) return warn(`Optional content group not found: ${t}`), !0;
                    if (!this.#Ps.get(t).visible) return !1;
                }
                return !0;
            }
            if ("AnyOff" === e1.policy) {
                for (const t of e1.ids){
                    if (!this.#Ps.has(t)) return warn(`Optional content group not found: ${t}`), !0;
                    if (!this.#Ps.get(t).visible) return !0;
                }
                return !1;
            }
            if ("AllOff" === e1.policy) {
                for (const t of e1.ids){
                    if (!this.#Ps.has(t)) return warn(`Optional content group not found: ${t}`), !0;
                    if (this.#Ps.get(t).visible) return !1;
                }
                return !0;
            }
            return warn(`Unknown optional content policy ${e1.policy}.`), !0;
        }
        return warn(`Unknown group type ${e1.type}.`), !0;
    }
    setVisibility(e1, t = !0, i = !0) {
        const n = this.#Ps.get(e1);
        if (n) {
            if (i && t && n.rbGroups.length) for (const t of n.rbGroups)for (const i of t)i !== e1 && this.#Ps.get(i)?._setVisible(sh, !1, !0);
            n._setVisible(sh, !!t, !0), this.#_s = null;
        } else warn(`Optional content group not found: ${e1}`);
    }
    setOCGState({ state: e1, preserveRB: t }) {
        let i;
        for (const n of e1){
            switch(n){
                case "ON":
                case "OFF":
                case "Toggle":
                    i = n;
                    continue;
            }
            const e1 = this.#Ps.get(n);
            if (e1) switch(i){
                case "ON":
                    this.setVisibility(n, !0, t);
                    break;
                case "OFF":
                    this.setVisibility(n, !1, t);
                    break;
                case "Toggle":
                    this.setVisibility(n, !e1.visible, t);
            }
        }
        this.#_s = null;
    }
    get hasInitialVisibility() {
        return null === this.#Rs || this.getHash() === this.#Rs;
    }
    getOrder() {
        return this.#Ps.size ? this.#Bs ? this.#Bs.slice() : [
            ...this.#Ps.keys()
        ] : null;
    }
    getGroup(e1) {
        return this.#Ps.get(e1) || null;
    }
    getHash() {
        if (null !== this.#_s) return this.#_s;
        const e1 = new MurmurHash3_64;
        for (const [t, i] of this.#Ps)e1.update(`${t}:${i.visible}`);
        return this.#_s = e1.hexdigest();
    }
    [Symbol.iterator]() {
        return this.#Ps.entries();
    }
}
class PDFDataTransportStream {
    constructor(e1, { disableRange: t = !1, disableStream: i = !1 }){
        assert(e1, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
        const { length: n, initialData: a, progressiveDone: s, contentDispositionFilename: r } = e1;
        if (this._queuedChunks = [], this._progressiveDone = s, this._contentDispositionFilename = r, a?.length > 0) {
            const e1 = a instanceof Uint8Array && a.byteLength === a.buffer.byteLength ? a.buffer : new Uint8Array(a).buffer;
            this._queuedChunks.push(e1);
        }
        this._pdfDataRangeTransport = e1, this._isStreamingSupported = !i, this._isRangeSupported = !t, this._contentLength = n, this._fullRequestReader = null, this._rangeReaders = [], e1.addRangeListener((e1, t)=>{
            this._onReceiveData({
                begin: e1,
                chunk: t
            });
        }), e1.addProgressListener((e1, t)=>{
            this._onProgress({
                loaded: e1,
                total: t
            });
        }), e1.addProgressiveReadListener((e1)=>{
            this._onReceiveData({
                chunk: e1
            });
        }), e1.addProgressiveDoneListener(()=>{
            this._onProgressiveDone();
        }), e1.transportReady();
    }
    _onReceiveData({ begin: e1, chunk: t }) {
        const i = t instanceof Uint8Array && t.byteLength === t.buffer.byteLength ? t.buffer : new Uint8Array(t).buffer;
        if (void 0 === e1) this._fullRequestReader ? this._fullRequestReader._enqueue(i) : this._queuedChunks.push(i);
        else {
            assert(this._rangeReaders.some(function(t) {
                return t._begin === e1 && (t._enqueue(i), !0);
            }), "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
        }
    }
    get _progressiveDataLength() {
        return this._fullRequestReader?._loaded ?? 0;
    }
    _onProgress(e1) {
        void 0 === e1.total ? this._rangeReaders[0]?.onProgress?.({
            loaded: e1.loaded
        }) : this._fullRequestReader?.onProgress?.({
            loaded: e1.loaded,
            total: e1.total
        });
    }
    _onProgressiveDone() {
        this._fullRequestReader?.progressiveDone(), this._progressiveDone = !0;
    }
    _removeRangeReader(e1) {
        const t = this._rangeReaders.indexOf(e1);
        t >= 0 && this._rangeReaders.splice(t, 1);
    }
    getFullReader() {
        assert(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
        const e1 = this._queuedChunks;
        return this._queuedChunks = null, new PDFDataTransportStreamReader(this, e1, this._progressiveDone, this._contentDispositionFilename);
    }
    getRangeReader(e1, t) {
        if (t <= this._progressiveDataLength) return null;
        const i = new PDFDataTransportStreamRangeReader(this, e1, t);
        return this._pdfDataRangeTransport.requestDataRange(e1, t), this._rangeReaders.push(i), i;
    }
    cancelAllRequests(e1) {
        this._fullRequestReader?.cancel(e1);
        for (const t of this._rangeReaders.slice(0))t.cancel(e1);
        this._pdfDataRangeTransport.abort();
    }
}
class PDFDataTransportStreamReader {
    constructor(e1, t, i = !1, n = null){
        this._stream = e1, this._done = i || !1, this._filename = isPdfFile(n) ? n : null, this._queuedChunks = t || [], this._loaded = 0;
        for (const e1 of this._queuedChunks)this._loaded += e1.byteLength;
        this._requests = [], this._headersReady = Promise.resolve(), e1._fullRequestReader = this, this.onProgress = null;
    }
    _enqueue(e1) {
        if (!this._done) {
            if (this._requests.length > 0) {
                this._requests.shift().resolve({
                    value: e1,
                    done: !1
                });
            } else this._queuedChunks.push(e1);
            this._loaded += e1.byteLength;
        }
    }
    get headersReady() {
        return this._headersReady;
    }
    get filename() {
        return this._filename;
    }
    get isRangeSupported() {
        return this._stream._isRangeSupported;
    }
    get isStreamingSupported() {
        return this._stream._isStreamingSupported;
    }
    get contentLength() {
        return this._stream._contentLength;
    }
    async read() {
        if (this._queuedChunks.length > 0) {
            return {
                value: this._queuedChunks.shift(),
                done: !1
            };
        }
        if (this._done) return {
            value: void 0,
            done: !0
        };
        const e1 = Promise.withResolvers();
        return this._requests.push(e1), e1.promise;
    }
    cancel(e1) {
        this._done = !0;
        for (const e1 of this._requests)e1.resolve({
            value: void 0,
            done: !0
        });
        this._requests.length = 0;
    }
    progressiveDone() {
        this._done || (this._done = !0);
    }
}
class PDFDataTransportStreamRangeReader {
    constructor(e1, t, i){
        this._stream = e1, this._begin = t, this._end = i, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
    }
    _enqueue(e1) {
        if (!this._done) {
            if (0 === this._requests.length) this._queuedChunk = e1;
            else {
                this._requests.shift().resolve({
                    value: e1,
                    done: !1
                });
                for (const e1 of this._requests)e1.resolve({
                    value: void 0,
                    done: !0
                });
                this._requests.length = 0;
            }
            this._done = !0, this._stream._removeRangeReader(this);
        }
    }
    get isStreamingSupported() {
        return !1;
    }
    async read() {
        if (this._queuedChunk) {
            const e1 = this._queuedChunk;
            return this._queuedChunk = null, {
                value: e1,
                done: !1
            };
        }
        if (this._done) return {
            value: void 0,
            done: !0
        };
        const e1 = Promise.withResolvers();
        return this._requests.push(e1), e1.promise;
    }
    cancel(e1) {
        this._done = !0;
        for (const e1 of this._requests)e1.resolve({
            value: void 0,
            done: !0
        });
        this._requests.length = 0, this._stream._removeRangeReader(this);
    }
}
function createHeaders(e1, t) {
    const i = new Headers;
    if (!e1 || !t || "object" != typeof t) return i;
    for(const e1 in t){
        const n = t[e1];
        void 0 !== n && i.append(e1, n);
    }
    return i;
}
function getResponseOrigin(e1) {
    return URL.parse(e1)?.origin ?? null;
}
function validateRangeRequestCapabilities({ responseHeaders: e1, isHttp: t, rangeChunkSize: i, disableRange: n }) {
    const a = {
        allowRangeRequests: !1,
        suggestedLength: void 0
    }, s = parseInt(e1.get("Content-Length"), 10);
    if (!Number.isInteger(s)) return a;
    if (a.suggestedLength = s, s <= 2 * i) return a;
    if (n || !t) return a;
    if ("bytes" !== e1.get("Accept-Ranges")) return a;
    return "identity" !== (e1.get("Content-Encoding") || "identity") || (a.allowRangeRequests = !0), a;
}
function extractFilenameFromHeader(e1) {
    const t = e1.get("Content-Disposition");
    if (t) {
        let e1 = function(e1) {
            let t = !0, i = toParamRegExp("filename\\*", "i").exec(e1);
            if (i) {
                i = i[1];
                let e1 = rfc2616unquote(i);
                return e1 = unescape(e1), e1 = rfc5987decode(e1), e1 = rfc2047decode(e1), fixupEncoding(e1);
            }
            if (i = function(e1) {
                const t = [];
                let i;
                const n = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                for(; null !== (i = n.exec(e1));){
                    let [, e1, n, a] = i;
                    if (e1 = parseInt(e1, 10), e1 in t) {
                        if (0 === e1) break;
                    } else t[e1] = [
                        n,
                        a
                    ];
                }
                const a = [];
                for(let e1 = 0; e1 < t.length && e1 in t; ++e1){
                    let [i, n] = t[e1];
                    n = rfc2616unquote(n), i && (n = unescape(n), 0 === e1 && (n = rfc5987decode(n))), a.push(n);
                }
                return a.join("");
            }(e1), i) return fixupEncoding(rfc2047decode(i));
            if (i = toParamRegExp("filename", "i").exec(e1), i) {
                i = i[1];
                let e1 = rfc2616unquote(i);
                return e1 = rfc2047decode(e1), fixupEncoding(e1);
            }
            function toParamRegExp(e1, t) {
                return new RegExp("(?:^|;)\\s*" + e1 + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', t);
            }
            function textdecode(e1, i) {
                if (e1) {
                    if (!/^[\x00-\xFF]+$/.test(i)) return i;
                    try {
                        const n = new TextDecoder(e1, {
                            fatal: !0
                        }), a = stringToBytes(i);
                        i = n.decode(a), t = !1;
                    } catch  {}
                }
                return i;
            }
            function fixupEncoding(e1) {
                return t && /[\x80-\xff]/.test(e1) && (e1 = textdecode("utf-8", e1), t && (e1 = textdecode("iso-8859-1", e1))), e1;
            }
            function rfc2616unquote(e1) {
                if (e1.startsWith('"')) {
                    const t = e1.slice(1).split('\\"');
                    for(let e1 = 0; e1 < t.length; ++e1){
                        const i = t[e1].indexOf('"');
                        -1 !== i && (t[e1] = t[e1].slice(0, i), t.length = e1 + 1), t[e1] = t[e1].replaceAll(/\\(.)/g, "$1");
                    }
                    e1 = t.join('"');
                }
                return e1;
            }
            function rfc5987decode(e1) {
                const t = e1.indexOf("'");
                return -1 === t ? e1 : textdecode(e1.slice(0, t), e1.slice(t + 1).replace(/^[^']*'/, ""));
            }
            function rfc2047decode(e1) {
                return !e1.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(e1) ? e1 : e1.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(e1, t, i, n) {
                    if ("q" === i || "Q" === i) return textdecode(t, n = (n = n.replaceAll("_", " ")).replaceAll(/=([0-9a-fA-F]{2})/g, function(e1, t) {
                        return String.fromCharCode(parseInt(t, 16));
                    }));
                    try {
                        n = atob(n);
                    } catch  {}
                    return textdecode(t, n);
                });
            }
            return "";
        }(t);
        if (e1.includes("%")) try {
            e1 = decodeURIComponent(e1);
        } catch  {}
        if (isPdfFile(e1)) return e1;
    }
    return null;
}
function createResponseError(e1, t) {
    return new ResponseException(`Unexpected server response (${e1}) while retrieving PDF "${t}".`, e1, 404 === e1 || 0 === e1 && t.startsWith("file:"));
}
function validateResponseStatus(e1) {
    return 200 === e1 || 206 === e1;
}
function createFetchOptions(e1, t, i) {
    return {
        method: "GET",
        headers: e1,
        signal: i.signal,
        mode: "cors",
        credentials: t ? "include" : "same-origin",
        redirect: "follow"
    };
}
function getArrayBuffer(e1) {
    return e1 instanceof Uint8Array ? e1.buffer : e1 instanceof ArrayBuffer ? e1 : (warn(`getArrayBuffer - unexpected data format: ${e1}`), new Uint8Array(e1).buffer);
}
class PDFFetchStream {
    _responseOrigin = null;
    constructor(e1){
        this.source = e1, this.isHttp = /^https?:/i.test(e1.url), this.headers = createHeaders(this.isHttp, e1.httpHeaders), this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
        return this._fullRequestReader?._loaded ?? 0;
    }
    getFullReader() {
        return assert(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new PDFFetchStreamReader(this), this._fullRequestReader;
    }
    getRangeReader(e1, t) {
        if (t <= this._progressiveDataLength) return null;
        const i = new PDFFetchStreamRangeReader(this, e1, t);
        return this._rangeRequestReaders.push(i), i;
    }
    cancelAllRequests(e1) {
        this._fullRequestReader?.cancel(e1);
        for (const t of this._rangeRequestReaders.slice(0))t.cancel(e1);
    }
}
class PDFFetchStreamReader {
    constructor(e1){
        this._stream = e1, this._reader = null, this._loaded = 0, this._filename = null;
        const t = e1.source;
        this._withCredentials = t.withCredentials || !1, this._contentLength = t.length, this._headersCapability = Promise.withResolvers(), this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = !0), this._abortController = new AbortController, this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange;
        const i = new Headers(e1.headers), n = t.url;
        fetch(n, createFetchOptions(i, this._withCredentials, this._abortController)).then((t)=>{
            if (e1._responseOrigin = getResponseOrigin(t.url), !validateResponseStatus(t.status)) throw createResponseError(t.status, n);
            this._reader = t.body.getReader(), this._headersCapability.resolve();
            const i = t.headers, { allowRangeRequests: a, suggestedLength: s } = validateRangeRequestCapabilities({
                responseHeaders: i,
                isHttp: e1.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
            });
            this._isRangeSupported = a, this._contentLength = s || this._contentLength, this._filename = extractFilenameFromHeader(i), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new AbortException("Streaming is disabled."));
        }).catch(this._headersCapability.reject), this.onProgress = null;
    }
    get headersReady() {
        return this._headersCapability.promise;
    }
    get filename() {
        return this._filename;
    }
    get contentLength() {
        return this._contentLength;
    }
    get isRangeSupported() {
        return this._isRangeSupported;
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    async read() {
        await this._headersCapability.promise;
        const { value: e1, done: t } = await this._reader.read();
        return t ? {
            value: e1,
            done: t
        } : (this._loaded += e1.byteLength, this.onProgress?.({
            loaded: this._loaded,
            total: this._contentLength
        }), {
            value: getArrayBuffer(e1),
            done: !1
        });
    }
    cancel(e1) {
        this._reader?.cancel(e1), this._abortController.abort();
    }
}
class PDFFetchStreamRangeReader {
    constructor(e1, t, i){
        this._stream = e1, this._reader = null, this._loaded = 0;
        const n = e1.source;
        this._withCredentials = n.withCredentials || !1, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !n.disableStream, this._abortController = new AbortController;
        const a = new Headers(e1.headers);
        a.append("Range", `bytes=${t}-${i - 1}`);
        const s = n.url;
        fetch(s, createFetchOptions(a, this._withCredentials, this._abortController)).then((t)=>{
            const i = getResponseOrigin(t.url);
            if (i !== e1._responseOrigin) throw new Error(`Expected range response-origin "${i}" to match "${e1._responseOrigin}".`);
            if (!validateResponseStatus(t.status)) throw createResponseError(t.status, s);
            this._readCapability.resolve(), this._reader = t.body.getReader();
        }).catch(this._readCapability.reject), this.onProgress = null;
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    async read() {
        await this._readCapability.promise;
        const { value: e1, done: t } = await this._reader.read();
        return t ? {
            value: e1,
            done: t
        } : (this._loaded += e1.byteLength, this.onProgress?.({
            loaded: this._loaded
        }), {
            value: getArrayBuffer(e1),
            done: !1
        });
    }
    cancel(e1) {
        this._reader?.cancel(e1), this._abortController.abort();
    }
}
class NetworkManager {
    _responseOrigin = null;
    constructor({ url: e1, httpHeaders: t, withCredentials: i }){
        this.url = e1, this.isHttp = /^https?:/i.test(e1), this.headers = createHeaders(this.isHttp, t), this.withCredentials = i || !1, this.currXhrId = 0, this.pendingRequests = Object.create(null);
    }
    request(e1) {
        const t = new XMLHttpRequest, i = this.currXhrId++, n = this.pendingRequests[i] = {
            xhr: t
        };
        t.open("GET", this.url), t.withCredentials = this.withCredentials;
        for (const [e1, i] of this.headers)t.setRequestHeader(e1, i);
        return this.isHttp && "begin" in e1 && "end" in e1 ? (t.setRequestHeader("Range", `bytes=${e1.begin}-${e1.end - 1}`), n.expectedStatus = 206) : n.expectedStatus = 200, t.responseType = "arraybuffer", assert(e1.onError, "Expected `onError` callback to be provided."), t.onerror = ()=>{
            e1.onError(t.status);
        }, t.onreadystatechange = this.onStateChange.bind(this, i), t.onprogress = this.onProgress.bind(this, i), n.onHeadersReceived = e1.onHeadersReceived, n.onDone = e1.onDone, n.onError = e1.onError, n.onProgress = e1.onProgress, t.send(null), i;
    }
    onProgress(e1, t) {
        const i = this.pendingRequests[e1];
        i && i.onProgress?.(t);
    }
    onStateChange(e1, t) {
        const i = this.pendingRequests[e1];
        if (!i) return;
        const n = i.xhr;
        if (n.readyState >= 2 && i.onHeadersReceived && (i.onHeadersReceived(), delete i.onHeadersReceived), 4 !== n.readyState) return;
        if (!(e1 in this.pendingRequests)) return;
        if (delete this.pendingRequests[e1], 0 === n.status && this.isHttp) return void i.onError(n.status);
        const a = n.status || 200;
        if (!(200 === a && 206 === i.expectedStatus) && a !== i.expectedStatus) return void i.onError(n.status);
        const s = function(e1) {
            const t = e1.response;
            return "string" != typeof t ? t : stringToBytes(t).buffer;
        }(n);
        if (206 === a) {
            const e1 = n.getResponseHeader("Content-Range"), t = /bytes (\d+)-(\d+)\/(\d+)/.exec(e1);
            t ? i.onDone({
                begin: parseInt(t[1], 10),
                chunk: s
            }) : (warn('Missing or invalid "Content-Range" header.'), i.onError(0));
        } else s ? i.onDone({
            begin: 0,
            chunk: s
        }) : i.onError(n.status);
    }
    getRequestXhr(e1) {
        return this.pendingRequests[e1].xhr;
    }
    isPendingRequest(e1) {
        return e1 in this.pendingRequests;
    }
    abortRequest(e1) {
        const t = this.pendingRequests[e1].xhr;
        delete this.pendingRequests[e1], t.abort();
    }
}
class PDFNetworkStream {
    constructor(e1){
        this._source = e1, this._manager = new NetworkManager(e1), this._rangeChunkSize = e1.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    _onRangeRequestReaderClosed(e1) {
        const t = this._rangeRequestReaders.indexOf(e1);
        t >= 0 && this._rangeRequestReaders.splice(t, 1);
    }
    getFullReader() {
        return assert(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source), this._fullRequestReader;
    }
    getRangeReader(e1, t) {
        const i = new PDFNetworkStreamRangeRequestReader(this._manager, e1, t);
        return i.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(i), i;
    }
    cancelAllRequests(e1) {
        this._fullRequestReader?.cancel(e1);
        for (const t of this._rangeRequestReaders.slice(0))t.cancel(e1);
    }
}
class PDFNetworkStreamFullRequestReader {
    constructor(e1, t){
        this._manager = e1, this._url = t.url, this._fullRequestId = e1.request({
            onHeadersReceived: this._onHeadersReceived.bind(this),
            onDone: this._onDone.bind(this),
            onError: this._onError.bind(this),
            onProgress: this._onProgress.bind(this)
        }), this._headersCapability = Promise.withResolvers(), this._disableRange = t.disableRange || !1, this._contentLength = t.length, this._rangeChunkSize = t.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
    }
    _onHeadersReceived() {
        const e1 = this._fullRequestId, t = this._manager.getRequestXhr(e1);
        this._manager._responseOrigin = getResponseOrigin(t.responseURL);
        const i = t.getAllResponseHeaders(), n = new Headers(i ? i.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map((e1)=>{
            const [t, ...i] = e1.split(": ");
            return [
                t,
                i.join(": ")
            ];
        }) : []), { allowRangeRequests: a, suggestedLength: s } = validateRangeRequestCapabilities({
            responseHeaders: n,
            isHttp: this._manager.isHttp,
            rangeChunkSize: this._rangeChunkSize,
            disableRange: this._disableRange
        });
        a && (this._isRangeSupported = !0), this._contentLength = s || this._contentLength, this._filename = extractFilenameFromHeader(n), this._isRangeSupported && this._manager.abortRequest(e1), this._headersCapability.resolve();
    }
    _onDone(e1) {
        if (e1) if (this._requests.length > 0) {
            this._requests.shift().resolve({
                value: e1.chunk,
                done: !1
            });
        } else this._cachedChunks.push(e1.chunk);
        if (this._done = !0, !(this._cachedChunks.length > 0)) {
            for (const e1 of this._requests)e1.resolve({
                value: void 0,
                done: !0
            });
            this._requests.length = 0;
        }
    }
    _onError(e1) {
        this._storedError = createResponseError(e1, this._url), this._headersCapability.reject(this._storedError);
        for (const e1 of this._requests)e1.reject(this._storedError);
        this._requests.length = 0, this._cachedChunks.length = 0;
    }
    _onProgress(e1) {
        this.onProgress?.({
            loaded: e1.loaded,
            total: e1.lengthComputable ? e1.total : this._contentLength
        });
    }
    get filename() {
        return this._filename;
    }
    get isRangeSupported() {
        return this._isRangeSupported;
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    get contentLength() {
        return this._contentLength;
    }
    get headersReady() {
        return this._headersCapability.promise;
    }
    async read() {
        if (await this._headersCapability.promise, this._storedError) throw this._storedError;
        if (this._cachedChunks.length > 0) {
            return {
                value: this._cachedChunks.shift(),
                done: !1
            };
        }
        if (this._done) return {
            value: void 0,
            done: !0
        };
        const e1 = Promise.withResolvers();
        return this._requests.push(e1), e1.promise;
    }
    cancel(e1) {
        this._done = !0, this._headersCapability.reject(e1);
        for (const e1 of this._requests)e1.resolve({
            value: void 0,
            done: !0
        });
        this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
    }
}
class PDFNetworkStreamRangeRequestReader {
    constructor(e1, t, i){
        this._manager = e1, this._url = e1.url, this._requestId = e1.request({
            begin: t,
            end: i,
            onHeadersReceived: this._onHeadersReceived.bind(this),
            onDone: this._onDone.bind(this),
            onError: this._onError.bind(this),
            onProgress: this._onProgress.bind(this)
        }), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
    }
    _onHeadersReceived() {
        const e1 = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);
        e1 !== this._manager._responseOrigin && (this._storedError = new Error(`Expected range response-origin "${e1}" to match "${this._manager._responseOrigin}".`), this._onError(0));
    }
    _close() {
        this.onClosed?.(this);
    }
    _onDone(e1) {
        const t = e1.chunk;
        if (this._requests.length > 0) {
            this._requests.shift().resolve({
                value: t,
                done: !1
            });
        } else this._queuedChunk = t;
        this._done = !0;
        for (const e1 of this._requests)e1.resolve({
            value: void 0,
            done: !0
        });
        this._requests.length = 0, this._close();
    }
    _onError(e1) {
        this._storedError ??= createResponseError(e1, this._url);
        for (const e1 of this._requests)e1.reject(this._storedError);
        this._requests.length = 0, this._queuedChunk = null;
    }
    _onProgress(e1) {
        this.isStreamingSupported || this.onProgress?.({
            loaded: e1.loaded
        });
    }
    get isStreamingSupported() {
        return !1;
    }
    async read() {
        if (this._storedError) throw this._storedError;
        if (null !== this._queuedChunk) {
            const e1 = this._queuedChunk;
            return this._queuedChunk = null, {
                value: e1,
                done: !1
            };
        }
        if (this._done) return {
            value: void 0,
            done: !0
        };
        const e1 = Promise.withResolvers();
        return this._requests.push(e1), e1.promise;
    }
    cancel(e1) {
        this._done = !0;
        for (const e1 of this._requests)e1.resolve({
            value: void 0,
            done: !0
        });
        this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
    }
}
const rh = /^[a-z][a-z0-9\-+.]+:/i;
class PDFNodeStream {
    constructor(e1){
        this.source = e1, this.url = function(e1) {
            if (rh.test(e1)) return new URL(e1);
            const t = process.getBuiltinModule("url");
            return new URL(t.pathToFileURL(e1));
        }(e1.url), assert("file:" === this.url.protocol, "PDFNodeStream only supports file:// URLs."), this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
        return this._fullRequestReader?._loaded ?? 0;
    }
    getFullReader() {
        return assert(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = new PDFNodeStreamFsFullReader(this), this._fullRequestReader;
    }
    getRangeReader(e1, t) {
        if (t <= this._progressiveDataLength) return null;
        const i = new PDFNodeStreamFsRangeReader(this, e1, t);
        return this._rangeRequestReaders.push(i), i;
    }
    cancelAllRequests(e1) {
        this._fullRequestReader?.cancel(e1);
        for (const t of this._rangeRequestReaders.slice(0))t.cancel(e1);
    }
}
class PDFNodeStreamFsFullReader {
    constructor(e1){
        this._url = e1.url, this._done = !1, this._storedError = null, this.onProgress = null;
        const t = e1.source;
        this._contentLength = t.length, this._loaded = 0, this._filename = null, this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = !0), this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
        const i = process.getBuiltinModule("fs");
        i.promises.lstat(this._url).then((e1)=>{
            this._contentLength = e1.size, this._setReadableStream(i.createReadStream(this._url)), this._headersCapability.resolve();
        }, (e1)=>{
            "ENOENT" === e1.code && (e1 = createResponseError(0, this._url.href)), this._storedError = e1, this._headersCapability.reject(e1);
        });
    }
    get headersReady() {
        return this._headersCapability.promise;
    }
    get filename() {
        return this._filename;
    }
    get contentLength() {
        return this._contentLength;
    }
    get isRangeSupported() {
        return this._isRangeSupported;
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    async read() {
        if (await this._readCapability.promise, this._done) return {
            value: void 0,
            done: !0
        };
        if (this._storedError) throw this._storedError;
        const e1 = this._readableStream.read();
        if (null === e1) return this._readCapability = Promise.withResolvers(), this.read();
        this._loaded += e1.length, this.onProgress?.({
            loaded: this._loaded,
            total: this._contentLength
        });
        return {
            value: new Uint8Array(e1).buffer,
            done: !1
        };
    }
    cancel(e1) {
        this._readableStream ? this._readableStream.destroy(e1) : this._error(e1);
    }
    _error(e1) {
        this._storedError = e1, this._readCapability.resolve();
    }
    _setReadableStream(e1) {
        this._readableStream = e1, e1.on("readable", ()=>{
            this._readCapability.resolve();
        }), e1.on("end", ()=>{
            e1.destroy(), this._done = !0, this._readCapability.resolve();
        }), e1.on("error", (e1)=>{
            this._error(e1);
        }), !this._isStreamingSupported && this._isRangeSupported && this._error(new AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
    }
}
class PDFNodeStreamFsRangeReader {
    constructor(e1, t, i){
        this._url = e1.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
        const n = e1.source;
        this._isStreamingSupported = !n.disableStream;
        const a = process.getBuiltinModule("fs");
        this._setReadableStream(a.createReadStream(this._url, {
            start: t,
            end: i - 1
        }));
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    async read() {
        if (await this._readCapability.promise, this._done) return {
            value: void 0,
            done: !0
        };
        if (this._storedError) throw this._storedError;
        const e1 = this._readableStream.read();
        if (null === e1) return this._readCapability = Promise.withResolvers(), this.read();
        this._loaded += e1.length, this.onProgress?.({
            loaded: this._loaded
        });
        return {
            value: new Uint8Array(e1).buffer,
            done: !1
        };
    }
    cancel(e1) {
        this._readableStream ? this._readableStream.destroy(e1) : this._error(e1);
    }
    _error(e1) {
        this._storedError = e1, this._readCapability.resolve();
    }
    _setReadableStream(e1) {
        this._readableStream = e1, e1.on("readable", ()=>{
            this._readCapability.resolve();
        }), e1.on("end", ()=>{
            e1.destroy(), this._done = !0, this._readCapability.resolve();
        }), e1.on("error", (e1)=>{
            this._error(e1);
        }), this._storedError && this._readableStream.destroy(this._storedError);
    }
}
const oh = Symbol("INITIAL_DATA");
class PDFObjects {
    #Ls = Object.create(null);
    #Us(e1) {
        return this.#Ls[e1] ||= {
            ...Promise.withResolvers(),
            data: oh
        };
    }
    get(e1, t = null) {
        if (t) {
            const i = this.#Us(e1);
            return i.promise.then(()=>t(i.data)), null;
        }
        const i = this.#Ls[e1];
        if (!i || i.data === oh) throw new Error(`Requesting object that isn't resolved yet ${e1}.`);
        return i.data;
    }
    has(e1) {
        const t = this.#Ls[e1];
        return !!t && t.data !== oh;
    }
    delete(e1) {
        const t = this.#Ls[e1];
        return !(!t || t.data === oh) && (delete this.#Ls[e1], !0);
    }
    resolve(e1, t = null) {
        const i = this.#Us(e1);
        i.data = t, i.resolve();
    }
    clear() {
        for(const e1 in this.#Ls){
            const { data: t } = this.#Ls[e1];
            t?.bitmap?.close();
        }
        this.#Ls = Object.create(null);
    }
    *[Symbol.iterator]() {
        for(const e1 in this.#Ls){
            const { data: t } = this.#Ls[e1];
            t !== oh && (yield [
                e1,
                t
            ]);
        }
    }
}
class TextLayer {
    #js = Promise.withResolvers();
    #Mi = null;
    #$s = !1;
    #Hs = !!globalThis.FontInspector?.enabled;
    #Xs = null;
    #qs = null;
    #zs = 0;
    #Ws = 0;
    #Gs = null;
    #Vs = null;
    #Ks = 0;
    #Ys = 0;
    #Js = Object.create(null);
    #Zs = [];
    #Qs = null;
    #er = [];
    #tr = new WeakMap;
    #ir = null;
    static #nr = new Map;
    static #ar = new Map;
    static #sr = new WeakMap;
    static #rr = null;
    static #or = new Set;
    constructor({ textContentSource: e1, container: t, viewport: i }){
        if (e1 instanceof ReadableStream) this.#Qs = e1;
        else {
            if ("object" != typeof e1) throw new Error('No "textContentSource" parameter specified.');
            this.#Qs = new ReadableStream({
                start (t) {
                    t.enqueue(e1), t.close();
                }
            });
        }
        this.#Mi = this.#Vs = t, this.#Ys = i.scale * OutputScale.pixelRatio, this.#Ks = i.rotation, this.#qs = {
            div: null,
            properties: null,
            ctx: null
        };
        const { pageWidth: n, pageHeight: a, pageX: s, pageY: r } = i.rawDims;
        this.#ir = [
            1,
            0,
            0,
            -1,
            -s,
            r + a
        ], this.#Ws = n, this.#zs = a, TextLayer.#lr(), setLayerDimensions(t, i), this.#js.promise.finally(()=>{
            TextLayer.#or.delete(this), this.#qs = null, this.#Js = null;
        }).catch(()=>{});
    }
    static get fontFamilyMap() {
        const { isWindows: e1, isFirefox: t } = util_FeatureTest.platform;
        return shadow(this, "fontFamilyMap", new Map([
            [
                "sans-serif",
                (e1 && t ? "Calibri, " : "") + "sans-serif"
            ],
            [
                "monospace",
                (e1 && t ? "Lucida Console, " : "") + "monospace"
            ]
        ]));
    }
    render() {
        const pump = ()=>{
            this.#Gs.read().then(({ value: e1, done: t })=>{
                t ? this.#js.resolve() : (this.#Xs ??= e1.lang, Object.assign(this.#Js, e1.styles), this.#cr(e1.items), pump());
            }, this.#js.reject);
        };
        return this.#Gs = this.#Qs.getReader(), TextLayer.#or.add(this), pump(), this.#js.promise;
    }
    update({ viewport: e1, onBefore: t = null }) {
        const i = e1.scale * OutputScale.pixelRatio, n = e1.rotation;
        if (n !== this.#Ks && (t?.(), this.#Ks = n, setLayerDimensions(this.#Vs, {
            rotation: n
        })), i !== this.#Ys) {
            t?.(), this.#Ys = i;
            const e1 = {
                div: null,
                properties: null,
                ctx: TextLayer.#hr(this.#Xs)
            };
            for (const t of this.#er)e1.properties = this.#tr.get(t), e1.div = t, this.#dr(e1);
        }
    }
    cancel() {
        const e1 = new AbortException("TextLayer task cancelled.");
        this.#Gs?.cancel(e1).catch(()=>{}), this.#Gs = null, this.#js.reject(e1);
    }
    get textDivs() {
        return this.#er;
    }
    get textContentItemsStr() {
        return this.#Zs;
    }
    #cr(e1) {
        if (this.#$s) return;
        this.#qs.ctx ??= TextLayer.#hr(this.#Xs);
        const t = this.#er, i = this.#Zs;
        for (const n of e1){
            if (t.length > 1e5) return warn("Ignoring additional textDivs for performance reasons."), void (this.#$s = !0);
            if (void 0 !== n.str) i.push(n.str), this.#ur(n);
            else if ("beginMarkedContentProps" === n.type || "beginMarkedContent" === n.type) {
                const e1 = this.#Mi;
                this.#Mi = document.createElement("span"), this.#Mi.classList.add("markedContent"), n.id && this.#Mi.setAttribute("id", `${n.id}`), e1.append(this.#Mi);
            } else "endMarkedContent" === n.type && (this.#Mi = this.#Mi.parentNode);
        }
    }
    #ur(e1) {
        const t = document.createElement("span"), i = {
            angle: 0,
            canvasWidth: 0,
            hasText: "" !== e1.str,
            hasEOL: e1.hasEOL,
            fontSize: 0
        };
        this.#er.push(t);
        const n = Util.transform(this.#ir, e1.transform);
        let a = Math.atan2(n[1], n[0]);
        const s = this.#Js[e1.fontName];
        s.vertical && (a += Math.PI / 2);
        let r = this.#Hs && s.fontSubstitution || s.fontFamily;
        r = TextLayer.fontFamilyMap.get(r) || r;
        const o = Math.hypot(n[2], n[3]), l = o * TextLayer.#gr(r, s, this.#Xs);
        let c, h;
        0 === a ? (c = n[4], h = n[5] - l) : (c = n[4] + l * Math.sin(a), h = n[5] - l * Math.cos(a));
        const d = "calc(var(--total-scale-factor) *", u = t.style;
        this.#Mi === this.#Vs ? (u.left = `${(100 * c / this.#Ws).toFixed(2)}%`, u.top = `${(100 * h / this.#zs).toFixed(2)}%`) : (u.left = `${d}${c.toFixed(2)}px)`, u.top = `${d}${h.toFixed(2)}px)`), u.fontSize = `${d}${(TextLayer.#rr * o).toFixed(2)}px)`, u.fontFamily = r, i.fontSize = o, t.setAttribute("role", "presentation"), t.textContent = e1.str, t.dir = e1.dir, this.#Hs && (t.dataset.fontName = s.fontSubstitutionLoadedName || e1.fontName), 0 !== a && (i.angle = a * (180 / Math.PI));
        let g = !1;
        if (e1.str.length > 1) g = !0;
        else if (" " !== e1.str && e1.transform[0] !== e1.transform[3]) {
            const t = Math.abs(e1.transform[0]), i = Math.abs(e1.transform[3]);
            t !== i && Math.max(t, i) / Math.min(t, i) > 1.5 && (g = !0);
        }
        if (g && (i.canvasWidth = s.vertical ? e1.height : e1.width), this.#tr.set(t, i), this.#qs.div = t, this.#qs.properties = i, this.#dr(this.#qs), i.hasText && this.#Mi.append(t), i.hasEOL) {
            const e1 = document.createElement("br");
            e1.setAttribute("role", "presentation"), this.#Mi.append(e1);
        }
    }
    #dr(e1) {
        const { div: t, properties: i, ctx: n } = e1, { style: a } = t;
        let s = "";
        if (TextLayer.#rr > 1 && (s = `scale(${1 / TextLayer.#rr})`), 0 !== i.canvasWidth && i.hasText) {
            const { fontFamily: e1 } = a, { canvasWidth: r, fontSize: o } = i;
            TextLayer.#fr(n, o * this.#Ys, e1);
            const { width: l } = n.measureText(t.textContent);
            l > 0 && (s = `scaleX(${r * this.#Ys / l}) ${s}`);
        }
        0 !== i.angle && (s = `rotate(${i.angle}deg) ${s}`), s.length > 0 && (a.transform = s);
    }
    static cleanup() {
        if (!(this.#or.size > 0)) {
            this.#nr.clear();
            for (const { canvas: e1 } of this.#ar.values())e1.remove();
            this.#ar.clear();
        }
    }
    static #hr(e1 = null) {
        let t = this.#ar.get(e1 ||= "");
        if (!t) {
            const i = document.createElement("canvas");
            i.className = "hiddenCanvasElement", i.lang = e1, document.body.append(i), t = i.getContext("2d", {
                alpha: !1,
                willReadFrequently: !0
            }), this.#ar.set(e1, t), this.#sr.set(t, {
                size: 0,
                family: ""
            });
        }
        return t;
    }
    static #fr(e1, t, i) {
        const n = this.#sr.get(e1);
        t === n.size && i === n.family || (e1.font = `${t}px ${i}`, n.size = t, n.family = i);
    }
    static #lr() {
        if (null !== this.#rr) return;
        const e1 = document.createElement("div");
        e1.style.opacity = 0, e1.style.lineHeight = 1, e1.style.fontSize = "1px", e1.style.position = "absolute", e1.textContent = "X", document.body.append(e1), this.#rr = e1.getBoundingClientRect().height, e1.remove();
    }
    static #gr(e1, t, i) {
        const n = this.#nr.get(e1);
        if (n) return n;
        const a = this.#hr(i);
        a.canvas.width = a.canvas.height = 30, this.#fr(a, 30, e1);
        const s = a.measureText(""), r = s.fontBoundingBoxAscent, o = Math.abs(s.fontBoundingBoxDescent);
        a.canvas.width = a.canvas.height = 0;
        let l = .8;
        return r ? l = r / (r + o) : (util_FeatureTest.platform.isFirefox && warn("Enable the `dom.textMetrics.fontBoundingBox.enabled` preference in `about:config` to improve TextLayer rendering."), t.ascent ? l = t.ascent : t.descent && (l = 1 + t.descent)), this.#nr.set(e1, l), l;
    }
}
function getDocument(e1 = {}) {
    "string" == typeof e1 || e1 instanceof URL ? e1 = {
        url: e1
    } : (e1 instanceof ArrayBuffer || ArrayBuffer.isView(e1)) && (e1 = {
        data: e1
    });
    const t = new PDFDocumentLoadingTask, { docId: i } = t, n = e1.url ? function(e1) {
        if (e1 instanceof URL) return e1.href;
        if ("string" == typeof e1) {
            if (Fl) return e1;
            const t = URL.parse(e1, window.location);
            if (t) return t.href;
        }
        throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
    }(e1.url) : null, a = e1.data ? function(e1) {
        if (Fl && "undefined" != typeof Buffer && e1 instanceof Buffer) throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
        if (e1 instanceof Uint8Array && e1.byteLength === e1.buffer.byteLength) return e1;
        if ("string" == typeof e1) return stringToBytes(e1);
        if (e1 instanceof ArrayBuffer || ArrayBuffer.isView(e1) || "object" == typeof e1 && !isNaN(e1?.length)) return new Uint8Array(e1);
        throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
    }(e1.data) : null, s = e1.httpHeaders || null, r = !0 === e1.withCredentials, o = e1.password ?? null, l = e1.range instanceof PDFDataRangeTransport ? e1.range : null, c = Number.isInteger(e1.rangeChunkSize) && e1.rangeChunkSize > 0 ? e1.rangeChunkSize : 65536;
    let h = e1.worker instanceof PDFWorker ? e1.worker : null;
    const d = e1.verbosity, u = "string" != typeof e1.docBaseUrl || isDataScheme(e1.docBaseUrl) ? null : e1.docBaseUrl, g = getFactoryUrlProp(e1.cMapUrl), f = !1 !== e1.cMapPacked, p = e1.CMapReaderFactory || (Fl ? NodeCMapReaderFactory : DOMCMapReaderFactory), m = getFactoryUrlProp(e1.iccUrl), b = getFactoryUrlProp(e1.standardFontDataUrl), y = e1.StandardFontDataFactory || (Fl ? NodeStandardFontDataFactory : DOMStandardFontDataFactory), w = getFactoryUrlProp(e1.wasmUrl), x = e1.WasmFactory || (Fl ? NodeWasmFactory : DOMWasmFactory), S = !0 !== e1.stopAtErrors, v = Number.isInteger(e1.maxImageSize) && e1.maxImageSize > -1 ? e1.maxImageSize : -1, C = !1 !== e1.isEvalSupported, k = "boolean" == typeof e1.isOffscreenCanvasSupported ? e1.isOffscreenCanvasSupported : !Fl, T = "boolean" == typeof e1.isImageDecoderSupported ? e1.isImageDecoderSupported : !Fl && (util_FeatureTest.platform.isFirefox || !globalThis.chrome), F = Number.isInteger(e1.canvasMaxAreaInBytes) ? e1.canvasMaxAreaInBytes : -1, E = "boolean" == typeof e1.disableFontFace ? e1.disableFontFace : Fl, M = !0 === e1.fontExtraProperties, D = !0 === e1.enableXfa, O = e1.ownerDocument || globalThis.document, _ = !0 === e1.disableRange, R = !0 === e1.disableStream, N = !0 === e1.disableAutoFetch, L = !0 === e1.pdfBug, U = e1.CanvasFactory || (Fl ? NodeCanvasFactory : DOMCanvasFactory), j = e1.FilterFactory || (Fl ? NodeFilterFactory : DOMFilterFactory), $ = !0 === e1.enableHWA, H = !1 !== e1.useWasm, X = l ? l.length : e1.length ?? NaN, q = "boolean" == typeof e1.useSystemFonts ? e1.useSystemFonts : !Fl && !E, z = "boolean" == typeof e1.useWorkerFetch ? e1.useWorkerFetch : !!(p === DOMCMapReaderFactory && y === DOMStandardFontDataFactory && x === DOMWasmFactory && g && b && w && isValidFetchUrl(g, document.baseURI) && isValidFetchUrl(b, document.baseURI) && isValidFetchUrl(w, document.baseURI));
    setVerbosityLevel(d);
    const W = {
        canvasFactory: new U({
            ownerDocument: O,
            enableHWA: $
        }),
        filterFactory: new j({
            docId: i,
            ownerDocument: O
        }),
        cMapReaderFactory: z ? null : new p({
            baseUrl: g,
            isCompressed: f
        }),
        standardFontDataFactory: z ? null : new y({
            baseUrl: b
        }),
        wasmFactory: z ? null : new x({
            baseUrl: w
        })
    };
    h || (h = PDFWorker.create({
        verbosity: d,
        port: GlobalWorkerOptions.workerPort
    }), t._worker = h);
    const G = {
        docId: i,
        apiVersion: "5.4.296",
        data: a,
        password: o,
        disableAutoFetch: N,
        rangeChunkSize: c,
        length: X,
        docBaseUrl: u,
        enableXfa: D,
        evaluatorOptions: {
            maxImageSize: v,
            disableFontFace: E,
            ignoreErrors: S,
            isEvalSupported: C,
            isOffscreenCanvasSupported: k,
            isImageDecoderSupported: T,
            canvasMaxAreaInBytes: F,
            fontExtraProperties: M,
            useSystemFonts: q,
            useWasm: H,
            useWorkerFetch: z,
            cMapUrl: g,
            iccUrl: m,
            standardFontDataUrl: b,
            wasmUrl: w
        }
    }, V = {
        ownerDocument: O,
        pdfBug: L,
        styleElement: null,
        loadingParams: {
            disableAutoFetch: N,
            enableXfa: D
        }
    };
    return h.promise.then(function() {
        if (t.destroyed) throw new Error("Loading aborted");
        if (h.destroyed) throw new Error("Worker was destroyed");
        const e1 = h.messageHandler.sendWithPromise("GetDocRequest", G, a ? [
            a.buffer
        ] : null);
        let o;
        if (l) o = new PDFDataTransportStream(l, {
            disableRange: _,
            disableStream: R
        });
        else if (!a) {
            if (!n) throw new Error("getDocument - no `url` parameter provided.");
            const e1 = isValidFetchUrl(n) ? PDFFetchStream : Fl ? PDFNodeStream : PDFNetworkStream;
            o = new e1({
                url: n,
                length: X,
                httpHeaders: s,
                withCredentials: r,
                rangeChunkSize: c,
                disableRange: _,
                disableStream: R
            });
        }
        return e1.then((e1)=>{
            if (t.destroyed) throw new Error("Loading aborted");
            if (h.destroyed) throw new Error("Worker was destroyed");
            const n = new MessageHandler(i, e1, h.port), a = new WorkerTransport(n, t, o, V, W, $);
            t._transport = a, n.send("Ready", null);
        });
    }).catch(t._capability.reject), t;
}
class PDFDocumentLoadingTask {
    static #La = 0;
    _capability = Promise.withResolvers();
    _transport = null;
    _worker = null;
    docId = "d" + PDFDocumentLoadingTask.#La++;
    destroyed = !1;
    onPassword = null;
    onProgress = null;
    get promise() {
        return this._capability.promise;
    }
    async destroy() {
        this.destroyed = !0;
        try {
            this._worker?.port && (this._worker._pendingDestroy = !0), await this._transport?.destroy();
        } catch (e1) {
            throw this._worker?.port && delete this._worker._pendingDestroy, e1;
        }
        this._transport = null, this._worker?.destroy(), this._worker = null;
    }
    async getData() {
        return this._transport.getData();
    }
}
class PDFDataRangeTransport {
    #js = Promise.withResolvers();
    #pr = [];
    #mr = [];
    #br = [];
    #yr = [];
    constructor(e1, t, i = !1, n = null){
        this.length = e1, this.initialData = t, this.progressiveDone = i, this.contentDispositionFilename = n;
    }
    addRangeListener(e1) {
        this.#yr.push(e1);
    }
    addProgressListener(e1) {
        this.#br.push(e1);
    }
    addProgressiveReadListener(e1) {
        this.#mr.push(e1);
    }
    addProgressiveDoneListener(e1) {
        this.#pr.push(e1);
    }
    onDataRange(e1, t) {
        for (const i of this.#yr)i(e1, t);
    }
    onDataProgress(e1, t) {
        this.#js.promise.then(()=>{
            for (const i of this.#br)i(e1, t);
        });
    }
    onDataProgressiveRead(e1) {
        this.#js.promise.then(()=>{
            for (const t of this.#mr)t(e1);
        });
    }
    onDataProgressiveDone() {
        this.#js.promise.then(()=>{
            for (const e1 of this.#pr)e1();
        });
    }
    transportReady() {
        this.#js.resolve();
    }
    requestDataRange(e1, t) {
        unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
    }
    abort() {}
}
class PDFDocumentProxy {
    constructor(e1, t){
        this._pdfInfo = e1, this._transport = t;
    }
    get annotationStorage() {
        return this._transport.annotationStorage;
    }
    get canvasFactory() {
        return this._transport.canvasFactory;
    }
    get filterFactory() {
        return this._transport.filterFactory;
    }
    get numPages() {
        return this._pdfInfo.numPages;
    }
    get fingerprints() {
        return this._pdfInfo.fingerprints;
    }
    get isPureXfa() {
        return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    get allXfaHtml() {
        return this._transport._htmlForXfa;
    }
    getPage(e1) {
        return this._transport.getPage(e1);
    }
    getPageIndex(e1) {
        return this._transport.getPageIndex(e1);
    }
    getDestinations() {
        return this._transport.getDestinations();
    }
    getDestination(e1) {
        return this._transport.getDestination(e1);
    }
    getPageLabels() {
        return this._transport.getPageLabels();
    }
    getPageLayout() {
        return this._transport.getPageLayout();
    }
    getPageMode() {
        return this._transport.getPageMode();
    }
    getViewerPreferences() {
        return this._transport.getViewerPreferences();
    }
    getOpenAction() {
        return this._transport.getOpenAction();
    }
    getAttachments() {
        return this._transport.getAttachments();
    }
    getAnnotationsByType(e1, t) {
        return this._transport.getAnnotationsByType(e1, t);
    }
    getJSActions() {
        return this._transport.getDocJSActions();
    }
    getOutline() {
        return this._transport.getOutline();
    }
    getOptionalContentConfig({ intent: e1 = "display" } = {}) {
        const { renderingIntent: t } = this._transport.getRenderingIntent(e1);
        return this._transport.getOptionalContentConfig(t);
    }
    getPermissions() {
        return this._transport.getPermissions();
    }
    getMetadata() {
        return this._transport.getMetadata();
    }
    getMarkInfo() {
        return this._transport.getMarkInfo();
    }
    getData() {
        return this._transport.getData();
    }
    saveDocument() {
        return this._transport.saveDocument();
    }
    getDownloadInfo() {
        return this._transport.downloadInfoCapability.promise;
    }
    cleanup(e1 = !1) {
        return this._transport.startCleanup(e1 || this.isPureXfa);
    }
    destroy() {
        return this.loadingTask.destroy();
    }
    cachedPageNumber(e1) {
        return this._transport.cachedPageNumber(e1);
    }
    get loadingParams() {
        return this._transport.loadingParams;
    }
    get loadingTask() {
        return this._transport.loadingTask;
    }
    getFieldObjects() {
        return this._transport.getFieldObjects();
    }
    hasJSActions() {
        return this._transport.hasJSActions();
    }
    getCalculationOrderIds() {
        return this._transport.getCalculationOrderIds();
    }
}
class PDFPageProxy {
    #wr = !1;
    constructor(e1, t, i, n = !1){
        this._pageIndex = e1, this._pageInfo = t, this._transport = i, this._stats = n ? new StatTimer : null, this._pdfBug = n, this.commonObjs = i.commonObjs, this.objs = new PDFObjects, this._intentStates = new Map, this.destroyed = !1, this.recordedBBoxes = null;
    }
    get pageNumber() {
        return this._pageIndex + 1;
    }
    get rotate() {
        return this._pageInfo.rotate;
    }
    get ref() {
        return this._pageInfo.ref;
    }
    get userUnit() {
        return this._pageInfo.userUnit;
    }
    get view() {
        return this._pageInfo.view;
    }
    getViewport({ scale: e1, rotation: t = this.rotate, offsetX: i = 0, offsetY: n = 0, dontFlip: a = !1 } = {}) {
        return new PageViewport({
            viewBox: this.view,
            userUnit: this.userUnit,
            scale: e1,
            rotation: t,
            offsetX: i,
            offsetY: n,
            dontFlip: a
        });
    }
    getAnnotations({ intent: e1 = "display" } = {}) {
        const { renderingIntent: t } = this._transport.getRenderingIntent(e1);
        return this._transport.getAnnotations(this._pageIndex, t);
    }
    getJSActions() {
        return this._transport.getPageJSActions(this._pageIndex);
    }
    get filterFactory() {
        return this._transport.filterFactory;
    }
    get isPureXfa() {
        return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    async getXfa() {
        return this._transport._htmlForXfa?.children[this._pageIndex] || null;
    }
    render({ canvasContext: e1, canvas: t = e1.canvas, viewport: i, intent: n = "display", annotationMode: a = jl.ENABLE, transform: s = null, background: r = null, optionalContentConfigPromise: o = null, annotationCanvasMap: l = null, pageColors: c = null, printAnnotationStorage: h = null, isEditing: d = !1, recordOperations: u = !1, operationsFilter: g = null }) {
        this._stats?.time("Overall");
        const f = this._transport.getRenderingIntent(n, a, h, d), { renderingIntent: p, cacheKey: m } = f;
        this.#wr = !1, o ||= this._transport.getOptionalContentConfig(p);
        let b = this._intentStates.get(m);
        b || (b = Object.create(null), this._intentStates.set(m, b)), b.streamReaderCancelTimeout && (clearTimeout(b.streamReaderCancelTimeout), b.streamReaderCancelTimeout = null);
        const y = !!(p & _l);
        b.displayReadyCapability || (b.displayReadyCapability = Promise.withResolvers(), b.operatorList = {
            fnArray: [],
            argsArray: [],
            lastChunk: !1,
            separateAnnots: null
        }, this._stats?.time("Page Request"), this._pumpOperatorList(f));
        const w = Boolean(this._pdfBug && globalThis.StepperManager?.enabled), x = !this.recordedBBoxes && (u || w), complete = (e1)=>{
            if (b.renderTasks.delete(S), x) {
                const e1 = S.gfx?.dependencyTracker.take();
                e1 && (S.stepper && S.stepper.setOperatorBBoxes(e1, S.gfx.dependencyTracker.takeDebugMetadata()), u && (this.recordedBBoxes = e1));
            }
            y && (this.#wr = !0), this.#Ar(), e1 ? (S.capability.reject(e1), this._abortOperatorList({
                intentState: b,
                reason: e1 instanceof Error ? e1 : new Error(e1)
            })) : S.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), globalThis.Stats?.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
        }, S = new InternalRenderTask({
            callback: complete,
            params: {
                canvas: t,
                canvasContext: e1,
                dependencyTracker: x ? new CanvasDependencyTracker(t, b.operatorList.length, w) : null,
                viewport: i,
                transform: s,
                background: r
            },
            objs: this.objs,
            commonObjs: this.commonObjs,
            annotationCanvasMap: l,
            operatorList: b.operatorList,
            pageIndex: this._pageIndex,
            canvasFactory: this._transport.canvasFactory,
            filterFactory: this._transport.filterFactory,
            useRequestAnimationFrame: !y,
            pdfBug: this._pdfBug,
            pageColors: c,
            enableHWA: this._transport.enableHWA,
            operationsFilter: g
        });
        (b.renderTasks ||= new Set).add(S);
        const v = S.task;
        return Promise.all([
            b.displayReadyCapability.promise,
            o
        ]).then(([e1, t])=>{
            if (this.destroyed) complete();
            else {
                if (this._stats?.time("Rendering"), !(t.renderingIntent & p)) throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
                S.initializeGraphics({
                    transparency: e1,
                    optionalContentConfig: t
                }), S.operatorListChanged();
            }
        }).catch(complete), v;
    }
    getOperatorList({ intent: e1 = "display", annotationMode: t = jl.ENABLE, printAnnotationStorage: i = null, isEditing: n = !1 } = {}) {
        const a = this._transport.getRenderingIntent(e1, t, i, n, !0);
        let s, r = this._intentStates.get(a.cacheKey);
        return r || (r = Object.create(null), this._intentStates.set(a.cacheKey, r)), r.opListReadCapability || (s = Object.create(null), s.operatorListChanged = function() {
            r.operatorList.lastChunk && (r.opListReadCapability.resolve(r.operatorList), r.renderTasks.delete(s));
        }, r.opListReadCapability = Promise.withResolvers(), (r.renderTasks ||= new Set).add(s), r.operatorList = {
            fnArray: [],
            argsArray: [],
            lastChunk: !1,
            separateAnnots: null
        }, this._stats?.time("Page Request"), this._pumpOperatorList(a)), r.opListReadCapability.promise;
    }
    streamTextContent({ includeMarkedContent: e1 = !1, disableNormalization: t = !1 } = {}) {
        return this._transport.messageHandler.sendWithStream("GetTextContent", {
            pageIndex: this._pageIndex,
            includeMarkedContent: !0 === e1,
            disableNormalization: !0 === t
        }, {
            highWaterMark: 100,
            size: (e1)=>e1.items.length
        });
    }
    getTextContent(e1 = {}) {
        if (this._transport._htmlForXfa) return this.getXfa().then((e1)=>XfaText.textContent(e1));
        const t = this.streamTextContent(e1);
        return new Promise(function(e1, i) {
            const n = t.getReader(), a = {
                items: [],
                styles: Object.create(null),
                lang: null
            };
            !function pump() {
                n.read().then(function({ value: t, done: i }) {
                    i ? e1(a) : (a.lang ??= t.lang, Object.assign(a.styles, t.styles), a.items.push(...t.items), pump());
                }, i);
            }();
        });
    }
    getStructTree() {
        return this._transport.getStructTree(this._pageIndex);
    }
    _destroy() {
        this.destroyed = !0;
        const e1 = [];
        for (const t of this._intentStates.values())if (this._abortOperatorList({
            intentState: t,
            reason: new Error("Page was destroyed."),
            force: !0
        }), !t.opListReadCapability) for (const i of t.renderTasks)e1.push(i.completed), i.cancel();
        return this.objs.clear(), this.#wr = !1, Promise.all(e1);
    }
    cleanup(e1 = !1) {
        this.#wr = !0;
        const t = this.#Ar();
        return e1 && t && (this._stats &&= new StatTimer), t;
    }
    #Ar() {
        if (!this.#wr || this.destroyed) return !1;
        for (const { renderTasks: e1, operatorList: t } of this._intentStates.values())if (e1.size > 0 || !t.lastChunk) return !1;
        return this._intentStates.clear(), this.objs.clear(), this.#wr = !1, !0;
    }
    _startRenderPage(e1, t) {
        const i = this._intentStates.get(t);
        i && (this._stats?.timeEnd("Page Request"), i.displayReadyCapability?.resolve(e1));
    }
    _renderPageChunk(e1, t) {
        for(let i = 0, n = e1.length; i < n; i++)t.operatorList.fnArray.push(e1.fnArray[i]), t.operatorList.argsArray.push(e1.argsArray[i]);
        t.operatorList.lastChunk = e1.lastChunk, t.operatorList.separateAnnots = e1.separateAnnots;
        for (const e1 of t.renderTasks)e1.operatorListChanged();
        e1.lastChunk && this.#Ar();
    }
    _pumpOperatorList({ renderingIntent: e1, cacheKey: t, annotationStorageSerializable: i, modifiedIds: n }) {
        const { map: a, transfer: s } = i, r = this._transport.messageHandler.sendWithStream("GetOperatorList", {
            pageIndex: this._pageIndex,
            intent: e1,
            cacheKey: t,
            annotationStorage: a,
            modifiedIds: n
        }, s).getReader(), o = this._intentStates.get(t);
        o.streamReader = r;
        const pump = ()=>{
            r.read().then(({ value: e1, done: t })=>{
                t ? o.streamReader = null : this._transport.destroyed || (this._renderPageChunk(e1, o), pump());
            }, (e1)=>{
                if (o.streamReader = null, !this._transport.destroyed) {
                    if (o.operatorList) {
                        o.operatorList.lastChunk = !0;
                        for (const e1 of o.renderTasks)e1.operatorListChanged();
                        this.#Ar();
                    }
                    if (o.displayReadyCapability) o.displayReadyCapability.reject(e1);
                    else {
                        if (!o.opListReadCapability) throw e1;
                        o.opListReadCapability.reject(e1);
                    }
                }
            });
        };
        pump();
    }
    _abortOperatorList({ intentState: e1, reason: t, force: i = !1 }) {
        if (e1.streamReader) {
            if (e1.streamReaderCancelTimeout && (clearTimeout(e1.streamReaderCancelTimeout), e1.streamReaderCancelTimeout = null), !i) {
                if (e1.renderTasks.size > 0) return;
                if (t instanceof RenderingCancelledException) {
                    let i = 100;
                    return t.extraDelay > 0 && t.extraDelay < 1e3 && (i += t.extraDelay), void (e1.streamReaderCancelTimeout = setTimeout(()=>{
                        e1.streamReaderCancelTimeout = null, this._abortOperatorList({
                            intentState: e1,
                            reason: t,
                            force: !0
                        });
                    }, i));
                }
            }
            if (e1.streamReader.cancel(new AbortException(t.message)).catch(()=>{}), e1.streamReader = null, !this._transport.destroyed) {
                for (const [t, i] of this._intentStates)if (i === e1) {
                    this._intentStates.delete(t);
                    break;
                }
                this.cleanup();
            }
        }
    }
    get stats() {
        return this._stats;
    }
}
class PDFWorker {
    #js = Promise.withResolvers();
    #xr = null;
    #ks = null;
    #Sr = null;
    static #vr = 0;
    static #Cr = !0;
    static #kr = new WeakMap;
    static{
        Fl && (this.#Cr = !0, GlobalWorkerOptions.workerSrc ||= "./pdf.worker.mjs"), this._isSameOrigin = (e1, t)=>{
            const i = URL.parse(e1);
            if (!i?.origin || "null" === i.origin) return !1;
            const n = new URL(t, i);
            return i.origin === n.origin;
        }, this._createCDNWrapper = (e1)=>{
            const t = `await import("${e1}");`;
            return URL.createObjectURL(new Blob([
                t
            ], {
                type: "text/javascript"
            }));
        }, this.fromPort = (e1)=>{
            var t;
            if (t = "`PDFWorker.fromPort` - please use `PDFWorker.create` instead.", console.log("Deprecated API usage: " + t), !e1?.port) throw new Error("PDFWorker.fromPort - invalid method signature.");
            return this.create(e1);
        };
    }
    constructor({ name: e1 = null, port: t = null, verbosity: i = getVerbosityLevel() } = {}){
        if (this.name = e1, this.destroyed = !1, this.verbosity = i, t) {
            if (PDFWorker.#kr.has(t)) throw new Error("Cannot use more than one PDFWorker per port.");
            PDFWorker.#kr.set(t, this), this.#Tr(t);
        } else this.#Fr();
    }
    get promise() {
        return this.#js.promise;
    }
    #Ir() {
        this.#js.resolve(), this.#xr.send("configure", {
            verbosity: this.verbosity
        });
    }
    get port() {
        return this.#ks;
    }
    get messageHandler() {
        return this.#xr;
    }
    #Tr(e1) {
        this.#ks = e1, this.#xr = new MessageHandler("main", "worker", e1), this.#xr.on("ready", ()=>{}), this.#Ir();
    }
    #Fr() {
        if (PDFWorker.#Cr || PDFWorker.#Er) return void this.#Mr();
        let { workerSrc: e1 } = PDFWorker;
        try {
            PDFWorker._isSameOrigin(window.location, e1) || (e1 = PDFWorker._createCDNWrapper(new URL(e1, window.location).href));
            const t = new Worker(e1, {
                type: "module"
            }), i = new MessageHandler("main", "worker", t), terminateEarly = ()=>{
                n.abort(), i.destroy(), t.terminate(), this.destroyed ? this.#js.reject(new Error("Worker was destroyed")) : this.#Mr();
            }, n = new AbortController;
            t.addEventListener("error", ()=>{
                this.#Sr || terminateEarly();
            }, {
                signal: n.signal
            }), i.on("test", (e1)=>{
                n.abort(), !this.destroyed && e1 ? (this.#xr = i, this.#ks = t, this.#Sr = t, this.#Ir()) : terminateEarly();
            }), i.on("ready", (e1)=>{
                if (n.abort(), this.destroyed) terminateEarly();
                else try {
                    sendTest();
                } catch  {
                    this.#Mr();
                }
            });
            const sendTest = ()=>{
                const e1 = new Uint8Array;
                i.send("test", e1, [
                    e1.buffer
                ]);
            };
            return void sendTest();
        } catch  {
            info("The worker has been disabled.");
        }
        this.#Mr();
    }
    #Mr() {
        PDFWorker.#Cr || (warn("Setting up fake worker."), PDFWorker.#Cr = !0), PDFWorker._setupFakeWorkerGlobal.then((e1)=>{
            if (this.destroyed) return void this.#js.reject(new Error("Worker was destroyed"));
            const t = new LoopbackPort;
            this.#ks = t;
            const i = "fake" + PDFWorker.#vr++, n = new MessageHandler(i + "_worker", i, t);
            e1.setup(n, t), this.#xr = new MessageHandler(i, i + "_worker", t), this.#Ir();
        }).catch((e1)=>{
            this.#js.reject(new Error(`Setting up fake worker failed: "${e1.message}".`));
        });
    }
    destroy() {
        this.destroyed = !0, this.#Sr?.terminate(), this.#Sr = null, PDFWorker.#kr.delete(this.#ks), this.#ks = null, this.#xr?.destroy(), this.#xr = null;
    }
    static create(e1) {
        const t = this.#kr.get(e1?.port);
        if (t) {
            if (t._pendingDestroy) throw new Error("PDFWorker.create - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
            return t;
        }
        return new PDFWorker(e1);
    }
    static get workerSrc() {
        if (GlobalWorkerOptions.workerSrc) return GlobalWorkerOptions.workerSrc;
        throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
    }
    static get #Er() {
        try {
            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
        } catch  {
            return null;
        }
    }
    static get _setupFakeWorkerGlobal() {
        return shadow(this, "_setupFakeWorkerGlobal", (async ()=>{
            if (this.#Er) return this.#Er;
            return (await Promise.resolve().then(()=>{
                const e1 = new Error("Cannot find module as expression is too dynamic");
                e1.code = 'MODULE_NOT_FOUND';
                throw e1;
            })).WorkerMessageHandler;
        })());
    }
}
class WorkerTransport {
    #Dr = new Map;
    #Or = new Map;
    #Ze = new Map;
    #_r = new Map;
    #Pr = null;
    constructor(e1, t, i, n, a, s){
        this.messageHandler = e1, this.loadingTask = t, this.commonObjs = new PDFObjects, this.fontLoader = new FontLoader({
            ownerDocument: n.ownerDocument,
            styleElement: n.styleElement
        }), this.loadingParams = n.loadingParams, this._params = n, this.canvasFactory = a.canvasFactory, this.filterFactory = a.filterFactory, this.cMapReaderFactory = a.cMapReaderFactory, this.standardFontDataFactory = a.standardFontDataFactory, this.wasmFactory = a.wasmFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = i, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.enableHWA = s, this.setupMessageHandler();
    }
    #Rr(e1, t = null) {
        const i = this.#Dr.get(e1);
        if (i) return i;
        const n = this.messageHandler.sendWithPromise(e1, t);
        return this.#Dr.set(e1, n), n;
    }
    get annotationStorage() {
        return shadow(this, "annotationStorage", new AnnotationStorage);
    }
    getRenderingIntent(e1, t = jl.ENABLE, i = null, n = !1, a = !1) {
        let s = Dl, r = vc;
        switch(e1){
            case "any":
                s = Ml;
                break;
            case "display":
                break;
            case "print":
                s = _l;
                break;
            default:
                warn(`getRenderingIntent - invalid intent: ${e1}`);
        }
        const o = s & _l && i instanceof PrintAnnotationStorage ? i : this.annotationStorage;
        switch(t){
            case jl.DISABLE:
                s += Bl;
                break;
            case jl.ENABLE:
                break;
            case jl.ENABLE_FORMS:
                s += Pl;
                break;
            case jl.ENABLE_STORAGE:
                s += Rl, r = o.serializable;
                break;
            default:
                warn(`getRenderingIntent - invalid annotationMode: ${t}`);
        }
        n && (s += Nl), a && (s += Ll);
        const { ids: l, hash: c } = o.modifiedIds;
        return {
            renderingIntent: s,
            cacheKey: [
                s,
                r.hash,
                c
            ].join("_"),
            annotationStorageSerializable: r,
            modifiedIds: l
        };
    }
    destroy() {
        if (this.destroyCapability) return this.destroyCapability.promise;
        this.destroyed = !0, this.destroyCapability = Promise.withResolvers(), this.#Pr?.reject(new Error("Worker was destroyed during onPassword callback"));
        const e1 = [];
        for (const t of this.#Or.values())e1.push(t._destroy());
        this.#Or.clear(), this.#Ze.clear(), this.#_r.clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
        const t = this.messageHandler.sendWithPromise("Terminate", null);
        return e1.push(t), Promise.all(e1).then(()=>{
            this.commonObjs.clear(), this.fontLoader.clear(), this.#Dr.clear(), this.filterFactory.destroy(), TextLayer.cleanup(), this._networkStream?.cancelAllRequests(new AbortException("Worker was terminated.")), this.messageHandler?.destroy(), this.messageHandler = null, this.destroyCapability.resolve();
        }, this.destroyCapability.reject), this.destroyCapability.promise;
    }
    setupMessageHandler() {
        const { messageHandler: e1, loadingTask: t } = this;
        e1.on("GetReader", (e1, t)=>{
            assert(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (e1)=>{
                this._lastProgress = {
                    loaded: e1.loaded,
                    total: e1.total
                };
            }, t.onPull = ()=>{
                this._fullReader.read().then(function({ value: e1, done: i }) {
                    i ? t.close() : (assert(e1 instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), t.enqueue(new Uint8Array(e1), 1, [
                        e1
                    ]));
                }).catch((e1)=>{
                    t.error(e1);
                });
            }, t.onCancel = (e1)=>{
                this._fullReader.cancel(e1), t.ready.catch((e1)=>{
                    if (!this.destroyed) throw e1;
                });
            };
        }), e1.on("ReaderHeadersReady", async (e1)=>{
            await this._fullReader.headersReady;
            const { isStreamingSupported: i, isRangeSupported: n, contentLength: a } = this._fullReader;
            return i && n || (this._lastProgress && t.onProgress?.(this._lastProgress), this._fullReader.onProgress = (e1)=>{
                t.onProgress?.({
                    loaded: e1.loaded,
                    total: e1.total
                });
            }), {
                isStreamingSupported: i,
                isRangeSupported: n,
                contentLength: a
            };
        }), e1.on("GetRangeReader", (e1, t)=>{
            assert(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
            const i = this._networkStream.getRangeReader(e1.begin, e1.end);
            i ? (t.onPull = ()=>{
                i.read().then(function({ value: e1, done: i }) {
                    i ? t.close() : (assert(e1 instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), t.enqueue(new Uint8Array(e1), 1, [
                        e1
                    ]));
                }).catch((e1)=>{
                    t.error(e1);
                });
            }, t.onCancel = (e1)=>{
                i.cancel(e1), t.ready.catch((e1)=>{
                    if (!this.destroyed) throw e1;
                });
            }) : t.close();
        }), e1.on("GetDoc", ({ pdfInfo: e1 })=>{
            this._numPages = e1.numPages, this._htmlForXfa = e1.htmlForXfa, delete e1.htmlForXfa, t._capability.resolve(new PDFDocumentProxy(e1, this));
        }), e1.on("DocException", (e1)=>{
            t._capability.reject(wrapReason(e1));
        }), e1.on("PasswordRequest", (e1)=>{
            this.#Pr = Promise.withResolvers();
            try {
                if (!t.onPassword) throw wrapReason(e1);
                const updatePassword = (e1)=>{
                    e1 instanceof Error ? this.#Pr.reject(e1) : this.#Pr.resolve({
                        password: e1
                    });
                };
                t.onPassword(updatePassword, e1.code);
            } catch (e1) {
                this.#Pr.reject(e1);
            }
            return this.#Pr.promise;
        }), e1.on("DataLoaded", (e1)=>{
            t.onProgress?.({
                loaded: e1.length,
                total: e1.length
            }), this.downloadInfoCapability.resolve(e1);
        }), e1.on("StartRenderPage", (e1)=>{
            if (this.destroyed) return;
            this.#Or.get(e1.pageIndex)._startRenderPage(e1.transparency, e1.cacheKey);
        }), e1.on("commonobj", ([t, i, n])=>{
            if (this.destroyed) return null;
            if (this.commonObjs.has(t)) return null;
            switch(i){
                case "Font":
                    if ("error" in n) {
                        const e1 = n.error;
                        warn(`Error during font loading: ${e1}`), this.commonObjs.resolve(t, e1);
                        break;
                    }
                    const a = new FontInfo(n), s = this._params.pdfBug && globalThis.FontInspector?.enabled ? (e1, t)=>globalThis.FontInspector.fontAdded(e1, t) : null, r = new FontFaceObject(a, s, n.extra, n.charProcOperatorList);
                    this.fontLoader.bind(r).catch(()=>e1.sendWithPromise("FontFallback", {
                            id: t
                        })).finally(()=>{
                        !r.fontExtraProperties && r.data && r.clearData(), this.commonObjs.resolve(t, r);
                    });
                    break;
                case "CopyLocalImage":
                    const { imageRef: o } = n;
                    assert(o, "The imageRef must be defined.");
                    for (const e1 of this.#Or.values())for (const [, i] of e1.objs)if (i?.ref === o) return i.dataLen ? (this.commonObjs.resolve(t, structuredClone(i)), i.dataLen) : null;
                    break;
                case "FontPath":
                case "Image":
                case "Pattern":
                    this.commonObjs.resolve(t, n);
                    break;
                default:
                    throw new Error(`Got unknown common object type ${i}`);
            }
            return null;
        }), e1.on("obj", ([e1, t, i, n])=>{
            if (this.destroyed) return;
            const a = this.#Or.get(t);
            if (!a.objs.has(e1)) if (0 !== a._intentStates.size) switch(i){
                case "Image":
                case "Pattern":
                    a.objs.resolve(e1, n);
                    break;
                default:
                    throw new Error(`Got unknown object type ${i}`);
            }
            else n?.bitmap?.close();
        }), e1.on("DocProgress", (e1)=>{
            this.destroyed || t.onProgress?.({
                loaded: e1.loaded,
                total: e1.total
            });
        }), e1.on("FetchBinaryData", async (e1)=>{
            if (this.destroyed) throw new Error("Worker was destroyed.");
            const t = this[e1.type];
            if (!t) throw new Error(`${e1.type} not initialized, see the \`useWorkerFetch\` parameter.`);
            return t.fetch(e1);
        });
    }
    getData() {
        return this.messageHandler.sendWithPromise("GetData", null);
    }
    saveDocument() {
        this.annotationStorage.size <= 0 && warn("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
        const { map: e1, transfer: t } = this.annotationStorage.serializable;
        return this.messageHandler.sendWithPromise("SaveDocument", {
            isPureXfa: !!this._htmlForXfa,
            numPages: this._numPages,
            annotationStorage: e1,
            filename: this._fullReader?.filename ?? null
        }, t).finally(()=>{
            this.annotationStorage.resetModified();
        });
    }
    getPage(e1) {
        if (!Number.isInteger(e1) || e1 <= 0 || e1 > this._numPages) return Promise.reject(new Error("Invalid page request."));
        const t = e1 - 1, i = this.#Ze.get(t);
        if (i) return i;
        const n = this.messageHandler.sendWithPromise("GetPage", {
            pageIndex: t
        }).then((i)=>{
            if (this.destroyed) throw new Error("Transport destroyed");
            i.refStr && this.#_r.set(i.refStr, e1);
            const n = new PDFPageProxy(t, i, this, this._params.pdfBug);
            return this.#Or.set(t, n), n;
        });
        return this.#Ze.set(t, n), n;
    }
    getPageIndex(e1) {
        return isRefProxy(e1) ? this.messageHandler.sendWithPromise("GetPageIndex", {
            num: e1.num,
            gen: e1.gen
        }) : Promise.reject(new Error("Invalid pageIndex request."));
    }
    getAnnotations(e1, t) {
        return this.messageHandler.sendWithPromise("GetAnnotations", {
            pageIndex: e1,
            intent: t
        });
    }
    getFieldObjects() {
        return this.#Rr("GetFieldObjects");
    }
    hasJSActions() {
        return this.#Rr("HasJSActions");
    }
    getCalculationOrderIds() {
        return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
    }
    getDestinations() {
        return this.messageHandler.sendWithPromise("GetDestinations", null);
    }
    getDestination(e1) {
        return "string" != typeof e1 ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
            id: e1
        });
    }
    getPageLabels() {
        return this.messageHandler.sendWithPromise("GetPageLabels", null);
    }
    getPageLayout() {
        return this.messageHandler.sendWithPromise("GetPageLayout", null);
    }
    getPageMode() {
        return this.messageHandler.sendWithPromise("GetPageMode", null);
    }
    getViewerPreferences() {
        return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
    }
    getOpenAction() {
        return this.messageHandler.sendWithPromise("GetOpenAction", null);
    }
    getAttachments() {
        return this.messageHandler.sendWithPromise("GetAttachments", null);
    }
    getAnnotationsByType(e1, t) {
        return this.messageHandler.sendWithPromise("GetAnnotationsByType", {
            types: e1,
            pageIndexesToSkip: t
        });
    }
    getDocJSActions() {
        return this.#Rr("GetDocJSActions");
    }
    getPageJSActions(e1) {
        return this.messageHandler.sendWithPromise("GetPageJSActions", {
            pageIndex: e1
        });
    }
    getStructTree(e1) {
        return this.messageHandler.sendWithPromise("GetStructTree", {
            pageIndex: e1
        });
    }
    getOutline() {
        return this.messageHandler.sendWithPromise("GetOutline", null);
    }
    getOptionalContentConfig(e1) {
        return this.#Rr("GetOptionalContentConfig").then((t)=>new OptionalContentConfig(t, e1));
    }
    getPermissions() {
        return this.messageHandler.sendWithPromise("GetPermissions", null);
    }
    getMetadata() {
        const e1 = "GetMetadata", t = this.#Dr.get(e1);
        if (t) return t;
        const i = this.messageHandler.sendWithPromise(e1, null).then((e1)=>({
                info: e1[0],
                metadata: e1[1] ? new Metadata(e1[1]) : null,
                contentDispositionFilename: this._fullReader?.filename ?? null,
                contentLength: this._fullReader?.contentLength ?? null
            }));
        return this.#Dr.set(e1, i), i;
    }
    getMarkInfo() {
        return this.messageHandler.sendWithPromise("GetMarkInfo", null);
    }
    async startCleanup(e1 = !1) {
        if (!this.destroyed) {
            await this.messageHandler.sendWithPromise("Cleanup", null);
            for (const e1 of this.#Or.values()){
                if (!e1.cleanup()) throw new Error(`startCleanup: Page ${e1.pageNumber} is currently rendering.`);
            }
            this.commonObjs.clear(), e1 || this.fontLoader.clear(), this.#Dr.clear(), this.filterFactory.destroy(!0), TextLayer.cleanup();
        }
    }
    cachedPageNumber(e1) {
        if (!isRefProxy(e1)) return null;
        const t = 0 === e1.gen ? `${e1.num}R` : `${e1.num}R${e1.gen}`;
        return this.#_r.get(t) ?? null;
    }
}
class RenderTask {
    #Br = null;
    onContinue = null;
    onError = null;
    constructor(e1){
        this.#Br = e1;
    }
    get promise() {
        return this.#Br.capability.promise;
    }
    cancel(e1 = 0) {
        this.#Br.cancel(null, e1);
    }
    get separateAnnots() {
        const { separateAnnots: e1 } = this.#Br.operatorList;
        if (!e1) return !1;
        const { annotationCanvasMap: t } = this.#Br;
        return e1.form || e1.canvas && t?.size > 0;
    }
}
class InternalRenderTask {
    #Nr = null;
    static #Lr = new WeakSet;
    constructor({ callback: e1, params: t, objs: i, commonObjs: n, annotationCanvasMap: a, operatorList: s, pageIndex: r, canvasFactory: o, filterFactory: l, useRequestAnimationFrame: c = !1, pdfBug: h = !1, pageColors: d = null, enableHWA: u = !1, operationsFilter: g = null }){
        this.callback = e1, this.params = t, this.objs = i, this.commonObjs = n, this.annotationCanvasMap = a, this.operatorListIdx = null, this.operatorList = s, this._pageIndex = r, this.canvasFactory = o, this.filterFactory = l, this._pdfBug = h, this.pageColors = d, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = !0 === c && "undefined" != ("TURBOPACK compile-time value", "undefined"), this.cancelled = !1, this.capability = Promise.withResolvers(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = t.canvas, this._canvasContext = t.canvas ? null : t.canvasContext, this._enableHWA = u, this._dependencyTracker = t.dependencyTracker, this._operationsFilter = g;
    }
    get completed() {
        return this.capability.promise.catch(function() {});
    }
    initializeGraphics({ transparency: e1 = !1, optionalContentConfig: t }) {
        if (this.cancelled) return;
        if (this._canvas) {
            if (InternalRenderTask.#Lr.has(this._canvas)) throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
            InternalRenderTask.#Lr.add(this._canvas);
        }
        this._pdfBug && globalThis.StepperManager?.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
        const { viewport: i, transform: n, background: a, dependencyTracker: s } = this.params, r = this._canvasContext || this._canvas.getContext("2d", {
            alpha: !1,
            willReadFrequently: !this._enableHWA
        });
        this.gfx = new CanvasGraphics(r, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
            optionalContentConfig: t
        }, this.annotationCanvasMap, this.pageColors, s), this.gfx.beginDrawing({
            transform: n,
            viewport: i,
            transparency: e1,
            background: a
        }), this.operatorListIdx = 0, this.graphicsReady = !0, this.graphicsReadyCallback?.();
    }
    cancel(e1 = null, t = 0) {
        this.running = !1, this.cancelled = !0, this.gfx?.endDrawing(), this.#Nr && (window.cancelAnimationFrame(this.#Nr), this.#Nr = null), InternalRenderTask.#Lr.delete(this._canvas), e1 ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, t), this.callback(e1), this.task.onError?.(e1);
    }
    operatorListChanged() {
        this.graphicsReady ? (this.gfx.dependencyTracker?.growOperationsCount(this.operatorList.fnArray.length), this.stepper?.updateOperatorList(this.operatorList), this.running || this._continue()) : this.graphicsReadyCallback ||= this._continueBound;
    }
    _continue() {
        this.running = !0, this.cancelled || (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
    }
    _scheduleNext() {
        this._useRequestAnimationFrame ? this.#Nr = window.requestAnimationFrame(()=>{
            this.#Nr = null, this._nextBound().catch(this._cancelBound);
        }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
    async _next() {
        this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._operationsFilter), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), InternalRenderTask.#Lr.delete(this._canvas), this.callback())));
    }
}
const lh = "5.4.296", hh = "f56dc8601";
class ColorPicker {
    #Ur = null;
    #jr = null;
    #$r;
    #Hr = null;
    #Xr = !1;
    #qr = !1;
    #ft = null;
    #zr;
    #Wr = null;
    #Tt = null;
    static #Gr = null;
    static get _keyboardManager() {
        return shadow(this, "_keyboardManager", new KeyboardManager([
            [
                [
                    "Escape",
                    "mac+Escape"
                ],
                ColorPicker.prototype._hideDropdownFromKeyboard
            ],
            [
                [
                    " ",
                    "mac+ "
                ],
                ColorPicker.prototype._colorSelectFromKeyboard
            ],
            [
                [
                    "ArrowDown",
                    "ArrowRight",
                    "mac+ArrowDown",
                    "mac+ArrowRight"
                ],
                ColorPicker.prototype._moveToNext
            ],
            [
                [
                    "ArrowUp",
                    "ArrowLeft",
                    "mac+ArrowUp",
                    "mac+ArrowLeft"
                ],
                ColorPicker.prototype._moveToPrevious
            ],
            [
                [
                    "Home",
                    "mac+Home"
                ],
                ColorPicker.prototype._moveToBeginning
            ],
            [
                [
                    "End",
                    "mac+End"
                ],
                ColorPicker.prototype._moveToEnd
            ]
        ]));
    }
    constructor({ editor: e1 = null, uiManager: t = null }){
        e1 ? (this.#qr = !1, this.#ft = e1) : this.#qr = !0, this.#Tt = e1?._uiManager || t, this.#zr = this.#Tt._eventBus, this.#$r = e1?.color?.toUpperCase() || this.#Tt?.highlightColors.values().next().value || "#FFFF98", ColorPicker.#Gr ||= Object.freeze({
            blue: "pdfjs-editor-colorpicker-blue",
            green: "pdfjs-editor-colorpicker-green",
            pink: "pdfjs-editor-colorpicker-pink",
            red: "pdfjs-editor-colorpicker-red",
            yellow: "pdfjs-editor-colorpicker-yellow"
        });
    }
    renderButton() {
        const e1 = this.#Ur = document.createElement("button");
        e1.className = "colorPicker", e1.tabIndex = "0", e1.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), e1.ariaHasPopup = "true", this.#ft && (e1.ariaControls = `${this.#ft.id}_colorpicker_dropdown`);
        const t = this.#Tt._signal;
        e1.addEventListener("click", this.#Vr.bind(this), {
            signal: t
        }), e1.addEventListener("keydown", this.#Kr.bind(this), {
            signal: t
        });
        const i = this.#jr = document.createElement("span");
        return i.className = "swatch", i.ariaHidden = "true", i.style.backgroundColor = this.#$r, e1.append(i), e1;
    }
    renderMainDropdown() {
        const e1 = this.#Hr = this.#Yr();
        return e1.ariaOrientation = "horizontal", e1.ariaLabelledBy = "highlightColorPickerLabel", e1;
    }
    #Yr() {
        const e1 = document.createElement("div"), t = this.#Tt._signal;
        e1.addEventListener("contextmenu", noContextMenu, {
            signal: t
        }), e1.className = "dropdown", e1.role = "listbox", e1.ariaMultiSelectable = "false", e1.ariaOrientation = "vertical", e1.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown"), this.#ft && (e1.id = `${this.#ft.id}_colorpicker_dropdown`);
        for (const [i, n] of this.#Tt.highlightColors){
            const a = document.createElement("button");
            a.tabIndex = "0", a.role = "option", a.setAttribute("data-color", n), a.title = i, a.setAttribute("data-l10n-id", ColorPicker.#Gr[i]);
            const s = document.createElement("span");
            a.append(s), s.className = "swatch", s.style.backgroundColor = n, a.ariaSelected = n === this.#$r, a.addEventListener("click", this.#Jr.bind(this, n), {
                signal: t
            }), e1.append(a);
        }
        return e1.addEventListener("keydown", this.#Kr.bind(this), {
            signal: t
        }), e1;
    }
    #Jr(e1, t) {
        t.stopPropagation(), this.#zr.dispatch("switchannotationeditorparams", {
            source: this,
            type: Xl.HIGHLIGHT_COLOR,
            value: e1
        }), this.updateColor(e1);
    }
    _colorSelectFromKeyboard(e1) {
        if (e1.target === this.#Ur) return void this.#Vr(e1);
        const t = e1.target.getAttribute("data-color");
        t && this.#Jr(t, e1);
    }
    _moveToNext(e1) {
        this.#Zr ? e1.target !== this.#Ur ? e1.target.nextSibling?.focus() : this.#Hr.firstChild?.focus() : this.#Vr(e1);
    }
    _moveToPrevious(e1) {
        e1.target !== this.#Hr?.firstChild && e1.target !== this.#Ur ? (this.#Zr || this.#Vr(e1), e1.target.previousSibling?.focus()) : this.#Zr && this._hideDropdownFromKeyboard();
    }
    _moveToBeginning(e1) {
        this.#Zr ? this.#Hr.firstChild?.focus() : this.#Vr(e1);
    }
    _moveToEnd(e1) {
        this.#Zr ? this.#Hr.lastChild?.focus() : this.#Vr(e1);
    }
    #Kr(e1) {
        ColorPicker._keyboardManager.exec(this, e1);
    }
    #Vr(e1) {
        if (this.#Zr) return void this.hideDropdown();
        if (this.#Xr = 0 === e1.detail, this.#Wr || (this.#Wr = new AbortController, window.addEventListener("pointerdown", this.#xt.bind(this), {
            signal: this.#Tt.combinedSignal(this.#Wr)
        })), this.#Ur.ariaExpanded = "true", this.#Hr) return void this.#Hr.classList.remove("hidden");
        const t = this.#Hr = this.#Yr();
        this.#Ur.append(t);
    }
    #xt(e1) {
        this.#Hr?.contains(e1.target) || this.hideDropdown();
    }
    hideDropdown() {
        this.#Hr?.classList.add("hidden"), this.#Ur.ariaExpanded = "false", this.#Wr?.abort(), this.#Wr = null;
    }
    get #Zr() {
        return this.#Hr && !this.#Hr.classList.contains("hidden");
    }
    _hideDropdownFromKeyboard() {
        this.#qr || (this.#Zr ? (this.hideDropdown(), this.#Ur.focus({
            preventScroll: !0,
            focusVisible: this.#Xr
        })) : this.#ft?.unselect());
    }
    updateColor(e1) {
        if (this.#jr && (this.#jr.style.backgroundColor = e1), !this.#Hr) return;
        const t = this.#Tt.highlightColors.values();
        for (const i of this.#Hr.children)i.ariaSelected = t.next().value === e1.toUpperCase();
    }
    destroy() {
        this.#Ur?.remove(), this.#Ur = null, this.#jr = null, this.#Hr?.remove(), this.#Hr = null;
    }
}
class BasicColorPicker {
    #Qr = null;
    #ft = null;
    #Tt = null;
    static #Gr = null;
    constructor(e1){
        this.#ft = e1, this.#Tt = e1._uiManager, BasicColorPicker.#Gr ||= Object.freeze({
            freetext: "pdfjs-editor-color-picker-free-text-input",
            ink: "pdfjs-editor-color-picker-ink-input"
        });
    }
    renderButton() {
        if (this.#Qr) return this.#Qr;
        const { editorType: e1, colorType: t, colorValue: i } = this.#ft, n = this.#Qr = document.createElement("input");
        return n.type = "color", n.value = i || "#000000", n.className = "basicColorPicker", n.tabIndex = 0, n.setAttribute("data-l10n-id", BasicColorPicker.#Gr[e1]), n.addEventListener("input", ()=>{
            this.#Tt.updateParams(t, n.value);
        }, {
            signal: this.#Tt._signal
        }), n;
    }
    update(e1) {
        this.#Qr && (this.#Qr.value = e1);
    }
    destroy() {
        this.#Qr?.remove(), this.#Qr = null;
    }
    hideDropdown() {}
}
function makeColorComp(e1) {
    return Math.floor(255 * Math.max(0, Math.min(1, e1))).toString(16).padStart(2, "0");
}
function scaleAndClamp(e1) {
    return Math.max(0, Math.min(255, 255 * e1));
}
class ColorConverters {
    static CMYK_G([e1, t, i, n]) {
        return [
            "G",
            1 - Math.min(1, .3 * e1 + .59 * i + .11 * t + n)
        ];
    }
    static G_CMYK([e1]) {
        return [
            "CMYK",
            0,
            0,
            0,
            1 - e1
        ];
    }
    static G_RGB([e1]) {
        return [
            "RGB",
            e1,
            e1,
            e1
        ];
    }
    static G_rgb([e1]) {
        return [
            e1 = scaleAndClamp(e1),
            e1,
            e1
        ];
    }
    static G_HTML([e1]) {
        const t = makeColorComp(e1);
        return `#${t}${t}${t}`;
    }
    static RGB_G([e1, t, i]) {
        return [
            "G",
            .3 * e1 + .59 * t + .11 * i
        ];
    }
    static RGB_rgb(e1) {
        return e1.map(scaleAndClamp);
    }
    static RGB_HTML(e1) {
        return `#${e1.map(makeColorComp).join("")}`;
    }
    static T_HTML() {
        return "#00000000";
    }
    static T_rgb() {
        return [
            null
        ];
    }
    static CMYK_RGB([e1, t, i, n]) {
        return [
            "RGB",
            1 - Math.min(1, e1 + n),
            1 - Math.min(1, i + n),
            1 - Math.min(1, t + n)
        ];
    }
    static CMYK_rgb([e1, t, i, n]) {
        return [
            scaleAndClamp(1 - Math.min(1, e1 + n)),
            scaleAndClamp(1 - Math.min(1, i + n)),
            scaleAndClamp(1 - Math.min(1, t + n))
        ];
    }
    static CMYK_HTML(e1) {
        const t = this.CMYK_RGB(e1).slice(1);
        return this.RGB_HTML(t);
    }
    static RGB_CMYK([e1, t, i]) {
        const n = 1 - e1, a = 1 - t, s = 1 - i;
        return [
            "CMYK",
            n,
            a,
            s,
            Math.min(n, a, s)
        ];
    }
}
class BaseSVGFactory {
    create(e1, t, i = !1) {
        if (e1 <= 0 || t <= 0) throw new Error("Invalid SVG dimensions");
        const n = this._createSVG("svg:svg");
        return n.setAttribute("version", "1.1"), i || (n.setAttribute("width", `${e1}px`), n.setAttribute("height", `${t}px`)), n.setAttribute("preserveAspectRatio", "none"), n.setAttribute("viewBox", `0 0 ${e1} ${t}`), n;
    }
    createElement(e1) {
        if ("string" != typeof e1) throw new Error("Invalid SVG element type");
        return this._createSVG(e1);
    }
    _createSVG(e1) {
        unreachable("Abstract method `_createSVG` called.");
    }
}
class DOMSVGFactory extends BaseSVGFactory {
    _createSVG(e1) {
        return document.createElementNS(bc, e1);
    }
}
const dh = new WeakSet, uh = 60 * (new Date).getTimezoneOffset() * 1e3;
class AnnotationElementFactory {
    static create(e1) {
        switch(e1.data.annotationType){
            case Zl.LINK:
                return new LinkAnnotationElement(e1);
            case Zl.TEXT:
                return new TextAnnotationElement(e1);
            case Zl.WIDGET:
                switch(e1.data.fieldType){
                    case "Tx":
                        return new TextWidgetAnnotationElement(e1);
                    case "Btn":
                        return e1.data.radioButton ? new RadioButtonWidgetAnnotationElement(e1) : e1.data.checkBox ? new CheckboxWidgetAnnotationElement(e1) : new PushButtonWidgetAnnotationElement(e1);
                    case "Ch":
                        return new ChoiceWidgetAnnotationElement(e1);
                    case "Sig":
                        return new SignatureWidgetAnnotationElement(e1);
                }
                return new WidgetAnnotationElement(e1);
            case Zl.POPUP:
                return new PopupAnnotationElement(e1);
            case Zl.FREETEXT:
                return new FreeTextAnnotationElement(e1);
            case Zl.LINE:
                return new LineAnnotationElement(e1);
            case Zl.SQUARE:
                return new SquareAnnotationElement(e1);
            case Zl.CIRCLE:
                return new CircleAnnotationElement(e1);
            case Zl.POLYLINE:
                return new PolylineAnnotationElement(e1);
            case Zl.CARET:
                return new CaretAnnotationElement(e1);
            case Zl.INK:
                return new InkAnnotationElement(e1);
            case Zl.POLYGON:
                return new PolygonAnnotationElement(e1);
            case Zl.HIGHLIGHT:
                return new HighlightAnnotationElement(e1);
            case Zl.UNDERLINE:
                return new UnderlineAnnotationElement(e1);
            case Zl.SQUIGGLY:
                return new SquigglyAnnotationElement(e1);
            case Zl.STRIKEOUT:
                return new StrikeOutAnnotationElement(e1);
            case Zl.STAMP:
                return new StampAnnotationElement(e1);
            case Zl.FILEATTACHMENT:
                return new FileAttachmentAnnotationElement(e1);
            default:
                return new AnnotationElement(e1);
        }
    }
}
class AnnotationElement {
    #eo = null;
    #to = !1;
    #io = null;
    constructor(e1, { isRenderable: t = !1, ignoreBorder: i = !1, createQuadrilaterals: n = !1 } = {}){
        this.isRenderable = t, this.data = e1.data, this.layer = e1.layer, this.linkService = e1.linkService, this.downloadManager = e1.downloadManager, this.imageResourcesPath = e1.imageResourcesPath, this.renderForms = e1.renderForms, this.svgFactory = e1.svgFactory, this.annotationStorage = e1.annotationStorage, this.enableComment = e1.enableComment, this.enableScripting = e1.enableScripting, this.hasJSActions = e1.hasJSActions, this._fieldObjects = e1.fieldObjects, this.parent = e1.parent, t && (this.container = this._createContainer(i)), n && this._createQuadrilaterals();
    }
    static _hasPopupData({ contentsObj: e1, richText: t }) {
        return !(!e1?.str && !t?.str);
    }
    get _isEditable() {
        return this.data.isEditable;
    }
    get hasPopupData() {
        return AnnotationElement._hasPopupData(this.data) || this.enableComment && !!this.commentText;
    }
    get commentData() {
        const { data: e1 } = this, t = this.annotationStorage?.getEditor(e1.id);
        return t ? t.getData() : e1;
    }
    get hasCommentButton() {
        return this.enableComment && this.hasPopupElement;
    }
    get commentButtonPosition() {
        const e1 = this.annotationStorage?.getEditor(this.data.id);
        if (e1) return e1.commentButtonPositionInPage;
        const { quadPoints: t, inkLists: i, rect: n } = this.data;
        let a = -1 / 0, s = -1 / 0;
        if (t?.length >= 8) {
            for(let e1 = 0; e1 < t.length; e1 += 8)t[e1 + 1] > s ? (s = t[e1 + 1], a = t[e1 + 2]) : t[e1 + 1] === s && (a = Math.max(a, t[e1 + 2]));
            return [
                a,
                s
            ];
        }
        if (i?.length >= 1) {
            for (const e1 of i)for(let t = 0, i = e1.length; t < i; t += 2)e1[t + 1] > s ? (s = e1[t + 1], a = e1[t]) : e1[t + 1] === s && (a = Math.max(a, e1[t]));
            if (a !== 1 / 0) return [
                a,
                s
            ];
        }
        return n ? [
            n[2],
            n[3]
        ] : null;
    }
    _normalizePoint(e1) {
        const { page: { view: t }, viewport: { rawDims: { pageWidth: i, pageHeight: n, pageX: a, pageY: s } } } = this.parent;
        return e1[1] = t[3] - e1[1] + t[1], e1[0] = 100 * (e1[0] - a) / i, e1[1] = 100 * (e1[1] - s) / n, e1;
    }
    get commentText() {
        const { data: e1 } = this;
        return this.annotationStorage.getRawValue(`${$l}${e1.id}`)?.popup?.contents || e1.contentsObj?.str || "";
    }
    set commentText(e1) {
        const { data: t } = this, i = {
            deleted: !e1,
            contents: e1 || ""
        };
        this.annotationStorage.updateEditor(t.id, {
            popup: i
        }) || this.annotationStorage.setValue(`${$l}${t.id}`, {
            id: t.id,
            annotationType: t.annotationType,
            pageIndex: this.parent.page._pageIndex,
            popup: i,
            popupRef: t.popupRef,
            modificationDate: new Date
        }), e1 || this.removePopup();
    }
    removePopup() {
        (this.#io?.popup || this.popup)?.remove(), this.#io = this.popup = null;
    }
    updateEdited(e1) {
        if (!this.container) return;
        e1.rect && (this.#eo ||= {
            rect: this.data.rect.slice(0)
        });
        const { rect: t, popup: i } = e1;
        t && this.#no(t);
        let n = this.#io?.popup || this.popup;
        !n && i?.text && (this._createPopup(i), n = this.#io.popup), n && (n.updateEdited(e1), i?.deleted && (n.remove(), this.#io = null, this.popup = null));
    }
    resetEdited() {
        this.#eo && (this.#no(this.#eo.rect), this.#io?.popup.resetEdited(), this.#eo = null);
    }
    #no(e1) {
        const { container: { style: t }, data: { rect: i, rotation: n }, parent: { viewport: { rawDims: { pageWidth: a, pageHeight: s, pageX: r, pageY: o } } } } = this;
        i?.splice(0, 4, ...e1), t.left = 100 * (e1[0] - r) / a + "%", t.top = 100 * (s - e1[3] + o) / s + "%", 0 === n ? (t.width = 100 * (e1[2] - e1[0]) / a + "%", t.height = 100 * (e1[3] - e1[1]) / s + "%") : this.setRotation(n);
    }
    _createContainer(e1) {
        const { data: t, parent: { page: i, viewport: n } } = this, a = document.createElement("section");
        a.setAttribute("data-annotation-id", t.id), this instanceof WidgetAnnotationElement || this instanceof LinkAnnotationElement || (a.tabIndex = 0);
        const { style: s } = a;
        if (s.zIndex = this.parent.zIndex, this.parent.zIndex += 2, t.alternativeText && (a.title = t.alternativeText), t.noRotate && a.classList.add("norotate"), !t.rect || this instanceof PopupAnnotationElement) {
            const { rotation: e1 } = t;
            return t.hasOwnCanvas || 0 === e1 || this.setRotation(e1, a), a;
        }
        const { width: r, height: o } = this;
        if (!e1 && t.borderStyle.width > 0) {
            s.borderWidth = `${t.borderStyle.width}px`;
            const e1 = t.borderStyle.horizontalCornerRadius, i = t.borderStyle.verticalCornerRadius;
            if (e1 > 0 || i > 0) {
                const t = `calc(${e1}px * var(--total-scale-factor)) / calc(${i}px * var(--total-scale-factor))`;
                s.borderRadius = t;
            } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                const e1 = `calc(${r}px * var(--total-scale-factor)) / calc(${o}px * var(--total-scale-factor))`;
                s.borderRadius = e1;
            }
            switch(t.borderStyle.style){
                case Ql:
                    s.borderStyle = "solid";
                    break;
                case ec:
                    s.borderStyle = "dashed";
                    break;
                case tc:
                    warn("Unimplemented border style: beveled");
                    break;
                case ic:
                    warn("Unimplemented border style: inset");
                    break;
                case nc:
                    s.borderBottomStyle = "solid";
            }
            const n = t.borderColor || null;
            n ? (this.#to = !0, s.borderColor = Util.makeHexColor(0 | n[0], 0 | n[1], 0 | n[2])) : s.borderWidth = 0;
        }
        const l = Util.normalizeRect([
            t.rect[0],
            i.view[3] - t.rect[1] + i.view[1],
            t.rect[2],
            i.view[3] - t.rect[3] + i.view[1]
        ]), { pageWidth: c, pageHeight: h, pageX: d, pageY: u } = n.rawDims;
        s.left = 100 * (l[0] - d) / c + "%", s.top = 100 * (l[1] - u) / h + "%";
        const { rotation: g } = t;
        return t.hasOwnCanvas || 0 === g ? (s.width = 100 * r / c + "%", s.height = 100 * o / h + "%") : this.setRotation(g, a), a;
    }
    setRotation(e1, t = this.container) {
        if (!this.data.rect) return;
        const { pageWidth: i, pageHeight: n } = this.parent.viewport.rawDims;
        let { width: a, height: s } = this;
        e1 % 180 != 0 && ([a, s] = [
            s,
            a
        ]), t.style.width = 100 * a / i + "%", t.style.height = 100 * s / n + "%", t.setAttribute("data-main-rotation", (360 - e1) % 360);
    }
    get _commonActions() {
        const setColor = (e1, t, i)=>{
            const n = i.detail[e1], a = n[0], s = n.slice(1);
            i.target.style[t] = ColorConverters[`${a}_HTML`](s), this.annotationStorage.setValue(this.data.id, {
                [t]: ColorConverters[`${a}_rgb`](s)
            });
        };
        return shadow(this, "_commonActions", {
            display: (e1)=>{
                const { display: t } = e1.detail, i = t % 2 == 1;
                this.container.style.visibility = i ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    noView: i,
                    noPrint: 1 === t || 2 === t
                });
            },
            print: (e1)=>{
                this.annotationStorage.setValue(this.data.id, {
                    noPrint: !e1.detail.print
                });
            },
            hidden: (e1)=>{
                const { hidden: t } = e1.detail;
                this.container.style.visibility = t ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    noPrint: t,
                    noView: t
                });
            },
            focus: (e1)=>{
                setTimeout(()=>e1.target.focus({
                        preventScroll: !1
                    }), 0);
            },
            userName: (e1)=>{
                e1.target.title = e1.detail.userName;
            },
            readonly: (e1)=>{
                e1.target.disabled = e1.detail.readonly;
            },
            required: (e1)=>{
                this._setRequired(e1.target, e1.detail.required);
            },
            bgColor: (e1)=>{
                setColor("bgColor", "backgroundColor", e1);
            },
            fillColor: (e1)=>{
                setColor("fillColor", "backgroundColor", e1);
            },
            fgColor: (e1)=>{
                setColor("fgColor", "color", e1);
            },
            textColor: (e1)=>{
                setColor("textColor", "color", e1);
            },
            borderColor: (e1)=>{
                setColor("borderColor", "borderColor", e1);
            },
            strokeColor: (e1)=>{
                setColor("strokeColor", "borderColor", e1);
            },
            rotation: (e1)=>{
                const t = e1.detail.rotation;
                this.setRotation(t), this.annotationStorage.setValue(this.data.id, {
                    rotation: t
                });
            }
        });
    }
    _dispatchEventFromSandbox(e1, t) {
        const i = this._commonActions;
        for (const n of Object.keys(t.detail)){
            const a = e1[n] || i[n];
            a?.(t);
        }
    }
    _setDefaultPropertiesFromJS(e1) {
        if (!this.enableScripting) return;
        const t = this.annotationStorage.getRawValue(this.data.id);
        if (!t) return;
        const i = this._commonActions;
        for (const [n, a] of Object.entries(t)){
            const s = i[n];
            if (s) {
                s({
                    detail: {
                        [n]: a
                    },
                    target: e1
                }), delete t[n];
            }
        }
    }
    _createQuadrilaterals() {
        if (!this.container) return;
        const { quadPoints: e1 } = this.data;
        if (!e1) return;
        const [t, i, n, a] = this.data.rect.map((e1)=>Math.fround(e1));
        if (8 === e1.length) {
            const [s, r, o, l] = e1.subarray(2, 6);
            if (n === s && a === r && t === o && i === l) return;
        }
        const { style: s } = this.container;
        let r;
        if (this.#to) {
            const { borderColor: e1, borderWidth: t } = s;
            s.borderWidth = 0, r = [
                "url('data:image/svg+xml;utf8,",
                '<svg xmlns="http://www.w3.org/2000/svg"',
                ' preserveAspectRatio="none" viewBox="0 0 1 1">',
                `<g fill="transparent" stroke="${e1}" stroke-width="${t}">`
            ], this.container.classList.add("hasBorder");
        }
        const o = n - t, l = a - i, { svgFactory: c } = this, h = c.createElement("svg");
        h.classList.add("quadrilateralsContainer"), h.setAttribute("width", 0), h.setAttribute("height", 0), h.role = "none";
        const d = c.createElement("defs");
        h.append(d);
        const u = c.createElement("clipPath"), g = `clippath_${this.data.id}`;
        u.setAttribute("id", g), u.setAttribute("clipPathUnits", "objectBoundingBox"), d.append(u);
        for(let i = 2, n = e1.length; i < n; i += 8){
            const n = e1[i], s = e1[i + 1], h = e1[i + 2], d = e1[i + 3], g = c.createElement("rect"), f = (h - t) / o, p = (a - s) / l, m = (n - h) / o, b = (s - d) / l;
            g.setAttribute("x", f), g.setAttribute("y", p), g.setAttribute("width", m), g.setAttribute("height", b), u.append(g), r?.push(`<rect vector-effect="non-scaling-stroke" x="${f}" y="${p}" width="${m}" height="${b}"/>`);
        }
        this.#to && (r.push("</g></svg>')"), s.backgroundImage = r.join("")), this.container.append(h), this.container.style.clipPath = `url(#${g})`;
    }
    _createPopup(e1 = null) {
        const { data: t } = this;
        let i, n;
        e1 ? (i = {
            str: e1.text
        }, n = e1.date) : (i = t.contentsObj, n = t.modificationDate);
        const a = this.#io = new PopupAnnotationElement({
            data: {
                color: t.color,
                titleObj: t.titleObj,
                modificationDate: n,
                contentsObj: i,
                richText: t.richText,
                parentRect: t.rect,
                borderStyle: 0,
                id: `popup_${t.id}`,
                rotation: t.rotation,
                noRotate: !0
            },
            linkService: this.linkService,
            parent: this.parent,
            elements: [
                this
            ]
        });
        this.parent._commentManager || this.parent.div.append(a.render());
    }
    get hasPopupElement() {
        return !!(this.#io || this.popup || this.data.popupRef);
    }
    get extraPopupElement() {
        return this.#io;
    }
    render() {
        unreachable("Abstract method `AnnotationElement.render` called");
    }
    _getElementsByName(e1, t = null) {
        const i = [];
        if (this._fieldObjects) {
            const n = this._fieldObjects[e1];
            if (n) for (const { page: e1, id: a, exportValues: s } of n){
                if (-1 === e1) continue;
                if (a === t) continue;
                const n = "string" == typeof s ? s : null, r = document.querySelector(`[data-element-id="${a}"]`);
                !r || dh.has(r) ? i.push({
                    id: a,
                    exportValue: n,
                    domElement: r
                }) : warn(`_getElementsByName - element not allowed: ${a}`);
            }
            return i;
        }
        for (const n of document.getElementsByName(e1)){
            const { exportValue: e1 } = n, a = n.getAttribute("data-element-id");
            a !== t && dh.has(n) && i.push({
                id: a,
                exportValue: e1,
                domElement: n
            });
        }
        return i;
    }
    show() {
        this.container && (this.container.hidden = !1), this.popup?.maybeShow();
    }
    hide() {
        this.container && (this.container.hidden = !0), this.popup?.forceHide();
    }
    getElementsToTriggerPopup() {
        return this.container;
    }
    addHighlightArea() {
        const e1 = this.getElementsToTriggerPopup();
        if (Array.isArray(e1)) for (const t of e1)t.classList.add("highlightArea");
        else e1.classList.add("highlightArea");
    }
    _editOnDoubleClick() {
        if (!this._isEditable) return;
        const { annotationEditorType: e1, data: { id: t } } = this;
        this.container.addEventListener("dblclick", ()=>{
            this.linkService.eventBus?.dispatch("switchannotationeditormode", {
                source: this,
                mode: e1,
                editId: t,
                mustEnterInEditMode: !0
            });
        });
    }
    get width() {
        return this.data.rect[2] - this.data.rect[0];
    }
    get height() {
        return this.data.rect[3] - this.data.rect[1];
    }
}
class EditorAnnotationElement extends AnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0
        }), this.editor = e1.editor;
    }
    render() {
        return this.container.className = "editorAnnotation", this.container;
    }
    createOrUpdatePopup() {
        const { editor: e1 } = this;
        e1.hasComment && (this._createPopup(e1.comment), this.extraPopupElement.popup.renderCommentButton());
    }
    get hasCommentButton() {
        return this.enableComment && this.editor.hasComment;
    }
    get commentButtonPosition() {
        return this.editor.commentButtonPositionInPage;
    }
    get commentText() {
        return this.editor.comment.text;
    }
    set commentText(e1) {
        this.editor.comment = e1, e1 || this.removePopup();
    }
    get commentData() {
        return this.editor.getData();
    }
    remove() {
        this.container.remove(), this.container = null, this.removePopup();
    }
}
class LinkAnnotationElement extends AnnotationElement {
    constructor(e1, t = null){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !!t?.ignoreBorder,
            createQuadrilaterals: !0
        }), this.isTooltipOnly = e1.data.isTooltipOnly;
    }
    render() {
        const { data: e1, linkService: t } = this, i = document.createElement("a");
        i.setAttribute("data-element-id", e1.id);
        let n = !1;
        return e1.url ? (t.addLinkAttributes(i, e1.url, e1.newWindow), n = !0) : e1.action ? (this._bindNamedAction(i, e1.action, e1.overlaidText), n = !0) : e1.attachment ? (this.#ao(i, e1.attachment, e1.overlaidText, e1.attachmentDest), n = !0) : e1.setOCGState ? (this.#so(i, e1.setOCGState, e1.overlaidText), n = !0) : e1.dest ? (this._bindLink(i, e1.dest, e1.overlaidText), n = !0) : (e1.actions && (e1.actions.Action || e1.actions["Mouse Up"] || e1.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(i, e1), n = !0), e1.resetForm ? (this._bindResetFormAction(i, e1.resetForm), n = !0) : this.isTooltipOnly && !n && (this._bindLink(i, ""), n = !0)), this.container.classList.add("linkAnnotation"), n && this.container.append(i), this.container;
    }
    #ro() {
        this.container.setAttribute("data-internal-link", "");
    }
    _bindLink(e1, t, i = "") {
        e1.href = this.linkService.getDestinationHash(t), e1.onclick = ()=>(t && this.linkService.goToDestination(t), !1), (t || "" === t) && this.#ro(), i && (e1.title = i);
    }
    _bindNamedAction(e1, t, i = "") {
        e1.href = this.linkService.getAnchorUrl(""), e1.onclick = ()=>(this.linkService.executeNamedAction(t), !1), i && (e1.title = i), this.#ro();
    }
    #ao(e1, t, i = "", n = null) {
        e1.href = this.linkService.getAnchorUrl(""), t.description ? e1.title = t.description : i && (e1.title = i), e1.onclick = ()=>(this.downloadManager?.openOrDownloadData(t.content, t.filename, n), !1), this.#ro();
    }
    #so(e1, t, i = "") {
        e1.href = this.linkService.getAnchorUrl(""), e1.onclick = ()=>(this.linkService.executeSetOCGState(t), !1), i && (e1.title = i), this.#ro();
    }
    _bindJSAction(e1, t) {
        e1.href = this.linkService.getAnchorUrl("");
        const i = new Map([
            [
                "Action",
                "onclick"
            ],
            [
                "Mouse Up",
                "onmouseup"
            ],
            [
                "Mouse Down",
                "onmousedown"
            ]
        ]);
        for (const n of Object.keys(t.actions)){
            const a = i.get(n);
            a && (e1[a] = ()=>(this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                        id: t.id,
                        name: n
                    }
                }), !1));
        }
        t.overlaidText && (e1.title = t.overlaidText), e1.onclick || (e1.onclick = ()=>!1), this.#ro();
    }
    _bindResetFormAction(e1, t) {
        const i = e1.onclick;
        if (i || (e1.href = this.linkService.getAnchorUrl("")), this.#ro(), !this._fieldObjects) return warn('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), void (i || (e1.onclick = ()=>!1));
        e1.onclick = ()=>{
            i?.();
            const { fields: e1, refs: n, include: a } = t, s = [];
            if (0 !== e1.length || 0 !== n.length) {
                const t = new Set(n);
                for (const i of e1){
                    const e1 = this._fieldObjects[i] || [];
                    for (const { id: i } of e1)t.add(i);
                }
                for (const e1 of Object.values(this._fieldObjects))for (const i of e1)t.has(i.id) === a && s.push(i);
            } else for (const e1 of Object.values(this._fieldObjects))s.push(...e1);
            const r = this.annotationStorage, o = [];
            for (const e1 of s){
                const { id: t } = e1;
                switch(o.push(t), e1.type){
                    case "text":
                        {
                            const i = e1.defaultValue || "";
                            r.setValue(t, {
                                value: i
                            });
                            break;
                        }
                    case "checkbox":
                    case "radiobutton":
                        {
                            const i = e1.defaultValue === e1.exportValues;
                            r.setValue(t, {
                                value: i
                            });
                            break;
                        }
                    case "combobox":
                    case "listbox":
                        {
                            const i = e1.defaultValue || "";
                            r.setValue(t, {
                                value: i
                            });
                            break;
                        }
                    default:
                        continue;
                }
                const i = document.querySelector(`[data-element-id="${t}"]`);
                i && (dh.has(i) ? i.dispatchEvent(new Event("resetform")) : warn(`_bindResetFormAction - element not allowed: ${t}`));
            }
            return this.enableScripting && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                    id: "app",
                    ids: o,
                    name: "ResetForm"
                }
            }), !1;
        };
    }
}
class TextAnnotationElement extends AnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: !0
        });
    }
    render() {
        this.container.classList.add("textAnnotation");
        const e1 = document.createElement("img");
        return e1.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", e1.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), e1.setAttribute("data-l10n-args", JSON.stringify({
            type: this.data.name
        })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(e1), this.container;
    }
}
class WidgetAnnotationElement extends AnnotationElement {
    render() {
        return this.container;
    }
    showElementAndHideCanvas(e1) {
        this.data.hasOwnCanvas && ("CANVAS" === e1.previousSibling?.nodeName && (e1.previousSibling.hidden = !0), e1.hidden = !1);
    }
    _getKeyModifier(e1) {
        return util_FeatureTest.platform.isMac ? e1.metaKey : e1.ctrlKey;
    }
    _setEventListener(e1, t, i, n, a) {
        i.includes("mouse") ? e1.addEventListener(i, (e1)=>{
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                    id: this.data.id,
                    name: n,
                    value: a(e1),
                    shift: e1.shiftKey,
                    modifier: this._getKeyModifier(e1)
                }
            });
        }) : e1.addEventListener(i, (e1)=>{
            if ("blur" === i) {
                if (!t.focused || !e1.relatedTarget) return;
                t.focused = !1;
            } else if ("focus" === i) {
                if (t.focused) return;
                t.focused = !0;
            }
            a && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                    id: this.data.id,
                    name: n,
                    value: a(e1)
                }
            });
        });
    }
    _setEventListeners(e1, t, i, n) {
        for (const [a, s] of i)("Action" === s || this.data.actions?.[s]) && ("Focus" !== s && "Blur" !== s || (t ||= {
            focused: !1
        }), this._setEventListener(e1, t, a, s, n), "Focus" !== s || this.data.actions?.Blur ? "Blur" !== s || this.data.actions?.Focus || this._setEventListener(e1, t, "focus", "Focus", null) : this._setEventListener(e1, t, "blur", "Blur", null));
    }
    _setBackgroundColor(e1) {
        const t = this.data.backgroundColor || null;
        e1.style.backgroundColor = null === t ? "transparent" : Util.makeHexColor(t[0], t[1], t[2]);
    }
    _setTextStyle(e1) {
        const t = [
            "left",
            "center",
            "right"
        ], { fontColor: i } = this.data.defaultAppearanceData, n = this.data.defaultAppearanceData.fontSize || 9, a = e1.style;
        let s;
        const roundToOneDecimal = (e1)=>Math.round(10 * e1) / 10;
        if (this.data.multiLine) {
            const e1 = Math.abs(this.data.rect[3] - this.data.rect[1] - 2), t = e1 / (Math.round(e1 / (El * n)) || 1);
            s = Math.min(n, roundToOneDecimal(t / El));
        } else {
            const e1 = Math.abs(this.data.rect[3] - this.data.rect[1] - 2);
            s = Math.min(n, roundToOneDecimal(e1 / El));
        }
        a.fontSize = `calc(${s}px * var(--total-scale-factor))`, a.color = Util.makeHexColor(i[0], i[1], i[2]), null !== this.data.textAlignment && (a.textAlign = t[this.data.textAlignment]);
    }
    _setRequired(e1, t) {
        t ? e1.setAttribute("required", !0) : e1.removeAttribute("required"), e1.setAttribute("aria-required", t);
    }
}
class TextWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: e1.renderForms || e1.data.hasOwnCanvas || !e1.data.hasAppearance && !!e1.data.fieldValue
        });
    }
    setPropertyOnSiblings(e1, t, i, n) {
        const a = this.annotationStorage;
        for (const s of this._getElementsByName(e1.name, e1.id))s.domElement && (s.domElement[t] = i), a.setValue(s.id, {
            [n]: i
        });
    }
    render() {
        const e1 = this.annotationStorage, t = this.data.id;
        this.container.classList.add("textWidgetAnnotation");
        let i = null;
        if (this.renderForms) {
            const n = e1.getValue(t, {
                value: this.data.fieldValue
            });
            let a = n.value || "";
            const s = e1.getValue(t, {
                charLimit: this.data.maxLen
            }).charLimit;
            s && a.length > s && (a = a.slice(0, s));
            let r = n.formattedValue || this.data.textContent?.join("\n") || null;
            r && this.data.comb && (r = r.replaceAll(/\s+/g, ""));
            const o = {
                userValue: a,
                formattedValue: r,
                lastCommittedValue: null,
                commitKey: 1,
                focused: !1
            };
            this.data.multiLine ? (i = document.createElement("textarea"), i.textContent = r ?? a, this.data.doNotScroll && (i.style.overflowY = "hidden")) : (i = document.createElement("input"), i.type = this.data.password ? "password" : "text", i.setAttribute("value", r ?? a), this.data.doNotScroll && (i.style.overflowX = "hidden")), this.data.hasOwnCanvas && (i.hidden = !0), dh.add(i), i.setAttribute("data-element-id", t), i.disabled = this.data.readOnly, i.name = this.data.fieldName, i.tabIndex = 0;
            const { datetimeFormat: l, datetimeType: c, timeStep: h } = this.data, d = !!c && this.enableScripting;
            l && (i.title = l), this._setRequired(i, this.data.required), s && (i.maxLength = s), i.addEventListener("input", (n)=>{
                e1.setValue(t, {
                    value: n.target.value
                }), this.setPropertyOnSiblings(i, "value", n.target.value, "value"), o.formattedValue = null;
            }), i.addEventListener("resetform", (e1)=>{
                const t = this.data.defaultFieldValue ?? "";
                i.value = o.userValue = t, o.formattedValue = null;
            });
            let blurListener = (e1)=>{
                const { formattedValue: t } = o;
                null != t && (e1.target.value = t), e1.target.scrollLeft = 0;
            };
            if (this.enableScripting && this.hasJSActions) {
                i.addEventListener("focus", (e1)=>{
                    if (o.focused) return;
                    const { target: t } = e1;
                    if (d && (t.type = c, h && (t.step = h)), o.userValue) {
                        const e1 = o.userValue;
                        if (d) if ("time" === c) {
                            const i = new Date(e1), n = [
                                i.getHours(),
                                i.getMinutes(),
                                i.getSeconds()
                            ];
                            t.value = n.map((e1)=>e1.toString().padStart(2, "0")).join(":");
                        } else t.value = new Date(e1 - uh).toISOString().split("date" === c ? "T" : ".", 1)[0];
                        else t.value = e1;
                    }
                    o.lastCommittedValue = t.value, o.commitKey = 1, this.data.actions?.Focus || (o.focused = !0);
                }), i.addEventListener("updatefromsandbox", (i)=>{
                    this.showElementAndHideCanvas(i.target);
                    const n = {
                        value (i) {
                            o.userValue = i.detail.value ?? "", d || e1.setValue(t, {
                                value: o.userValue.toString()
                            }), i.target.value = o.userValue;
                        },
                        formattedValue (i) {
                            const { formattedValue: n } = i.detail;
                            o.formattedValue = n, null != n && i.target !== document.activeElement && (i.target.value = n);
                            const a = {
                                formattedValue: n
                            };
                            d && (a.value = n), e1.setValue(t, a);
                        },
                        selRange (e1) {
                            e1.target.setSelectionRange(...e1.detail.selRange);
                        },
                        charLimit: (i)=>{
                            const { charLimit: n } = i.detail, { target: a } = i;
                            if (0 === n) return void a.removeAttribute("maxLength");
                            a.setAttribute("maxLength", n);
                            let s = o.userValue;
                            !s || s.length <= n || (s = s.slice(0, n), a.value = o.userValue = s, e1.setValue(t, {
                                value: s
                            }), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                                source: this,
                                detail: {
                                    id: t,
                                    name: "Keystroke",
                                    value: s,
                                    willCommit: !0,
                                    commitKey: 1,
                                    selStart: a.selectionStart,
                                    selEnd: a.selectionEnd
                                }
                            }));
                        }
                    };
                    this._dispatchEventFromSandbox(n, i);
                }), i.addEventListener("keydown", (e1)=>{
                    o.commitKey = 1;
                    let i = -1;
                    if ("Escape" === e1.key ? i = 0 : "Enter" !== e1.key || this.data.multiLine ? "Tab" === e1.key && (o.commitKey = 3) : i = 2, -1 === i) return;
                    const { value: n } = e1.target;
                    o.lastCommittedValue !== n && (o.lastCommittedValue = n, o.userValue = n, this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                            id: t,
                            name: "Keystroke",
                            value: n,
                            willCommit: !0,
                            commitKey: i,
                            selStart: e1.target.selectionStart,
                            selEnd: e1.target.selectionEnd
                        }
                    }));
                });
                const n = blurListener;
                blurListener = null, i.addEventListener("blur", (e1)=>{
                    if (!o.focused || !e1.relatedTarget) return;
                    this.data.actions?.Blur || (o.focused = !1);
                    const { target: i } = e1;
                    let { value: a } = i;
                    if (d) {
                        if (a && "time" === c) {
                            const e1 = a.split(":").map((e1)=>parseInt(e1, 10));
                            a = new Date(2e3, 0, 1, e1[0], e1[1], e1[2] || 0).valueOf(), i.step = "";
                        } else a.includes("T") || (a = `${a}T00:00`), a = new Date(a).valueOf();
                        i.type = "text";
                    }
                    o.userValue = a, o.lastCommittedValue !== a && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                            id: t,
                            name: "Keystroke",
                            value: a,
                            willCommit: !0,
                            commitKey: o.commitKey,
                            selStart: e1.target.selectionStart,
                            selEnd: e1.target.selectionEnd
                        }
                    }), n(e1);
                }), this.data.actions?.Keystroke && i.addEventListener("beforeinput", (e1)=>{
                    o.lastCommittedValue = null;
                    const { data: i, target: n } = e1, { value: a, selectionStart: s, selectionEnd: r } = n;
                    let l = s, c = r;
                    switch(e1.inputType){
                        case "deleteWordBackward":
                            {
                                const e1 = a.substring(0, s).match(/\w*[^\w]*$/);
                                e1 && (l -= e1[0].length);
                                break;
                            }
                        case "deleteWordForward":
                            {
                                const e1 = a.substring(s).match(/^[^\w]*\w*/);
                                e1 && (c += e1[0].length);
                                break;
                            }
                        case "deleteContentBackward":
                            s === r && (l -= 1);
                            break;
                        case "deleteContentForward":
                            s === r && (c += 1);
                    }
                    e1.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                            id: t,
                            name: "Keystroke",
                            value: a,
                            change: i || "",
                            willCommit: !1,
                            selStart: l,
                            selEnd: c
                        }
                    });
                }), this._setEventListeners(i, o, [
                    [
                        "focus",
                        "Focus"
                    ],
                    [
                        "blur",
                        "Blur"
                    ],
                    [
                        "mousedown",
                        "Mouse Down"
                    ],
                    [
                        "mouseenter",
                        "Mouse Enter"
                    ],
                    [
                        "mouseleave",
                        "Mouse Exit"
                    ],
                    [
                        "mouseup",
                        "Mouse Up"
                    ]
                ], (e1)=>e1.target.value);
            }
            if (blurListener && i.addEventListener("blur", blurListener), this.data.comb) {
                const e1 = (this.data.rect[2] - this.data.rect[0]) / s;
                i.classList.add("comb"), i.style.letterSpacing = `calc(${e1}px * var(--total-scale-factor) - 1ch)`;
            }
        } else i = document.createElement("div"), i.textContent = this.data.fieldValue, i.style.verticalAlign = "middle", i.style.display = "table-cell", this.data.hasOwnCanvas && (i.hidden = !0);
        return this._setTextStyle(i), this._setBackgroundColor(i), this._setDefaultPropertiesFromJS(i), this.container.append(i), this.container;
    }
}
class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: !!e1.data.hasOwnCanvas
        });
    }
}
class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: e1.renderForms
        });
    }
    render() {
        const e1 = this.annotationStorage, t = this.data, i = t.id;
        let n = e1.getValue(i, {
            value: t.exportValue === t.fieldValue
        }).value;
        "string" == typeof n && (n = "Off" !== n, e1.setValue(i, {
            value: n
        })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
        const a = document.createElement("input");
        return dh.add(a), a.setAttribute("data-element-id", i), a.disabled = t.readOnly, this._setRequired(a, this.data.required), a.type = "checkbox", a.name = t.fieldName, n && a.setAttribute("checked", !0), a.setAttribute("exportValue", t.exportValue), a.tabIndex = 0, a.addEventListener("change", (n)=>{
            const { name: a, checked: s } = n.target;
            for (const n of this._getElementsByName(a, i)){
                const i = s && n.exportValue === t.exportValue;
                n.domElement && (n.domElement.checked = i), e1.setValue(n.id, {
                    value: i
                });
            }
            e1.setValue(i, {
                value: s
            });
        }), a.addEventListener("resetform", (e1)=>{
            const i = t.defaultFieldValue || "Off";
            e1.target.checked = i === t.exportValue;
        }), this.enableScripting && this.hasJSActions && (a.addEventListener("updatefromsandbox", (t)=>{
            const n = {
                value (t) {
                    t.target.checked = "Off" !== t.detail.value, e1.setValue(i, {
                        value: t.target.checked
                    });
                }
            };
            this._dispatchEventFromSandbox(n, t);
        }), this._setEventListeners(a, null, [
            [
                "change",
                "Validate"
            ],
            [
                "change",
                "Action"
            ],
            [
                "focus",
                "Focus"
            ],
            [
                "blur",
                "Blur"
            ],
            [
                "mousedown",
                "Mouse Down"
            ],
            [
                "mouseenter",
                "Mouse Enter"
            ],
            [
                "mouseleave",
                "Mouse Exit"
            ],
            [
                "mouseup",
                "Mouse Up"
            ]
        ], (e1)=>e1.target.checked)), this._setBackgroundColor(a), this._setDefaultPropertiesFromJS(a), this.container.append(a), this.container;
    }
}
class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: e1.renderForms
        });
    }
    render() {
        this.container.classList.add("buttonWidgetAnnotation", "radioButton");
        const e1 = this.annotationStorage, t = this.data, i = t.id;
        let n = e1.getValue(i, {
            value: t.fieldValue === t.buttonValue
        }).value;
        if ("string" == typeof n && (n = n !== t.buttonValue, e1.setValue(i, {
            value: n
        })), n) for (const n of this._getElementsByName(t.fieldName, i))e1.setValue(n.id, {
            value: !1
        });
        const a = document.createElement("input");
        if (dh.add(a), a.setAttribute("data-element-id", i), a.disabled = t.readOnly, this._setRequired(a, this.data.required), a.type = "radio", a.name = t.fieldName, n && a.setAttribute("checked", !0), a.tabIndex = 0, a.addEventListener("change", (t)=>{
            const { name: n, checked: a } = t.target;
            for (const t of this._getElementsByName(n, i))e1.setValue(t.id, {
                value: !1
            });
            e1.setValue(i, {
                value: a
            });
        }), a.addEventListener("resetform", (e1)=>{
            const i = t.defaultFieldValue;
            e1.target.checked = null != i && i === t.buttonValue;
        }), this.enableScripting && this.hasJSActions) {
            const n = t.buttonValue;
            a.addEventListener("updatefromsandbox", (t)=>{
                const a = {
                    value: (t)=>{
                        const a = n === t.detail.value;
                        for (const n of this._getElementsByName(t.target.name)){
                            const t = a && n.id === i;
                            n.domElement && (n.domElement.checked = t), e1.setValue(n.id, {
                                value: t
                            });
                        }
                    }
                };
                this._dispatchEventFromSandbox(a, t);
            }), this._setEventListeners(a, null, [
                [
                    "change",
                    "Validate"
                ],
                [
                    "change",
                    "Action"
                ],
                [
                    "focus",
                    "Focus"
                ],
                [
                    "blur",
                    "Blur"
                ],
                [
                    "mousedown",
                    "Mouse Down"
                ],
                [
                    "mouseenter",
                    "Mouse Enter"
                ],
                [
                    "mouseleave",
                    "Mouse Exit"
                ],
                [
                    "mouseup",
                    "Mouse Up"
                ]
            ], (e1)=>e1.target.checked);
        }
        return this._setBackgroundColor(a), this._setDefaultPropertiesFromJS(a), this.container.append(a), this.container;
    }
}
class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
    constructor(e1){
        super(e1, {
            ignoreBorder: e1.data.hasAppearance
        });
    }
    render() {
        const e1 = super.render();
        e1.classList.add("buttonWidgetAnnotation", "pushButton");
        const t = e1.lastChild;
        return this.enableScripting && this.hasJSActions && t && (this._setDefaultPropertiesFromJS(t), t.addEventListener("updatefromsandbox", (e1)=>{
            this._dispatchEventFromSandbox({}, e1);
        })), e1;
    }
}
class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: e1.renderForms
        });
    }
    render() {
        this.container.classList.add("choiceWidgetAnnotation");
        const e1 = this.annotationStorage, t = this.data.id, i = e1.getValue(t, {
            value: this.data.fieldValue
        }), n = document.createElement("select");
        dh.add(n), n.setAttribute("data-element-id", t), n.disabled = this.data.readOnly, this._setRequired(n, this.data.required), n.name = this.data.fieldName, n.tabIndex = 0;
        let a = this.data.combo && this.data.options.length > 0;
        this.data.combo || (n.size = this.data.options.length, this.data.multiSelect && (n.multiple = !0)), n.addEventListener("resetform", (e1)=>{
            const t = this.data.defaultFieldValue;
            for (const e1 of n.options)e1.selected = e1.value === t;
        });
        for (const e1 of this.data.options){
            const t = document.createElement("option");
            t.textContent = e1.displayValue, t.value = e1.exportValue, i.value.includes(e1.exportValue) && (t.setAttribute("selected", !0), a = !1), n.append(t);
        }
        let s = null;
        if (a) {
            const e1 = document.createElement("option");
            e1.value = " ", e1.setAttribute("hidden", !0), e1.setAttribute("selected", !0), n.prepend(e1), s = ()=>{
                e1.remove(), n.removeEventListener("input", s), s = null;
            }, n.addEventListener("input", s);
        }
        const getValue = (e1)=>{
            const t = e1 ? "value" : "textContent", { options: i, multiple: a } = n;
            return a ? Array.prototype.filter.call(i, (e1)=>e1.selected).map((e1)=>e1[t]) : -1 === i.selectedIndex ? null : i[i.selectedIndex][t];
        };
        let r = getValue(!1);
        const getItems = (e1)=>{
            const t = e1.target.options;
            return Array.prototype.map.call(t, (e1)=>({
                    displayValue: e1.textContent,
                    exportValue: e1.value
                }));
        };
        return this.enableScripting && this.hasJSActions ? (n.addEventListener("updatefromsandbox", (i)=>{
            const a = {
                value (i) {
                    s?.();
                    const a = i.detail.value, o = new Set(Array.isArray(a) ? a : [
                        a
                    ]);
                    for (const e1 of n.options)e1.selected = o.has(e1.value);
                    e1.setValue(t, {
                        value: getValue(!0)
                    }), r = getValue(!1);
                },
                multipleSelection (e1) {
                    n.multiple = !0;
                },
                remove (i) {
                    const a = n.options, s = i.detail.remove;
                    if (a[s].selected = !1, n.remove(s), a.length > 0) {
                        -1 === Array.prototype.findIndex.call(a, (e1)=>e1.selected) && (a[0].selected = !0);
                    }
                    e1.setValue(t, {
                        value: getValue(!0),
                        items: getItems(i)
                    }), r = getValue(!1);
                },
                clear (i) {
                    for(; 0 !== n.length;)n.remove(0);
                    e1.setValue(t, {
                        value: null,
                        items: []
                    }), r = getValue(!1);
                },
                insert (i) {
                    const { index: a, displayValue: s, exportValue: o } = i.detail.insert, l = n.children[a], c = document.createElement("option");
                    c.textContent = s, c.value = o, l ? l.before(c) : n.append(c), e1.setValue(t, {
                        value: getValue(!0),
                        items: getItems(i)
                    }), r = getValue(!1);
                },
                items (i) {
                    const { items: a } = i.detail;
                    for(; 0 !== n.length;)n.remove(0);
                    for (const e1 of a){
                        const { displayValue: t, exportValue: i } = e1, a = document.createElement("option");
                        a.textContent = t, a.value = i, n.append(a);
                    }
                    n.options.length > 0 && (n.options[0].selected = !0), e1.setValue(t, {
                        value: getValue(!0),
                        items: getItems(i)
                    }), r = getValue(!1);
                },
                indices (i) {
                    const n = new Set(i.detail.indices);
                    for (const e1 of i.target.options)e1.selected = n.has(e1.index);
                    e1.setValue(t, {
                        value: getValue(!0)
                    }), r = getValue(!1);
                },
                editable (e1) {
                    e1.target.disabled = !e1.detail.editable;
                }
            };
            this._dispatchEventFromSandbox(a, i);
        }), n.addEventListener("input", (i)=>{
            const n = getValue(!0), a = getValue(!1);
            e1.setValue(t, {
                value: n
            }), i.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                    id: t,
                    name: "Keystroke",
                    value: r,
                    change: a,
                    changeEx: n,
                    willCommit: !1,
                    commitKey: 1,
                    keyDown: !1
                }
            });
        }), this._setEventListeners(n, null, [
            [
                "focus",
                "Focus"
            ],
            [
                "blur",
                "Blur"
            ],
            [
                "mousedown",
                "Mouse Down"
            ],
            [
                "mouseenter",
                "Mouse Enter"
            ],
            [
                "mouseleave",
                "Mouse Exit"
            ],
            [
                "mouseup",
                "Mouse Up"
            ],
            [
                "input",
                "Action"
            ],
            [
                "input",
                "Validate"
            ]
        ], (e1)=>e1.target.value)) : n.addEventListener("input", function(i) {
            e1.setValue(t, {
                value: getValue(!0)
            });
        }), this.data.combo && this._setTextStyle(n), this._setBackgroundColor(n), this._setDefaultPropertiesFromJS(n), this.container.append(n), this.container;
    }
}
class PopupAnnotationElement extends AnnotationElement {
    constructor(e1){
        const { data: t, elements: i, parent: n } = e1, a = !!n._commentManager;
        if (super(e1, {
            isRenderable: !a && AnnotationElement._hasPopupData(t)
        }), this.elements = i, a && AnnotationElement._hasPopupData(t)) {
            const e1 = this.popup = this.#oo();
            for (const t of i)t.popup = e1;
        } else this.popup = null;
    }
    #oo() {
        return new PopupElement({
            container: this.container,
            color: this.data.color,
            titleObj: this.data.titleObj,
            modificationDate: this.data.modificationDate || this.data.creationDate,
            contentsObj: this.data.contentsObj,
            richText: this.data.richText,
            rect: this.data.rect,
            parentRect: this.data.parentRect || null,
            parent: this.parent,
            elements: this.elements,
            open: this.data.open,
            commentManager: this.parent._commentManager
        });
    }
    render() {
        const { container: e1 } = this;
        e1.classList.add("popupAnnotation"), e1.role = "comment";
        const t = this.popup = this.#oo(), i = [];
        for (const e1 of this.elements)e1.popup = t, e1.container.ariaHasPopup = "dialog", i.push(e1.data.id), e1.addHighlightArea();
        return this.container.setAttribute("aria-controls", i.map((e1)=>`${mc}${e1}`).join(",")), this.container;
    }
}
class PopupElement {
    #Vt = null;
    #lo = this.#Kr.bind(this);
    #co = this.#ho.bind(this);
    #do = this.#uo.bind(this);
    #go = this.#fo.bind(this);
    #po = null;
    #Mi = null;
    #mo = null;
    #bo = null;
    #yo = null;
    #wo = null;
    #Ao = null;
    #xo = !1;
    #So = null;
    #vo = null;
    #Nt = null;
    #Co = null;
    #ko = null;
    #xn = null;
    #To = null;
    #yn = null;
    #Fo = null;
    #eo = null;
    #Io = !1;
    #Eo = null;
    #Mo = null;
    constructor({ container: e1, color: t, elements: i, titleObj: n, modificationDate: a, contentsObj: s, richText: r, parent: o, rect: l, parentRect: c, open: h, commentManager: d = null }){
        this.#Mi = e1, this.#Fo = n, this.#mo = s, this.#yn = r, this.#wo = o, this.#po = t, this.#To = l, this.#Ao = c, this.#yo = i, this.#Vt = d, this.#Eo = i[0], this.#bo = PDFDateString.toDateObject(a), this.trigger = i.flatMap((e1)=>e1.getElementsToTriggerPopup()), d ? this.renderCommentButton() : (this.#Do(), this.#Mi.hidden = !0, h && this.#fo());
    }
    #Do() {
        if (this.#vo) return;
        this.#vo = new AbortController;
        const { signal: e1 } = this.#vo;
        for (const t of this.trigger)t.addEventListener("click", this.#go, {
            signal: e1
        }), t.addEventListener("pointerenter", this.#do, {
            signal: e1
        }), t.addEventListener("pointerleave", this.#co, {
            signal: e1
        }), t.classList.add("popupTriggerArea");
        for (const t of this.#yo)t.container?.addEventListener("keydown", this.#lo, {
            signal: e1
        });
    }
    #Oo() {
        const e1 = this.#yo.find((e1)=>e1.hasCommentButton);
        e1 && (this.#ko = e1._normalizePoint(e1.commentButtonPosition));
    }
    renderCommentButton() {
        if (this.#Co) return;
        if (this.#ko || this.#Oo(), !this.#ko) return;
        const { signal: e1 } = this.#vo = new AbortController, t = !!this.#Eo.extraPopupElement, togglePopup = ()=>{
            this.#Vt.toggleCommentPopup(this, !0, void 0, !t);
        }, showPopup = ()=>{
            this.#Vt.toggleCommentPopup(this, !1, !0, !t);
        }, hidePopup = ()=>{
            this.#Vt.toggleCommentPopup(this, !1, !1);
        };
        if (t) {
            this.#Co = this.#Eo.container;
            for (const t of this.trigger)t.ariaHasPopup = "dialog", t.ariaControls = "commentPopup", t.addEventListener("keydown", this.#lo, {
                signal: e1
            }), t.addEventListener("click", togglePopup, {
                signal: e1
            }), t.addEventListener("pointerenter", showPopup, {
                signal: e1
            }), t.addEventListener("pointerleave", hidePopup, {
                signal: e1
            }), t.classList.add("popupTriggerArea");
        } else {
            const t = this.#Co = document.createElement("button");
            t.className = "annotationCommentButton";
            const i = this.#Eo.container;
            t.style.zIndex = i.style.zIndex + 1, t.tabIndex = 0, t.ariaHasPopup = "dialog", t.ariaControls = "commentPopup", t.setAttribute("data-l10n-id", "pdfjs-show-comment-button"), this.#_o(), this.#Po(), t.addEventListener("keydown", this.#lo, {
                signal: e1
            }), t.addEventListener("click", togglePopup, {
                signal: e1
            }), t.addEventListener("pointerenter", showPopup, {
                signal: e1
            }), t.addEventListener("pointerleave", hidePopup, {
                signal: e1
            }), i.after(t);
        }
    }
    #Po() {
        if (this.#Eo.extraPopupElement && !this.#Eo.editor) return;
        this.renderCommentButton();
        const [e1, t] = this.#ko, { style: i } = this.#Co;
        i.left = `calc(${e1}%)`, i.top = `calc(${t}% - var(--comment-button-dim))`;
    }
    #_o() {
        this.#Eo.extraPopupElement || (this.renderCommentButton(), this.#Co.style.backgroundColor = this.commentButtonColor || "");
    }
    get commentButtonColor() {
        const { color: e1, opacity: t } = this.#Eo.commentData;
        return e1 ? this.#wo._commentManager.makeCommentColor(e1, t) : null;
    }
    focusCommentButton() {
        setTimeout(()=>{
            this.#Co?.focus();
        }, 0);
    }
    getData() {
        const { richText: e1, color: t, opacity: i, creationDate: n, modificationDate: a } = this.#Eo.commentData;
        return {
            contentsObj: {
                str: this.comment
            },
            richText: e1,
            color: t,
            opacity: i,
            creationDate: n,
            modificationDate: a
        };
    }
    get elementBeforePopup() {
        return this.#Co;
    }
    get comment() {
        return this.#Mo ||= this.#Eo.commentText, this.#Mo;
    }
    set comment(e1) {
        e1 !== this.comment && (this.#Eo.commentText = this.#Mo = e1);
    }
    get parentBoundingClientRect() {
        return this.#Eo.layer.getBoundingClientRect();
    }
    setCommentButtonStates({ selected: e1, hasPopup: t }) {
        this.#Co && (this.#Co.classList.toggle("selected", e1), this.#Co.ariaExpanded = t);
    }
    setSelectedCommentButton(e1) {
        this.#Co.classList.toggle("selected", e1);
    }
    get commentPopupPosition() {
        if (this.#xn) return this.#xn;
        const { x: e1, y: t, height: i } = this.#Co.getBoundingClientRect(), { x: n, y: a, width: s, height: r } = this.#Eo.layer.getBoundingClientRect();
        return [
            (e1 - n) / s,
            (t + i - a) / r
        ];
    }
    set commentPopupPosition(e1) {
        this.#xn = e1;
    }
    hasDefaultPopupPosition() {
        return null === this.#xn;
    }
    get commentButtonPosition() {
        return this.#ko;
    }
    get commentButtonWidth() {
        return this.#Co.getBoundingClientRect().width / this.parentBoundingClientRect.width;
    }
    editComment(e1) {
        const [t, i] = this.#xn || this.commentButtonPosition.map((e1)=>e1 / 100), n = this.parentBoundingClientRect, { x: a, y: s, width: r, height: o } = n;
        this.#Vt.showDialog(null, this, a + t * r, s + i * o, {
            ...e1,
            parentDimensions: n
        });
    }
    render() {
        if (this.#So) return;
        const e1 = this.#So = document.createElement("div");
        if (e1.className = "popup", this.#po) {
            const t = e1.style.outlineColor = Util.makeHexColor(...this.#po);
            e1.style.backgroundColor = `color-mix(in srgb, ${t} 30%, white)`;
        }
        const t = document.createElement("span");
        if (t.className = "header", this.#Fo?.str) {
            const e1 = document.createElement("span");
            e1.className = "title", t.append(e1), { dir: e1.dir, str: e1.textContent } = this.#Fo;
        }
        if (e1.append(t), this.#bo) {
            const e1 = document.createElement("time");
            e1.className = "popupDate", e1.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string"), e1.setAttribute("data-l10n-args", JSON.stringify({
                dateObj: this.#bo.valueOf()
            })), e1.dateTime = this.#bo.toISOString(), t.append(e1);
        }
        renderRichText({
            html: this.#Ro || this.#mo.str,
            dir: this.#mo?.dir,
            className: "popupContent"
        }, e1), this.#Mi.append(e1);
    }
    get #Ro() {
        const e1 = this.#yn, t = this.#mo;
        return !e1?.str || t?.str && t.str !== e1.str ? null : this.#yn.html || null;
    }
    get #Bo() {
        return this.#Ro?.attributes?.style?.fontSize || 0;
    }
    get #No() {
        return this.#Ro?.attributes?.style?.color || null;
    }
    #Lo(e1) {
        const t = [], i = {
            str: e1,
            html: {
                name: "div",
                attributes: {
                    dir: "auto"
                },
                children: [
                    {
                        name: "p",
                        children: t
                    }
                ]
            }
        }, n = {
            style: {
                color: this.#No,
                fontSize: this.#Bo ? `calc(${this.#Bo}px * var(--total-scale-factor))` : ""
            }
        };
        for (const i of e1.split("\n"))t.push({
            name: "span",
            value: i,
            attributes: n
        });
        return i;
    }
    #Kr(e1) {
        e1.altKey || e1.shiftKey || e1.ctrlKey || e1.metaKey || ("Enter" === e1.key || "Escape" === e1.key && this.#xo) && this.#fo();
    }
    updateEdited({ rect: e1, popup: t, deleted: i }) {
        if (this.#Vt) return i ? (this.remove(), this.#Mo = null) : t && (t.deleted ? this.remove() : (this.#_o(), this.#Mo = t.text)), void (e1 && (this.#ko = null, this.#Oo(), this.#Po()));
        i || t?.deleted ? this.remove() : (this.#Do(), this.#eo ||= {
            contentsObj: this.#mo,
            richText: this.#yn
        }, e1 && (this.#Nt = null), t && t.text && (this.#yn = this.#Lo(t.text), this.#bo = PDFDateString.toDateObject(t.date), this.#mo = null), this.#So?.remove(), this.#So = null);
    }
    resetEdited() {
        this.#eo && ({ contentsObj: this.#mo, richText: this.#yn } = this.#eo, this.#eo = null, this.#So?.remove(), this.#So = null, this.#Nt = null);
    }
    remove() {
        if (this.#vo?.abort(), this.#vo = null, this.#So?.remove(), this.#So = null, this.#Io = !1, this.#xo = !1, this.#Co?.remove(), this.#Co = null, this.trigger) for (const e1 of this.trigger)e1.classList.remove("popupTriggerArea");
    }
    #Uo() {
        if (null !== this.#Nt) return;
        const { page: { view: e1 }, viewport: { rawDims: { pageWidth: t, pageHeight: i, pageX: n, pageY: a } } } = this.#wo;
        let s = !!this.#Ao, r = s ? this.#Ao : this.#To;
        for (const e1 of this.#yo)if (!r || null !== Util.intersect(e1.data.rect, r)) {
            r = e1.data.rect, s = !0;
            break;
        }
        const o = Util.normalizeRect([
            r[0],
            e1[3] - r[1] + e1[1],
            r[2],
            e1[3] - r[3] + e1[1]
        ]), l = s ? r[2] - r[0] + 5 : 0, c = o[0] + l, h = o[1];
        this.#Nt = [
            100 * (c - n) / t,
            100 * (h - a) / i
        ];
        const { style: d } = this.#Mi;
        d.left = `${this.#Nt[0]}%`, d.top = `${this.#Nt[1]}%`;
    }
    #fo() {
        this.#Vt ? this.#Vt.toggleCommentPopup(this, !1) : (this.#xo = !this.#xo, this.#xo ? (this.#uo(), this.#Mi.addEventListener("click", this.#go), this.#Mi.addEventListener("keydown", this.#lo)) : (this.#ho(), this.#Mi.removeEventListener("click", this.#go), this.#Mi.removeEventListener("keydown", this.#lo)));
    }
    #uo() {
        this.#So || this.render(), this.isVisible ? this.#xo && this.#Mi.classList.add("focused") : (this.#Uo(), this.#Mi.hidden = !1, this.#Mi.style.zIndex = parseInt(this.#Mi.style.zIndex) + 1e3);
    }
    #ho() {
        this.#Mi.classList.remove("focused"), !this.#xo && this.isVisible && (this.#Mi.hidden = !0, this.#Mi.style.zIndex = parseInt(this.#Mi.style.zIndex) - 1e3);
    }
    forceHide() {
        this.#Io = this.isVisible, this.#Io && (this.#Mi.hidden = !0);
    }
    maybeShow() {
        this.#Vt || (this.#Do(), this.#Io && (this.#So || this.#uo(), this.#Io = !1, this.#Mi.hidden = !1));
    }
    get isVisible() {
        return !this.#Vt && !1 === this.#Mi.hidden;
    }
}
class FreeTextAnnotationElement extends AnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0
        }), this.textContent = e1.data.textContent, this.textPosition = e1.data.textPosition, this.annotationEditorType = Hl.FREETEXT;
    }
    render() {
        if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
            const e1 = document.createElement("div");
            e1.classList.add("annotationTextContent"), e1.setAttribute("role", "comment");
            for (const t of this.textContent){
                const i = document.createElement("span");
                i.textContent = t, e1.append(i);
            }
            this.container.append(e1);
        }
        return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
    }
}
class LineAnnotationElement extends AnnotationElement {
    #jo = null;
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0
        });
    }
    render() {
        this.container.classList.add("lineAnnotation");
        const { data: e1, width: t, height: i } = this, n = this.svgFactory.create(t, i, !0), a = this.#jo = this.svgFactory.createElement("svg:line");
        return a.setAttribute("x1", e1.rect[2] - e1.lineCoordinates[0]), a.setAttribute("y1", e1.rect[3] - e1.lineCoordinates[1]), a.setAttribute("x2", e1.rect[2] - e1.lineCoordinates[2]), a.setAttribute("y2", e1.rect[3] - e1.lineCoordinates[3]), a.setAttribute("stroke-width", e1.borderStyle.width || 1), a.setAttribute("stroke", "transparent"), a.setAttribute("fill", "transparent"), n.append(a), this.container.append(n), !e1.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
        return this.#jo;
    }
    addHighlightArea() {
        this.container.classList.add("highlightArea");
    }
}
class SquareAnnotationElement extends AnnotationElement {
    #$o = null;
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0
        });
    }
    render() {
        this.container.classList.add("squareAnnotation");
        const { data: e1, width: t, height: i } = this, n = this.svgFactory.create(t, i, !0), a = e1.borderStyle.width, s = this.#$o = this.svgFactory.createElement("svg:rect");
        return s.setAttribute("x", a / 2), s.setAttribute("y", a / 2), s.setAttribute("width", t - a), s.setAttribute("height", i - a), s.setAttribute("stroke-width", a || 1), s.setAttribute("stroke", "transparent"), s.setAttribute("fill", "transparent"), n.append(s), this.container.append(n), !e1.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
        return this.#$o;
    }
    addHighlightArea() {
        this.container.classList.add("highlightArea");
    }
}
class CircleAnnotationElement extends AnnotationElement {
    #Ho = null;
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0
        });
    }
    render() {
        this.container.classList.add("circleAnnotation");
        const { data: e1, width: t, height: i } = this, n = this.svgFactory.create(t, i, !0), a = e1.borderStyle.width, s = this.#Ho = this.svgFactory.createElement("svg:ellipse");
        return s.setAttribute("cx", t / 2), s.setAttribute("cy", i / 2), s.setAttribute("rx", t / 2 - a / 2), s.setAttribute("ry", i / 2 - a / 2), s.setAttribute("stroke-width", a || 1), s.setAttribute("stroke", "transparent"), s.setAttribute("fill", "transparent"), n.append(s), this.container.append(n), !e1.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
        return this.#Ho;
    }
    addHighlightArea() {
        this.container.classList.add("highlightArea");
    }
}
class PolylineAnnotationElement extends AnnotationElement {
    #Xo = null;
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0
        }), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
    }
    render() {
        this.container.classList.add(this.containerClassName);
        const { data: { rect: e1, vertices: t, borderStyle: i, popupRef: n }, width: a, height: s } = this;
        if (!t) return this.container;
        const r = this.svgFactory.create(a, s, !0);
        let o = [];
        for(let i = 0, n = t.length; i < n; i += 2){
            const n = t[i] - e1[0], a = e1[3] - t[i + 1];
            o.push(`${n},${a}`);
        }
        o = o.join(" ");
        const l = this.#Xo = this.svgFactory.createElement(this.svgElementName);
        return l.setAttribute("points", o), l.setAttribute("stroke-width", i.width || 1), l.setAttribute("stroke", "transparent"), l.setAttribute("fill", "transparent"), r.append(l), this.container.append(r), !n && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
        return this.#Xo;
    }
    addHighlightArea() {
        this.container.classList.add("highlightArea");
    }
}
class PolygonAnnotationElement extends PolylineAnnotationElement {
    constructor(e1){
        super(e1), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
    }
}
class CaretAnnotationElement extends AnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0
        });
    }
    render() {
        return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
}
class InkAnnotationElement extends AnnotationElement {
    #qo = null;
    #zo = [];
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0
        }), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = "InkHighlight" === this.data.it ? Hl.HIGHLIGHT : Hl.INK;
    }
    #Wo(e1, t) {
        switch(e1){
            case 90:
                return {
                    transform: `rotate(90) translate(${-t[0]},${t[1]}) scale(1,-1)`,
                    width: t[3] - t[1],
                    height: t[2] - t[0]
                };
            case 180:
                return {
                    transform: `rotate(180) translate(${-t[2]},${t[1]}) scale(1,-1)`,
                    width: t[2] - t[0],
                    height: t[3] - t[1]
                };
            case 270:
                return {
                    transform: `rotate(270) translate(${-t[2]},${t[3]}) scale(1,-1)`,
                    width: t[3] - t[1],
                    height: t[2] - t[0]
                };
            default:
                return {
                    transform: `translate(${-t[0]},${t[3]}) scale(1,-1)`,
                    width: t[2] - t[0],
                    height: t[3] - t[1]
                };
        }
    }
    render() {
        this.container.classList.add(this.containerClassName);
        const { data: { rect: e1, rotation: t, inkLists: i, borderStyle: n, popupRef: a } } = this, { transform: s, width: r, height: o } = this.#Wo(t, e1), l = this.svgFactory.create(r, o, !0), c = this.#qo = this.svgFactory.createElement("svg:g");
        l.append(c), c.setAttribute("stroke-width", n.width || 1), c.setAttribute("stroke-linecap", "round"), c.setAttribute("stroke-linejoin", "round"), c.setAttribute("stroke-miterlimit", 10), c.setAttribute("stroke", "transparent"), c.setAttribute("fill", "transparent"), c.setAttribute("transform", s);
        for(let e1 = 0, t = i.length; e1 < t; e1++){
            const t = this.svgFactory.createElement(this.svgElementName);
            this.#zo.push(t), t.setAttribute("points", i[e1].join(",")), c.append(t);
        }
        return !a && this.hasPopupData && this._createPopup(), this.container.append(l), this._editOnDoubleClick(), this.container;
    }
    updateEdited(e1) {
        super.updateEdited(e1);
        const { thickness: t, points: i, rect: n } = e1, a = this.#qo;
        if (t >= 0 && a.setAttribute("stroke-width", t || 1), i) for(let e1 = 0, t = this.#zo.length; e1 < t; e1++)this.#zo[e1].setAttribute("points", i[e1].join(","));
        if (n) {
            const { transform: e1, width: t, height: i } = this.#Wo(this.data.rotation, n);
            a.parentElement.setAttribute("viewBox", `0 0 ${t} ${i}`), a.setAttribute("transform", e1);
        }
    }
    getElementsToTriggerPopup() {
        return this.#zo;
    }
    addHighlightArea() {
        this.container.classList.add("highlightArea");
    }
}
class HighlightAnnotationElement extends AnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0,
            createQuadrilaterals: !0
        }), this.annotationEditorType = Hl.HIGHLIGHT;
    }
    render() {
        const { data: { overlaidText: e1, popupRef: t } } = this;
        if (!t && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this._editOnDoubleClick(), e1) {
            const t = document.createElement("mark");
            t.classList.add("overlaidText"), t.textContent = e1, this.container.append(t);
        }
        return this.container;
    }
}
class UnderlineAnnotationElement extends AnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0,
            createQuadrilaterals: !0
        });
    }
    render() {
        const { data: { overlaidText: e1, popupRef: t } } = this;
        if (!t && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), e1) {
            const t = document.createElement("u");
            t.classList.add("overlaidText"), t.textContent = e1, this.container.append(t);
        }
        return this.container;
    }
}
class SquigglyAnnotationElement extends AnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0,
            createQuadrilaterals: !0
        });
    }
    render() {
        const { data: { overlaidText: e1, popupRef: t } } = this;
        if (!t && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), e1) {
            const t = document.createElement("u");
            t.classList.add("overlaidText"), t.textContent = e1, this.container.append(t);
        }
        return this.container;
    }
}
class StrikeOutAnnotationElement extends AnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0,
            createQuadrilaterals: !0
        });
    }
    render() {
        const { data: { overlaidText: e1, popupRef: t } } = this;
        if (!t && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), e1) {
            const t = document.createElement("s");
            t.classList.add("overlaidText"), t.textContent = e1, this.container.append(t);
        }
        return this.container;
    }
}
class StampAnnotationElement extends AnnotationElement {
    constructor(e1){
        super(e1, {
            isRenderable: !0,
            ignoreBorder: !0
        }), this.annotationEditorType = Hl.STAMP;
    }
    render() {
        return this.container.classList.add("stampAnnotation"), this.container.setAttribute("role", "img"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
    }
}
class FileAttachmentAnnotationElement extends AnnotationElement {
    #Go = null;
    constructor(e1){
        super(e1, {
            isRenderable: !0
        });
        const { file: t } = this.data;
        this.filename = t.filename, this.content = t.content, this.linkService.eventBus?.dispatch("fileattachmentannotation", {
            source: this,
            ...t
        });
    }
    render() {
        this.container.classList.add("fileAttachmentAnnotation");
        const { container: e1, data: t } = this;
        let i;
        t.hasAppearance || 0 === t.fillAlpha ? i = document.createElement("div") : (i = document.createElement("img"), i.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(t.name) ? "paperclip" : "pushpin"}.svg`, t.fillAlpha && t.fillAlpha < 1 && (i.style = `filter: opacity(${Math.round(100 * t.fillAlpha)}%);`)), i.addEventListener("dblclick", this.#Vo.bind(this)), this.#Go = i;
        const { isMac: n } = util_FeatureTest.platform;
        return e1.addEventListener("keydown", (e1)=>{
            "Enter" === e1.key && (n ? e1.metaKey : e1.ctrlKey) && this.#Vo();
        }), !t.popupRef && this.hasPopupData ? this._createPopup() : i.classList.add("popupTriggerArea"), e1.append(i), e1;
    }
    getElementsToTriggerPopup() {
        return this.#Go;
    }
    addHighlightArea() {
        this.container.classList.add("highlightArea");
    }
    #Vo() {
        this.downloadManager?.openOrDownloadData(this.content, this.filename);
    }
}
class AnnotationLayer {
    #Ko = null;
    #Yo = null;
    #zt = null;
    #Jo = new Map;
    #Zo = null;
    #Qo = null;
    constructor({ div: e1, accessibilityManager: t, annotationCanvasMap: i, annotationEditorUIManager: n, page: a, viewport: s, structTreeLayer: r, commentManager: o, linkService: l, annotationStorage: c }){
        this.div = e1, this.#Ko = t, this.#Yo = i, this.#Zo = r || null, this.#Qo = l || null, this.#zt = c || new AnnotationStorage, this.page = a, this.viewport = s, this.zIndex = 0, this._annotationEditorUIManager = n, this._commentManager = o || null;
    }
    hasEditableAnnotations() {
        return this.#Jo.size > 0;
    }
    async #el(e1, t, i) {
        const n = e1.firstChild || e1, a = n.id = `${mc}${t}`, s = await this.#Zo?.getAriaAttributes(a);
        if (s) for (const [e1, t] of s)n.setAttribute(e1, t);
        i ? i.at(-1).container.after(e1) : (this.div.append(e1), this.#Ko?.moveElementInDOM(this.div, e1, n, !1));
    }
    async render(e1) {
        const { annotations: t } = e1, i = this.div;
        setLayerDimensions(i, this.viewport);
        const n = new Map, a = {
            data: null,
            layer: i,
            linkService: this.#Qo,
            downloadManager: e1.downloadManager,
            imageResourcesPath: e1.imageResourcesPath || "",
            renderForms: !1 !== e1.renderForms,
            svgFactory: new DOMSVGFactory,
            annotationStorage: this.#zt,
            enableComment: !0 === e1.enableComment,
            enableScripting: !0 === e1.enableScripting,
            hasJSActions: e1.hasJSActions,
            fieldObjects: e1.fieldObjects,
            parent: this,
            elements: null
        };
        for (const e1 of t){
            if (e1.noHTML) continue;
            const t = e1.annotationType === Zl.POPUP;
            if (t) {
                const t = n.get(e1.id);
                if (!t) continue;
                a.elements = t;
            } else if (e1.rect[2] === e1.rect[0] || e1.rect[3] === e1.rect[1]) continue;
            a.data = e1;
            const i = AnnotationElementFactory.create(a);
            if (!i.isRenderable) continue;
            if (!t && e1.popupRef) {
                const t = n.get(e1.popupRef);
                t ? t.push(i) : n.set(e1.popupRef, [
                    i
                ]);
            }
            const s = i.render();
            e1.hidden && (s.style.visibility = "hidden"), await this.#el(s, e1.id, a.elements), i.extraPopupElement?.popup?.renderCommentButton(), i._isEditable && (this.#Jo.set(i.data.id, i), this._annotationEditorUIManager?.renderAnnotationElement(i));
        }
        this.#tl();
    }
    async addLinkAnnotations(e1) {
        const t = {
            data: null,
            layer: this.div,
            linkService: this.#Qo,
            svgFactory: new DOMSVGFactory,
            parent: this
        };
        for (const i of e1){
            i.borderStyle ||= AnnotationLayer._defaultBorderStyle, t.data = i;
            const e1 = AnnotationElementFactory.create(t);
            if (!e1.isRenderable) continue;
            const n = e1.render();
            await this.#el(n, i.id, null);
        }
    }
    update({ viewport: e1 }) {
        const t = this.div;
        this.viewport = e1, setLayerDimensions(t, {
            rotation: e1.rotation
        }), this.#tl(), t.hidden = !1;
    }
    #tl() {
        if (!this.#Yo) return;
        const e1 = this.div;
        for (const [t, i] of this.#Yo){
            const n = e1.querySelector(`[data-annotation-id="${t}"]`);
            if (!n) continue;
            i.className = "annotationContent";
            const { firstChild: a } = n;
            a ? "CANVAS" === a.nodeName ? a.replaceWith(i) : a.classList.contains("annotationContent") ? a.after(i) : a.before(i) : n.append(i);
            const s = this.#Jo.get(t);
            s && (s._hasNoCanvas ? (this._annotationEditorUIManager?.setMissingCanvas(t, n.id, i), s._hasNoCanvas = !1) : s.canvas = i);
        }
        this.#Yo.clear();
    }
    getEditableAnnotations() {
        return Array.from(this.#Jo.values());
    }
    getEditableAnnotation(e1) {
        return this.#Jo.get(e1);
    }
    addFakeAnnotation(e1) {
        const { div: t } = this, { id: i, rotation: n } = e1, a = new EditorAnnotationElement({
            data: {
                id: i,
                rect: e1.getPDFRect(),
                rotation: n
            },
            editor: e1,
            layer: t,
            parent: this,
            enableComment: !!this._commentManager,
            linkService: this.#Qo,
            annotationStorage: this.#zt
        }), s = a.render();
        return t.append(s), this.#Ko?.moveElementInDOM(t, s, s, !1), a.createOrUpdatePopup(), a;
    }
    static get _defaultBorderStyle() {
        return shadow(this, "_defaultBorderStyle", Object.freeze({
            width: 1,
            rawWidth: 1,
            style: Ql,
            dashArray: [
                3
            ],
            horizontalCornerRadius: 0,
            verticalCornerRadius: 0
        }));
    }
}
const gh = /\r\n?|\n/g;
class FreeTextEditor extends AnnotationEditor {
    #il = "";
    #nl = `${this.id}-editor`;
    #al = null;
    #Bo;
    _colorPicker = null;
    static _freeTextDefaultContent = "";
    static _internalPadding = 0;
    static _defaultColor = null;
    static _defaultFontSize = 10;
    static get _keyboardManager() {
        const e1 = FreeTextEditor.prototype, arrowChecker = (e1)=>e1.isEmpty(), t = AnnotationEditorUIManager.TRANSLATE_SMALL, i = AnnotationEditorUIManager.TRANSLATE_BIG;
        return shadow(this, "_keyboardManager", new KeyboardManager([
            [
                [
                    "ctrl+s",
                    "mac+meta+s",
                    "ctrl+p",
                    "mac+meta+p"
                ],
                e1.commitOrRemove,
                {
                    bubbles: !0
                }
            ],
            [
                [
                    "ctrl+Enter",
                    "mac+meta+Enter",
                    "Escape",
                    "mac+Escape"
                ],
                e1.commitOrRemove
            ],
            [
                [
                    "ArrowLeft",
                    "mac+ArrowLeft"
                ],
                e1._translateEmpty,
                {
                    args: [
                        -t,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowLeft",
                    "mac+shift+ArrowLeft"
                ],
                e1._translateEmpty,
                {
                    args: [
                        -i,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ArrowRight",
                    "mac+ArrowRight"
                ],
                e1._translateEmpty,
                {
                    args: [
                        t,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowRight",
                    "mac+shift+ArrowRight"
                ],
                e1._translateEmpty,
                {
                    args: [
                        i,
                        0
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ArrowUp",
                    "mac+ArrowUp"
                ],
                e1._translateEmpty,
                {
                    args: [
                        0,
                        -t
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowUp",
                    "mac+shift+ArrowUp"
                ],
                e1._translateEmpty,
                {
                    args: [
                        0,
                        -i
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ArrowDown",
                    "mac+ArrowDown"
                ],
                e1._translateEmpty,
                {
                    args: [
                        0,
                        t
                    ],
                    checker: arrowChecker
                }
            ],
            [
                [
                    "ctrl+ArrowDown",
                    "mac+shift+ArrowDown"
                ],
                e1._translateEmpty,
                {
                    args: [
                        0,
                        i
                    ],
                    checker: arrowChecker
                }
            ]
        ]));
    }
    static _type = "freetext";
    static _editorType = Hl.FREETEXT;
    constructor(e1){
        super({
            ...e1,
            name: "freeTextEditor"
        }), this.color = e1.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor, this.#Bo = e1.fontSize || FreeTextEditor._defaultFontSize, this.annotationElementId || this._uiManager.a11yAlert("pdfjs-editor-freetext-added-alert");
    }
    static initialize(e1, t) {
        AnnotationEditor.initialize(e1, t);
        const i = getComputedStyle(document.documentElement);
        this._internalPadding = parseFloat(i.getPropertyValue("--freetext-padding"));
    }
    static updateDefaultParams(e1, t) {
        switch(e1){
            case Xl.FREETEXT_SIZE:
                FreeTextEditor._defaultFontSize = t;
                break;
            case Xl.FREETEXT_COLOR:
                FreeTextEditor._defaultColor = t;
        }
    }
    updateParams(e1, t) {
        switch(e1){
            case Xl.FREETEXT_SIZE:
                this.#sl(t);
                break;
            case Xl.FREETEXT_COLOR:
                this.#_o(t);
        }
    }
    static get defaultPropertiesToUpdate() {
        return [
            [
                Xl.FREETEXT_SIZE,
                FreeTextEditor._defaultFontSize
            ],
            [
                Xl.FREETEXT_COLOR,
                FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor
            ]
        ];
    }
    get propertiesToUpdate() {
        return [
            [
                Xl.FREETEXT_SIZE,
                this.#Bo
            ],
            [
                Xl.FREETEXT_COLOR,
                this.color
            ]
        ];
    }
    get toolbarButtons() {
        return this._colorPicker ||= new BasicColorPicker(this), [
            [
                "colorPicker",
                this._colorPicker
            ]
        ];
    }
    get colorType() {
        return Xl.FREETEXT_COLOR;
    }
    #sl(e1) {
        const setFontsize = (e1)=>{
            this.editorDiv.style.fontSize = `calc(${e1}px * var(--total-scale-factor))`, this.translate(0, -(e1 - this.#Bo) * this.parentScale), this.#Bo = e1, this.#rl();
        }, t = this.#Bo;
        this.addCommands({
            cmd: setFontsize.bind(this, e1),
            undo: setFontsize.bind(this, t),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: !0,
            type: Xl.FREETEXT_SIZE,
            overwriteIfSameType: !0,
            keepUndo: !0
        });
    }
    onUpdatedColor() {
        this.editorDiv.style.color = this.color, this._colorPicker?.update(this.color), super.onUpdatedColor();
    }
    #_o(e1) {
        const setColor = (e1)=>{
            this.color = e1, this.onUpdatedColor();
        }, t = this.color;
        this.addCommands({
            cmd: setColor.bind(this, e1),
            undo: setColor.bind(this, t),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: !0,
            type: Xl.FREETEXT_COLOR,
            overwriteIfSameType: !0,
            keepUndo: !0
        });
    }
    _translateEmpty(e1, t) {
        this._uiManager.translateSelectedEditors(e1, t, !0);
    }
    getInitialTranslation() {
        const e1 = this.parentScale;
        return [
            -FreeTextEditor._internalPadding * e1,
            -(FreeTextEditor._internalPadding + this.#Bo) * e1
        ];
    }
    rebuild() {
        this.parent && (super.rebuild(), null !== this.div && (this.isAttachedToDOM || this.parent.add(this)));
    }
    enableEditMode() {
        if (!super.enableEditMode()) return !1;
        this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.#al = new AbortController;
        const e1 = this._uiManager.combinedSignal(this.#al);
        return this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
            signal: e1
        }), this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
            signal: e1
        }), this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
            signal: e1
        }), this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
            signal: e1
        }), this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
            signal: e1
        }), !0;
    }
    disableEditMode() {
        return !!super.disableEditMode() && (this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", this.#nl), this._isDraggable = !0, this.#al?.abort(), this.#al = null, this.div.focus({
            preventScroll: !0
        }), this.isEditing = !1, this.parent.div.classList.add("freetextEditing"), !0);
    }
    focusin(e1) {
        this._focusEventsAllowed && (super.focusin(e1), e1.target !== this.editorDiv && this.editorDiv.focus());
    }
    onceAdded(e1) {
        this.width || (this.enableEditMode(), e1 && this.editorDiv.focus(), this._initialOptions?.isCentered && this.center(), this._initialOptions = null);
    }
    isEmpty() {
        return !this.editorDiv || "" === this.editorDiv.innerText.trim();
    }
    remove() {
        this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freetextEditing")), super.remove();
    }
    #ol() {
        const e1 = [];
        this.editorDiv.normalize();
        let t = null;
        for (const i of this.editorDiv.childNodes)t?.nodeType === Node.TEXT_NODE && "BR" === i.nodeName || (e1.push(FreeTextEditor.#ll(i)), t = i);
        return e1.join("\n");
    }
    #rl() {
        const [e1, t] = this.parentDimensions;
        let i;
        if (this.isAttachedToDOM) i = this.div.getBoundingClientRect();
        else {
            const { currentLayer: e1, div: t } = this, n = t.style.display, a = t.classList.contains("hidden");
            t.classList.remove("hidden"), t.style.display = "hidden", e1.div.append(this.div), i = t.getBoundingClientRect(), t.remove(), t.style.display = n, t.classList.toggle("hidden", a);
        }
        this.rotation % 180 == this.parentRotation % 180 ? (this.width = i.width / e1, this.height = i.height / t) : (this.width = i.height / e1, this.height = i.width / t), this.fixAndSetPosition();
    }
    commit() {
        if (!this.isInEditMode()) return;
        super.commit(), this.disableEditMode();
        const e1 = this.#il, t = this.#il = this.#ol().trimEnd();
        if (e1 === t) return;
        const setText = (e1)=>{
            this.#il = e1, e1 ? (this.#cl(), this._uiManager.rebuild(this), this.#rl()) : this.remove();
        };
        this.addCommands({
            cmd: ()=>{
                setText(t);
            },
            undo: ()=>{
                setText(e1);
            },
            mustExec: !1
        }), this.#rl();
    }
    shouldGetKeyboardEvents() {
        return this.isInEditMode();
    }
    enterInEditMode() {
        this.enableEditMode(), this.editorDiv.focus();
    }
    keydown(e1) {
        e1.target === this.div && "Enter" === e1.key && (this.enterInEditMode(), e1.preventDefault());
    }
    editorDivKeydown(e1) {
        FreeTextEditor._keyboardManager.exec(this, e1);
    }
    editorDivFocus(e1) {
        this.isEditing = !0;
    }
    editorDivBlur(e1) {
        this.isEditing = !1;
    }
    editorDivInput(e1) {
        this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
    }
    disableEditing() {
        this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
    }
    enableEditing() {
        this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
    }
    get canChangeContent() {
        return !0;
    }
    render() {
        if (this.div) return this.div;
        let e1, t;
        (this._isCopy || this.annotationElementId) && (e1 = this.x, t = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", this.#nl), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2"), this.editorDiv.setAttribute("data-l10n-attrs", "default-content"), this.enableEditing(), this.editorDiv.contentEditable = !0;
        const { style: i } = this.editorDiv;
        if (i.fontSize = `calc(${this.#Bo}px * var(--total-scale-factor))`, i.color = this.color, this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), this._isCopy || this.annotationElementId) {
            const [i, n] = this.parentDimensions;
            if (this.annotationElementId) {
                const { position: a } = this._initialData;
                let [s, r] = this.getInitialTranslation();
                [s, r] = this.pageTranslationToScreen(s, r);
                const [o, l] = this.pageDimensions, [c, h] = this.pageTranslation;
                let d, u;
                switch(this.rotation){
                    case 0:
                        d = e1 + (a[0] - c) / o, u = t + this.height - (a[1] - h) / l;
                        break;
                    case 90:
                        d = e1 + (a[0] - c) / o, u = t - (a[1] - h) / l, [s, r] = [
                            r,
                            -s
                        ];
                        break;
                    case 180:
                        d = e1 - this.width + (a[0] - c) / o, u = t - (a[1] - h) / l, [s, r] = [
                            -s,
                            -r
                        ];
                        break;
                    case 270:
                        d = e1 + (a[0] - c - this.height * l) / o, u = t + (a[1] - h - this.width * o) / l, [s, r] = [
                            -r,
                            s
                        ];
                }
                this.setAt(d * i, u * n, s, r);
            } else this._moveAfterPaste(e1, t);
            this.#cl(), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
        } else this._isDraggable = !1, this.editorDiv.contentEditable = !0;
        return this.div;
    }
    static #ll(e1) {
        return (e1.nodeType === Node.TEXT_NODE ? e1.nodeValue : e1.innerText).replaceAll(gh, "");
    }
    editorDivPaste(e1) {
        const t = e1.clipboardData || window.clipboardData, { types: i } = t;
        if (1 === i.length && "text/plain" === i[0]) return;
        e1.preventDefault();
        const n = FreeTextEditor.#hl(t.getData("text") || "").replaceAll(gh, "\n");
        if (!n) return;
        const a = window.getSelection();
        if (!a.rangeCount) return;
        this.editorDiv.normalize(), a.deleteFromDocument();
        const s = a.getRangeAt(0);
        if (!n.includes("\n")) return s.insertNode(document.createTextNode(n)), this.editorDiv.normalize(), void a.collapseToStart();
        const { startContainer: r, startOffset: o } = s, l = [], c = [];
        if (r.nodeType === Node.TEXT_NODE) {
            const e1 = r.parentElement;
            if (c.push(r.nodeValue.slice(o).replaceAll(gh, "")), e1 !== this.editorDiv) {
                let t = l;
                for (const i of this.editorDiv.childNodes)i !== e1 ? t.push(FreeTextEditor.#ll(i)) : t = c;
            }
            l.push(r.nodeValue.slice(0, o).replaceAll(gh, ""));
        } else if (r === this.editorDiv) {
            let e1 = l, t = 0;
            for (const i of this.editorDiv.childNodes)t++ === o && (e1 = c), e1.push(FreeTextEditor.#ll(i));
        }
        this.#il = `${l.join("\n")}${n}${c.join("\n")}`, this.#cl();
        const h = new Range;
        let d = Math.sumPrecise(l.map((e1)=>e1.length));
        for (const { firstChild: e1 } of this.editorDiv.childNodes)if (e1.nodeType === Node.TEXT_NODE) {
            const t = e1.nodeValue.length;
            if (d <= t) {
                h.setStart(e1, d), h.setEnd(e1, d);
                break;
            }
            d -= t;
        }
        a.removeAllRanges(), a.addRange(h);
    }
    #cl() {
        if (this.editorDiv.replaceChildren(), this.#il) for (const e1 of this.#il.split("\n")){
            const t = document.createElement("div");
            t.append(e1 ? document.createTextNode(e1) : document.createElement("br")), this.editorDiv.append(t);
        }
    }
    #dl() {
        return this.#il.replaceAll("Â ", " ");
    }
    static #hl(e1) {
        return e1.replaceAll(" ", "Â ");
    }
    get contentDiv() {
        return this.editorDiv;
    }
    getPDFRect() {
        const e1 = FreeTextEditor._internalPadding * this.parentScale;
        return this.getRect(e1, e1);
    }
    static async deserialize(e1, t, i) {
        let n = null;
        if (e1 instanceof FreeTextAnnotationElement) {
            const { data: { defaultAppearanceData: { fontSize: t, fontColor: i }, rect: a, rotation: s, id: r, popupRef: o, richText: l, contentsObj: c, creationDate: h, modificationDate: d }, textContent: u, textPosition: g, parent: { page: { pageNumber: f } } } = e1;
            if (!u || 0 === u.length) return null;
            n = e1 = {
                annotationType: Hl.FREETEXT,
                color: Array.from(i),
                fontSize: t,
                value: u.join("\n"),
                position: g,
                pageIndex: f - 1,
                rect: a.slice(0),
                rotation: s,
                annotationElementId: r,
                id: r,
                deleted: !1,
                popupRef: o,
                comment: c?.str || null,
                richText: l,
                creationDate: h,
                modificationDate: d
            };
        }
        const a = await super.deserialize(e1, t, i);
        return a.#Bo = e1.fontSize, a.color = Util.makeHexColor(...e1.color), a.#il = FreeTextEditor.#hl(e1.value), a._initialData = n, e1.comment && a.setCommentData(e1), a;
    }
    serialize(e1 = !1) {
        if (this.isEmpty()) return null;
        if (this.deleted) return this.serializeDeleted();
        const t = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.color), i = Object.assign(super.serialize(e1), {
            color: t,
            fontSize: this.#Bo,
            value: this.#dl()
        });
        return this.addComment(i), e1 ? (i.isCopy = !0, i) : this.annotationElementId && !this.#ul(i) ? null : (i.id = this.annotationElementId, i);
    }
    #ul(e1) {
        const { value: t, fontSize: i, color: n, pageIndex: a } = this._initialData;
        return this.hasEditedComment || this._hasBeenMoved || e1.value !== t || e1.fontSize !== i || e1.color.some((e1, t)=>e1 !== n[t]) || e1.pageIndex !== a;
    }
    renderAnnotationElement(e1) {
        const t = super.renderAnnotationElement(e1);
        if (!t) return null;
        const { style: i } = t;
        i.fontSize = `calc(${this.#Bo}px * var(--total-scale-factor))`, i.color = this.color, t.replaceChildren();
        for (const e1 of this.#il.split("\n")){
            const i = document.createElement("div");
            i.append(e1 ? document.createTextNode(e1) : document.createElement("br")), t.append(i);
        }
        return e1.updateEdited({
            rect: this.getPDFRect(),
            popup: this._uiManager.hasCommentManager() || this.hasEditedComment ? this.comment : {
                text: this.#il
            }
        }), t;
    }
    resetAnnotationElement(e1) {
        super.resetAnnotationElement(e1), e1.resetEdited();
    }
}
class Outline {
    static PRECISION = 1e-4;
    toSVGPath() {
        unreachable("Abstract method `toSVGPath` must be implemented.");
    }
    get box() {
        unreachable("Abstract getter `box` must be implemented.");
    }
    serialize(e1, t) {
        unreachable("Abstract method `serialize` must be implemented.");
    }
    static _rescale(e1, t, i, n, a, s) {
        s ||= new Float32Array(e1.length);
        for(let r = 0, o = e1.length; r < o; r += 2)s[r] = t + e1[r] * n, s[r + 1] = i + e1[r + 1] * a;
        return s;
    }
    static _rescaleAndSwap(e1, t, i, n, a, s) {
        s ||= new Float32Array(e1.length);
        for(let r = 0, o = e1.length; r < o; r += 2)s[r] = t + e1[r + 1] * n, s[r + 1] = i + e1[r] * a;
        return s;
    }
    static _translate(e1, t, i, n) {
        n ||= new Float32Array(e1.length);
        for(let a = 0, s = e1.length; a < s; a += 2)n[a] = t + e1[a], n[a + 1] = i + e1[a + 1];
        return n;
    }
    static svgRound(e1) {
        return Math.round(1e4 * e1);
    }
    static _normalizePoint(e1, t, i, n, a) {
        switch(a){
            case 90:
                return [
                    1 - t / i,
                    e1 / n
                ];
            case 180:
                return [
                    1 - e1 / i,
                    1 - t / n
                ];
            case 270:
                return [
                    t / i,
                    1 - e1 / n
                ];
            default:
                return [
                    e1 / i,
                    t / n
                ];
        }
    }
    static _normalizePagePoint(e1, t, i) {
        switch(i){
            case 90:
                return [
                    1 - t,
                    e1
                ];
            case 180:
                return [
                    1 - e1,
                    1 - t
                ];
            case 270:
                return [
                    t,
                    1 - e1
                ];
            default:
                return [
                    e1,
                    t
                ];
        }
    }
    static createBezierPoints(e1, t, i, n, a, s) {
        return [
            (e1 + 5 * i) / 6,
            (t + 5 * n) / 6,
            (5 * i + a) / 6,
            (5 * n + s) / 6,
            (i + a) / 2,
            (n + s) / 2
        ];
    }
}
class FreeDrawOutliner {
    #gl;
    #fl = [];
    #pl;
    #ml;
    #bl = [];
    #yl = new Float32Array(18);
    #wl;
    #Al;
    #xl;
    #Sl;
    #vl;
    #Cl;
    #kl = [];
    static #Tl = 8;
    static #Fl = 2;
    static #Il = FreeDrawOutliner.#Tl + FreeDrawOutliner.#Fl;
    constructor({ x: e1, y: t }, i, n, a, s, r = 0){
        this.#gl = i, this.#Cl = a * n, this.#ml = s, this.#yl.set([
            NaN,
            NaN,
            NaN,
            NaN,
            e1,
            t
        ], 6), this.#pl = r, this.#Sl = FreeDrawOutliner.#Tl * n, this.#xl = FreeDrawOutliner.#Il * n, this.#vl = n, this.#kl.push(e1, t);
    }
    isEmpty() {
        return isNaN(this.#yl[8]);
    }
    #El() {
        const e1 = this.#yl.subarray(4, 6), t = this.#yl.subarray(16, 18), [i, n, a, s] = this.#gl;
        return [
            (this.#wl + (e1[0] - t[0]) / 2 - i) / a,
            (this.#Al + (e1[1] - t[1]) / 2 - n) / s,
            (this.#wl + (t[0] - e1[0]) / 2 - i) / a,
            (this.#Al + (t[1] - e1[1]) / 2 - n) / s
        ];
    }
    add({ x: e1, y: t }) {
        this.#wl = e1, this.#Al = t;
        const [i, n, a, s] = this.#gl;
        let [r, o, l, c] = this.#yl.subarray(8, 12);
        const h = e1 - l, d = t - c, u = Math.hypot(h, d);
        if (u < this.#xl) return !1;
        const g = u - this.#Sl, f = g / u, p = f * h, m = f * d;
        let b = r, y = o;
        r = l, o = c, l += p, c += m, this.#kl?.push(e1, t);
        const w = p / g, x = -m / g * this.#Cl, S = w * this.#Cl;
        if (this.#yl.set(this.#yl.subarray(2, 8), 0), this.#yl.set([
            l + x,
            c + S
        ], 4), this.#yl.set(this.#yl.subarray(14, 18), 12), this.#yl.set([
            l - x,
            c - S
        ], 16), isNaN(this.#yl[6])) return 0 === this.#bl.length && (this.#yl.set([
            r + x,
            o + S
        ], 2), this.#bl.push(NaN, NaN, NaN, NaN, (r + x - i) / a, (o + S - n) / s), this.#yl.set([
            r - x,
            o - S
        ], 14), this.#fl.push(NaN, NaN, NaN, NaN, (r - x - i) / a, (o - S - n) / s)), this.#yl.set([
            b,
            y,
            r,
            o,
            l,
            c
        ], 6), !this.isEmpty();
        this.#yl.set([
            b,
            y,
            r,
            o,
            l,
            c
        ], 6);
        return Math.abs(Math.atan2(y - o, b - r) - Math.atan2(m, p)) < Math.PI / 2 ? ([r, o, l, c] = this.#yl.subarray(2, 6), this.#bl.push(NaN, NaN, NaN, NaN, ((r + l) / 2 - i) / a, ((o + c) / 2 - n) / s), [r, o, b, y] = this.#yl.subarray(14, 18), this.#fl.push(NaN, NaN, NaN, NaN, ((b + r) / 2 - i) / a, ((y + o) / 2 - n) / s), !0) : ([b, y, r, o, l, c] = this.#yl.subarray(0, 6), this.#bl.push(((b + 5 * r) / 6 - i) / a, ((y + 5 * o) / 6 - n) / s, ((5 * r + l) / 6 - i) / a, ((5 * o + c) / 6 - n) / s, ((r + l) / 2 - i) / a, ((o + c) / 2 - n) / s), [l, c, r, o, b, y] = this.#yl.subarray(12, 18), this.#fl.push(((b + 5 * r) / 6 - i) / a, ((y + 5 * o) / 6 - n) / s, ((5 * r + l) / 6 - i) / a, ((5 * o + c) / 6 - n) / s, ((r + l) / 2 - i) / a, ((o + c) / 2 - n) / s), !0);
    }
    toSVGPath() {
        if (this.isEmpty()) return "";
        const e1 = this.#bl, t = this.#fl;
        if (isNaN(this.#yl[6]) && !this.isEmpty()) return this.#Ml();
        const i = [];
        i.push(`M${e1[4]} ${e1[5]}`);
        for(let t = 6; t < e1.length; t += 6)isNaN(e1[t]) ? i.push(`L${e1[t + 4]} ${e1[t + 5]}`) : i.push(`C${e1[t]} ${e1[t + 1]} ${e1[t + 2]} ${e1[t + 3]} ${e1[t + 4]} ${e1[t + 5]}`);
        this.#Dl(i);
        for(let e1 = t.length - 6; e1 >= 6; e1 -= 6)isNaN(t[e1]) ? i.push(`L${t[e1 + 4]} ${t[e1 + 5]}`) : i.push(`C${t[e1]} ${t[e1 + 1]} ${t[e1 + 2]} ${t[e1 + 3]} ${t[e1 + 4]} ${t[e1 + 5]}`);
        return this.#Ol(i), i.join(" ");
    }
    #Ml() {
        const [e1, t, i, n] = this.#gl, [a, s, r, o] = this.#El();
        return `M${(this.#yl[2] - e1) / i} ${(this.#yl[3] - t) / n} L${(this.#yl[4] - e1) / i} ${(this.#yl[5] - t) / n} L${a} ${s} L${r} ${o} L${(this.#yl[16] - e1) / i} ${(this.#yl[17] - t) / n} L${(this.#yl[14] - e1) / i} ${(this.#yl[15] - t) / n} Z`;
    }
    #Ol(e1) {
        const t = this.#fl;
        e1.push(`L${t[4]} ${t[5]} Z`);
    }
    #Dl(e1) {
        const [t, i, n, a] = this.#gl, s = this.#yl.subarray(4, 6), r = this.#yl.subarray(16, 18), [o, l, c, h] = this.#El();
        e1.push(`L${(s[0] - t) / n} ${(s[1] - i) / a} L${o} ${l} L${c} ${h} L${(r[0] - t) / n} ${(r[1] - i) / a}`);
    }
    newFreeDrawOutline(e1, t, i, n, a, s) {
        return new FreeDrawOutline(e1, t, i, n, a, s);
    }
    getOutlines() {
        const e1 = this.#bl, t = this.#fl, i = this.#yl, [n, a, s, r] = this.#gl, o = new Float32Array((this.#kl?.length ?? 0) + 2);
        for(let e1 = 0, t = o.length - 2; e1 < t; e1 += 2)o[e1] = (this.#kl[e1] - n) / s, o[e1 + 1] = (this.#kl[e1 + 1] - a) / r;
        if (o[o.length - 2] = (this.#wl - n) / s, o[o.length - 1] = (this.#Al - a) / r, isNaN(i[6]) && !this.isEmpty()) return this.#_l(o);
        const l = new Float32Array(this.#bl.length + 24 + this.#fl.length);
        let c = e1.length;
        for(let t = 0; t < c; t += 2)isNaN(e1[t]) ? l[t] = l[t + 1] = NaN : (l[t] = e1[t], l[t + 1] = e1[t + 1]);
        c = this.#Pl(l, c);
        for(let e1 = t.length - 6; e1 >= 6; e1 -= 6)for(let i = 0; i < 6; i += 2)isNaN(t[e1 + i]) ? (l[c] = l[c + 1] = NaN, c += 2) : (l[c] = t[e1 + i], l[c + 1] = t[e1 + i + 1], c += 2);
        return this.#Rl(l, c), this.newFreeDrawOutline(l, o, this.#gl, this.#vl, this.#pl, this.#ml);
    }
    #_l(e1) {
        const t = this.#yl, [i, n, a, s] = this.#gl, [r, o, l, c] = this.#El(), h = new Float32Array(36);
        return h.set([
            NaN,
            NaN,
            NaN,
            NaN,
            (t[2] - i) / a,
            (t[3] - n) / s,
            NaN,
            NaN,
            NaN,
            NaN,
            (t[4] - i) / a,
            (t[5] - n) / s,
            NaN,
            NaN,
            NaN,
            NaN,
            r,
            o,
            NaN,
            NaN,
            NaN,
            NaN,
            l,
            c,
            NaN,
            NaN,
            NaN,
            NaN,
            (t[16] - i) / a,
            (t[17] - n) / s,
            NaN,
            NaN,
            NaN,
            NaN,
            (t[14] - i) / a,
            (t[15] - n) / s
        ], 0), this.newFreeDrawOutline(h, e1, this.#gl, this.#vl, this.#pl, this.#ml);
    }
    #Rl(e1, t) {
        const i = this.#fl;
        return e1.set([
            NaN,
            NaN,
            NaN,
            NaN,
            i[4],
            i[5]
        ], t), t + 6;
    }
    #Pl(e1, t) {
        const i = this.#yl.subarray(4, 6), n = this.#yl.subarray(16, 18), [a, s, r, o] = this.#gl, [l, c, h, d] = this.#El();
        return e1.set([
            NaN,
            NaN,
            NaN,
            NaN,
            (i[0] - a) / r,
            (i[1] - s) / o,
            NaN,
            NaN,
            NaN,
            NaN,
            l,
            c,
            NaN,
            NaN,
            NaN,
            NaN,
            h,
            d,
            NaN,
            NaN,
            NaN,
            NaN,
            (n[0] - a) / r,
            (n[1] - s) / o
        ], t), t + 24;
    }
}
class FreeDrawOutline extends Outline {
    #gl;
    #Bl = new Float32Array(4);
    #pl;
    #ml;
    #kl;
    #vl;
    #Nl;
    constructor(e1, t, i, n, a, s){
        super(), this.#Nl = e1, this.#kl = t, this.#gl = i, this.#vl = n, this.#pl = a, this.#ml = s, this.firstPoint = [
            NaN,
            NaN
        ], this.lastPoint = [
            NaN,
            NaN
        ], this.#Ll(s);
        const [r, o, l, c] = this.#Bl;
        for(let t = 0, i = e1.length; t < i; t += 2)e1[t] = (e1[t] - r) / l, e1[t + 1] = (e1[t + 1] - o) / c;
        for(let e1 = 0, i = t.length; e1 < i; e1 += 2)t[e1] = (t[e1] - r) / l, t[e1 + 1] = (t[e1 + 1] - o) / c;
    }
    toSVGPath() {
        const e1 = [
            `M${this.#Nl[4]} ${this.#Nl[5]}`
        ];
        for(let t = 6, i = this.#Nl.length; t < i; t += 6)isNaN(this.#Nl[t]) ? e1.push(`L${this.#Nl[t + 4]} ${this.#Nl[t + 5]}`) : e1.push(`C${this.#Nl[t]} ${this.#Nl[t + 1]} ${this.#Nl[t + 2]} ${this.#Nl[t + 3]} ${this.#Nl[t + 4]} ${this.#Nl[t + 5]}`);
        return e1.push("Z"), e1.join(" ");
    }
    serialize([e1, t, i, n], a) {
        const s = i - e1, r = n - t;
        let o, l;
        switch(a){
            case 0:
                o = Outline._rescale(this.#Nl, e1, n, s, -r), l = Outline._rescale(this.#kl, e1, n, s, -r);
                break;
            case 90:
                o = Outline._rescaleAndSwap(this.#Nl, e1, t, s, r), l = Outline._rescaleAndSwap(this.#kl, e1, t, s, r);
                break;
            case 180:
                o = Outline._rescale(this.#Nl, i, t, -s, r), l = Outline._rescale(this.#kl, i, t, -s, r);
                break;
            case 270:
                o = Outline._rescaleAndSwap(this.#Nl, i, n, -s, -r), l = Outline._rescaleAndSwap(this.#kl, i, n, -s, -r);
        }
        return {
            outline: Array.from(o),
            points: [
                Array.from(l)
            ]
        };
    }
    #Ll(e1) {
        const t = this.#Nl;
        let i = t[4], n = t[5];
        const a = [
            i,
            n,
            i,
            n
        ];
        let s = i, r = n, o = i, l = n;
        const c = e1 ? Math.max : Math.min, h = new Float32Array(4);
        for(let e1 = 6, d = t.length; e1 < d; e1 += 6){
            const d = t[e1 + 4], u = t[e1 + 5];
            isNaN(t[e1]) ? (Util.pointBoundingBox(d, u, a), r > u ? (s = d, r = u) : r === u && (s = c(s, d)), l < u ? (o = d, l = u) : l === u && (o = c(o, d))) : (h[0] = h[1] = 1 / 0, h[2] = h[3] = -1 / 0, Util.bezierBoundingBox(i, n, ...t.slice(e1, e1 + 6), h), Util.rectBoundingBox(h[0], h[1], h[2], h[3], a), r > h[1] ? (s = h[0], r = h[1]) : r === h[1] && (s = c(s, h[0])), l < h[3] ? (o = h[2], l = h[3]) : l === h[3] && (o = c(o, h[2]))), i = d, n = u;
        }
        const d = this.#Bl;
        d[0] = a[0] - this.#pl, d[1] = a[1] - this.#pl, d[2] = a[2] - a[0] + 2 * this.#pl, d[3] = a[3] - a[1] + 2 * this.#pl, this.firstPoint = [
            s,
            r
        ], this.lastPoint = [
            o,
            l
        ];
    }
    get box() {
        return this.#Bl;
    }
    newOutliner(e1, t, i, n, a, s = 0) {
        return new FreeDrawOutliner(e1, t, i, n, a, s);
    }
    getNewOutline(e1, t) {
        const [i, n, a, s] = this.#Bl, [r, o, l, c] = this.#gl, h = a * l, d = s * c, u = i * l + r, g = n * c + o, f = this.newOutliner({
            x: this.#kl[0] * h + u,
            y: this.#kl[1] * d + g
        }, this.#gl, this.#vl, e1, this.#ml, t ?? this.#pl);
        for(let e1 = 2; e1 < this.#kl.length; e1 += 2)f.add({
            x: this.#kl[e1] * h + u,
            y: this.#kl[e1 + 1] * d + g
        });
        return f.getOutlines();
    }
}
class HighlightOutliner {
    #gl;
    #Ul;
    #jl;
    #$l = [];
    #Hl = [];
    constructor(e1, t = 0, i = 0, n = !0){
        const a = [
            1 / 0,
            1 / 0,
            -1 / 0,
            -1 / 0
        ], s = 1e-4;
        for (const { x: i, y: n, width: r, height: o } of e1){
            const e1 = Math.floor((i - t) / s) * s, l = Math.ceil((i + r + t) / s) * s, c = Math.floor((n - t) / s) * s, h = Math.ceil((n + o + t) / s) * s, d = [
                e1,
                c,
                h,
                !0
            ], u = [
                l,
                c,
                h,
                !1
            ];
            this.#$l.push(d, u), Util.rectBoundingBox(e1, c, l, h, a);
        }
        const r = a[2] - a[0] + 2 * i, o = a[3] - a[1] + 2 * i, l = a[0] - i, c = a[1] - i;
        let h = n ? -1 / 0 : 1 / 0, d = 1 / 0;
        const u = this.#$l.at(n ? -1 : -2), g = [
            u[0],
            u[2]
        ];
        for (const e1 of this.#$l){
            const [t, i, a, s] = e1;
            !s && n ? i < d ? (d = i, h = t) : i === d && (h = Math.max(h, t)) : s && !n && (i < d ? (d = i, h = t) : i === d && (h = Math.min(h, t))), e1[0] = (t - l) / r, e1[1] = (i - c) / o, e1[2] = (a - c) / o;
        }
        this.#gl = new Float32Array([
            l,
            c,
            r,
            o
        ]), this.#Ul = [
            h,
            d
        ], this.#jl = g;
    }
    getOutlines() {
        this.#$l.sort((e1, t)=>e1[0] - t[0] || e1[1] - t[1] || e1[2] - t[2]);
        const e1 = [];
        for (const t of this.#$l)t[3] ? (e1.push(...this.#Xl(t)), this.#ql(t)) : (this.#zl(t), e1.push(...this.#Xl(t)));
        return this.#Wl(e1);
    }
    #Wl(e1) {
        const t = [], i = new Set;
        for (const i of e1){
            const [e1, n, a] = i;
            t.push([
                e1,
                n,
                i
            ], [
                e1,
                a,
                i
            ]);
        }
        t.sort((e1, t)=>e1[1] - t[1] || e1[0] - t[0]);
        for(let e1 = 0, n = t.length; e1 < n; e1 += 2){
            const n = t[e1][2], a = t[e1 + 1][2];
            n.push(a), a.push(n), i.add(n), i.add(a);
        }
        const n = [];
        let a;
        for(; i.size > 0;){
            const e1 = i.values().next().value;
            let [t, s, r, o, l] = e1;
            i.delete(e1);
            let c = t, h = s;
            for(a = [
                t,
                r
            ], n.push(a);;){
                let e1;
                if (i.has(o)) e1 = o;
                else {
                    if (!i.has(l)) break;
                    e1 = l;
                }
                i.delete(e1), [t, s, r, o, l] = e1, c !== t && (a.push(c, h, t, h === s ? s : r), c = t), h = h === s ? r : s;
            }
            a.push(c, h);
        }
        return new HighlightOutline(n, this.#gl, this.#Ul, this.#jl);
    }
    #Gl(e1) {
        const t = this.#Hl;
        let i = 0, n = t.length - 1;
        for(; i <= n;){
            const a = i + n >> 1, s = t[a][0];
            if (s === e1) return a;
            s < e1 ? i = a + 1 : n = a - 1;
        }
        return n + 1;
    }
    #ql([, e1, t]) {
        const i = this.#Gl(e1);
        this.#Hl.splice(i, 0, [
            e1,
            t
        ]);
    }
    #zl([, e1, t]) {
        const i = this.#Gl(e1);
        for(let n = i; n < this.#Hl.length; n++){
            const [i, a] = this.#Hl[n];
            if (i !== e1) break;
            if (i === e1 && a === t) return void this.#Hl.splice(n, 1);
        }
        for(let n = i - 1; n >= 0; n--){
            const [i, a] = this.#Hl[n];
            if (i !== e1) break;
            if (i === e1 && a === t) return void this.#Hl.splice(n, 1);
        }
    }
    #Xl(e1) {
        const [t, i, n] = e1, a = [
            [
                t,
                i,
                n
            ]
        ], s = this.#Gl(n);
        for(let e1 = 0; e1 < s; e1++){
            const [i, n] = this.#Hl[e1];
            for(let e1 = 0, s = a.length; e1 < s; e1++){
                const [, r, o] = a[e1];
                if (!(n <= r || o <= i)) if (r >= i) if (o > n) a[e1][1] = n;
                else {
                    if (1 === s) return [];
                    a.splice(e1, 1), e1--, s--;
                }
                else a[e1][2] = i, o > n && a.push([
                    t,
                    n,
                    o
                ]);
            }
        }
        return a;
    }
}
class HighlightOutline extends Outline {
    #gl;
    #Vl;
    constructor(e1, t, i, n){
        super(), this.#Vl = e1, this.#gl = t, this.firstPoint = i, this.lastPoint = n;
    }
    toSVGPath() {
        const e1 = [];
        for (const t of this.#Vl){
            let [i, n] = t;
            e1.push(`M${i} ${n}`);
            for(let a = 2; a < t.length; a += 2){
                const s = t[a], r = t[a + 1];
                s === i ? (e1.push(`V${r}`), n = r) : r === n && (e1.push(`H${s}`), i = s);
            }
            e1.push("Z");
        }
        return e1.join(" ");
    }
    serialize([e1, t, i, n], a) {
        const s = [], r = i - e1, o = n - t;
        for (const t of this.#Vl){
            const i = new Array(t.length);
            for(let a = 0; a < t.length; a += 2)i[a] = e1 + t[a] * r, i[a + 1] = n - t[a + 1] * o;
            s.push(i);
        }
        return s;
    }
    get box() {
        return this.#gl;
    }
    get classNamesForOutlining() {
        return [
            "highlightOutline"
        ];
    }
}
class FreeHighlightOutliner extends FreeDrawOutliner {
    newFreeDrawOutline(e1, t, i, n, a, s) {
        return new FreeHighlightOutline(e1, t, i, n, a, s);
    }
}
class FreeHighlightOutline extends FreeDrawOutline {
    newOutliner(e1, t, i, n, a, s = 0) {
        return new FreeHighlightOutliner(e1, t, i, n, a, s);
    }
}
class HighlightEditor extends AnnotationEditor {
    #Kl = null;
    #Yl = 0;
    #Jl;
    #Zl = null;
    #gt = null;
    #Ql = null;
    #ec = null;
    #tc = 0;
    #ic = null;
    #nc = null;
    #Mt = null;
    #ac = !1;
    #Ul = null;
    #jl = null;
    #sc = null;
    #_e = "";
    #Cl;
    #rc = "";
    static _defaultColor = null;
    static _defaultOpacity = 1;
    static _defaultThickness = 12;
    static _type = "highlight";
    static _editorType = Hl.HIGHLIGHT;
    static _freeHighlightId = -1;
    static _freeHighlight = null;
    static _freeHighlightClipId = "";
    static get _keyboardManager() {
        const e1 = HighlightEditor.prototype;
        return shadow(this, "_keyboardManager", new KeyboardManager([
            [
                [
                    "ArrowLeft",
                    "mac+ArrowLeft"
                ],
                e1._moveCaret,
                {
                    args: [
                        0
                    ]
                }
            ],
            [
                [
                    "ArrowRight",
                    "mac+ArrowRight"
                ],
                e1._moveCaret,
                {
                    args: [
                        1
                    ]
                }
            ],
            [
                [
                    "ArrowUp",
                    "mac+ArrowUp"
                ],
                e1._moveCaret,
                {
                    args: [
                        2
                    ]
                }
            ],
            [
                [
                    "ArrowDown",
                    "mac+ArrowDown"
                ],
                e1._moveCaret,
                {
                    args: [
                        3
                    ]
                }
            ]
        ]));
    }
    constructor(e1){
        super({
            ...e1,
            name: "highlightEditor"
        }), this.color = e1.color || HighlightEditor._defaultColor, this.#Cl = e1.thickness || HighlightEditor._defaultThickness, this.opacity = e1.opacity || HighlightEditor._defaultOpacity, this.#Jl = e1.boxes || null, this.#rc = e1.methodOfCreation || "", this.#_e = e1.text || "", this._isDraggable = !1, this.defaultL10nId = "pdfjs-editor-highlight-editor", e1.highlightId > -1 ? (this.#ac = !0, this.#oc(e1), this.#lc()) : this.#Jl && (this.#Kl = e1.anchorNode, this.#Yl = e1.anchorOffset, this.#ec = e1.focusNode, this.#tc = e1.focusOffset, this.#cc(), this.#lc(), this.rotate(this.rotation)), this.annotationElementId || this._uiManager.a11yAlert("pdfjs-editor-highlight-added-alert");
    }
    get telemetryInitialData() {
        return {
            action: "added",
            type: this.#ac ? "free_highlight" : "highlight",
            color: this._uiManager.getNonHCMColorName(this.color),
            thickness: this.#Cl,
            methodOfCreation: this.#rc
        };
    }
    get telemetryFinalData() {
        return {
            type: "highlight",
            color: this._uiManager.getNonHCMColorName(this.color)
        };
    }
    static computeTelemetryFinalData(e1) {
        return {
            numberOfColors: e1.get("color").size
        };
    }
    #cc() {
        const e1 = new HighlightOutliner(this.#Jl, .001);
        this.#nc = e1.getOutlines(), [this.x, this.y, this.width, this.height] = this.#nc.box;
        const t = new HighlightOutliner(this.#Jl, .0025, .001, "ltr" === this._uiManager.direction);
        this.#Ql = t.getOutlines();
        const { firstPoint: i } = this.#nc;
        this.#Ul = [
            (i[0] - this.x) / this.width,
            (i[1] - this.y) / this.height
        ];
        const { lastPoint: n } = this.#Ql;
        this.#jl = [
            (n[0] - this.x) / this.width,
            (n[1] - this.y) / this.height
        ];
    }
    #oc({ highlightOutlines: e1, highlightId: t, clipPathId: i }) {
        this.#nc = e1;
        if (this.#Ql = e1.getNewOutline(this.#Cl / 2 + 1.5, .0025), t >= 0) this.#Mt = t, this.#Zl = i, this.parent.drawLayer.finalizeDraw(t, {
            bbox: e1.box,
            path: {
                d: e1.toSVGPath()
            }
        }), this.#sc = this.parent.drawLayer.drawOutline({
            rootClass: {
                highlightOutline: !0,
                free: !0
            },
            bbox: this.#Ql.box,
            path: {
                d: this.#Ql.toSVGPath()
            }
        }, !0);
        else if (this.parent) {
            const t = this.parent.viewport.rotation;
            this.parent.drawLayer.updateProperties(this.#Mt, {
                bbox: HighlightEditor.#hc(this.#nc.box, (t - this.rotation + 360) % 360),
                path: {
                    d: e1.toSVGPath()
                }
            }), this.parent.drawLayer.updateProperties(this.#sc, {
                bbox: HighlightEditor.#hc(this.#Ql.box, t),
                path: {
                    d: this.#Ql.toSVGPath()
                }
            });
        }
        const [n, a, s, r] = e1.box;
        switch(this.rotation){
            case 0:
                this.x = n, this.y = a, this.width = s, this.height = r;
                break;
            case 90:
                {
                    const [e1, t] = this.parentDimensions;
                    this.x = a, this.y = 1 - n, this.width = s * t / e1, this.height = r * e1 / t;
                    break;
                }
            case 180:
                this.x = 1 - n, this.y = 1 - a, this.width = s, this.height = r;
                break;
            case 270:
                {
                    const [e1, t] = this.parentDimensions;
                    this.x = 1 - a, this.y = n, this.width = s * t / e1, this.height = r * e1 / t;
                    break;
                }
        }
        const { firstPoint: o } = e1;
        this.#Ul = [
            (o[0] - n) / s,
            (o[1] - a) / r
        ];
        const { lastPoint: l } = this.#Ql;
        this.#jl = [
            (l[0] - n) / s,
            (l[1] - a) / r
        ];
    }
    static initialize(e1, t) {
        AnnotationEditor.initialize(e1, t), HighlightEditor._defaultColor ||= t.highlightColors?.values().next().value || "#fff066";
    }
    static updateDefaultParams(e1, t) {
        switch(e1){
            case Xl.HIGHLIGHT_COLOR:
                HighlightEditor._defaultColor = t;
                break;
            case Xl.HIGHLIGHT_THICKNESS:
                HighlightEditor._defaultThickness = t;
        }
    }
    translateInPage(e1, t) {}
    get toolbarPosition() {
        return this.#jl;
    }
    get commentButtonPosition() {
        return this.#Ul;
    }
    updateParams(e1, t) {
        switch(e1){
            case Xl.HIGHLIGHT_COLOR:
                this.#_o(t);
                break;
            case Xl.HIGHLIGHT_THICKNESS:
                this.#dc(t);
        }
    }
    static get defaultPropertiesToUpdate() {
        return [
            [
                Xl.HIGHLIGHT_COLOR,
                HighlightEditor._defaultColor
            ],
            [
                Xl.HIGHLIGHT_THICKNESS,
                HighlightEditor._defaultThickness
            ]
        ];
    }
    get propertiesToUpdate() {
        return [
            [
                Xl.HIGHLIGHT_COLOR,
                this.color || HighlightEditor._defaultColor
            ],
            [
                Xl.HIGHLIGHT_THICKNESS,
                this.#Cl || HighlightEditor._defaultThickness
            ],
            [
                Xl.HIGHLIGHT_FREE,
                this.#ac
            ]
        ];
    }
    onUpdatedColor() {
        this.parent?.drawLayer.updateProperties(this.#Mt, {
            root: {
                fill: this.color,
                "fill-opacity": this.opacity
            }
        }), this.#gt?.updateColor(this.color), super.onUpdatedColor();
    }
    #_o(e1) {
        const setColorAndOpacity = (e1, t)=>{
            this.color = e1, this.opacity = t, this.onUpdatedColor();
        }, t = this.color, i = this.opacity;
        this.addCommands({
            cmd: setColorAndOpacity.bind(this, e1, HighlightEditor._defaultOpacity),
            undo: setColorAndOpacity.bind(this, t, i),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: !0,
            type: Xl.HIGHLIGHT_COLOR,
            overwriteIfSameType: !0,
            keepUndo: !0
        }), this._reportTelemetry({
            action: "color_changed",
            color: this._uiManager.getNonHCMColorName(e1)
        }, !0);
    }
    #dc(e1) {
        const t = this.#Cl, setThickness = (e1)=>{
            this.#Cl = e1, this.#uc(e1);
        };
        this.addCommands({
            cmd: setThickness.bind(this, e1),
            undo: setThickness.bind(this, t),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: !0,
            type: Xl.INK_THICKNESS,
            overwriteIfSameType: !0,
            keepUndo: !0
        }), this._reportTelemetry({
            action: "thickness_changed",
            thickness: e1
        }, !0);
    }
    get toolbarButtons() {
        if (this._uiManager.highlightColors) {
            return [
                [
                    "colorPicker",
                    this.#gt = new ColorPicker({
                        editor: this
                    })
                ]
            ];
        }
        return super.toolbarButtons;
    }
    disableEditing() {
        super.disableEditing(), this.div.classList.toggle("disabled", !0);
    }
    enableEditing() {
        super.enableEditing(), this.div.classList.toggle("disabled", !1);
    }
    fixAndSetPosition() {
        return super.fixAndSetPosition(this.#gc());
    }
    getBaseTranslation() {
        return [
            0,
            0
        ];
    }
    getRect(e1, t) {
        return super.getRect(e1, t, this.#gc());
    }
    onceAdded(e1) {
        this.annotationElementId || this.parent.addUndoableEditor(this), e1 && this.div.focus();
    }
    remove() {
        this.#fc(), this._reportTelemetry({
            action: "deleted"
        }), super.remove();
    }
    rebuild() {
        this.parent && (super.rebuild(), null !== this.div && (this.#lc(), this.isAttachedToDOM || this.parent.add(this)));
    }
    setParent(e1) {
        let t = !1;
        this.parent && !e1 ? this.#fc() : e1 && (this.#lc(e1), t = !this.parent && this.div?.classList.contains("selectedEditor")), super.setParent(e1), this.show(this._isVisible), t && this.select();
    }
    #uc(e1) {
        this.#ac && (this.#oc({
            highlightOutlines: this.#nc.getNewOutline(e1 / 2)
        }), this.fixAndSetPosition(), this.setDims(this.width, this.height));
    }
    #fc() {
        null !== this.#Mt && this.parent && (this.parent.drawLayer.remove(this.#Mt), this.#Mt = null, this.parent.drawLayer.remove(this.#sc), this.#sc = null);
    }
    #lc(e1 = this.parent) {
        null === this.#Mt && ({ id: this.#Mt, clipPathId: this.#Zl } = e1.drawLayer.draw({
            bbox: this.#nc.box,
            root: {
                viewBox: "0 0 1 1",
                fill: this.color,
                "fill-opacity": this.opacity
            },
            rootClass: {
                highlight: !0,
                free: this.#ac
            },
            path: {
                d: this.#nc.toSVGPath()
            }
        }, !1, !0), this.#sc = e1.drawLayer.drawOutline({
            rootClass: {
                highlightOutline: !0,
                free: this.#ac
            },
            bbox: this.#Ql.box,
            path: {
                d: this.#Ql.toSVGPath()
            }
        }, this.#ac), this.#ic && (this.#ic.style.clipPath = this.#Zl));
    }
    static #hc([e1, t, i, n], a) {
        switch(a){
            case 90:
                return [
                    1 - t - n,
                    e1,
                    n,
                    i
                ];
            case 180:
                return [
                    1 - e1 - i,
                    1 - t - n,
                    i,
                    n
                ];
            case 270:
                return [
                    t,
                    1 - e1 - i,
                    n,
                    i
                ];
        }
        return [
            e1,
            t,
            i,
            n
        ];
    }
    rotate(e1) {
        const { drawLayer: t } = this.parent;
        let i;
        this.#ac ? (e1 = (e1 - this.rotation + 360) % 360, i = HighlightEditor.#hc(this.#nc.box, e1)) : i = HighlightEditor.#hc([
            this.x,
            this.y,
            this.width,
            this.height
        ], e1), t.updateProperties(this.#Mt, {
            bbox: i,
            root: {
                "data-main-rotation": e1
            }
        }), t.updateProperties(this.#sc, {
            bbox: HighlightEditor.#hc(this.#Ql.box, e1),
            root: {
                "data-main-rotation": e1
            }
        });
    }
    render() {
        if (this.div) return this.div;
        const e1 = super.render();
        this.#_e && (e1.setAttribute("aria-label", this.#_e), e1.setAttribute("role", "mark")), this.#ac ? e1.classList.add("free") : this.div.addEventListener("keydown", this.#pc.bind(this), {
            signal: this._uiManager._signal
        });
        const t = this.#ic = document.createElement("div");
        return e1.append(t), t.setAttribute("aria-hidden", "true"), t.className = "internal", t.style.clipPath = this.#Zl, this.setDims(this.width, this.height), bindEvents(this, this.#ic, [
            "pointerover",
            "pointerleave"
        ]), this.enableEditing(), e1;
    }
    pointerover() {
        this.isSelected || this.parent?.drawLayer.updateProperties(this.#sc, {
            rootClass: {
                hovered: !0
            }
        });
    }
    pointerleave() {
        this.isSelected || this.parent?.drawLayer.updateProperties(this.#sc, {
            rootClass: {
                hovered: !1
            }
        });
    }
    #pc(e1) {
        HighlightEditor._keyboardManager.exec(this, e1);
    }
    _moveCaret(e1) {
        switch(this.parent.unselect(this), e1){
            case 0:
            case 2:
                this.#mc(!0);
                break;
            case 1:
            case 3:
                this.#mc(!1);
        }
    }
    #mc(e1) {
        if (!this.#Kl) return;
        const t = window.getSelection();
        e1 ? t.setPosition(this.#Kl, this.#Yl) : t.setPosition(this.#ec, this.#tc);
    }
    select() {
        super.select(), this.#sc && this.parent?.drawLayer.updateProperties(this.#sc, {
            rootClass: {
                hovered: !1,
                selected: !0
            }
        });
    }
    unselect() {
        super.unselect(), this.#sc && (this.parent?.drawLayer.updateProperties(this.#sc, {
            rootClass: {
                selected: !1
            }
        }), this.#ac || this.#mc(!1));
    }
    get _mustFixPosition() {
        return !this.#ac;
    }
    show(e1 = this._isVisible) {
        super.show(e1), this.parent && (this.parent.drawLayer.updateProperties(this.#Mt, {
            rootClass: {
                hidden: !e1
            }
        }), this.parent.drawLayer.updateProperties(this.#sc, {
            rootClass: {
                hidden: !e1
            }
        }));
    }
    #gc() {
        return this.#ac ? this.rotation : 0;
    }
    #bc() {
        if (this.#ac) return null;
        const [e1, t] = this.pageDimensions, [i, n] = this.pageTranslation, a = this.#Jl, s = new Float32Array(8 * a.length);
        let r = 0;
        for (const { x: o, y: l, width: c, height: h } of a){
            const a = o * e1 + i, d = (1 - l) * t + n;
            s[r] = s[r + 4] = a, s[r + 1] = s[r + 3] = d, s[r + 2] = s[r + 6] = a + c * e1, s[r + 5] = s[r + 7] = d - h * t, r += 8;
        }
        return s;
    }
    #yc(e1) {
        return this.#nc.serialize(e1, this.#gc());
    }
    static startHighlighting(e1, t, { target: i, x: n, y: a }) {
        const { x: s, y: r, width: o, height: l } = i.getBoundingClientRect(), c = new AbortController, h = e1.combinedSignal(c), pointerUpCallback = (t)=>{
            c.abort(), this.#wc(e1, t);
        };
        window.addEventListener("blur", pointerUpCallback, {
            signal: h
        }), window.addEventListener("pointerup", pointerUpCallback, {
            signal: h
        }), window.addEventListener("pointerdown", stopEvent, {
            capture: !0,
            passive: !1,
            signal: h
        }), window.addEventListener("contextmenu", noContextMenu, {
            signal: h
        }), i.addEventListener("pointermove", this.#Ac.bind(this, e1), {
            signal: h
        }), this._freeHighlight = new FreeHighlightOutliner({
            x: n,
            y: a
        }, [
            s,
            r,
            o,
            l
        ], e1.scale, this._defaultThickness / 2, t, .001), { id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = e1.drawLayer.draw({
            bbox: [
                0,
                0,
                1,
                1
            ],
            root: {
                viewBox: "0 0 1 1",
                fill: this._defaultColor,
                "fill-opacity": this._defaultOpacity
            },
            rootClass: {
                highlight: !0,
                free: !0
            },
            path: {
                d: this._freeHighlight.toSVGPath()
            }
        }, !0, !0);
    }
    static #Ac(e1, t) {
        this._freeHighlight.add(t) && e1.drawLayer.updateProperties(this._freeHighlightId, {
            path: {
                d: this._freeHighlight.toSVGPath()
            }
        });
    }
    static #wc(e1, t) {
        this._freeHighlight.isEmpty() ? e1.drawLayer.remove(this._freeHighlightId) : e1.createAndAddNewEditor(t, !1, {
            highlightId: this._freeHighlightId,
            highlightOutlines: this._freeHighlight.getOutlines(),
            clipPathId: this._freeHighlightClipId,
            methodOfCreation: "main_toolbar"
        }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
    }
    static async deserialize(e1, t, i) {
        let n = null;
        if (e1 instanceof HighlightAnnotationElement) {
            const { data: { quadPoints: t, rect: i, rotation: a, id: s, color: r, opacity: o, popupRef: l, richText: c, contentsObj: h, creationDate: d, modificationDate: u }, parent: { page: { pageNumber: g } } } = e1;
            n = e1 = {
                annotationType: Hl.HIGHLIGHT,
                color: Array.from(r),
                opacity: o,
                quadPoints: t,
                boxes: null,
                pageIndex: g - 1,
                rect: i.slice(0),
                rotation: a,
                annotationElementId: s,
                id: s,
                deleted: !1,
                popupRef: l,
                richText: c,
                comment: h?.str || null,
                creationDate: d,
                modificationDate: u
            };
        } else if (e1 instanceof InkAnnotationElement) {
            const { data: { inkLists: t, rect: i, rotation: a, id: s, color: r, borderStyle: { rawWidth: o }, popupRef: l, richText: c, contentsObj: h, creationDate: d, modificationDate: u }, parent: { page: { pageNumber: g } } } = e1;
            n = e1 = {
                annotationType: Hl.HIGHLIGHT,
                color: Array.from(r),
                thickness: o,
                inkLists: t,
                boxes: null,
                pageIndex: g - 1,
                rect: i.slice(0),
                rotation: a,
                annotationElementId: s,
                id: s,
                deleted: !1,
                popupRef: l,
                richText: c,
                comment: h?.str || null,
                creationDate: d,
                modificationDate: u
            };
        }
        const { color: a, quadPoints: s, inkLists: r, opacity: o } = e1, l = await super.deserialize(e1, t, i);
        l.color = Util.makeHexColor(...a), l.opacity = o || 1, r && (l.#Cl = e1.thickness), l._initialData = n, e1.comment && l.setCommentData(e1);
        const [c, h] = l.pageDimensions, [d, u] = l.pageTranslation;
        if (s) {
            const e1 = l.#Jl = [];
            for(let t = 0; t < s.length; t += 8)e1.push({
                x: (s[t] - d) / c,
                y: 1 - (s[t + 1] - u) / h,
                width: (s[t + 2] - s[t]) / c,
                height: (s[t + 1] - s[t + 5]) / h
            });
            l.#cc(), l.#lc(), l.rotate(l.rotation);
        } else if (r) {
            l.#ac = !0;
            const e1 = r[0], i = {
                x: e1[0] - d,
                y: h - (e1[1] - u)
            }, n = new FreeHighlightOutliner(i, [
                0,
                0,
                c,
                h
            ], 1, l.#Cl / 2, !0, .001);
            for(let t = 0, a = e1.length; t < a; t += 2)i.x = e1[t] - d, i.y = h - (e1[t + 1] - u), n.add(i);
            const { id: a, clipPathId: s } = t.drawLayer.draw({
                bbox: [
                    0,
                    0,
                    1,
                    1
                ],
                root: {
                    viewBox: "0 0 1 1",
                    fill: l.color,
                    "fill-opacity": l._defaultOpacity
                },
                rootClass: {
                    highlight: !0,
                    free: !0
                },
                path: {
                    d: n.toSVGPath()
                }
            }, !0, !0);
            l.#oc({
                highlightOutlines: n.getOutlines(),
                highlightId: a,
                clipPathId: s
            }), l.#lc(), l.rotate(l.parentRotation);
        }
        return l;
    }
    serialize(e1 = !1) {
        if (this.isEmpty() || e1) return null;
        if (this.deleted) return this.serializeDeleted();
        const t = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color)), i = super.serialize(e1);
        return Object.assign(i, {
            color: t,
            opacity: this.opacity,
            thickness: this.#Cl,
            quadPoints: this.#bc(),
            outlines: this.#yc(i.rect)
        }), this.addComment(i), this.annotationElementId && !this.#ul(i) ? null : (i.id = this.annotationElementId, i);
    }
    #ul(e1) {
        const { color: t } = this._initialData;
        return this.hasEditedComment || e1.color.some((e1, i)=>e1 !== t[i]);
    }
    renderAnnotationElement(e1) {
        return this.deleted ? (e1.hide(), null) : (e1.updateEdited({
            rect: this.getPDFRect(),
            popup: this.comment
        }), null);
    }
    static canCreateNewEmptyEditor() {
        return !1;
    }
}
class DrawingOptions {
    #xc = Object.create(null);
    updateProperty(e1, t) {
        this[e1] = t, this.updateSVGProperty(e1, t);
    }
    updateProperties(e1) {
        if (e1) for (const [t, i] of Object.entries(e1))t.startsWith("_") || this.updateProperty(t, i);
    }
    updateSVGProperty(e1, t) {
        this.#xc[e1] = t;
    }
    toSVGProperties() {
        const e1 = this.#xc;
        return this.#xc = Object.create(null), {
            root: e1
        };
    }
    reset() {
        this.#xc = Object.create(null);
    }
    updateAll(e1 = this) {
        this.updateProperties(e1);
    }
    clone() {
        unreachable("Not implemented");
    }
}
class DrawingEditor extends AnnotationEditor {
    #Sc = null;
    #vc;
    _colorPicker = null;
    _drawId = null;
    static _currentDrawId = -1;
    static _currentParent = null;
    static #Cc = null;
    static #kc = null;
    static #Tc = null;
    static #Fc = NaN;
    static #Ic = null;
    static #Ec = null;
    static #Mc = NaN;
    static _INNER_MARGIN = 3;
    constructor(e1){
        super(e1), this.#vc = e1.mustBeCommitted || !1, this._addOutlines(e1);
    }
    onUpdatedColor() {
        this._colorPicker?.update(this.color), super.onUpdatedColor();
    }
    _addOutlines(e1) {
        e1.drawOutlines && (this.#Dc(e1), this.#lc());
    }
    #Dc({ drawOutlines: e1, drawId: t, drawingOptions: i }) {
        this.#Sc = e1, this._drawingOptions ||= i, this.annotationElementId || this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`), t >= 0 ? (this._drawId = t, this.parent.drawLayer.finalizeDraw(t, e1.defaultProperties)) : this._drawId = this.#Oc(e1, this.parent), this.#_c(e1.box);
    }
    #Oc(e1, t) {
        const { id: i } = t.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), e1.defaultSVGProperties), !1, !1);
        return i;
    }
    static _mergeSVGProperties(e1, t) {
        const i = new Set(Object.keys(e1));
        for (const [n, a] of Object.entries(t))i.has(n) ? Object.assign(e1[n], a) : e1[n] = a;
        return e1;
    }
    static getDefaultDrawingOptions(e1) {
        unreachable("Not implemented");
    }
    static get typesMap() {
        unreachable("Not implemented");
    }
    static get isDrawer() {
        return !0;
    }
    static get supportMultipleDrawings() {
        return !1;
    }
    static updateDefaultParams(e1, t) {
        const i = this.typesMap.get(e1);
        i && this._defaultDrawingOptions.updateProperty(i, t), this._currentParent && (DrawingEditor.#Cc.updateProperty(i, t), this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties()));
    }
    updateParams(e1, t) {
        const i = this.constructor.typesMap.get(e1);
        i && this._updateProperty(e1, i, t);
    }
    static get defaultPropertiesToUpdate() {
        const e1 = [], t = this._defaultDrawingOptions;
        for (const [i, n] of this.typesMap)e1.push([
            i,
            t[n]
        ]);
        return e1;
    }
    get propertiesToUpdate() {
        const e1 = [], { _drawingOptions: t } = this;
        for (const [i, n] of this.constructor.typesMap)e1.push([
            i,
            t[n]
        ]);
        return e1;
    }
    _updateProperty(e1, t, i) {
        const n = this._drawingOptions, a = n[t], setter = (i)=>{
            n.updateProperty(t, i);
            const a = this.#Sc.updateProperty(t, i);
            a && this.#_c(a), this.parent?.drawLayer.updateProperties(this._drawId, n.toSVGProperties()), e1 === this.colorType && this.onUpdatedColor();
        };
        this.addCommands({
            cmd: setter.bind(this, i),
            undo: setter.bind(this, a),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: !0,
            type: e1,
            overwriteIfSameType: !0,
            keepUndo: !0
        });
    }
    _onResizing() {
        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#Sc.getPathResizingSVGProperties(this.#Pc()), {
            bbox: this.#Rc()
        }));
    }
    _onResized() {
        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#Sc.getPathResizedSVGProperties(this.#Pc()), {
            bbox: this.#Rc()
        }));
    }
    _onTranslating(e1, t) {
        this.parent?.drawLayer.updateProperties(this._drawId, {
            bbox: this.#Rc()
        });
    }
    _onTranslated() {
        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#Sc.getPathTranslatedSVGProperties(this.#Pc(), this.parentDimensions), {
            bbox: this.#Rc()
        }));
    }
    _onStartDragging() {
        this.parent?.drawLayer.updateProperties(this._drawId, {
            rootClass: {
                moving: !0
            }
        });
    }
    _onStopDragging() {
        this.parent?.drawLayer.updateProperties(this._drawId, {
            rootClass: {
                moving: !1
            }
        });
    }
    commit() {
        super.commit(), this.disableEditMode(), this.disableEditing();
    }
    disableEditing() {
        super.disableEditing(), this.div.classList.toggle("disabled", !0);
    }
    enableEditing() {
        super.enableEditing(), this.div.classList.toggle("disabled", !1);
    }
    getBaseTranslation() {
        return [
            0,
            0
        ];
    }
    get isResizable() {
        return !0;
    }
    onceAdded(e1) {
        this.annotationElementId || this.parent.addUndoableEditor(this), this._isDraggable = !0, this.#vc && (this.#vc = !1, this.commit(), this.parent.setSelected(this), e1 && this.isOnScreen && this.div.focus());
    }
    remove() {
        this.#fc(), super.remove();
    }
    rebuild() {
        this.parent && (super.rebuild(), null !== this.div && (this.#lc(), this.#_c(this.#Sc.box), this.isAttachedToDOM || this.parent.add(this)));
    }
    setParent(e1) {
        let t = !1;
        this.parent && !e1 ? (this._uiManager.removeShouldRescale(this), this.#fc()) : e1 && (this._uiManager.addShouldRescale(this), this.#lc(e1), t = !this.parent && this.div?.classList.contains("selectedEditor")), super.setParent(e1), t && this.select();
    }
    #fc() {
        null !== this._drawId && this.parent && (this.parent.drawLayer.remove(this._drawId), this._drawId = null, this._drawingOptions.reset());
    }
    #lc(e1 = this.parent) {
        null !== this._drawId && this.parent === e1 || (null === this._drawId ? (this._drawingOptions.updateAll(), this._drawId = this.#Oc(this.#Sc, e1)) : this.parent.drawLayer.updateParent(this._drawId, e1.drawLayer));
    }
    #Bc([e1, t, i, n]) {
        const { parentDimensions: [a, s], rotation: r } = this;
        switch(r){
            case 90:
                return [
                    t,
                    1 - e1,
                    i * (s / a),
                    n * (a / s)
                ];
            case 180:
                return [
                    1 - e1,
                    1 - t,
                    i,
                    n
                ];
            case 270:
                return [
                    1 - t,
                    e1,
                    i * (s / a),
                    n * (a / s)
                ];
            default:
                return [
                    e1,
                    t,
                    i,
                    n
                ];
        }
    }
    #Pc() {
        const { x: e1, y: t, width: i, height: n, parentDimensions: [a, s], rotation: r } = this;
        switch(r){
            case 90:
                return [
                    1 - t,
                    e1,
                    i * (a / s),
                    n * (s / a)
                ];
            case 180:
                return [
                    1 - e1,
                    1 - t,
                    i,
                    n
                ];
            case 270:
                return [
                    t,
                    1 - e1,
                    i * (a / s),
                    n * (s / a)
                ];
            default:
                return [
                    e1,
                    t,
                    i,
                    n
                ];
        }
    }
    #_c(e1) {
        [this.x, this.y, this.width, this.height] = this.#Bc(e1), this.div && (this.fixAndSetPosition(), this.setDims()), this._onResized();
    }
    #Rc() {
        const { x: e1, y: t, width: i, height: n, rotation: a, parentRotation: s, parentDimensions: [r, o] } = this;
        switch((4 * a + s) / 90){
            case 1:
                return [
                    1 - t - n,
                    e1,
                    n,
                    i
                ];
            case 2:
                return [
                    1 - e1 - i,
                    1 - t - n,
                    i,
                    n
                ];
            case 3:
                return [
                    t,
                    1 - e1 - i,
                    n,
                    i
                ];
            case 4:
                return [
                    e1,
                    t - i * (r / o),
                    n * (o / r),
                    i * (r / o)
                ];
            case 5:
                return [
                    1 - t,
                    e1,
                    i * (r / o),
                    n * (o / r)
                ];
            case 6:
                return [
                    1 - e1 - n * (o / r),
                    1 - t,
                    n * (o / r),
                    i * (r / o)
                ];
            case 7:
                return [
                    t - i * (r / o),
                    1 - e1 - n * (o / r),
                    i * (r / o),
                    n * (o / r)
                ];
            case 8:
                return [
                    e1 - i,
                    t - n,
                    i,
                    n
                ];
            case 9:
                return [
                    1 - t,
                    e1 - i,
                    n,
                    i
                ];
            case 10:
                return [
                    1 - e1,
                    1 - t,
                    i,
                    n
                ];
            case 11:
                return [
                    t - n,
                    1 - e1,
                    n,
                    i
                ];
            case 12:
                return [
                    e1 - n * (o / r),
                    t,
                    n * (o / r),
                    i * (r / o)
                ];
            case 13:
                return [
                    1 - t - i * (r / o),
                    e1 - n * (o / r),
                    i * (r / o),
                    n * (o / r)
                ];
            case 14:
                return [
                    1 - e1,
                    1 - t - i * (r / o),
                    n * (o / r),
                    i * (r / o)
                ];
            case 15:
                return [
                    t,
                    1 - e1,
                    i * (r / o),
                    n * (o / r)
                ];
            default:
                return [
                    e1,
                    t,
                    i,
                    n
                ];
        }
    }
    rotate() {
        this.parent && this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({
            bbox: this.#Rc()
        }, this.#Sc.updateRotation((this.parentRotation - this.rotation + 360) % 360)));
    }
    onScaleChanging() {
        this.parent && this.#_c(this.#Sc.updateParentDimensions(this.parentDimensions, this.parent.scale));
    }
    static onScaleChangingWhenDrawing() {}
    render() {
        if (this.div) return this.div;
        let e1, t;
        this._isCopy && (e1 = this.x, t = this.y);
        const i = super.render();
        i.classList.add("draw");
        const n = document.createElement("div");
        return i.append(n), n.setAttribute("aria-hidden", "true"), n.className = "internal", this.setDims(), this._uiManager.addShouldRescale(this), this.disableEditing(), this._isCopy && this._moveAfterPaste(e1, t), i;
    }
    static createDrawerInstance(e1, t, i, n, a) {
        unreachable("Not implemented");
    }
    static startDrawing(e1, t, i, n) {
        const { target: a, offsetX: s, offsetY: r, pointerId: o, pointerType: l } = n;
        if (DrawingEditor.#Ic && DrawingEditor.#Ic !== l) return;
        const { viewport: { rotation: c } } = e1, { width: h, height: d } = a.getBoundingClientRect(), u = DrawingEditor.#kc = new AbortController, g = e1.combinedSignal(u);
        DrawingEditor.#Fc ||= o, DrawingEditor.#Ic ??= l, window.addEventListener("pointerup", (e1)=>{
            DrawingEditor.#Fc === e1.pointerId ? this._endDraw(e1) : DrawingEditor.#Ec?.delete(e1.pointerId);
        }, {
            signal: g
        }), window.addEventListener("pointercancel", (e1)=>{
            DrawingEditor.#Fc === e1.pointerId ? this._currentParent.endDrawingSession() : DrawingEditor.#Ec?.delete(e1.pointerId);
        }, {
            signal: g
        }), window.addEventListener("pointerdown", (e1)=>{
            DrawingEditor.#Ic === e1.pointerType && ((DrawingEditor.#Ec ||= new Set).add(e1.pointerId), DrawingEditor.#Cc.isCancellable() && (DrawingEditor.#Cc.removeLastElement(), DrawingEditor.#Cc.isEmpty() ? this._currentParent.endDrawingSession(!0) : this._endDraw(null)));
        }, {
            capture: !0,
            passive: !1,
            signal: g
        }), window.addEventListener("contextmenu", noContextMenu, {
            signal: g
        }), a.addEventListener("pointermove", this._drawMove.bind(this), {
            signal: g
        }), a.addEventListener("touchmove", (e1)=>{
            e1.timeStamp === DrawingEditor.#Mc && stopEvent(e1);
        }, {
            signal: g
        }), e1.toggleDrawing(), t._editorUndoBar?.hide(), DrawingEditor.#Cc ? e1.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#Cc.startNew(s, r, h, d, c)) : (t.updateUIForDefaultProperties(this), DrawingEditor.#Cc = this.createDrawerInstance(s, r, h, d, c), DrawingEditor.#Tc = this.getDefaultDrawingOptions(), this._currentParent = e1, { id: this._currentDrawId } = e1.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#Tc.toSVGProperties(), DrawingEditor.#Cc.defaultSVGProperties), !0, !1));
    }
    static _drawMove(e1) {
        if (DrawingEditor.#Mc = -1, !DrawingEditor.#Cc) return;
        const { offsetX: t, offsetY: i, pointerId: n } = e1;
        DrawingEditor.#Fc === n && (DrawingEditor.#Ec?.size >= 1 ? this._endDraw(e1) : (this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#Cc.add(t, i)), DrawingEditor.#Mc = e1.timeStamp, stopEvent(e1)));
    }
    static _cleanup(e1) {
        e1 && (this._currentDrawId = -1, this._currentParent = null, DrawingEditor.#Cc = null, DrawingEditor.#Tc = null, DrawingEditor.#Ic = null, DrawingEditor.#Mc = NaN), DrawingEditor.#kc && (DrawingEditor.#kc.abort(), DrawingEditor.#kc = null, DrawingEditor.#Fc = NaN, DrawingEditor.#Ec = null);
    }
    static _endDraw(e1) {
        const t = this._currentParent;
        if (t) {
            if (t.toggleDrawing(!0), this._cleanup(!1), e1?.target === t.div && t.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#Cc.end(e1.offsetX, e1.offsetY)), this.supportMultipleDrawings) {
                const e1 = DrawingEditor.#Cc, i = this._currentDrawId, n = e1.getLastElement();
                return void t.addCommands({
                    cmd: ()=>{
                        t.drawLayer.updateProperties(i, e1.setLastElement(n));
                    },
                    undo: ()=>{
                        t.drawLayer.updateProperties(i, e1.removeLastElement());
                    },
                    mustExec: !1,
                    type: Xl.DRAW_STEP
                });
            }
            this.endDrawing(!1);
        }
    }
    static endDrawing(e1) {
        const t = this._currentParent;
        if (!t) return null;
        if (t.toggleDrawing(!0), t.cleanUndoStack(Xl.DRAW_STEP), !DrawingEditor.#Cc.isEmpty()) {
            const { pageDimensions: [i, n], scale: a } = t, s = t.createAndAddNewEditor({
                offsetX: 0,
                offsetY: 0
            }, !1, {
                drawId: this._currentDrawId,
                drawOutlines: DrawingEditor.#Cc.getOutlines(i * a, n * a, a, this._INNER_MARGIN),
                drawingOptions: DrawingEditor.#Tc,
                mustBeCommitted: !e1
            });
            return this._cleanup(!0), s;
        }
        return t.drawLayer.remove(this._currentDrawId), this._cleanup(!0), null;
    }
    createDrawingOptions(e1) {}
    static deserializeDraw(e1, t, i, n, a, s) {
        unreachable("Not implemented");
    }
    static async deserialize(e1, t, i) {
        const { rawDims: { pageWidth: n, pageHeight: a, pageX: s, pageY: r } } = t.viewport, o = this.deserializeDraw(s, r, n, a, this._INNER_MARGIN, e1), l = await super.deserialize(e1, t, i);
        return l.createDrawingOptions(e1), l.#Dc({
            drawOutlines: o
        }), l.#lc(), l.onScaleChanging(), l.rotate(), l;
    }
    serializeDraw(e1) {
        const [t, i] = this.pageTranslation, [n, a] = this.pageDimensions;
        return this.#Sc.serialize([
            t,
            i,
            n,
            a
        ], e1);
    }
    renderAnnotationElement(e1) {
        return e1.updateEdited({
            rect: this.getPDFRect()
        }), null;
    }
    static canCreateNewEmptyEditor() {
        return !1;
    }
}
class InkDrawOutliner {
    #yl = new Float64Array(6);
    #jo;
    #Nc;
    #Ks;
    #Cl;
    #kl;
    #Lc = "";
    #Uc = 0;
    #Vl = new InkDrawOutline;
    #jc;
    #$c;
    constructor(e1, t, i, n, a, s){
        this.#jc = i, this.#$c = n, this.#Ks = a, this.#Cl = s, [e1, t] = this.#Hc(e1, t);
        const r = this.#jo = [
            NaN,
            NaN,
            NaN,
            NaN,
            e1,
            t
        ];
        this.#kl = [
            e1,
            t
        ], this.#Nc = [
            {
                line: r,
                points: this.#kl
            }
        ], this.#yl.set(r, 0);
    }
    updateProperty(e1, t) {
        "stroke-width" === e1 && (this.#Cl = t);
    }
    #Hc(e1, t) {
        return Outline._normalizePoint(e1, t, this.#jc, this.#$c, this.#Ks);
    }
    isEmpty() {
        return !this.#Nc || 0 === this.#Nc.length;
    }
    isCancellable() {
        return this.#kl.length <= 10;
    }
    add(e1, t) {
        [e1, t] = this.#Hc(e1, t);
        const [i, n, a, s] = this.#yl.subarray(2, 6), r = e1 - a, o = t - s;
        return Math.hypot(this.#jc * r, this.#$c * o) <= 2 ? null : (this.#kl.push(e1, t), isNaN(i) ? (this.#yl.set([
            a,
            s,
            e1,
            t
        ], 2), this.#jo.push(NaN, NaN, NaN, NaN, e1, t), {
            path: {
                d: this.toSVGPath()
            }
        }) : (isNaN(this.#yl[0]) && this.#jo.splice(6, 6), this.#yl.set([
            i,
            n,
            a,
            s,
            e1,
            t
        ], 0), this.#jo.push(...Outline.createBezierPoints(i, n, a, s, e1, t)), {
            path: {
                d: this.toSVGPath()
            }
        }));
    }
    end(e1, t) {
        const i = this.add(e1, t);
        return i || (2 === this.#kl.length ? {
            path: {
                d: this.toSVGPath()
            }
        } : null);
    }
    startNew(e1, t, i, n, a) {
        this.#jc = i, this.#$c = n, this.#Ks = a, [e1, t] = this.#Hc(e1, t);
        const s = this.#jo = [
            NaN,
            NaN,
            NaN,
            NaN,
            e1,
            t
        ];
        this.#kl = [
            e1,
            t
        ];
        const r = this.#Nc.at(-1);
        return r && (r.line = new Float32Array(r.line), r.points = new Float32Array(r.points)), this.#Nc.push({
            line: s,
            points: this.#kl
        }), this.#yl.set(s, 0), this.#Uc = 0, this.toSVGPath(), null;
    }
    getLastElement() {
        return this.#Nc.at(-1);
    }
    setLastElement(e1) {
        return this.#Nc ? (this.#Nc.push(e1), this.#jo = e1.line, this.#kl = e1.points, this.#Uc = 0, {
            path: {
                d: this.toSVGPath()
            }
        }) : this.#Vl.setLastElement(e1);
    }
    removeLastElement() {
        if (!this.#Nc) return this.#Vl.removeLastElement();
        this.#Nc.pop(), this.#Lc = "";
        for(let e1 = 0, t = this.#Nc.length; e1 < t; e1++){
            const { line: t, points: i } = this.#Nc[e1];
            this.#jo = t, this.#kl = i, this.#Uc = 0, this.toSVGPath();
        }
        return {
            path: {
                d: this.#Lc
            }
        };
    }
    toSVGPath() {
        const e1 = Outline.svgRound(this.#jo[4]), t = Outline.svgRound(this.#jo[5]);
        if (2 === this.#kl.length) return this.#Lc = `${this.#Lc} M ${e1} ${t} Z`, this.#Lc;
        if (this.#kl.length <= 6) {
            const i = this.#Lc.lastIndexOf("M");
            this.#Lc = `${this.#Lc.slice(0, i)} M ${e1} ${t}`, this.#Uc = 6;
        }
        if (4 === this.#kl.length) {
            const e1 = Outline.svgRound(this.#jo[10]), t = Outline.svgRound(this.#jo[11]);
            return this.#Lc = `${this.#Lc} L ${e1} ${t}`, this.#Uc = 12, this.#Lc;
        }
        const i = [];
        0 === this.#Uc && (i.push(`M ${e1} ${t}`), this.#Uc = 6);
        for(let e1 = this.#Uc, t = this.#jo.length; e1 < t; e1 += 6){
            const [t, n, a, s, r, o] = this.#jo.slice(e1, e1 + 6).map(Outline.svgRound);
            i.push(`C${t} ${n} ${a} ${s} ${r} ${o}`);
        }
        return this.#Lc += i.join(" "), this.#Uc = this.#jo.length, this.#Lc;
    }
    getOutlines(e1, t, i, n) {
        const a = this.#Nc.at(-1);
        return a.line = new Float32Array(a.line), a.points = new Float32Array(a.points), this.#Vl.build(this.#Nc, e1, t, i, this.#Ks, this.#Cl, n), this.#yl = null, this.#jo = null, this.#Nc = null, this.#Lc = null, this.#Vl;
    }
    get defaultSVGProperties() {
        return {
            root: {
                viewBox: "0 0 10000 10000"
            },
            rootClass: {
                draw: !0
            },
            bbox: [
                0,
                0,
                1,
                1
            ]
        };
    }
}
class InkDrawOutline extends Outline {
    #Bl;
    #Xc = 0;
    #pl;
    #Nc;
    #jc;
    #$c;
    #qc;
    #Ks;
    #Cl;
    build(e1, t, i, n, a, s, r) {
        this.#jc = t, this.#$c = i, this.#qc = n, this.#Ks = a, this.#Cl = s, this.#pl = r ?? 0, this.#Nc = e1, this.#zc();
    }
    get thickness() {
        return this.#Cl;
    }
    setLastElement(e1) {
        return this.#Nc.push(e1), {
            path: {
                d: this.toSVGPath()
            }
        };
    }
    removeLastElement() {
        return this.#Nc.pop(), {
            path: {
                d: this.toSVGPath()
            }
        };
    }
    toSVGPath() {
        const e1 = [];
        for (const { line: t } of this.#Nc)if (e1.push(`M${Outline.svgRound(t[4])} ${Outline.svgRound(t[5])}`), 6 !== t.length) if (12 === t.length && isNaN(t[6])) e1.push(`L${Outline.svgRound(t[10])} ${Outline.svgRound(t[11])}`);
        else for(let i = 6, n = t.length; i < n; i += 6){
            const [n, a, s, r, o, l] = t.subarray(i, i + 6).map(Outline.svgRound);
            e1.push(`C${n} ${a} ${s} ${r} ${o} ${l}`);
        }
        else e1.push("Z");
        return e1.join("");
    }
    serialize([e1, t, i, n], a) {
        const s = [], r = [], [o, l, c, h] = this.#Wc();
        let d, u, g, f, p, m, b, y, w;
        switch(this.#Ks){
            case 0:
                w = Outline._rescale, d = e1, u = t + n, g = i, f = -n, p = e1 + o * i, m = t + (1 - l - h) * n, b = e1 + (o + c) * i, y = t + (1 - l) * n;
                break;
            case 90:
                w = Outline._rescaleAndSwap, d = e1, u = t, g = i, f = n, p = e1 + l * i, m = t + o * n, b = e1 + (l + h) * i, y = t + (o + c) * n;
                break;
            case 180:
                w = Outline._rescale, d = e1 + i, u = t, g = -i, f = n, p = e1 + (1 - o - c) * i, m = t + l * n, b = e1 + (1 - o) * i, y = t + (l + h) * n;
                break;
            case 270:
                w = Outline._rescaleAndSwap, d = e1 + i, u = t + n, g = -i, f = -n, p = e1 + (1 - l - h) * i, m = t + (1 - o - c) * n, b = e1 + (1 - l) * i, y = t + (1 - o) * n;
        }
        for (const { line: e1, points: t } of this.#Nc)s.push(w(e1, d, u, g, f, a ? new Array(e1.length) : null)), r.push(w(t, d, u, g, f, a ? new Array(t.length) : null));
        return {
            lines: s,
            points: r,
            rect: [
                p,
                m,
                b,
                y
            ]
        };
    }
    static deserialize(e1, t, i, n, a, { paths: { lines: s, points: r }, rotation: o, thickness: l }) {
        const c = [];
        let h, d, u, g, f;
        switch(o){
            case 0:
                f = Outline._rescale, h = -e1 / i, d = t / n + 1, u = 1 / i, g = -1 / n;
                break;
            case 90:
                f = Outline._rescaleAndSwap, h = -t / n, d = -e1 / i, u = 1 / n, g = 1 / i;
                break;
            case 180:
                f = Outline._rescale, h = e1 / i + 1, d = -t / n, u = -1 / i, g = 1 / n;
                break;
            case 270:
                f = Outline._rescaleAndSwap, h = t / n + 1, d = e1 / i + 1, u = -1 / n, g = -1 / i;
        }
        if (!s) {
            s = [];
            for (const e1 of r){
                const t = e1.length;
                if (2 === t) {
                    s.push(new Float32Array([
                        NaN,
                        NaN,
                        NaN,
                        NaN,
                        e1[0],
                        e1[1]
                    ]));
                    continue;
                }
                if (4 === t) {
                    s.push(new Float32Array([
                        NaN,
                        NaN,
                        NaN,
                        NaN,
                        e1[0],
                        e1[1],
                        NaN,
                        NaN,
                        NaN,
                        NaN,
                        e1[2],
                        e1[3]
                    ]));
                    continue;
                }
                const i = new Float32Array(3 * (t - 2));
                s.push(i);
                let [n, a, r, o] = e1.subarray(0, 4);
                i.set([
                    NaN,
                    NaN,
                    NaN,
                    NaN,
                    n,
                    a
                ], 0);
                for(let s = 4; s < t; s += 2){
                    const t = e1[s], l = e1[s + 1];
                    i.set(Outline.createBezierPoints(n, a, r, o, t, l), 3 * (s - 2)), [n, a, r, o] = [
                        r,
                        o,
                        t,
                        l
                    ];
                }
            }
        }
        for(let e1 = 0, t = s.length; e1 < t; e1++)c.push({
            line: f(s[e1].map((e1)=>e1 ?? NaN), h, d, u, g),
            points: f(r[e1].map((e1)=>e1 ?? NaN), h, d, u, g)
        });
        const p = new this.prototype.constructor;
        return p.build(c, i, n, 1, o, l, a), p;
    }
    #Gc(e1 = this.#Cl) {
        const t = this.#pl + e1 / 2 * this.#qc;
        return this.#Ks % 180 == 0 ? [
            t / this.#jc,
            t / this.#$c
        ] : [
            t / this.#$c,
            t / this.#jc
        ];
    }
    #Wc() {
        const [e1, t, i, n] = this.#Bl, [a, s] = this.#Gc(0);
        return [
            e1 + a,
            t + s,
            i - 2 * a,
            n - 2 * s
        ];
    }
    #zc() {
        const e1 = this.#Bl = new Float32Array([
            1 / 0,
            1 / 0,
            -1 / 0,
            -1 / 0
        ]);
        for (const { line: t } of this.#Nc){
            if (t.length <= 12) {
                for(let i = 4, n = t.length; i < n; i += 6)Util.pointBoundingBox(t[i], t[i + 1], e1);
                continue;
            }
            let i = t[4], n = t[5];
            for(let a = 6, s = t.length; a < s; a += 6){
                const [s, r, o, l, c, h] = t.subarray(a, a + 6);
                Util.bezierBoundingBox(i, n, s, r, o, l, c, h, e1), i = c, n = h;
            }
        }
        const [t, i] = this.#Gc();
        e1[0] = MathClamp(e1[0] - t, 0, 1), e1[1] = MathClamp(e1[1] - i, 0, 1), e1[2] = MathClamp(e1[2] + t, 0, 1), e1[3] = MathClamp(e1[3] + i, 0, 1), e1[2] -= e1[0], e1[3] -= e1[1];
    }
    get box() {
        return this.#Bl;
    }
    updateProperty(e1, t) {
        return "stroke-width" === e1 ? this.#dc(t) : null;
    }
    #dc(e1) {
        const [t, i] = this.#Gc();
        this.#Cl = e1;
        const [n, a] = this.#Gc(), [s, r] = [
            n - t,
            a - i
        ], o = this.#Bl;
        return o[0] -= s, o[1] -= r, o[2] += 2 * s, o[3] += 2 * r, o;
    }
    updateParentDimensions([e1, t], i) {
        const [n, a] = this.#Gc();
        this.#jc = e1, this.#$c = t, this.#qc = i;
        const [s, r] = this.#Gc(), o = s - n, l = r - a, c = this.#Bl;
        return c[0] -= o, c[1] -= l, c[2] += 2 * o, c[3] += 2 * l, c;
    }
    updateRotation(e1) {
        return this.#Xc = e1, {
            path: {
                transform: this.rotationTransform
            }
        };
    }
    get viewBox() {
        return this.#Bl.map(Outline.svgRound).join(" ");
    }
    get defaultProperties() {
        const [e1, t] = this.#Bl;
        return {
            root: {
                viewBox: this.viewBox
            },
            path: {
                "transform-origin": `${Outline.svgRound(e1)} ${Outline.svgRound(t)}`
            }
        };
    }
    get rotationTransform() {
        const [, , e1, t] = this.#Bl;
        let i = 0, n = 0, a = 0, s = 0, r = 0, o = 0;
        switch(this.#Xc){
            case 90:
                n = t / e1, a = -e1 / t, r = e1;
                break;
            case 180:
                i = -1, s = -1, r = e1, o = t;
                break;
            case 270:
                n = -t / e1, a = e1 / t, o = t;
                break;
            default:
                return "";
        }
        return `matrix(${i} ${n} ${a} ${s} ${Outline.svgRound(r)} ${Outline.svgRound(o)})`;
    }
    getPathResizingSVGProperties([e1, t, i, n]) {
        const [a, s] = this.#Gc(), [r, o, l, c] = this.#Bl;
        if (Math.abs(l - a) <= Outline.PRECISION || Math.abs(c - s) <= Outline.PRECISION) {
            const a = e1 + i / 2 - (r + l / 2), s = t + n / 2 - (o + c / 2);
            return {
                path: {
                    "transform-origin": `${Outline.svgRound(e1)} ${Outline.svgRound(t)}`,
                    transform: `${this.rotationTransform} translate(${a} ${s})`
                }
            };
        }
        const h = (i - 2 * a) / (l - 2 * a), d = (n - 2 * s) / (c - 2 * s), u = l / i, g = c / n;
        return {
            path: {
                "transform-origin": `${Outline.svgRound(r)} ${Outline.svgRound(o)}`,
                transform: `${this.rotationTransform} scale(${u} ${g}) translate(${Outline.svgRound(a)} ${Outline.svgRound(s)}) scale(${h} ${d}) translate(${Outline.svgRound(-a)} ${Outline.svgRound(-s)})`
            }
        };
    }
    getPathResizedSVGProperties([e1, t, i, n]) {
        const [a, s] = this.#Gc(), r = this.#Bl, [o, l, c, h] = r;
        if (r[0] = e1, r[1] = t, r[2] = i, r[3] = n, Math.abs(c - a) <= Outline.PRECISION || Math.abs(h - s) <= Outline.PRECISION) {
            const a = e1 + i / 2 - (o + c / 2), s = t + n / 2 - (l + h / 2);
            for (const { line: e1, points: t } of this.#Nc)Outline._translate(e1, a, s, e1), Outline._translate(t, a, s, t);
            return {
                root: {
                    viewBox: this.viewBox
                },
                path: {
                    "transform-origin": `${Outline.svgRound(e1)} ${Outline.svgRound(t)}`,
                    transform: this.rotationTransform || null,
                    d: this.toSVGPath()
                }
            };
        }
        const d = (i - 2 * a) / (c - 2 * a), u = (n - 2 * s) / (h - 2 * s), g = -d * (o + a) + e1 + a, f = -u * (l + s) + t + s;
        if (1 !== d || 1 !== u || 0 !== g || 0 !== f) for (const { line: e1, points: t } of this.#Nc)Outline._rescale(e1, g, f, d, u, e1), Outline._rescale(t, g, f, d, u, t);
        return {
            root: {
                viewBox: this.viewBox
            },
            path: {
                "transform-origin": `${Outline.svgRound(e1)} ${Outline.svgRound(t)}`,
                transform: this.rotationTransform || null,
                d: this.toSVGPath()
            }
        };
    }
    getPathTranslatedSVGProperties([e1, t], i) {
        const [n, a] = i, s = this.#Bl, r = e1 - s[0], o = t - s[1];
        if (this.#jc === n && this.#$c === a) for (const { line: e1, points: t } of this.#Nc)Outline._translate(e1, r, o, e1), Outline._translate(t, r, o, t);
        else {
            const e1 = this.#jc / n, t = this.#$c / a;
            this.#jc = n, this.#$c = a;
            for (const { line: i, points: n } of this.#Nc)Outline._rescale(i, r, o, e1, t, i), Outline._rescale(n, r, o, e1, t, n);
            s[2] *= e1, s[3] *= t;
        }
        return s[0] = e1, s[1] = t, {
            root: {
                viewBox: this.viewBox
            },
            path: {
                d: this.toSVGPath(),
                "transform-origin": `${Outline.svgRound(e1)} ${Outline.svgRound(t)}`
            }
        };
    }
    get defaultSVGProperties() {
        const e1 = this.#Bl;
        return {
            root: {
                viewBox: this.viewBox
            },
            rootClass: {
                draw: !0
            },
            path: {
                d: this.toSVGPath(),
                "transform-origin": `${Outline.svgRound(e1[0])} ${Outline.svgRound(e1[1])}`,
                transform: this.rotationTransform || null
            },
            bbox: e1
        };
    }
}
class InkDrawingOptions extends DrawingOptions {
    constructor(e1){
        super(), this._viewParameters = e1, super.updateProperties({
            fill: "none",
            stroke: AnnotationEditor._defaultLineColor,
            "stroke-opacity": 1,
            "stroke-width": 1,
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-miterlimit": 10
        });
    }
    updateSVGProperty(e1, t) {
        "stroke-width" === e1 && (t ??= this["stroke-width"], t *= this._viewParameters.realScale), super.updateSVGProperty(e1, t);
    }
    clone() {
        const e1 = new InkDrawingOptions(this._viewParameters);
        return e1.updateAll(this), e1;
    }
}
class InkEditor extends DrawingEditor {
    static _type = "ink";
    static _editorType = Hl.INK;
    static _defaultDrawingOptions = null;
    constructor(e1){
        super({
            ...e1,
            name: "inkEditor"
        }), this._willKeepAspectRatio = !0, this.defaultL10nId = "pdfjs-editor-ink-editor";
    }
    static initialize(e1, t) {
        AnnotationEditor.initialize(e1, t), this._defaultDrawingOptions = new InkDrawingOptions(t.viewParameters);
    }
    static getDefaultDrawingOptions(e1) {
        const t = this._defaultDrawingOptions.clone();
        return t.updateProperties(e1), t;
    }
    static get supportMultipleDrawings() {
        return !0;
    }
    static get typesMap() {
        return shadow(this, "typesMap", new Map([
            [
                Xl.INK_THICKNESS,
                "stroke-width"
            ],
            [
                Xl.INK_COLOR,
                "stroke"
            ],
            [
                Xl.INK_OPACITY,
                "stroke-opacity"
            ]
        ]));
    }
    static createDrawerInstance(e1, t, i, n, a) {
        return new InkDrawOutliner(e1, t, i, n, a, this._defaultDrawingOptions["stroke-width"]);
    }
    static deserializeDraw(e1, t, i, n, a, s) {
        return InkDrawOutline.deserialize(e1, t, i, n, a, s);
    }
    static async deserialize(e1, t, i) {
        let n = null;
        if (e1 instanceof InkAnnotationElement) {
            const { data: { inkLists: t, rect: i, rotation: a, id: s, color: r, opacity: o, borderStyle: { rawWidth: l }, popupRef: c, richText: h, contentsObj: d, creationDate: u, modificationDate: g }, parent: { page: { pageNumber: f } } } = e1;
            n = e1 = {
                annotationType: Hl.INK,
                color: Array.from(r),
                thickness: l,
                opacity: o,
                paths: {
                    points: t
                },
                boxes: null,
                pageIndex: f - 1,
                rect: i.slice(0),
                rotation: a,
                annotationElementId: s,
                id: s,
                deleted: !1,
                popupRef: c,
                richText: h,
                comment: d?.str || null,
                creationDate: u,
                modificationDate: g
            };
        }
        const a = await super.deserialize(e1, t, i);
        return a._initialData = n, e1.comment && a.setCommentData(e1), a;
    }
    get toolbarButtons() {
        return this._colorPicker ||= new BasicColorPicker(this), [
            [
                "colorPicker",
                this._colorPicker
            ]
        ];
    }
    get colorType() {
        return Xl.INK_COLOR;
    }
    get color() {
        return this._drawingOptions.stroke;
    }
    get opacity() {
        return this._drawingOptions["stroke-opacity"];
    }
    onScaleChanging() {
        if (!this.parent) return;
        super.onScaleChanging();
        const { _drawId: e1, _drawingOptions: t, parent: i } = this;
        t.updateSVGProperty("stroke-width"), i.drawLayer.updateProperties(e1, t.toSVGProperties());
    }
    static onScaleChangingWhenDrawing() {
        const e1 = this._currentParent;
        e1 && (super.onScaleChangingWhenDrawing(), this._defaultDrawingOptions.updateSVGProperty("stroke-width"), e1.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties()));
    }
    createDrawingOptions({ color: e1, thickness: t, opacity: i }) {
        this._drawingOptions = InkEditor.getDefaultDrawingOptions({
            stroke: Util.makeHexColor(...e1),
            "stroke-width": t,
            "stroke-opacity": i
        });
    }
    serialize(e1 = !1) {
        if (this.isEmpty()) return null;
        if (this.deleted) return this.serializeDeleted();
        const { lines: t, points: i } = this.serializeDraw(e1), { _drawingOptions: { stroke: n, "stroke-opacity": a, "stroke-width": s } } = this, r = Object.assign(super.serialize(e1), {
            color: AnnotationEditor._colorManager.convert(n),
            opacity: a,
            thickness: s,
            paths: {
                lines: t,
                points: i
            }
        });
        return this.addComment(r), e1 ? (r.isCopy = !0, r) : this.annotationElementId && !this.#ul(r) ? null : (r.id = this.annotationElementId, r);
    }
    #ul(e1) {
        const { color: t, thickness: i, opacity: n, pageIndex: a } = this._initialData;
        return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || e1.color.some((e1, i)=>e1 !== t[i]) || e1.thickness !== i || e1.opacity !== n || e1.pageIndex !== a;
    }
    renderAnnotationElement(e1) {
        if (this.deleted) return e1.hide(), null;
        const { points: t, rect: i } = this.serializeDraw(!1);
        return e1.updateEdited({
            rect: i,
            thickness: this._drawingOptions["stroke-width"],
            points: t,
            popup: this.comment
        }), null;
    }
}
class ContourDrawOutline extends InkDrawOutline {
    toSVGPath() {
        let e1 = super.toSVGPath();
        return e1.endsWith("Z") || (e1 += "Z"), e1;
    }
}
class SignatureExtractor {
    static #Vc = {
        maxDim: 512,
        sigmaSFactor: .02,
        sigmaR: 25,
        kernelSize: 16
    };
    static #Kc(e1, t, i, n) {
        return n -= t, 0 === (i -= e1) ? n > 0 ? 0 : 4 : 1 === i ? n + 6 : 2 - n;
    }
    static #Yc = new Int32Array([
        0,
        1,
        -1,
        1,
        -1,
        0,
        -1,
        -1,
        0,
        -1,
        1,
        -1,
        1,
        0,
        1,
        1
    ]);
    static #Jc(e1, t, i, n, a, s, r) {
        const o = this.#Kc(i, n, a, s);
        for(let a = 0; a < 8; a++){
            const s = (-a + o - r + 16) % 8;
            if (0 !== e1[(i + this.#Yc[2 * s]) * t + (n + this.#Yc[2 * s + 1])]) return s;
        }
        return -1;
    }
    static #Zc(e1, t, i, n, a, s, r) {
        const o = this.#Kc(i, n, a, s);
        for(let a = 0; a < 8; a++){
            const s = (a + o + r + 16) % 8;
            if (0 !== e1[(i + this.#Yc[2 * s]) * t + (n + this.#Yc[2 * s + 1])]) return s;
        }
        return -1;
    }
    static #Qc(e1, t, i, n) {
        const a = e1.length, s = new Int32Array(a);
        for(let t = 0; t < a; t++)s[t] = e1[t] <= n ? 1 : 0;
        for(let e1 = 1; e1 < i - 1; e1++)s[e1 * t] = s[e1 * t + t - 1] = 0;
        for(let e1 = 0; e1 < t; e1++)s[e1] = s[t * i - 1 - e1] = 0;
        let r, o = 1;
        const l = [];
        for(let e1 = 1; e1 < i - 1; e1++){
            r = 1;
            for(let i = 1; i < t - 1; i++){
                const n = e1 * t + i, a = s[n];
                if (0 === a) continue;
                let c = e1, h = i;
                if (1 === a && 0 === s[n - 1]) o += 1, h -= 1;
                else {
                    if (!(a >= 1 && 0 === s[n + 1])) {
                        1 !== a && (r = Math.abs(a));
                        continue;
                    }
                    o += 1, h += 1, a > 1 && (r = a);
                }
                const d = [
                    i,
                    e1
                ], u = h === i + 1, g = {
                    isHole: u,
                    points: d,
                    id: o,
                    parent: 0
                };
                let f;
                l.push(g);
                for (const e1 of l)if (e1.id === r) {
                    f = e1;
                    break;
                }
                f ? f.isHole ? g.parent = u ? f.parent : r : g.parent = u ? r : f.parent : g.parent = u ? r : 0;
                const p = this.#Jc(s, t, e1, i, c, h, 0);
                if (-1 === p) {
                    s[n] = -o, 1 !== s[n] && (r = Math.abs(s[n]));
                    continue;
                }
                let m = this.#Yc[2 * p], b = this.#Yc[2 * p + 1];
                const y = e1 + m, w = i + b;
                c = y, h = w;
                let x = e1, S = i;
                for(;;){
                    const a = this.#Zc(s, t, x, S, c, h, 1);
                    m = this.#Yc[2 * a], b = this.#Yc[2 * a + 1];
                    const l = x + m, u = S + b;
                    d.push(u, l);
                    const g = x * t + S;
                    if (0 === s[g + 1] ? s[g] = -o : 1 === s[g] && (s[g] = o), l === e1 && u === i && x === y && S === w) {
                        1 !== s[n] && (r = Math.abs(s[n]));
                        break;
                    }
                    c = x, h = S, x = l, S = u;
                }
            }
        }
        return l;
    }
    static #eh(e1, t, i, n) {
        if (i - t <= 4) {
            for(let a = t; a < i - 2; a += 2)n.push(e1[a], e1[a + 1]);
            return;
        }
        const a = e1[t], s = e1[t + 1], r = e1[i - 4] - a, o = e1[i - 3] - s, l = Math.hypot(r, o), c = r / l, h = o / l, d = c * s - h * a, u = o / r, g = 1 / l, f = Math.atan(u), p = Math.cos(f), m = Math.sin(f), b = g * (Math.abs(p) + Math.abs(m)), y = g * (1 - b + b ** 2), w = Math.max(Math.atan(Math.abs(m + p) * y), Math.atan(Math.abs(m - p) * y));
        let x = 0, S = t;
        for(let n = t + 2; n < i - 2; n += 2){
            const t = Math.abs(d - c * e1[n + 1] + h * e1[n]);
            t > x && (S = n, x = t);
        }
        x > (l * w) ** 2 ? (this.#eh(e1, t, S + 2, n), this.#eh(e1, S, i, n)) : n.push(a, s);
    }
    static #th(e1) {
        const t = [], i = e1.length;
        return this.#eh(e1, 0, i, t), t.push(e1[i - 2], e1[i - 1]), t.length <= 4 ? null : t;
    }
    static #ih(e1, t, i, n, a, s) {
        const r = new Float32Array(s ** 2), o = -2 * n ** 2, l = s >> 1;
        for(let e1 = 0; e1 < s; e1++){
            const t = (e1 - l) ** 2;
            for(let i = 0; i < s; i++)r[e1 * s + i] = Math.exp((t + (i - l) ** 2) / o);
        }
        const c = new Float32Array(256), h = -2 * a ** 2;
        for(let e1 = 0; e1 < 256; e1++)c[e1] = Math.exp(e1 ** 2 / h);
        const d = e1.length, u = new Uint8Array(d), g = new Uint32Array(256);
        for(let n = 0; n < i; n++)for(let a = 0; a < t; a++){
            const o = n * t + a, h = e1[o];
            let d = 0, f = 0;
            for(let o = 0; o < s; o++){
                const u = n + o - l;
                if (!(u < 0 || u >= i)) for(let i = 0; i < s; i++){
                    const n = a + i - l;
                    if (n < 0 || n >= t) continue;
                    const g = e1[u * t + n], p = r[o * s + i] * c[Math.abs(g - h)];
                    d += g * p, f += p;
                }
            }
            g[u[o] = Math.round(d / f)]++;
        }
        return [
            u,
            g
        ];
    }
    static #nh(e1) {
        const t = new Uint32Array(256);
        for (const i of e1)t[i]++;
        return t;
    }
    static #ah(e1) {
        const t = e1.length, i = new Uint8ClampedArray(t >> 2);
        let n = -1 / 0, a = 1 / 0;
        for(let t = 0, s = i.length; t < s; t++){
            const s = i[t] = e1[t << 2];
            n = Math.max(n, s), a = Math.min(a, s);
        }
        const s = 255 / (n - a);
        for(let e1 = 0, t = i.length; e1 < t; e1++)i[e1] = (i[e1] - a) * s;
        return i;
    }
    static #sh(e1) {
        let t, i = -1 / 0, n = -1 / 0;
        const a = e1.findIndex((e1)=>0 !== e1);
        let s = a, r = a;
        for(t = a; t < 256; t++){
            const a = e1[t];
            a > i && (t - s > n && (n = t - s, r = t - 1), i = a, s = t);
        }
        for(t = r - 1; t >= 0 && !(e1[t] > e1[t + 1]); t--);
        return t;
    }
    static #rh(e1) {
        const t = e1, { width: i, height: n } = e1, { maxDim: a } = this.#Vc;
        let s = i, r = n;
        if (i > a || n > a) {
            let o = i, l = n, c = Math.log2(Math.max(i, n) / a);
            const h = Math.floor(c);
            c = c === h ? h - 1 : h;
            for(let i = 0; i < c; i++){
                s = Math.ceil(o / 2), r = Math.ceil(l / 2);
                const i = new OffscreenCanvas(s, r);
                i.getContext("2d").drawImage(e1, 0, 0, o, l, 0, 0, s, r), o = s, l = r, e1 !== t && e1.close(), e1 = i.transferToImageBitmap();
            }
            const d = Math.min(a / s, a / r);
            s = Math.round(s * d), r = Math.round(r * d);
        }
        const o = new OffscreenCanvas(s, r).getContext("2d", {
            willReadFrequently: !0
        });
        o.fillStyle = "white", o.fillRect(0, 0, s, r), o.filter = "grayscale(1)", o.drawImage(e1, 0, 0, e1.width, e1.height, 0, 0, s, r);
        const l = o.getImageData(0, 0, s, r).data;
        return [
            this.#ah(l),
            s,
            r
        ];
    }
    static extractContoursFromText(e1, { fontFamily: t, fontStyle: i, fontWeight: n }, a, s, r, o) {
        let l = new OffscreenCanvas(1, 1), c = l.getContext("2d", {
            alpha: !1
        });
        const h = c.font = `${i} ${n} 200px ${t}`, { actualBoundingBoxLeft: d, actualBoundingBoxRight: u, actualBoundingBoxAscent: g, actualBoundingBoxDescent: f, fontBoundingBoxAscent: p, fontBoundingBoxDescent: m, width: b } = c.measureText(e1), y = 1.5, w = Math.ceil(Math.max(Math.abs(d) + Math.abs(u) || 0, b) * y), x = Math.ceil(Math.max(Math.abs(g) + Math.abs(f) || 200, Math.abs(p) + Math.abs(m) || 200) * y);
        l = new OffscreenCanvas(w, x), c = l.getContext("2d", {
            alpha: !0,
            willReadFrequently: !0
        }), c.font = h, c.filter = "grayscale(1)", c.fillStyle = "white", c.fillRect(0, 0, w, x), c.fillStyle = "black", c.fillText(e1, .5 * w / 2, 1.5 * x / 2);
        const S = this.#ah(c.getImageData(0, 0, w, x).data), v = this.#nh(S), C = this.#sh(v), k = this.#Qc(S, w, x, C);
        return this.processDrawnLines({
            lines: {
                curves: k,
                width: w,
                height: x
            },
            pageWidth: a,
            pageHeight: s,
            rotation: r,
            innerMargin: o,
            mustSmooth: !0,
            areContours: !0
        });
    }
    static process(e1, t, i, n, a) {
        const [s, r, o] = this.#rh(e1), [l, c] = this.#ih(s, r, o, Math.hypot(r, o) * this.#Vc.sigmaSFactor, this.#Vc.sigmaR, this.#Vc.kernelSize), h = this.#sh(c), d = this.#Qc(l, r, o, h);
        return this.processDrawnLines({
            lines: {
                curves: d,
                width: r,
                height: o
            },
            pageWidth: t,
            pageHeight: i,
            rotation: n,
            innerMargin: a,
            mustSmooth: !0,
            areContours: !0
        });
    }
    static processDrawnLines({ lines: e1, pageWidth: t, pageHeight: i, rotation: n, innerMargin: a, mustSmooth: s, areContours: r }) {
        n % 180 != 0 && ([t, i] = [
            i,
            t
        ]);
        const { curves: o, width: l, height: c } = e1, h = e1.thickness ?? 0, d = [], u = Math.min(t / l, i / c), g = u / t, f = u / i, p = [];
        for (const { points: e1 } of o){
            const t = s ? this.#th(e1) : e1;
            if (!t) continue;
            p.push(t);
            const i = t.length, n = new Float32Array(i), a = new Float32Array(3 * (2 === i ? 2 : i - 2));
            if (d.push({
                line: a,
                points: n
            }), 2 === i) {
                n[0] = t[0] * g, n[1] = t[1] * f, a.set([
                    NaN,
                    NaN,
                    NaN,
                    NaN,
                    n[0],
                    n[1]
                ], 0);
                continue;
            }
            let [r, o, l, c] = t;
            r *= g, o *= f, l *= g, c *= f, n.set([
                r,
                o,
                l,
                c
            ], 0), a.set([
                NaN,
                NaN,
                NaN,
                NaN,
                r,
                o
            ], 0);
            for(let e1 = 4; e1 < i; e1 += 2){
                const i = n[e1] = t[e1] * g, s = n[e1 + 1] = t[e1 + 1] * f;
                a.set(Outline.createBezierPoints(r, o, l, c, i, s), 3 * (e1 - 2)), [r, o, l, c] = [
                    l,
                    c,
                    i,
                    s
                ];
            }
        }
        if (0 === d.length) return null;
        const m = r ? new ContourDrawOutline : new InkDrawOutline;
        return m.build(d, t, i, 1, n, r ? 0 : h, a), {
            outline: m,
            newCurves: p,
            areContours: r,
            thickness: h,
            width: l,
            height: c
        };
    }
    static async compressSignature({ outlines: e1, areContours: t, thickness: i, width: n, height: a }) {
        let s, r = 1 / 0, o = -1 / 0, l = 0;
        for (const t of e1){
            l += t.length;
            for(let e1 = 2, i = t.length; e1 < i; e1++){
                const i = t[e1] - t[e1 - 2];
                r = Math.min(r, i), o = Math.max(o, i);
            }
        }
        s = r >= -128 && o <= 127 ? Int8Array : r >= -32768 && o <= 32767 ? Int16Array : Int32Array;
        const c = e1.length, h = 8 + 3 * c, d = new Uint32Array(h);
        let u = 0;
        d[u++] = h * Uint32Array.BYTES_PER_ELEMENT + (l - 2 * c) * s.BYTES_PER_ELEMENT, d[u++] = 0, d[u++] = n, d[u++] = a, d[u++] = t ? 0 : 1, d[u++] = Math.max(0, Math.floor(i ?? 0)), d[u++] = c, d[u++] = s.BYTES_PER_ELEMENT;
        for (const t of e1)d[u++] = t.length - 2, d[u++] = t[0], d[u++] = t[1];
        const g = new CompressionStream("deflate-raw"), f = g.writable.getWriter();
        await f.ready, f.write(d);
        const p = s.prototype.constructor;
        for (const t of e1){
            const e1 = new p(t.length - 2);
            for(let i = 2, n = t.length; i < n; i++)e1[i - 2] = t[i] - t[i - 2];
            f.write(e1);
        }
        f.close();
        const m = await new Response(g.readable).arrayBuffer();
        return toBase64Util(new Uint8Array(m));
    }
    static async decompressSignature(e1) {
        try {
            const i = (t = e1, Uint8Array.fromBase64 ? Uint8Array.fromBase64(t) : stringToBytes(atob(t))), { readable: n, writable: a } = new DecompressionStream("deflate-raw"), s = a.getWriter();
            await s.ready, s.write(i).then(async ()=>{
                await s.ready, await s.close();
            }).catch(()=>{});
            let r = null, o = 0;
            for await (const e1 of n)r ||= new Uint8Array(new Uint32Array(e1.buffer, 0, 4)[0]), r.set(e1, o), o += e1.length;
            const l = new Uint32Array(r.buffer, 0, r.length >> 2), c = l[1];
            if (0 !== c) throw new Error(`Invalid version: ${c}`);
            const h = l[2], d = l[3], u = 0 === l[4], g = l[5], f = l[6], p = l[7], m = [], b = (8 + 3 * f) * Uint32Array.BYTES_PER_ELEMENT;
            let y;
            switch(p){
                case Int8Array.BYTES_PER_ELEMENT:
                    y = new Int8Array(r.buffer, b);
                    break;
                case Int16Array.BYTES_PER_ELEMENT:
                    y = new Int16Array(r.buffer, b);
                    break;
                case Int32Array.BYTES_PER_ELEMENT:
                    y = new Int32Array(r.buffer, b);
            }
            o = 0;
            for(let e1 = 0; e1 < f; e1++){
                const t = l[3 * e1 + 8], i = new Float32Array(t + 2);
                m.push(i);
                for(let t = 0; t < 2; t++)i[t] = l[3 * e1 + 8 + t + 1];
                for(let e1 = 0; e1 < t; e1++)i[e1 + 2] = i[e1] + y[o++];
            }
            return {
                areContours: u,
                thickness: g,
                outlines: m,
                width: h,
                height: d
            };
        } catch (e1) {
            return warn(`decompressSignature: ${e1}`), null;
        }
        var t;
    }
}
class SignatureOptions extends DrawingOptions {
    constructor(){
        super(), super.updateProperties({
            fill: AnnotationEditor._defaultLineColor,
            "stroke-width": 0
        });
    }
    clone() {
        const e1 = new SignatureOptions;
        return e1.updateAll(this), e1;
    }
}
class DrawnSignatureOptions extends InkDrawingOptions {
    constructor(e1){
        super(e1), super.updateProperties({
            stroke: AnnotationEditor._defaultLineColor,
            "stroke-width": 1
        });
    }
    clone() {
        const e1 = new DrawnSignatureOptions(this._viewParameters);
        return e1.updateAll(this), e1;
    }
}
class SignatureEditor extends DrawingEditor {
    #oh = !1;
    #lh = null;
    #ch = null;
    #hh = null;
    static _type = "signature";
    static _editorType = Hl.SIGNATURE;
    static _defaultDrawingOptions = null;
    constructor(e1){
        super({
            ...e1,
            mustBeCommitted: !0,
            name: "signatureEditor"
        }), this._willKeepAspectRatio = !0, this.#ch = e1.signatureData || null, this.#lh = null, this.defaultL10nId = "pdfjs-editor-signature-editor1";
    }
    static initialize(e1, t) {
        AnnotationEditor.initialize(e1, t), this._defaultDrawingOptions = new SignatureOptions, this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(t.viewParameters);
    }
    static getDefaultDrawingOptions(e1) {
        const t = this._defaultDrawingOptions.clone();
        return t.updateProperties(e1), t;
    }
    static get supportMultipleDrawings() {
        return !1;
    }
    static get typesMap() {
        return shadow(this, "typesMap", new Map);
    }
    static get isDrawer() {
        return !1;
    }
    get telemetryFinalData() {
        return {
            type: "signature",
            hasDescription: !!this.#lh
        };
    }
    static computeTelemetryFinalData(e1) {
        const t = e1.get("hasDescription");
        return {
            hasAltText: t.get(!0) ?? 0,
            hasNoAltText: t.get(!1) ?? 0
        };
    }
    get isResizable() {
        return !0;
    }
    onScaleChanging() {
        null !== this._drawId && super.onScaleChanging();
    }
    render() {
        if (this.div) return this.div;
        let e1, t;
        const { _isCopy: i } = this;
        if (i && (this._isCopy = !1, e1 = this.x, t = this.y), super.render(), null === this._drawId) if (this.#ch) {
            const { lines: e1, mustSmooth: t, areContours: i, description: n, uuid: a, heightInPage: s } = this.#ch, { rawDims: { pageWidth: r, pageHeight: o }, rotation: l } = this.parent.viewport, c = SignatureExtractor.processDrawnLines({
                lines: e1,
                pageWidth: r,
                pageHeight: o,
                rotation: l,
                innerMargin: SignatureEditor._INNER_MARGIN,
                mustSmooth: t,
                areContours: i
            });
            this.addSignature(c, s, n, a);
        } else this.div.setAttribute("data-l10n-args", JSON.stringify({
            description: ""
        })), this.div.hidden = !0, this._uiManager.getSignature(this);
        else this.div.setAttribute("data-l10n-args", JSON.stringify({
            description: this.#lh || ""
        }));
        return i && (this._isCopy = !0, this._moveAfterPaste(e1, t)), this.div;
    }
    setUuid(e1) {
        this.#hh = e1, this.addEditToolbar();
    }
    getUuid() {
        return this.#hh;
    }
    get description() {
        return this.#lh;
    }
    set description(e1) {
        this.#lh = e1, this.div && (this.div.setAttribute("data-l10n-args", JSON.stringify({
            description: e1
        })), super.addEditToolbar().then((t)=>{
            t?.updateEditSignatureButton(e1);
        }));
    }
    getSignaturePreview() {
        const { newCurves: e1, areContours: t, thickness: i, width: n, height: a } = this.#ch, s = Math.max(n, a);
        return {
            areContours: t,
            outline: SignatureExtractor.processDrawnLines({
                lines: {
                    curves: e1.map((e1)=>({
                            points: e1
                        })),
                    thickness: i,
                    width: n,
                    height: a
                },
                pageWidth: s,
                pageHeight: s,
                rotation: 0,
                innerMargin: 0,
                mustSmooth: !1,
                areContours: t
            }).outline
        };
    }
    get toolbarButtons() {
        return this._uiManager.signatureManager ? [
            [
                "editSignature",
                this._uiManager.signatureManager
            ]
        ] : super.toolbarButtons;
    }
    addSignature(e1, t, i, n) {
        const { x: a, y: s } = this, { outline: r } = this.#ch = e1;
        let o;
        this.#oh = r instanceof ContourDrawOutline, this.description = i, this.#oh ? o = SignatureEditor.getDefaultDrawingOptions() : (o = SignatureEditor._defaultDrawnSignatureOptions.clone(), o.updateProperties({
            "stroke-width": r.thickness
        })), this._addOutlines({
            drawOutlines: r,
            drawingOptions: o
        });
        const [, l] = this.pageDimensions;
        let c = t / l;
        c = c >= 1 ? .5 : c, this.width *= c / this.height, this.width >= 1 && (c *= .9 / this.width, this.width = .9), this.height = c, this.setDims(), this.x = a, this.y = s, this.center(), this._onResized(), this.onScaleChanging(), this.rotate(), this._uiManager.addToAnnotationStorage(this), this.setUuid(n), this._reportTelemetry({
            action: "pdfjs.signature.inserted",
            data: {
                hasBeenSaved: !!n,
                hasDescription: !!i
            }
        }), this.div.hidden = !1;
    }
    getFromImage(e1) {
        const { rawDims: { pageWidth: t, pageHeight: i }, rotation: n } = this.parent.viewport;
        return SignatureExtractor.process(e1, t, i, n, SignatureEditor._INNER_MARGIN);
    }
    getFromText(e1, t) {
        const { rawDims: { pageWidth: i, pageHeight: n }, rotation: a } = this.parent.viewport;
        return SignatureExtractor.extractContoursFromText(e1, t, i, n, a, SignatureEditor._INNER_MARGIN);
    }
    getDrawnSignature(e1) {
        const { rawDims: { pageWidth: t, pageHeight: i }, rotation: n } = this.parent.viewport;
        return SignatureExtractor.processDrawnLines({
            lines: e1,
            pageWidth: t,
            pageHeight: i,
            rotation: n,
            innerMargin: SignatureEditor._INNER_MARGIN,
            mustSmooth: !1,
            areContours: !1
        });
    }
    createDrawingOptions({ areContours: e1, thickness: t }) {
        e1 ? this._drawingOptions = SignatureEditor.getDefaultDrawingOptions() : (this._drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone(), this._drawingOptions.updateProperties({
            "stroke-width": t
        }));
    }
    serialize(e1 = !1) {
        if (this.isEmpty()) return null;
        const { lines: t, points: i } = this.serializeDraw(e1), { _drawingOptions: { "stroke-width": n } } = this, a = Object.assign(super.serialize(e1), {
            isSignature: !0,
            areContours: this.#oh,
            color: [
                0,
                0,
                0
            ],
            thickness: this.#oh ? 0 : n
        });
        return this.addComment(a), e1 ? (a.paths = {
            lines: t,
            points: i
        }, a.uuid = this.#hh, a.isCopy = !0) : a.lines = t, this.#lh && (a.accessibilityData = {
            type: "Figure",
            alt: this.#lh
        }), a;
    }
    static deserializeDraw(e1, t, i, n, a, s) {
        return s.areContours ? ContourDrawOutline.deserialize(e1, t, i, n, a, s) : InkDrawOutline.deserialize(e1, t, i, n, a, s);
    }
    static async deserialize(e1, t, i) {
        const n = await super.deserialize(e1, t, i);
        return n.#oh = e1.areContours, n.description = e1.accessibilityData?.alt || "", n.#hh = e1.uuid, n;
    }
}
class StampEditor extends AnnotationEditor {
    #dh = null;
    #uh = null;
    #gh = null;
    #fh = null;
    #ph = null;
    #mh = "";
    #bh = null;
    #yh = !1;
    #wh = null;
    #Ah = !1;
    #xh = !1;
    static _type = "stamp";
    static _editorType = Hl.STAMP;
    constructor(e1){
        super({
            ...e1,
            name: "stampEditor"
        }), this.#fh = e1.bitmapUrl, this.#ph = e1.bitmapFile, this.defaultL10nId = "pdfjs-editor-stamp-editor";
    }
    static initialize(e1, t) {
        AnnotationEditor.initialize(e1, t);
    }
    static isHandlingMimeForPasting(e1) {
        return yc.includes(e1);
    }
    static paste(e1, t) {
        t.pasteEditor({
            mode: Hl.STAMP
        }, {
            bitmapFile: e1.getAsFile()
        });
    }
    altTextFinish() {
        this._uiManager.useNewAltTextFlow && (this.div.hidden = !1), super.altTextFinish();
    }
    get telemetryFinalData() {
        return {
            type: "stamp",
            hasAltText: !!this.altTextData?.altText
        };
    }
    static computeTelemetryFinalData(e1) {
        const t = e1.get("hasAltText");
        return {
            hasAltText: t.get(!0) ?? 0,
            hasNoAltText: t.get(!1) ?? 0
        };
    }
    #Sh(e1, t = !1) {
        e1 ? (this.#dh = e1.bitmap, t || (this.#uh = e1.id, this.#Ah = e1.isSvg), e1.file && (this.#mh = e1.file.name), this.#vh()) : this.remove();
    }
    #Ch() {
        if (this.#gh = null, this._uiManager.enableWaiting(!1), this.#bh) if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#dh) this.addEditToolbar().then(()=>{
            this._editToolbar.hide(), this._uiManager.editAltText(this, !0);
        });
        else {
            if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#dh) {
                this._reportTelemetry({
                    action: "pdfjs.image.image_added",
                    data: {
                        alt_text_modal: !1,
                        alt_text_type: "empty"
                    }
                });
                try {
                    this.mlGuessAltText();
                } catch  {}
            }
            this.div.focus();
        }
    }
    async mlGuessAltText(e1 = null, t = !0) {
        if (this.hasAltTextData()) return null;
        const { mlManager: i } = this._uiManager;
        if (!i) throw new Error("No ML.");
        if (!await i.isEnabledFor("altText")) throw new Error("ML isn't enabled for alt text.");
        const { data: n, width: a, height: s } = e1 || this.copyCanvas(null, null, !0).imageData, r = await i.guess({
            name: "altText",
            request: {
                data: n,
                width: a,
                height: s,
                channels: n.length / (a * s)
            }
        });
        if (!r) throw new Error("No response from the AI service.");
        if (r.error) throw new Error("Error from the AI service.");
        if (r.cancel) return null;
        if (!r.output) throw new Error("No valid response from the AI service.");
        const o = r.output;
        return await this.setGuessedAltText(o), t && !this.hasAltTextData() && (this.altTextData = {
            alt: o,
            decorative: !1
        }), o;
    }
    #kh() {
        if (this.#uh) return this._uiManager.enableWaiting(!0), void this._uiManager.imageManager.getFromId(this.#uh).then((e1)=>this.#Sh(e1, !0)).finally(()=>this.#Ch());
        if (this.#fh) {
            const e1 = this.#fh;
            return this.#fh = null, this._uiManager.enableWaiting(!0), void (this.#gh = this._uiManager.imageManager.getFromUrl(e1).then((e1)=>this.#Sh(e1)).finally(()=>this.#Ch()));
        }
        if (this.#ph) {
            const e1 = this.#ph;
            return this.#ph = null, this._uiManager.enableWaiting(!0), void (this.#gh = this._uiManager.imageManager.getFromFile(e1).then((e1)=>this.#Sh(e1)).finally(()=>this.#Ch()));
        }
        const e1 = document.createElement("input");
        e1.type = "file", e1.accept = yc.join(",");
        const t = this._uiManager._signal;
        this.#gh = new Promise((i)=>{
            e1.addEventListener("change", async ()=>{
                if (e1.files && 0 !== e1.files.length) {
                    this._uiManager.enableWaiting(!0);
                    const t = await this._uiManager.imageManager.getFromFile(e1.files[0]);
                    this._reportTelemetry({
                        action: "pdfjs.image.image_selected",
                        data: {
                            alt_text_modal: this._uiManager.useNewAltTextFlow
                        }
                    }), this.#Sh(t);
                } else this.remove();
                i();
            }, {
                signal: t
            }), e1.addEventListener("cancel", ()=>{
                this.remove(), i();
            }, {
                signal: t
            });
        }).finally(()=>this.#Ch()), e1.click();
    }
    remove() {
        this.#uh && (this.#dh = null, this._uiManager.imageManager.deleteId(this.#uh), this.#bh?.remove(), this.#bh = null, this.#wh && (clearTimeout(this.#wh), this.#wh = null)), super.remove();
    }
    rebuild() {
        this.parent ? (super.rebuild(), null !== this.div && (this.#uh && null === this.#bh && this.#kh(), this.isAttachedToDOM || this.parent.add(this))) : this.#uh && this.#kh();
    }
    onceAdded(e1) {
        this._isDraggable = !0, e1 && this.div.focus();
    }
    isEmpty() {
        return !(this.#gh || this.#dh || this.#fh || this.#ph || this.#uh || this.#yh);
    }
    get toolbarButtons() {
        return [
            [
                "altText",
                this.createAltText()
            ]
        ];
    }
    get isResizable() {
        return !0;
    }
    render() {
        if (this.div) return this.div;
        let e1, t;
        return this._isCopy && (e1 = this.x, t = this.y), super.render(), this.div.hidden = !0, this.createAltText(), this.#yh || (this.#dh ? this.#vh() : this.#kh()), this._isCopy && this._moveAfterPaste(e1, t), this._uiManager.addShouldRescale(this), this.div;
    }
    setCanvas(e1, t) {
        const { id: i, bitmap: n } = this._uiManager.imageManager.getFromCanvas(e1, t);
        t.remove(), i && this._uiManager.imageManager.isValidId(i) && (this.#uh = i, n && (this.#dh = n), this.#yh = !1, this.#vh());
    }
    _onResized() {
        this.onScaleChanging();
    }
    onScaleChanging() {
        if (!this.parent) return;
        null !== this.#wh && clearTimeout(this.#wh);
        this.#wh = setTimeout(()=>{
            this.#wh = null, this.#Th();
        }, 200);
    }
    #vh() {
        const { div: e1 } = this;
        let { width: t, height: i } = this.#dh;
        const [n, a] = this.pageDimensions, s = .75;
        if (this.width) t = this.width * n, i = this.height * a;
        else if (t > s * n || i > s * a) {
            const e1 = Math.min(s * n / t, s * a / i);
            t *= e1, i *= e1;
        }
        this._uiManager.enableWaiting(!1);
        const r = this.#bh = document.createElement("canvas");
        r.setAttribute("role", "img"), this.addContainer(r), this.width = t / n, this.height = i / a, this.setDims(), this._initialOptions?.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && !this.annotationElementId || (e1.hidden = !1), this.#Th(), this.#xh || (this.parent.addUndoableEditor(this), this.#xh = !0), this._reportTelemetry({
            action: "inserted_image"
        }), this.#mh && this.div.setAttribute("aria-description", this.#mh), this.annotationElementId || this._uiManager.a11yAlert("pdfjs-editor-stamp-added-alert");
    }
    copyCanvas(e1, t, i = !1) {
        e1 || (e1 = 224);
        const { width: n, height: a } = this.#dh, s = new OutputScale;
        let r = this.#dh, o = n, l = a, c = null;
        if (t) {
            if (n > t || a > t) {
                const e1 = Math.min(t / n, t / a);
                o = Math.floor(n * e1), l = Math.floor(a * e1);
            }
            c = document.createElement("canvas");
            const e1 = c.width = Math.ceil(o * s.sx), i = c.height = Math.ceil(l * s.sy);
            this.#Ah || (r = this.#Fh(e1, i));
            const h = c.getContext("2d");
            h.filter = this._uiManager.hcmFilter;
            let d = "white", u = "#cfcfd8";
            "none" !== this._uiManager.hcmFilter ? u = "black" : ColorScheme.isDarkMode && (d = "#8f8f9d", u = "#42414d");
            const g = 15, f = g * s.sx, p = g * s.sy, m = new OffscreenCanvas(2 * f, 2 * p), b = m.getContext("2d");
            b.fillStyle = d, b.fillRect(0, 0, 2 * f, 2 * p), b.fillStyle = u, b.fillRect(0, 0, f, p), b.fillRect(f, p, f, p), h.fillStyle = h.createPattern(m, "repeat"), h.fillRect(0, 0, e1, i), h.drawImage(r, 0, 0, r.width, r.height, 0, 0, e1, i);
        }
        let h = null;
        if (i) {
            let t, i;
            if (s.symmetric && r.width < e1 && r.height < e1) t = r.width, i = r.height;
            else if (r = this.#dh, n > e1 || a > e1) {
                const s = Math.min(e1 / n, e1 / a);
                t = Math.floor(n * s), i = Math.floor(a * s), this.#Ah || (r = this.#Fh(t, i));
            }
            const o = new OffscreenCanvas(t, i).getContext("2d", {
                willReadFrequently: !0
            });
            o.drawImage(r, 0, 0, r.width, r.height, 0, 0, t, i), h = {
                width: t,
                height: i,
                data: o.getImageData(0, 0, t, i).data
            };
        }
        return {
            canvas: c,
            width: o,
            height: l,
            imageData: h
        };
    }
    #Fh(e1, t) {
        const { width: i, height: n } = this.#dh;
        let a = i, s = n, r = this.#dh;
        for(; a > 2 * e1 || s > 2 * t;){
            const i = a, n = s;
            a > 2 * e1 && (a = a >= 16384 ? Math.floor(a / 2) - 1 : Math.ceil(a / 2)), s > 2 * t && (s = s >= 16384 ? Math.floor(s / 2) - 1 : Math.ceil(s / 2));
            const o = new OffscreenCanvas(a, s);
            o.getContext("2d").drawImage(r, 0, 0, i, n, 0, 0, a, s), r = o.transferToImageBitmap();
        }
        return r;
    }
    #Th() {
        const [e1, t] = this.parentDimensions, { width: i, height: n } = this, a = new OutputScale, s = Math.ceil(i * e1 * a.sx), r = Math.ceil(n * t * a.sy), o = this.#bh;
        if (!o || o.width === s && o.height === r) return;
        o.width = s, o.height = r;
        const l = this.#Ah ? this.#dh : this.#Fh(s, r), c = o.getContext("2d");
        c.filter = this._uiManager.hcmFilter, c.drawImage(l, 0, 0, l.width, l.height, 0, 0, s, r);
    }
    #Ih(e1) {
        if (e1) {
            if (this.#Ah) {
                const e1 = this._uiManager.imageManager.getSvgUrl(this.#uh);
                if (e1) return e1;
            }
            const e1 = document.createElement("canvas");
            ({ width: e1.width, height: e1.height } = this.#dh);
            return e1.getContext("2d").drawImage(this.#dh, 0, 0), e1.toDataURL();
        }
        if (this.#Ah) {
            const [e1, t] = this.pageDimensions, i = Math.round(this.width * e1 * PixelsPerInch.PDF_TO_CSS_UNITS), n = Math.round(this.height * t * PixelsPerInch.PDF_TO_CSS_UNITS), a = new OffscreenCanvas(i, n);
            return a.getContext("2d").drawImage(this.#dh, 0, 0, this.#dh.width, this.#dh.height, 0, 0, i, n), a.transferToImageBitmap();
        }
        return structuredClone(this.#dh);
    }
    static async deserialize(e1, t, i) {
        let n = null, a = !1;
        if (e1 instanceof StampAnnotationElement) {
            const { data: { rect: s, rotation: r, id: o, structParent: l, popupRef: c, richText: h, contentsObj: d, creationDate: u, modificationDate: g }, container: f, parent: { page: { pageNumber: p } }, canvas: m } = e1;
            let b, y;
            m ? (delete e1.canvas, { id: b, bitmap: y } = i.imageManager.getFromCanvas(f.id, m), m.remove()) : (a = !0, e1._hasNoCanvas = !0);
            const w = (await t._structTree.getAriaAttributes(`${mc}${o}`))?.get("aria-label") || "";
            n = e1 = {
                annotationType: Hl.STAMP,
                bitmapId: b,
                bitmap: y,
                pageIndex: p - 1,
                rect: s.slice(0),
                rotation: r,
                annotationElementId: o,
                id: o,
                deleted: !1,
                accessibilityData: {
                    decorative: !1,
                    altText: w
                },
                isSvg: !1,
                structParent: l,
                popupRef: c,
                richText: h,
                comment: d?.str || null,
                creationDate: u,
                modificationDate: g
            };
        }
        const s = await super.deserialize(e1, t, i), { rect: r, bitmap: o, bitmapUrl: l, bitmapId: c, isSvg: h, accessibilityData: d } = e1;
        a ? (i.addMissingCanvas(e1.id, s), s.#yh = !0) : c && i.imageManager.isValidId(c) ? (s.#uh = c, o && (s.#dh = o)) : s.#fh = l, s.#Ah = h;
        const [u, g] = s.pageDimensions;
        return s.width = (r[2] - r[0]) / u, s.height = (r[3] - r[1]) / g, d && (s.altTextData = d), s._initialData = n, e1.comment && s.setCommentData(e1), s.#xh = !!n, s;
    }
    serialize(e1 = !1, t = null) {
        if (this.isEmpty()) return null;
        if (this.deleted) return this.serializeDeleted();
        const i = Object.assign(super.serialize(e1), {
            bitmapId: this.#uh,
            isSvg: this.#Ah
        });
        if (this.addComment(i), e1) return i.bitmapUrl = this.#Ih(!0), i.accessibilityData = this.serializeAltText(!0), i.isCopy = !0, i;
        const { decorative: n, altText: a } = this.serializeAltText(!1);
        if (!n && a && (i.accessibilityData = {
            type: "Figure",
            alt: a
        }), this.annotationElementId) {
            const e1 = this.#ul(i);
            return e1.isSame ? null : (e1.isSameAltText ? delete i.accessibilityData : i.accessibilityData.structParent = this._initialData.structParent ?? -1, i.id = this.annotationElementId, delete i.bitmapId, i);
        }
        if (null === t) return i;
        t.stamps ||= new Map;
        const s = this.#Ah ? (i.rect[2] - i.rect[0]) * (i.rect[3] - i.rect[1]) : null;
        if (t.stamps.has(this.#uh)) {
            if (this.#Ah) {
                const e1 = t.stamps.get(this.#uh);
                s > e1.area && (e1.area = s, e1.serialized.bitmap.close(), e1.serialized.bitmap = this.#Ih(!1));
            }
        } else t.stamps.set(this.#uh, {
            area: s,
            serialized: i
        }), i.bitmap = this.#Ih(!1);
        return i;
    }
    #ul(e1) {
        const { pageIndex: t, accessibilityData: { altText: i } } = this._initialData, n = e1.pageIndex === t, a = (e1.accessibilityData?.alt || "") === i;
        return {
            isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && n && a,
            isSameAltText: a
        };
    }
    renderAnnotationElement(e1) {
        return this.deleted ? (e1.hide(), null) : (e1.updateEdited({
            rect: this.getPDFRect(),
            popup: this.comment
        }), null);
    }
}
class AnnotationEditorLayer {
    #Ko;
    #Eh = !1;
    #Mh = null;
    #Dh = null;
    #Oh = null;
    #_h = new Map;
    #Ph = !1;
    #Rh = !1;
    #Bh = !1;
    #Nh = null;
    #Lh = null;
    #Uh = null;
    #jh = null;
    #$h = null;
    #Hh = -1;
    #Tt;
    static _initialized = !1;
    static #ei = new Map([
        FreeTextEditor,
        InkEditor,
        StampEditor,
        HighlightEditor,
        SignatureEditor
    ].map((e1)=>[
            e1._editorType,
            e1
        ]));
    constructor({ uiManager: e1, pageIndex: t, div: i, structTreeLayer: n, accessibilityManager: a, annotationLayer: s, drawLayer: r, textLayer: o, viewport: l, l10n: c }){
        const h = [
            ...AnnotationEditorLayer.#ei.values()
        ];
        if (!AnnotationEditorLayer._initialized) {
            AnnotationEditorLayer._initialized = !0;
            for (const t of h)t.initialize(c, e1);
        }
        e1.registerEditorTypes(h), this.#Tt = e1, this.pageIndex = t, this.div = i, this.#Ko = a, this.#Mh = s, this.viewport = l, this.#Uh = o, this.drawLayer = r, this._structTree = n, this.#Tt.addLayer(this);
    }
    get isEmpty() {
        return 0 === this.#_h.size;
    }
    get isInvisible() {
        return this.isEmpty && this.#Tt.getMode() === Hl.NONE;
    }
    updateToolbar(e1) {
        this.#Tt.updateToolbar(e1);
    }
    updateMode(e1 = this.#Tt.getMode()) {
        switch(this.#Xh(), e1){
            case Hl.NONE:
                return this.div.classList.toggle("nonEditing", !0), this.disableTextSelection(), this.togglePointerEvents(!1), this.toggleAnnotationLayerPointerEvents(!0), void this.disableClick();
            case Hl.INK:
                this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
                break;
            case Hl.HIGHLIGHT:
                this.enableTextSelection(), this.togglePointerEvents(!1), this.disableClick();
                break;
            default:
                this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
        }
        this.toggleAnnotationLayerPointerEvents(!1);
        const { classList: t } = this.div;
        if (t.toggle("nonEditing", !1), e1 === Hl.POPUP) t.toggle("commentEditing", !0);
        else {
            t.toggle("commentEditing", !1);
            for (const i of AnnotationEditorLayer.#ei.values())t.toggle(`${i._type}Editing`, e1 === i._editorType);
        }
        this.div.hidden = !1;
    }
    hasTextLayer(e1) {
        return e1 === this.#Uh?.div;
    }
    setEditingState(e1) {
        this.#Tt.setEditingState(e1);
    }
    addCommands(e1) {
        this.#Tt.addCommands(e1);
    }
    cleanUndoStack(e1) {
        this.#Tt.cleanUndoStack(e1);
    }
    toggleDrawing(e1 = !1) {
        this.div.classList.toggle("drawing", !e1);
    }
    togglePointerEvents(e1 = !1) {
        this.div.classList.toggle("disabled", !e1);
    }
    toggleAnnotationLayerPointerEvents(e1 = !1) {
        this.#Mh?.div.classList.toggle("disabled", !e1);
    }
    get #qh() {
        return 0 !== this.#_h.size ? this.#_h.values() : this.#Tt.getEditors(this.pageIndex);
    }
    async enable() {
        this.#Bh = !0, this.div.tabIndex = 0, this.togglePointerEvents(!0), this.div.classList.toggle("nonEditing", !1), this.#$h?.abort(), this.#$h = null;
        const e1 = new Set;
        for (const t of this.#qh)t.enableEditing(), t.show(!0), t.annotationElementId && (this.#Tt.removeChangedExistingAnnotation(t), e1.add(t.annotationElementId));
        const t = this.#Mh;
        if (t) for (const i of t.getEditableAnnotations()){
            if (i.hide(), this.#Tt.isDeletedAnnotationElement(i.data.id)) continue;
            if (e1.has(i.data.id)) continue;
            const t = await this.deserialize(i);
            t && (this.addOrRebuild(t), t.enableEditing());
        }
        this.#Bh = !1, this.#Tt._eventBus.dispatch("editorsrendered", {
            source: this,
            pageNumber: this.pageIndex + 1
        });
    }
    disable() {
        if (this.#Rh = !0, this.div.tabIndex = -1, this.togglePointerEvents(!1), this.div.classList.toggle("nonEditing", !0), this.#Uh && !this.#$h) {
            this.#$h = new AbortController;
            const e1 = this.#Tt.combinedSignal(this.#$h);
            this.#Uh.div.addEventListener("pointerdown", (e1)=>{
                const { clientX: t, clientY: i, timeStamp: n } = e1;
                if (n - this.#Hh > 500) return void (this.#Hh = n);
                this.#Hh = -1;
                const { classList: a } = this.div;
                a.toggle("getElements", !0);
                const s = document.elementsFromPoint(t, i);
                if (a.toggle("getElements", !1), !this.div.contains(s[0])) return;
                let r;
                const o = new RegExp(`^${$l}[0-9]+$`);
                for (const e1 of s)if (o.test(e1.id)) {
                    r = e1.id;
                    break;
                }
                if (!r) return;
                const l = this.#_h.get(r);
                null === l?.annotationElementId && (e1.stopPropagation(), e1.preventDefault(), l.dblclick(e1));
            }, {
                signal: e1,
                capture: !0
            });
        }
        const e1 = this.#Mh;
        if (e1) {
            const t = new Map, i = new Map;
            for (const n of this.#qh)n.disableEditing(), n.annotationElementId ? null === n.serialize() ? (i.set(n.annotationElementId, n), this.getEditableAnnotation(n.annotationElementId)?.show(), n.remove()) : t.set(n.annotationElementId, n) : n.updateFakeAnnotationElement(e1);
            const n = e1.getEditableAnnotations();
            for (const e1 of n){
                const { id: n } = e1.data;
                if (this.#Tt.isDeletedAnnotationElement(n)) {
                    e1.updateEdited({
                        deleted: !0
                    });
                    continue;
                }
                let a = i.get(n);
                a ? (a.resetAnnotationElement(e1), a.show(!1), e1.show()) : (a = t.get(n), a && (this.#Tt.addChangedExistingAnnotation(a), a.renderAnnotationElement(e1) && a.show(!1)), e1.show());
            }
        }
        this.#Xh(), this.isEmpty && (this.div.hidden = !0);
        const { classList: t } = this.div;
        for (const e1 of AnnotationEditorLayer.#ei.values())t.remove(`${e1._type}Editing`);
        this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(!0), this.#Rh = !1;
    }
    getEditableAnnotation(e1) {
        return this.#Mh?.getEditableAnnotation(e1) || null;
    }
    setActiveEditor(e1) {
        this.#Tt.getActive() !== e1 && this.#Tt.setActiveEditor(e1);
    }
    enableTextSelection() {
        if (this.div.tabIndex = -1, this.#Uh?.div && !this.#jh) {
            this.#jh = new AbortController;
            const e1 = this.#Tt.combinedSignal(this.#jh);
            this.#Uh.div.addEventListener("pointerdown", this.#zh.bind(this), {
                signal: e1
            }), this.#Uh.div.classList.add("highlighting");
        }
    }
    disableTextSelection() {
        this.div.tabIndex = 0, this.#Uh?.div && this.#jh && (this.#jh.abort(), this.#jh = null, this.#Uh.div.classList.remove("highlighting"));
    }
    #zh(e1) {
        this.#Tt.unselectAll();
        const { target: t } = e1;
        if (t === this.#Uh.div || ("img" === t.getAttribute("role") || t.classList.contains("endOfContent")) && this.#Uh.div.contains(t)) {
            const { isMac: t } = util_FeatureTest.platform;
            if (0 !== e1.button || e1.ctrlKey && t) return;
            this.#Tt.showAllEditors("highlight", !0, !0), this.#Uh.div.classList.add("free"), this.toggleDrawing(), HighlightEditor.startHighlighting(this, "ltr" === this.#Tt.direction, {
                target: this.#Uh.div,
                x: e1.x,
                y: e1.y
            }), this.#Uh.div.addEventListener("pointerup", ()=>{
                this.#Uh.div.classList.remove("free"), this.toggleDrawing(!0);
            }, {
                once: !0,
                signal: this.#Tt._signal
            }), e1.preventDefault();
        }
    }
    enableClick() {
        if (this.#Dh) return;
        this.#Dh = new AbortController;
        const e1 = this.#Tt.combinedSignal(this.#Dh);
        this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
            signal: e1
        });
        const t = this.pointerup.bind(this);
        this.div.addEventListener("pointerup", t, {
            signal: e1
        }), this.div.addEventListener("pointercancel", t, {
            signal: e1
        });
    }
    disableClick() {
        this.#Dh?.abort(), this.#Dh = null;
    }
    attach(e1) {
        this.#_h.set(e1.id, e1);
        const { annotationElementId: t } = e1;
        t && this.#Tt.isDeletedAnnotationElement(t) && this.#Tt.removeDeletedAnnotationElement(e1);
    }
    detach(e1) {
        this.#_h.delete(e1.id), this.#Ko?.removePointerInTextLayer(e1.contentDiv), !this.#Rh && e1.annotationElementId && this.#Tt.addDeletedAnnotationElement(e1);
    }
    remove(e1) {
        this.detach(e1), this.#Tt.removeEditor(e1), e1.div.remove(), e1.isAttachedToDOM = !1;
    }
    changeParent(e1) {
        e1.parent !== this && (e1.parent && e1.annotationElementId && (this.#Tt.addDeletedAnnotationElement(e1.annotationElementId), AnnotationEditor.deleteAnnotationElement(e1), e1.annotationElementId = null), this.attach(e1), e1.parent?.detach(e1), e1.setParent(this), e1.div && e1.isAttachedToDOM && (e1.div.remove(), this.div.append(e1.div)));
    }
    add(e1) {
        if (e1.parent !== this || !e1.isAttachedToDOM) {
            if (this.changeParent(e1), this.#Tt.addEditor(e1), this.attach(e1), !e1.isAttachedToDOM) {
                const t = e1.render();
                this.div.append(t), e1.isAttachedToDOM = !0;
            }
            e1.fixAndSetPosition(), e1.onceAdded(!this.#Bh), this.#Tt.addToAnnotationStorage(e1), e1._reportTelemetry(e1.telemetryInitialData);
        }
    }
    moveEditorInDOM(e1) {
        if (!e1.isAttachedToDOM) return;
        const { activeElement: t } = document;
        e1.div.contains(t) && !this.#Oh && (e1._focusEventsAllowed = !1, this.#Oh = setTimeout(()=>{
            this.#Oh = null, e1.div.contains(document.activeElement) ? e1._focusEventsAllowed = !0 : (e1.div.addEventListener("focusin", ()=>{
                e1._focusEventsAllowed = !0;
            }, {
                once: !0,
                signal: this.#Tt._signal
            }), t.focus());
        }, 0)), e1._structTreeParentId = this.#Ko?.moveElementInDOM(this.div, e1.div, e1.contentDiv, !0);
    }
    addOrRebuild(e1) {
        e1.needsToBeRebuilt() ? (e1.parent ||= this, e1.rebuild(), e1.show()) : this.add(e1);
    }
    addUndoableEditor(e1) {
        this.addCommands({
            cmd: ()=>e1._uiManager.rebuild(e1),
            undo: ()=>{
                e1.remove();
            },
            mustExec: !1
        });
    }
    getEditorByUID(e1) {
        for (const t of this.#_h.values())if (t.uid === e1) return t;
        return null;
    }
    getNextId() {
        return this.#Tt.getId();
    }
    get #Wh() {
        return AnnotationEditorLayer.#ei.get(this.#Tt.getMode());
    }
    combinedSignal(e1) {
        return this.#Tt.combinedSignal(e1);
    }
    #Gh(e1) {
        const t = this.#Wh;
        return t ? new t.prototype.constructor(e1) : null;
    }
    canCreateNewEmptyEditor() {
        return this.#Wh?.canCreateNewEmptyEditor();
    }
    async pasteEditor(e1, t) {
        this.updateToolbar(e1), await this.#Tt.updateMode(e1.mode);
        const { offsetX: i, offsetY: n } = this.#Vh(), a = this.getNextId(), s = this.#Gh({
            parent: this,
            id: a,
            x: i,
            y: n,
            uiManager: this.#Tt,
            isCentered: !0,
            ...t
        });
        s && this.add(s);
    }
    async deserialize(e1) {
        return await AnnotationEditorLayer.#ei.get(e1.annotationType ?? e1.annotationEditorType)?.deserialize(e1, this, this.#Tt) || null;
    }
    createAndAddNewEditor(e1, t, i = {}) {
        const n = this.getNextId(), a = this.#Gh({
            parent: this,
            id: n,
            x: e1.offsetX,
            y: e1.offsetY,
            uiManager: this.#Tt,
            isCentered: t,
            ...i
        });
        return a && this.add(a), a;
    }
    get boundingClientRect() {
        return this.div.getBoundingClientRect();
    }
    #Vh() {
        const { x: e1, y: t, width: i, height: n } = this.boundingClientRect, a = Math.max(0, e1), s = Math.max(0, t), r = (a + Math.min(window.innerWidth, e1 + i)) / 2 - e1, o = (s + Math.min(window.innerHeight, t + n)) / 2 - t, [l, c] = this.viewport.rotation % 180 == 0 ? [
            r,
            o
        ] : [
            o,
            r
        ];
        return {
            offsetX: l,
            offsetY: c
        };
    }
    addNewEditor(e1 = {}) {
        this.createAndAddNewEditor(this.#Vh(), !0, e1);
    }
    setSelected(e1) {
        this.#Tt.setSelected(e1);
    }
    toggleSelected(e1) {
        this.#Tt.toggleSelected(e1);
    }
    unselect(e1) {
        this.#Tt.unselect(e1);
    }
    pointerup(e1) {
        const { isMac: t } = util_FeatureTest.platform;
        if (0 !== e1.button || e1.ctrlKey && t) return;
        if (e1.target !== this.div) return;
        if (!this.#Ph) return;
        if (this.#Ph = !1, this.#Wh?.isDrawer && this.#Wh.supportMultipleDrawings) return;
        if (!this.#Eh) return void (this.#Eh = !0);
        const i = this.#Tt.getMode();
        i !== Hl.STAMP && i !== Hl.SIGNATURE ? this.createAndAddNewEditor(e1, !1) : this.#Tt.unselectAll();
    }
    pointerdown(e1) {
        if (this.#Tt.getMode() === Hl.HIGHLIGHT && this.enableTextSelection(), this.#Ph) return void (this.#Ph = !1);
        const { isMac: t } = util_FeatureTest.platform;
        if (0 !== e1.button || e1.ctrlKey && t) return;
        if (e1.target !== this.div) return;
        if (this.#Ph = !0, this.#Wh?.isDrawer) return void this.startDrawingSession(e1);
        const i = this.#Tt.getActive();
        this.#Eh = !i || i.isEmpty();
    }
    startDrawingSession(e1) {
        if (this.div.focus({
            preventScroll: !0
        }), this.#Nh) return void this.#Wh.startDrawing(this, this.#Tt, !1, e1);
        this.#Tt.setCurrentDrawingSession(this), this.#Nh = new AbortController;
        const t = this.#Tt.combinedSignal(this.#Nh);
        this.div.addEventListener("blur", ({ relatedTarget: e1 })=>{
            e1 && !this.div.contains(e1) && (this.#Lh = null, this.commitOrRemove());
        }, {
            signal: t
        }), this.#Wh.startDrawing(this, this.#Tt, !1, e1);
    }
    pause(e1) {
        if (e1) {
            const { activeElement: e1 } = document;
            return void (this.div.contains(e1) && (this.#Lh = e1));
        }
        this.#Lh && setTimeout(()=>{
            this.#Lh?.focus(), this.#Lh = null;
        }, 0);
    }
    endDrawingSession(e1 = !1) {
        return this.#Nh ? (this.#Tt.setCurrentDrawingSession(null), this.#Nh.abort(), this.#Nh = null, this.#Lh = null, this.#Wh.endDrawing(e1)) : null;
    }
    findNewParent(e1, t, i) {
        const n = this.#Tt.findParent(t, i);
        return null !== n && n !== this && (n.changeParent(e1), !0);
    }
    commitOrRemove() {
        return !!this.#Nh && (this.endDrawingSession(), !0);
    }
    onScaleChanging() {
        this.#Nh && this.#Wh.onScaleChangingWhenDrawing(this);
    }
    destroy() {
        this.commitOrRemove(), this.#Tt.getActive()?.parent === this && (this.#Tt.commitOrRemove(), this.#Tt.setActiveEditor(null)), this.#Oh && (clearTimeout(this.#Oh), this.#Oh = null);
        for (const e1 of this.#_h.values())this.#Ko?.removePointerInTextLayer(e1.contentDiv), e1.setParent(null), e1.isAttachedToDOM = !1, e1.div.remove();
        this.div = null, this.#_h.clear(), this.#Tt.removeLayer(this);
    }
    #Xh() {
        for (const e1 of this.#_h.values())e1.isEmpty() && e1.remove();
    }
    render({ viewport: e1 }) {
        this.viewport = e1, setLayerDimensions(this.div, e1);
        for (const e1 of this.#Tt.getEditors(this.pageIndex))this.add(e1), e1.rebuild();
        this.updateMode();
    }
    update({ viewport: e1 }) {
        this.#Tt.commitOrRemove(), this.#Xh();
        const t = this.viewport.rotation, i = e1.rotation;
        if (this.viewport = e1, setLayerDimensions(this.div, {
            rotation: i
        }), t !== i) for (const e1 of this.#_h.values())e1.rotate(i);
    }
    get pageDimensions() {
        const { pageWidth: e1, pageHeight: t } = this.viewport.rawDims;
        return [
            e1,
            t
        ];
    }
    get scale() {
        return this.#Tt.viewParameters.realScale;
    }
}
class DrawLayer {
    #wo = null;
    #Kh = new Map;
    #Yh = new Map;
    static #Mt = 0;
    constructor({ pageIndex: e1 }){
        this.pageIndex = e1;
    }
    setParent(e1) {
        if (this.#wo) {
            if (this.#wo !== e1) {
                if (this.#Kh.size > 0) for (const t of this.#Kh.values())t.remove(), e1.append(t);
                this.#wo = e1;
            }
        } else this.#wo = e1;
    }
    static get _svgFactory() {
        return shadow(this, "_svgFactory", new DOMSVGFactory);
    }
    static #Jh(e1, [t, i, n, a]) {
        const { style: s } = e1;
        s.top = 100 * i + "%", s.left = 100 * t + "%", s.width = 100 * n + "%", s.height = 100 * a + "%";
    }
    #Zh() {
        const e1 = DrawLayer._svgFactory.create(1, 1, !0);
        return this.#wo.append(e1), e1.setAttribute("aria-hidden", !0), e1;
    }
    #Qh(e1, t) {
        const i = DrawLayer._svgFactory.createElement("clipPath");
        e1.append(i);
        const n = `clip_${t}`;
        i.setAttribute("id", n), i.setAttribute("clipPathUnits", "objectBoundingBox");
        const a = DrawLayer._svgFactory.createElement("use");
        return i.append(a), a.setAttribute("href", `#${t}`), a.classList.add("clip"), n;
    }
    #ed(e1, t) {
        for (const [i, n] of Object.entries(t))null === n ? e1.removeAttribute(i) : e1.setAttribute(i, n);
    }
    draw(e1, t = !1, i = !1) {
        const n = DrawLayer.#Mt++, a = this.#Zh(), s = DrawLayer._svgFactory.createElement("defs");
        a.append(s);
        const r = DrawLayer._svgFactory.createElement("path");
        s.append(r);
        const o = `path_p${this.pageIndex}_${n}`;
        r.setAttribute("id", o), r.setAttribute("vector-effect", "non-scaling-stroke"), t && this.#Yh.set(n, r);
        const l = i ? this.#Qh(s, o) : null, c = DrawLayer._svgFactory.createElement("use");
        return a.append(c), c.setAttribute("href", `#${o}`), this.updateProperties(a, e1), this.#Kh.set(n, a), {
            id: n,
            clipPathId: `url(#${l})`
        };
    }
    drawOutline(e1, t) {
        const i = DrawLayer.#Mt++, n = this.#Zh(), a = DrawLayer._svgFactory.createElement("defs");
        n.append(a);
        const s = DrawLayer._svgFactory.createElement("path");
        a.append(s);
        const r = `path_p${this.pageIndex}_${i}`;
        let o;
        if (s.setAttribute("id", r), s.setAttribute("vector-effect", "non-scaling-stroke"), t) {
            const e1 = DrawLayer._svgFactory.createElement("mask");
            a.append(e1), o = `mask_p${this.pageIndex}_${i}`, e1.setAttribute("id", o), e1.setAttribute("maskUnits", "objectBoundingBox");
            const t = DrawLayer._svgFactory.createElement("rect");
            e1.append(t), t.setAttribute("width", "1"), t.setAttribute("height", "1"), t.setAttribute("fill", "white");
            const n = DrawLayer._svgFactory.createElement("use");
            e1.append(n), n.setAttribute("href", `#${r}`), n.setAttribute("stroke", "none"), n.setAttribute("fill", "black"), n.setAttribute("fill-rule", "nonzero"), n.classList.add("mask");
        }
        const l = DrawLayer._svgFactory.createElement("use");
        n.append(l), l.setAttribute("href", `#${r}`), o && l.setAttribute("mask", `url(#${o})`);
        const c = l.cloneNode();
        return n.append(c), l.classList.add("mainOutline"), c.classList.add("secondaryOutline"), this.updateProperties(n, e1), this.#Kh.set(i, n), i;
    }
    finalizeDraw(e1, t) {
        this.#Yh.delete(e1), this.updateProperties(e1, t);
    }
    updateProperties(e1, t) {
        if (!t) return;
        const { root: i, bbox: n, rootClass: a, path: s } = t, r = "number" == typeof e1 ? this.#Kh.get(e1) : e1;
        if (r) {
            if (i && this.#ed(r, i), n && DrawLayer.#Jh(r, n), a) {
                const { classList: e1 } = r;
                for (const [t, i] of Object.entries(a))e1.toggle(t, i);
            }
            if (s) {
                const e1 = r.firstChild.firstChild;
                this.#ed(e1, s);
            }
        }
    }
    updateParent(e1, t) {
        if (t === this) return;
        const i = this.#Kh.get(e1);
        i && (t.#wo.append(i), this.#Kh.delete(e1), t.#Kh.set(e1, i));
    }
    remove(e1) {
        this.#Yh.delete(e1), null !== this.#wo && (this.#Kh.get(e1).remove(), this.#Kh.delete(e1));
    }
    destroy() {
        this.#wo = null;
        for (const e1 of this.#Kh.values())e1.remove();
        this.#Kh.clear(), this.#Yh.clear();
    }
}
globalThis._pdfjsTestingUtils = {
    HighlightOutliner: HighlightOutliner
}, globalThis.pdfjsLib = {
    AbortException: AbortException,
    AnnotationEditorLayer: AnnotationEditorLayer,
    AnnotationEditorParamsType: Xl,
    AnnotationEditorType: Hl,
    AnnotationEditorUIManager: AnnotationEditorUIManager,
    AnnotationLayer: AnnotationLayer,
    AnnotationMode: jl,
    AnnotationType: Zl,
    applyOpacity: applyOpacity,
    build: hh,
    ColorPicker: ColorPicker,
    createValidAbsoluteUrl: createValidAbsoluteUrl,
    CSSConstants: CSSConstants,
    DOMSVGFactory: DOMSVGFactory,
    DrawLayer: DrawLayer,
    FeatureTest: util_FeatureTest,
    fetchData: fetchData,
    findContrastColor: findContrastColor,
    getDocument: getDocument,
    getFilenameFromUrl: getFilenameFromUrl,
    getPdfFilenameFromUrl: getPdfFilenameFromUrl,
    getRGB: getRGB,
    getUuid: getUuid,
    getXfaPageViewport: getXfaPageViewport,
    GlobalWorkerOptions: GlobalWorkerOptions,
    ImageKind: Jl,
    InvalidPDFException: InvalidPDFException,
    isDataScheme: isDataScheme,
    isPdfFile: isPdfFile,
    isValidExplicitDest: Cc,
    MathClamp: MathClamp,
    noContextMenu: noContextMenu,
    normalizeUnicode: normalizeUnicode,
    OPS: sc,
    OutputScale: OutputScale,
    PasswordResponses: hc,
    PDFDataRangeTransport: PDFDataRangeTransport,
    PDFDateString: PDFDateString,
    PDFWorker: PDFWorker,
    PermissionFlag: ql,
    PixelsPerInch: PixelsPerInch,
    RenderingCancelledException: RenderingCancelledException,
    renderRichText: renderRichText,
    ResponseException: ResponseException,
    setLayerDimensions: setLayerDimensions,
    shadow: shadow,
    SignatureExtractor: SignatureExtractor,
    stopEvent: stopEvent,
    SupportedImageMimeTypes: yc,
    TextLayer: TextLayer,
    TouchManager: TouchManager,
    updateUrlHash: updateUrlHash,
    Util: Util,
    VerbosityLevel: ac,
    version: lh,
    XfaLayer: XfaLayer
};
;
}),
];

//# sourceMappingURL=node_modules_unpdf_dist_pdfjs_mjs_a275bec9._.js.map